//@cannot search
//------------------------------------------------------------------------------------------------------
//  GameCreator Runtime
//  请勿修改该JS文件，引擎会根据版本自动替换该文件
//------------------------------------------------------------------------------------------------------
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var AsynTask = (function () {
    function AsynTask(onFin) {
        this._asynCount = 0;
        this._asynLength = 0;
        this._onFin = onFin;
    }
    AsynTask.prototype.execute = function (code) {
        this._asynLength++;
    };
    AsynTask.prototype.complete = function () {
        this._asynCount++;
        if (this._asynCount == this._asynLength) {
            this._onFin && this._onFin.run();
        }
    };
    Object.defineProperty(AsynTask.prototype, "length", {
        get: function () {
            return this._asynLength;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AsynTask.prototype, "currentCount", {
        get: function () {
            return this._asynCount;
        },
        enumerable: false,
        configurable: true
    });
    return AsynTask;
}());
var SyncTask = (function () {
    function SyncTask(taskName, func, arg, thisPtr, isConver, jumpQuere) {
        if (func === void 0) { func = null; }
        if (arg === void 0) { arg = null; }
        if (thisPtr === void 0) { thisPtr = null; }
        if (isConver === void 0) { isConver = false; }
        if (jumpQuere === void 0) { jumpQuere = false; }
        var taskList = SyncTask.taskLists[taskName];
        if (!taskList)
            taskList = SyncTask.taskLists[taskName] = [];
        if (isConver) {
            var sameTaskList = ArrayUtils.matchAttributes(taskList, { func: func }, false);
            while (sameTaskList.length > 0) {
                var idx = taskList.indexOf(sameTaskList.shift());
                taskList.splice(idx, 1);
            }
        }
        if (jumpQuere) {
            taskList.unshift(this);
        }
        else {
            taskList.push(this);
        }
        this.func = func;
        this.arg = arg;
        this.thisPtr = thisPtr;
        SyncTask.doTask(taskName);
    }
    SyncTask.prototype.execute = function (taskName) {
        SyncTask.taskExecuteing[taskName] = true;
        if (!this.func)
            return;
        this.thisPtr ? this.func.apply(this.thisPtr, this.arg) : this.func.apply(this, this.arg);
    };
    SyncTask.doTask = function (taskName) {
        if (SyncTask.taskExecuteing[taskName])
            return;
        var taskList = SyncTask.taskLists[taskName];
        if (taskList && taskList.length > 0)
            taskList.shift().execute(taskName);
    };
    SyncTask.taskOver = function (taskName) {
        SyncTask.taskExecuteing[taskName] = false;
        SyncTask.doTask(taskName);
    };
    SyncTask.clear = function (taskName) {
        delete SyncTask.taskExecuteing[taskName];
        delete SyncTask.taskLists[taskName];
    };
    SyncTask.taskLists = {};
    SyncTask.taskExecuteing = [];
    return SyncTask;
}());
var ArrayUtils = (function () {
    function ArrayUtils() {
    }
    ArrayUtils.randOrder = function (arr) {
        var arrClone = arr.concat();
        var newArr = [];
        while (arrClone.length > 0) {
            var obj = arrClone.splice(MathUtils.rand(arrClone.length), 1)[0];
            newArr.push(obj);
        }
        var len = arr.length;
        for (var i = 0; i < len; i++) {
            arr[i] = newArr[i];
        }
    };
    ArrayUtils.insert = function (arr, index) {
        var arg = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            arg[_i - 2] = arguments[_i];
        }
        var returnIndex;
        if (index == -1) {
            returnIndex = arr.length;
            arr.push.apply(arr, arg);
        }
        else {
            returnIndex = index;
            arr.splice.apply(arr, [index, 0].concat(arg));
        }
        return returnIndex;
    };
    ArrayUtils.delete = function (arr, index) {
        return index == -1 ? arr.pop() : arr.splice(index, 1)[0];
    };
    ArrayUtils.remove = function (arr, obj) {
        var idx = arr.indexOf(obj);
        if (idx == -1)
            return null;
        return arr.splice(idx, 1)[0];
    };
    ArrayUtils.get = function (arr, index) {
        var index = index == -1 ? arr.length - 1 : index;
        return arr[index];
    };
    ArrayUtils.set = function (arr, index, paramValue) {
        function setValue(obj, paramValue) {
            for (var s in paramValue) {
                obj[s] = paramValue[s];
            }
        }
        if (index == -2) {
            var len = arr.length;
            for (var i = 0; i < len; i++) {
                setValue(arr[i], paramValue);
            }
            return arr;
        }
        else if (index == -1) {
            var obj = arr[arr.length - 1];
            setValue(obj, paramValue);
            return [obj];
        }
        else {
            var obj = arr[index];
            setValue(obj, paramValue);
            return [obj];
        }
    };
    ArrayUtils.insertToNullPosition = function (arr, obj) {
        var idx = ArrayUtils.getNullPosition(arr);
        arr[idx] = obj;
        return idx;
    };
    ArrayUtils.getNullPosition = function (arr, startIndex) {
        if (startIndex === void 0) { startIndex = 0; }
        var index = -1;
        for (var i = startIndex; i < arr.length; i++) {
            if (!arr[i]) {
                index = i;
                break;
            }
        }
        if (index == -1)
            index = arr.length;
        return index;
    };
    ArrayUtils.removeSameObject = function (arr) {
        var newArr = [];
        for (var i = arr.length - 1; i >= 0; i--) {
            var obj = arr[i];
            if (newArr.indexOf(obj) == -1) {
                newArr.push(obj);
            }
        }
        return newArr.reverse();
    };
    ;
    ArrayUtils.removeSameObjectD2 = function (arr, attrName, ifNullIgnore) {
        var newArr = [];
        for (var i = arr.length - 1; i >= 0; i--) {
            var obj = arr[i];
            var matchValue = obj[attrName];
            if (matchValue == null && ifNullIgnore) {
                newArr.push(obj);
                return;
            }
            var matchObj = {};
            matchObj[attrName] = matchValue;
            if (ArrayUtils.matchAttributes(newArr, matchObj, true).length == 0) {
                newArr.push(obj);
            }
        }
        return newArr.reverse();
    };
    ;
    ArrayUtils.matchAttributes = function (arr, matchData, onlyOne, symbol, indexOfMode) {
        if (symbol === void 0) { symbol = "=="; }
        if (indexOfMode === void 0) { indexOfMode = false; }
        var matchs = [];
        for (var i in arr) {
            var obj = arr[i];
            if (!obj)
                continue;
            var isMatch = true;
            for (var s in matchData) {
                if ((symbol == "==" && obj[s] != matchData[s]) ||
                    (symbol == ">=" && obj[s] < matchData[s]) ||
                    (symbol == "<=" && obj[s] > matchData[s]) ||
                    (symbol == ">" && obj[s] <= matchData[s]) ||
                    (symbol == "<" && obj[s] >= matchData[s]) ||
                    (symbol == "!=" && obj[s] == matchData[s])) {
                    isMatch = false;
                    break;
                }
            }
            if (isMatch) {
                matchs.push(indexOfMode ? parseInt(i) : obj);
                if (onlyOne)
                    break;
            }
        }
        return matchs;
    };
    ;
    ArrayUtils.matchAttributesD2 = function (arr, attribute, matchData, onlyOne, symbol, indexOfMode) {
        if (symbol === void 0) { symbol = "=="; }
        if (indexOfMode === void 0) { indexOfMode = false; }
        var matchs = [];
        for (var i in arr) {
            var obj = arr[i];
            var isMatch = true;
            if (!obj[attribute])
                continue;
            for (var s in matchData) {
                if ((symbol == "==" && obj[attribute][s] != matchData[s]) ||
                    (symbol == ">=" && obj[attribute][s] < matchData[s]) ||
                    (symbol == "<=" && obj[attribute][s] > matchData[s]) ||
                    (symbol == ">" && obj[attribute][s] <= matchData[s]) ||
                    (symbol == "<" && obj[attribute][s] >= matchData[s]) ||
                    (symbol == "!=" && obj[attribute][s] == matchData[s])) {
                    isMatch = false;
                    break;
                }
            }
            if (isMatch) {
                matchs.push(indexOfMode ? parseInt(i) : obj);
                if (onlyOne)
                    break;
            }
        }
        return matchs;
    };
    ;
    ArrayUtils.matchAttributesD3 = function (arr, attribute, attribute2, matchData, onlyOne, symbol, indexOfMode) {
        if (symbol === void 0) { symbol = "=="; }
        if (indexOfMode === void 0) { indexOfMode = false; }
        var matchs = [];
        for (var i in arr) {
            var obj = arr[i];
            var isMatch = true;
            if (!obj[attribute])
                continue;
            if (!obj[attribute][attribute2])
                continue;
            for (var s in matchData) {
                if ((symbol == "==" && obj[attribute][attribute2][s] != matchData[s]) ||
                    (symbol == ">=" && obj[attribute][attribute2][s] < matchData[s]) ||
                    (symbol == "<=" && obj[attribute][attribute2][s] > matchData[s]) ||
                    (symbol == ">" && obj[attribute][attribute2][s] <= matchData[s]) ||
                    (symbol == "<" && obj[attribute][attribute2][s] >= matchData[s]) ||
                    (symbol == "!=" && obj[attribute][attribute2][s] == matchData[s])) {
                    isMatch = false;
                    break;
                }
            }
            if (isMatch) {
                matchs.push(indexOfMode ? parseInt(i) : obj);
                if (onlyOne)
                    break;
            }
        }
        return matchs;
    };
    ;
    ArrayUtils.getChildAttributeToCreateArray = function (arr, attributeName, ignoreNullChild) {
        if (ignoreNullChild === void 0) { ignoreNullChild = true; }
        var newArr = [];
        for (var i in arr) {
            var child = arr[i];
            if (child == null) {
                if (!ignoreNullChild)
                    newArr.push(child);
                continue;
            }
            newArr.push(child[attributeName]);
        }
        return newArr;
    };
    ArrayUtils.getElementSize = function (arr, value) {
        var n = 0;
        for (var i in arr) {
            if (arr[i] == value)
                n++;
        }
        return n;
    };
    ArrayUtils.createObjects = function (objCls, size, onCreateOne, arr) {
        if (onCreateOne === void 0) { onCreateOne = null; }
        if (arr === void 0) { arr = null; }
        if (!arr)
            arr = [];
        for (var i = 0; i < size; i++) {
            var o = new objCls();
            onCreateOne && onCreateOne(i, o);
            arr.push(o);
        }
        return arr;
    };
    ArrayUtils.swap = function (arr, index1, index2) {
        var last = arr[index1];
        arr[index1] = arr[index2];
        arr[index2] = last;
    };
    ArrayUtils.setIndex = function (arr, element, index) {
        var idx = arr.indexOf(element);
        if (idx == -1)
            return;
        arr.splice(idx, 1);
        arr.splice(index, 0, element);
    };
    ArrayUtils.sort = function (arr, attributeName, isAsc) {
        function order(a, b) {
            var aStr = a[attributeName];
            var bStr = b[attributeName];
            var min = Math.min(aStr.length, bStr.length);
            for (var i = 0; i < min; i++) {
                var code1 = aStr[i].toLocaleLowerCase().charCodeAt(0);
                var code2 = bStr[i].toLocaleLowerCase().charCodeAt(0);
                if (code1 == code2) {
                    continue;
                }
                return isAsc ? (code1 < code2 ? -1 : 1) : (code1 < code2 ? 1 : -1);
            }
            return -1;
        }
        arr.sort(order);
    };
    ;
    ArrayUtils.compare = function (aArr, bArr) {
        var appended = [];
        if (aArr == null)
            aArr = [];
        if (bArr == null)
            bArr = [];
        var subtract = bArr.concat();
        var aLen = aArr.length;
        for (var i = 0; i < aLen; i++) {
            var a = aArr[i];
            var idx = subtract.indexOf(a);
            if (idx != -1) {
                subtract.splice(idx, 1);
            }
            else {
                appended.push(a);
            }
        }
        return {
            appended: appended,
            subtract: subtract
        };
    };
    ArrayUtils.getTreeNodeArray = function (treeNode, childrenAttr, arrayList, checkIsOpen, isOpenAttr, ignoreChildrenCondition) {
        if (childrenAttr === void 0) { childrenAttr = "children"; }
        if (arrayList === void 0) { arrayList = null; }
        if (checkIsOpen === void 0) { checkIsOpen = false; }
        if (isOpenAttr === void 0) { isOpenAttr = "isOpen"; }
        if (ignoreChildrenCondition === void 0) { ignoreChildrenCondition = null; }
        if (!arrayList)
            arrayList = [];
        arrayList.push(treeNode);
        if (ignoreChildrenCondition && ignoreChildrenCondition.runWith([treeNode]))
            return arrayList;
        var children = treeNode[childrenAttr];
        if (!children)
            return arrayList;
        if (!checkIsOpen || (checkIsOpen && treeNode[isOpenAttr])) {
            var len = children.length;
            for (var i = 0; i < len; i++) {
                ArrayUtils.getTreeNodeArray(children[i], childrenAttr, arrayList, checkIsOpen, isOpenAttr, ignoreChildrenCondition);
            }
        }
        return arrayList;
    };
    return ArrayUtils;
}());
var Callback = (function () {
    function Callback(callbackFunc, caller, args) {
        if (args === void 0) { args = null; }
        this.delayRunSigns = [];
        this.callbackFunc = callbackFunc;
        this.caller = caller;
        this.args = args;
    }
    Callback.prototype.run = function () {
        var r = this.callbackFunc.apply(this.caller, this.args);
        return r;
    };
    Callback.prototype.runWith = function (addArgs) {
        var r = this.callbackFunc.apply(this.caller, this.args ? this.args.concat(addArgs) : addArgs);
        return r;
    };
    Callback.prototype.delayRun = function (delay, delayFunc, args) {
        if (delayFunc === void 0) { delayFunc = null; }
        if (args === void 0) { args = null; }
        var f = delayFunc ? delayFunc : setTimeout;
        this.delayRunSigns.push(f(function (callBack) {
            callBack.delayRunSigns.shift();
            args ? callBack.runWith(args) : callBack.run();
        }, delay, this));
        return this;
    };
    Callback.prototype.delayRunConver = function (delay, delayFunc, clearDelayFunc, args) {
        if (delayFunc === void 0) { delayFunc = null; }
        if (clearDelayFunc === void 0) { clearDelayFunc = null; }
        if (args === void 0) { args = null; }
        if (this.delayRunSign) {
            var f = clearDelayFunc ? clearDelayFunc : clearTimeout;
            f(this.delayRunSign);
        }
        this.delayRunSign = this.delayRun(delay, delayFunc, args);
        return this;
    };
    Callback.prototype.stopDelay = function (clearDelayFunc) {
        if (clearDelayFunc === void 0) { clearDelayFunc = null; }
        var f = clearDelayFunc ? clearDelayFunc : clearTimeout;
        if (this.delayRunSign) {
            f(this.delayRunSign);
            this.delayRunSign = null;
        }
        for (var i in this.delayRunSigns) {
            f(this.delayRunSigns[i]);
        }
        this.delayRunSigns.length = 0;
    };
    Callback.New = function (callbackFunc, caller, args) {
        if (args === void 0) { args = null; }
        var cb = new Callback(callbackFunc, caller, args);
        return cb;
    };
    Callback.CallLater = function (func, caller, args, delay) {
        if (args === void 0) { args = null; }
        if (delay === void 0) { delay = 0; }
        var map = caller["____clks"];
        if (!map)
            map = caller["____clks"] = new Dictionary();
        var keyInfo = map.get(func);
        if (keyInfo) {
            var key = keyInfo.key;
            var cb = keyInfo.cb;
            cb.args[2] = args;
        }
        else {
            key = ObjectUtils.getInstanceID();
            cb = Callback.New(function (func, caller, args, key) {
                if (args === void 0) { args = null; }
                var map = caller["____clks"];
                map.remove(func);
                func.apply(caller, args);
            }, this, [func, caller, args, key]).delayRun(delay);
            map.set(func, { key: key, cb: cb });
        }
    };
    Callback.CallLaterBeforeRender = function (func, caller, args) {
        if (args === void 0) { args = null; }
        var map = caller["____clks2"];
        if (!map)
            map = caller["____clks2"] = new Dictionary();
        var keyInfo = map.get(func);
        if (keyInfo) {
            var key = keyInfo.key;
            var cb = keyInfo.cb;
            cb.args = args;
        }
        else {
            key = ObjectUtils.getInstanceID();
            cb = Callback.New(func, caller, args);
            map.set(func, { key: key, cb: cb });
            Callback.beforeRenderFuncs[key] = cb;
        }
    };
    var _a;
    _a = Callback;
    Callback.EMPTY = new Callback(function () { }, _a);
    Callback.beforeRenderFuncs = [];
    return Callback;
}());
var EventUtils = (function () {
    function EventUtils() {
    }
    EventUtils.addEventListener = function (obj, type, callBack, isOnce) {
        if (isOnce === void 0) { isOnce = false; }
        if (!obj)
            return;
        var evIdx = obj["__evIdx"];
        var evTypes;
        if (evIdx != null) {
            evTypes = EventUtils.evList[evIdx];
        }
        else {
            evTypes = {};
            evIdx = ArrayUtils.insertToNullPosition(EventUtils.evList, evTypes);
            obj["__evIdx"] = evIdx;
        }
        var evArrs = evTypes[type];
        if (!evArrs)
            evTypes[type] = evArrs = [];
        var evArr = [callBack, isOnce];
        evArrs.push(evArr);
    };
    EventUtils.addEventListenerFunction = function (obj, type, onHappen, thisPtr, args, isOnce) {
        if (args === void 0) { args = null; }
        if (isOnce === void 0) { isOnce = false; }
        if (!obj)
            return;
        var evIdx = obj["__evIdx2"];
        var evTypes;
        if (evIdx != null) {
            evTypes = EventUtils.evList2[evIdx];
        }
        else {
            evTypes = {};
            evIdx = ArrayUtils.insertToNullPosition(EventUtils.evList2, evTypes);
            obj["__evIdx2"] = evIdx;
        }
        var evArrs = evTypes[type];
        if (!evArrs)
            evTypes[type] = evArrs = [];
        var evArr = [onHappen, thisPtr, args, isOnce];
        evArrs.push(evArr);
    };
    EventUtils.removeEventListener = function (obj, type, callBack) {
        if (!obj)
            return;
        var evIdx = obj["__evIdx"];
        if (evIdx != null) {
            var evTypes = EventUtils.evList[evIdx];
            var evArrs = evTypes[type];
            for (var i in evArrs) {
                var evArr = evArrs[i];
                if (evArr[0] == callBack) {
                    evArrs.splice(parseInt(i), 1);
                    break;
                }
            }
        }
    };
    EventUtils.removeEventListenerFunction = function (obj, type, onHappen, thisPtr) {
        if (!obj)
            return;
        var evIdx = obj["__evIdx2"];
        if (evIdx != null) {
            var evTypes = EventUtils.evList2[evIdx];
            var evArrs = evTypes[type];
            for (var i in evArrs) {
                var evArr = evArrs[i];
                if (evArr[0] == onHappen && evArr[1] == thisPtr) {
                    evArrs.splice(parseInt(i), 1);
                    break;
                }
            }
        }
    };
    EventUtils.happen = function (obj, type, args) {
        if (args === void 0) { args = null; }
        if (!obj)
            return;
        var evIdx = obj["__evIdx"];
        var happenFuncs = [];
        if (evIdx != null) {
            var evTypes = EventUtils.evList[evIdx];
            var evArrs = evTypes[type];
            if (evArrs) {
                for (var i = 0; i < evArrs.length; i++) {
                    var evArr = evArrs[i];
                    var callback = evArr[0];
                    var isOnce = evArr[1];
                    if (isOnce) {
                        evArrs.splice(i, 1);
                        i--;
                    }
                    happenFuncs.push(callback);
                }
                happenFuncs.forEach(function (callback, index, array) {
                    args ? callback.runWith(args) : callback.run();
                });
            }
        }
        var evIdx2 = obj["__evIdx2"];
        var happenFuncs2 = [];
        if (evIdx2 != null) {
            var evTypes2 = EventUtils.evList2[evIdx2];
            var evArrs2 = evTypes2[type];
            if (evArrs2) {
                for (var i = 0; i < evArrs2.length; i++) {
                    var evArr2 = evArrs2[i];
                    var func = evArr2[0];
                    var thisPtr = evArr2[1];
                    var funcArgs = evArr2[2];
                    var isOnce = evArr2[3];
                    if (isOnce) {
                        evArrs2.splice(i, 1);
                        i--;
                    }
                    happenFuncs2.push([func, thisPtr, funcArgs]);
                }
                happenFuncs2.forEach(function (funcArr, index, array) {
                    var func = funcArr[0];
                    var thisPtr = funcArr[1];
                    var funcArgs = funcArr[2];
                    if (args) {
                        func.apply(thisPtr, funcArgs ? funcArgs.concat(args) : args);
                    }
                    else {
                        func.apply(thisPtr, funcArgs);
                    }
                });
            }
        }
    };
    EventUtils.clear = function (obj, type) {
        if (type === void 0) { type = null; }
        if (!obj)
            return;
        var evIdx = obj["__evIdx"];
        if (evIdx != null) {
            if (type == null) {
                EventUtils.evList[evIdx] = null;
                delete obj["__evIdx"];
            }
            else {
                var evTypes = EventUtils.evList[evIdx];
                delete evTypes[type];
                var hasEv = false;
                for (var i in evTypes) {
                    hasEv = true;
                    break;
                }
                if (!hasEv) {
                    EventUtils.evList[evIdx] = null;
                    delete obj["__evIdx"];
                }
            }
        }
        var evIdx2 = obj["__evIdx2"];
        if (evIdx2 != null) {
            if (type == null) {
                EventUtils.evList2[evIdx2] = null;
                delete obj["__evIdx2"];
            }
            else {
                var evTypes2 = EventUtils.evList2[evIdx2];
                delete evTypes2[type];
                var hasEv = false;
                for (var i in evTypes2) {
                    hasEv = true;
                    break;
                }
                if (!hasEv) {
                    EventUtils.evList2[evIdx2] = null;
                    delete obj["__evIdx2"];
                }
            }
        }
    };
    EventUtils.evList = [];
    EventUtils.evList2 = [];
    return EventUtils;
}());
var MathUtils = (function () {
    function MathUtils() {
    }
    MathUtils.angle2Radian = function (angle) { return angle * Math.PI / 180; };
    ;
    MathUtils.radian2Angle = function (radian) { return 180 * radian / Math.PI; };
    ;
    MathUtils.rand = function (n) {
        return Math.floor(Math.random() * n);
    };
    MathUtils.direction360 = function (x1, y1, x2, y2) {
        var n_r = Math.PI / 2;
        if (x1 != x2) {
            n_r = Math.atan((y1 - y2) / (x1 - x2));
        }
        var angle = n_r * 180 / Math.PI;
        if (x2 > x1) {
            if (y2 > y1) {
                angle = Math.abs(angle) + 90;
            }
            else {
                angle = 90 - Math.abs(angle);
            }
        }
        else {
            if (y2 > y1) {
                angle = 90 - Math.abs(angle) + 180;
            }
            else {
                angle = Math.abs(angle) + 270;
            }
        }
        if (angle == 360) {
            angle = 0;
        }
        return angle;
    };
    MathUtils.directionCircle = function (x1, y1, x2, y2, lastAngle) {
        var angle = MathUtils.direction360(x1, y1, x2, y2);
        if (angle == lastAngle)
            return angle;
        var circle = Math.floor(lastAngle / 360);
        var last = lastAngle - circle * 360;
        if (last < 0)
            last += 360;
        if (angle > last) {
            if (angle > 270 && angle <= 360 && last >= 0 && last < 90) {
                circle--;
            }
        }
        else {
            if (angle >= 0 && angle < 90 && last > 270 && last <= 360) {
                circle++;
            }
        }
        return (angle + circle * 360);
    };
    MathUtils.fixIntDigit = function (s, fixDigit) {
        if (fixDigit === void 0) { fixDigit = 4; }
        var ss = s.toString();
        while (ss.length < fixDigit) {
            ss = "0" + ss;
        }
        return ss;
    };
    MathUtils.int = function (v) {
        var a = parseInt(v);
        if (isNaN(a))
            return 0;
        return a;
    };
    MathUtils.float = function (v) {
        var a = parseFloat(v);
        if (isNaN(a))
            return 0;
        return a;
    };
    MathUtils.inAngleRange = function (limitMax, limitMin, angle) {
        limitMax = limitMax + 360;
        limitMin = limitMin + 360;
        var angles = [angle, angle - 360, angle + 360];
        for (var i in angles) {
            var angle = angles[i];
            if (angle > limitMin && angle < limitMax) {
                return true;
            }
        }
        return false;
    };
    MathUtils.isPowerOfTwo = function (x) {
        return (x & (x - 1)) == 0;
    };
    MathUtils.nextHighestPowerOfTwo = function (x) {
        --x;
        for (var i = 1; i < 32; i <<= 1) {
            x = x | x >> i;
        }
        return x + 1;
    };
    MathUtils.getBezierPoint2 = function (startX, startY, CtrlX, CtrlY, endX, endY, t, resultPoint) {
        if (resultPoint === void 0) { resultPoint = null; }
        if (!resultPoint)
            resultPoint = new Point();
        resultPoint.x = Math.pow((1 - t), 2) * startX + 2 * t * (1 - t) * CtrlX + Math.pow(t, 2) * endX;
        resultPoint.y = Math.pow((1 - t), 2) * startY + 2 * t * (1 - t) * CtrlY + Math.pow(t, 2) * endY;
        return resultPoint;
    };
    MathUtils.getOffsetByRotation = function (rotation) {
        var offset = new Point(0, 0);
        if (rotation > 0) {
            var per = Math.floor(rotation / 360);
            var angle360 = rotation - 360 * per;
            if (angle360 < 0)
                angle360 += 360;
            if (angle360 > 0 && angle360 <= 90) {
                offset.x = angle360 / 90;
                var angle45 = Math.abs(angle360 - 45);
                offset.y = (angle45 - 45) / 180;
            }
            else if (angle360 > 90 && angle360 <= 180) {
                var angle135 = Math.abs(angle360 - 135);
                offset.x = (225 - angle135) / 180;
                offset.y = (angle360 - 90) / 90;
            }
            else if (angle360 > 180 && angle360 <= 270) {
                offset.x = (270 - angle360) / 90;
                var angle225 = Math.abs(angle360 - 225);
                offset.y = (225 - angle225) / 180;
            }
            else if (angle360 > 270 && angle360 <= 360) {
                var angle315 = Math.abs(angle360 - 315);
                offset.x = (angle315 - 45) / 180;
                offset.y = (360 - angle360) / 90;
            }
        }
        return offset;
    };
    return MathUtils;
}());
var ObjectUtils = (function () {
    function ObjectUtils() {
    }
    ObjectUtils.getInstanceID = function () {
        return ObjectUtils.idCount++;
    };
    ObjectUtils.getRandID = function () {
        return (new Date().getTime() - 1557554040401) + "_" + Math.random();
    };
    ObjectUtils.clone = function (form, to) {
        for (var i in form) {
            to[i] = form[i];
        }
    };
    ObjectUtils.cloneExcludeFunction = function (form, to) {
        for (var i in form) {
            if (typeof form[i] == "function")
                continue;
            to[i] = form[i];
        }
    };
    ObjectUtils.cloneExcludeNonExistentAttribute = function (form, to) {
        for (var i in to) {
            to[i] = form[i];
        }
    };
    Object.defineProperty(ObjectUtils, "worker", {
        get: function () {
            var _this_1 = this;
            if (!ObjectUtils._worker) {
                ObjectUtils._worker = new Worker(URL.createObjectURL(new Blob([ObjectUtils.workerCode], { type: "text/javascript" })));
                ObjectUtils._worker.onmessage = function (event) {
                    var result = event.data;
                    if (result && result.gcJsonUtils) {
                        var key = result.key;
                        var callback = _this_1._workerOnFins[key];
                        if (callback) {
                            delete _this_1._workerOnFins[key];
                            callback.apply(_this_1, [result.data]);
                        }
                    }
                };
            }
            return ObjectUtils._worker;
        },
        enumerable: false,
        configurable: true
    });
    ObjectUtils.workJsonHandler = function (onFin, type, postData) {
        var worker = ObjectUtils.worker;
        var key = ObjectUtils.getInstanceID();
        this._workerOnFins[key] = onFin;
        try {
            worker.postMessage({ gcJsonUtils: true, key: key, type: type, params: postData });
        }
        catch (e) {
            console.log("Function present in serialized data!");
        }
    };
    ObjectUtils.depthClone = function (o, useworker, onFin) {
        if (useworker === void 0) { useworker = false; }
        if (onFin === void 0) { onFin = null; }
        if (o == null) {
            onFin && onFin.apply(this, [null]);
            return null;
        }
        if (useworker && typeof (Worker) !== "undefined") {
            this.workJsonHandler(onFin, 2, { dataObject: o });
            return null;
        }
        else {
            onFin && onFin.apply(this, [null]);
            return JSON.parse(JSON.stringify(o));
        }
    };
    ObjectUtils.jsonSerialize = function (o, onFin, type, useworker) {
        if (onFin === void 0) { onFin = null; }
        if (useworker === void 0) { useworker = false; }
        if (useworker && typeof (Worker) !== "undefined" && os.platform == 2) {
            this.workJsonHandler(onFin, type, o);
        }
        else {
            var result = JSON.stringify(o.dataObject, null, (o === null || o === void 0 ? void 0 : o.format) ? 4 : null);
            onFin && onFin.apply(this, [result]);
        }
    };
    ObjectUtils.same = function (a, b) {
        if ((a == null && b != null) || (a != null && b == null))
            return false;
        for (var i in a) {
            if (a[i] != b[i]) {
                return false;
            }
        }
        return true;
    };
    ObjectUtils.depthSame = function (a, b, exclude) {
        if (exclude === void 0) { exclude = []; }
        if ((a == null && b != null) || (a != null && b == null))
            return false;
        var aLen = 0, bLen = 0;
        for (var i in a) {
            if (i == "constructor")
                continue;
            if (exclude.some(function (v) { return v == i; }))
                continue;
            aLen++;
        }
        for (var i in b) {
            if (i == "constructor")
                continue;
            if (exclude.some(function (v) { return v == i; }))
                continue;
            bLen++;
        }
        if (bLen != aLen)
            return false;
        for (var i in a) {
            if (i == "constructor")
                continue;
            if (exclude.some(function (v) { return v == i; }))
                continue;
            var aValue = a[i];
            if (typeof aValue == "boolean" || typeof aValue == "number" || typeof aValue == "string") {
                if (aValue != b[i]) {
                    return false;
                }
            }
            else {
                if (!ObjectUtils.depthSame(aValue, b[i], exclude)) {
                    return false;
                }
            }
        }
        return true;
    };
    ObjectUtils.assignment = function (a, b) {
        for (var i in b) {
            var value = b[i];
            var attrType = typeof value;
            if (attrType == "number" || attrType == "string" || attrType == "boolean") {
                a[i] = value;
            }
            else if (typeof a[i] == "function") {
                continue;
            }
            else {
                if (a[i]) {
                    this.assignment(a[i], value);
                }
            }
        }
    };
    ObjectUtils.reDefineGetSet = function (target, defineContent) {
        for (var i in defineContent) {
            var str = "\n            Object.defineProperty(" + target + ", \"" + i + "\", {\n                set: function (v) {\n                    this._" + i + " = v;\n                    defineContent." + i + ".apply(this,[v]);\n                },\n                get: function () {\n                    return this._" + i + "\n                }\n            });\n            ";
            eval(str);
        }
        var arr = target.split(".");
        if (arr.pop() == "prototype") {
            eval("setTimeout(function(){new " + arr.join(".") + "()},0);");
        }
    };
    ObjectUtils.agentFunction = function (target, agentTargetName, funcs, logic) {
        if (logic === void 0) { logic = ""; }
        for (var i in funcs) {
            var funcName = funcs[i];
            eval("\n                target." + funcName + " = function () {\n                   " + logic + "\n                   return this." + agentTargetName + "." + funcName + ".apply(this." + agentTargetName + ",arguments);\n                }\n            ");
        }
    };
    ObjectUtils.idCount = 0;
    ObjectUtils.workerCode = "\n        // worker.js\n        self.addEventListener('message', function (event) {\n            const data = event.data;\n            if (!data || !data.gcJsonUtils) return;\n            var key = data.key;\n            var result = null;\n            var params = data.params;\n            if (data.type == 1) {\n                result = jsonSerialize(params.isJson, params.format, params.localURL, params.dataObject);\n            } else if (data.type == 2) {\n                result = jsonDepthClone(params.dataObject);\n            }else if (data.type == 3) {\n                result = jsonSerialize2(params.isJson, params.format, params.dataObject);\n            }else if (data.type == 4) {\n                result = jsonSerialize3(params.isJson, params.format, params.localURL, params.dataObject);\n            }\n            self.postMessage({key:key,gcJsonUtils:true,data:result});\n        });\n        /**\n         * json\u5E8F\u5217\u53161\n         */\n        function jsonSerialize(isJson, format, localURL, dataObject) {\n            var dataString = isJson ? (format ? JSON.stringify(dataObject, null, 4) : JSON.stringify(dataObject)) : dataObject;\n            var data = JSON.stringify({ mode: 0, localURL: localURL, content: dataString });\n            return data;\n        }\n        /**\n         * json\u6DF1\u5EA6\u514B\u9686\n         */\n        function jsonDepthClone(dataObject) {\n            var data = JSON.parse(JSON.stringify(dataObject));\n            return data;\n        }\n        /**\n         * json\u5E8F\u5217\u53162\n         */\n        function jsonSerialize2(isJson, format, dataObject) {\n            var dataString = isJson ? (format ? JSON.stringify(dataObject, null, 4) : JSON.stringify(dataObject)) : dataObject;\n            return dataString;\n        }\n        /**\n         * json\u5E8F\u5217\u53163\n         */\n        function jsonSerialize3(isJson, format, localURL, dataObject) {\n            var data = JSON.stringify({ mode: 8, localURL: localURL, content: dataObject });\n            return data;\n        }\n    ";
    ObjectUtils._workerOnFins = {};
    return ObjectUtils;
}());
var PoolUtils = (function () {
    function PoolUtils(cls) {
        this.pools = [];
        this.cls = cls;
    }
    PoolUtils.prototype.free = function (obj) {
        this.pools.push(obj);
    };
    PoolUtils.prototype.takeout = function (asc) {
        if (asc === void 0) { asc = true; }
        if (this.pools.length > 0) {
            return asc ? this.pools.shift() : this.pools.pop();
        }
        return new this.cls();
    };
    return PoolUtils;
}());
var StringUtils = (function () {
    function StringUtils() {
    }
    StringUtils.getRealLength = function (str) {
        var realLength = 0, len = str.length, charCode = -1;
        for (var i = 0; i < len; i++) {
            charCode = str.charCodeAt(i);
            if (charCode >= 0 && charCode <= 128)
                realLength += 1;
            else
                realLength += 2;
        }
        return realLength;
    };
    StringUtils.clearHtmlTag = function (str) {
        if (!str || typeof str != "string")
            return str;
        return str.replace(/<(s|\/s)pa[^>]+>/g, "");
    };
    StringUtils.clearHtmlTag1 = function (str) {
        if (!str || typeof str != "string")
            return str;
        var space = " ";
        str = str.replace(/<img[^>]+\/>|<(s|\/s)pa[^>]+>/g, "");
        str = str.replace(/\<br\>/g, "");
        str = str.replace(/\u0005/g, '');
        str = str.replace(/&nbsp;/g, space);
        str = str.replace(/[\s]+/g, space);
        str = str.replace(space, "");
        return str;
    };
    StringUtils.paraseCustomMessage = function (info) {
        var title = "", content = "";
        try {
            var arr = info.title.split("<span></span>");
            if (arr[1])
                title = StringUtils.clearHtmlTag1(arr[1]);
            if (arr[2])
                content = StringUtils.clearHtmlTag1(arr[2]);
        }
        catch (e) {
            title = StringUtils.clearHtmlTag1(info.title);
        }
        return { title: title, content: content };
    };
    StringUtils.toHtmlEscape = function (t) {
        if (!t || typeof t != "string")
            return t;
        t = t.replace(/\</g, "〈");
        t = t.replace(/\>/g, "〉");
        t = t.replace(/&/g, "&amp;");
        t = t.replace(/ /g, "&nbsp;");
        return t;
    };
    StringUtils.htmlEscapeToText = function (t) {
        if (!t || typeof t != "string")
            return t;
        t = t.replace(/〈/g, "<");
        t = t.replace(/&#60;/g, "<");
        t = t.replace(/〉/g, ">");
        t = t.replace(/&#62;/g, ">");
        t = t.replace(/&amp;/g, "&");
        t = t.replace(/&nbsp;/g, " ");
        return t;
    };
    StringUtils.getMiddleDiff = function (str1, str2) {
        var oldFirstEndIndex = 0;
        var newSccondStartIndex = 0;
        var shortLen = Math.min(str1.length, str2.length);
        for (var i = 0; i < shortLen; i++) {
            if (str1[i] == str2[i]) {
                oldFirstEndIndex = i + 1;
            }
            else {
                break;
            }
        }
        var nStr1 = str1.substr(oldFirstEndIndex);
        var nStr2 = str2.substr(oldFirstEndIndex);
        shortLen -= oldFirstEndIndex;
        for (var i = 0; i < shortLen; i++) {
            var oldIndex = nStr1.length - 1 - i;
            var newIndex = nStr2.length - 1 - i;
            if (nStr1[oldIndex] == nStr2[newIndex]) {
                newSccondStartIndex = i + 1;
            }
            else {
                break;
            }
        }
        return [oldFirstEndIndex, newSccondStartIndex];
    };
    ;
    StringUtils.clearHeadNotes = function (t) {
        if (!t || typeof t != "string")
            return t;
        t = t.replace(/\/\/.*?\\n/g, "");
        t = t.replace(/\*(.|[\r\n])*?\*/g, "");
        return t;
    };
    StringUtils.clearSpecialKey = function (t) {
        if (!t || typeof t != "string")
            return t;
        t = t.replace(/\/\/.*/g, "");
        t = t.replace(/@param.*/g, "");
        t = t.replace(/alert.*/g, "");
        t = t.replace(/trace.*/g, "");
        t = t.replace(/console.*/g, "");
        t = t.replace(/asset.*/g, "");
        return t;
    };
    StringUtils.getStringLineFeed = function (str) {
        if (!str || typeof str != "string")
            return str;
        str = str.replace(/(\\n)/g, "\n");
        str = str.replace(/(\r)/g, "\n");
        str = str.replace(/(\\r)/g, "\n");
        return str.split("\n");
    };
    StringUtils.removeTheFirstSpace = function (str) {
        if (!str || typeof str != "string")
            return str;
        var _str = str.split(",");
        if (_str.length > 1) {
            _str = _str.map(function (v) {
                return v.replace(/(^\s*)/g, "");
            });
            return _str.join(",");
        }
        else
            return str.replace(/(^\s*)/g, "");
    };
    return StringUtils;
}());
//@cannot search
// domain
var gcTop = top.top;

var gcParent = parent;
try {
    top.document.domain
}
catch (e) {
    gcTop = gcParent = window;
}

var top_kdsrpg;
if (gcTop.gcide_common && gcTop.gcide_common.kdsrpg) {
    top_kdsrpg = gcTop.gcide_common.kdsrpg;
}
if (typeof gcTop.gcide_common != "undefined" && typeof top_kdsrpg != "undefined") {
    gcTop.gcide_core.frameRef(1);
}

var console_warn = function () { }
var console_log = function () { }
var console_error = function () { }
var console_debug = function () { }
//------------------------------------------------------------------------------------------------------
// 第三方渲染引擎，API对接完成后替换底层渲染引擎
// 目前做了一些微略修改
//------------------------------------------------------------------------------------------------------
var Laya = window.Laya = (function (window, document) {
    var Laya = {
        __internals: [],
        __packages: {},
        __classmap: { 'Object': Object, 'Function': Function, 'Array': Array, 'String': String },
        __sysClass: { 'object': 'Object', 'array': 'Array', 'string': 'String', 'dictionary': 'Dictionary' },
        __propun: { writable: true, enumerable: false, configurable: true },
        __presubstr: String.prototype.substr,
        __substr: function (ofs, sz) { return arguments.length == 1 ? Laya.__presubstr.call(this, ofs) : Laya.__presubstr.call(this, ofs, sz > 0 ? sz : (this.length + sz)); },
        __init: function (_classs) { _classs.forEach(function (o) { o.__init$ && o.__init$(); }); },
        __isClass: function (o) { return o && (o.__isclass || o == Object || o == String || o == Array); },
        __newvec: function (sz, value) {
            var d = [];
            d.length = sz;
            for (var i = 0; i < sz; i++)
                d[i] = value;
            return d;
        },
        __extend: function (d, b) {
            for (var p in b) {
                if (!b.hasOwnProperty(p))
                    continue;
                var gs = Object.getOwnPropertyDescriptor(b, p);
                var g = gs.get, s = gs.set;
                if (g || s) {
                    if (g && s)
                        Object.defineProperty(d, p, gs);
                    else {
                        g && Object.defineProperty(d, p, g);
                        s && Object.defineProperty(d, p, s);
                    }
                }
                else
                    d[p] = b[p];
            }
            function __() { Laya.un(this, 'constructor', d); }
            __.prototype = b.prototype;
            d.prototype = new __();
            Laya.un(d.prototype, '__imps', Laya.__copy({}, b.prototype.__imps));
        },
        __copy: function (dec, src) {
            if (!src)
                return null;
            dec = dec || {};
            for (var i in src)
                dec[i] = src[i];
            return dec;
        },
        __package: function (name, o) {
            if (Laya.__packages[name])
                return;
            Laya.__packages[name] = true;
            var p = window, strs = name.split('.');
            if (strs.length > 1) {
                for (var i = 0, sz = strs.length - 1; i < sz; i++) {
                    var c = p[strs[i]];
                    p = c ? c : (p[strs[i]] = {});
                }
            }
            p[strs[strs.length - 1]] || (p[strs[strs.length - 1]] = o || {});
        },
        __hasOwnProperty: function (name, o) {
            o = o || this;
            function classHas(name, o) {
                if (Object.hasOwnProperty.call(o.prototype, name))
                    return true;
                var s = o.prototype.__super;
                return s == null ? null : classHas(name, s);
            }
            return (Object.hasOwnProperty.call(o, name)) || classHas(name, o.__class);
        },
        __typeof: function (o, value) {
            if (!o || !value)
                return false;
            if (value === String)
                return (typeof o === 'string');
            if (value === Number)
                return (typeof o === 'number');
            if (value.__interface__)
                value = value.__interface__;
            else if (typeof value != 'string')
                return (o instanceof value);
            return (o.__imps && o.__imps[value]) || (o.__class == value);
        },
        __as: function (value, type) {
            return (this.__typeof(value, type)) ? value : null;
        },
        __int: function (value) {
            return value ? parseInt(value) : 0;
        },
        interface: function (name, _super) {
            Laya.__package(name, {});
            var ins = Laya.__internals;
            var a = ins[name] = ins[name] || { self: name };
            if (_super) {
                var supers = _super.split(',');
                a.extend = [];
                for (var i = 0; i < supers.length; i++) {
                    var nm = supers[i];
                    ins[nm] = ins[nm] || { self: nm };
                    a.extend.push(ins[nm]);
                }
            }
            var o = window, words = name.split('.');
            for (var i = 0; i < words.length - 1; i++)
                o = o[words[i]];
            o[words[words.length - 1]] = { __interface__: name };
        },
        class: function (o, fullName, _super, miniName) {
            _super && Laya.__extend(o, _super);
            if (fullName) {
                Laya.__package(fullName, o);
                Laya.__classmap[fullName] = o;
                if (fullName.indexOf('.') > 0) {
                    if (fullName.indexOf('laya.') == 0) {
                        var paths = fullName.split('.');
                        miniName = miniName || paths[paths.length - 1];
                        if (Laya[miniName])
                            console_log("Warning!,this class[" + miniName + "] already exist:", Laya[miniName]);
                        Laya[miniName] = o;
                    }
                }
                else {
                    if (fullName == "Main")
                        window.Main = o;
                    else {
                        if (Laya[fullName]) {
                            console_log("Error!,this class[" + fullName + "] already exist:", Laya[fullName]);
                        }
                        Laya[fullName] = o;
                    }
                }
            }
            var un = Laya.un, p = o.prototype;
            un(p, 'hasOwnProperty', Laya.__hasOwnProperty);
            un(p, '__class', o);
            un(p, '__super', _super);
            un(p, '__className', fullName);
            un(o, '__super', _super);
            un(o, '__className', fullName);
            un(o, '__isclass', true);
            un(o, 'super', function (o) { this.__super.call(o); });
        },
        imps: function (dec, src) {
            if (!src)
                return null;
            var d = dec.__imps || Laya.un(dec, '__imps', {});
            function __(name) {
                var c, exs;
                if (!(c = Laya.__internals[name]))
                    return;
                d[name] = true;
                if (!(exs = c.extend))
                    return;
                for (var i = 0; i < exs.length; i++) {
                    __(exs[i].self);
                }
            }
            for (var i in src)
                __(i);
        },
        superSet: function (clas, o, prop, value) {
            var fun = clas.prototype["_$set_" + prop];
            fun && fun.call(o, value);
        },
        superGet: function (clas, o, prop) {
            var fun = clas.prototype["_$get_" + prop];
            return fun ? fun.call(o) : null;
        },
        getset: function (isStatic, o, name, getfn, setfn) {
            if (!isStatic) {
                getfn && Laya.un(o, '_$get_' + name, getfn);
                setfn && Laya.un(o, '_$set_' + name, setfn);
            }
            else {
                getfn && (o['_$GET_' + name] = getfn);
                setfn && (o['_$SET_' + name] = setfn);
            }
            if (getfn && setfn)
                Object.defineProperty(o, name, { get: getfn, set: setfn, enumerable: false, configurable: true });
            else {
                getfn && Object.defineProperty(o, name, { get: getfn, enumerable: false, configurable: true });
                setfn && Object.defineProperty(o, name, { set: setfn, enumerable: false, configurable: true });
            }
        },
        static: function (_class, def) {
            for (var i = 0, sz = def.length; i < sz; i += 2) {
                if (def[i] == 'length')
                    _class.length = def[i + 1].call(_class);
                else {
                    function tmp() {
                        var name = def[i];
                        var getfn = def[i + 1];
                        Object.defineProperty(_class, name, {
                            get: function () { delete this[name]; return this[name] = getfn.call(this); },
                            set: function (v) { delete this[name]; this[name] = v; }, enumerable: true, configurable: true
                        });
                    }
                    tmp();
                }
            }
        },
        un: function (obj, name, value) {
            value || (value = obj[name]);
            Laya.__propun.value = value;
            Object.defineProperty(obj, name, Laya.__propun);
            return value;
        },
        uns: function (obj, names) {
            names.forEach(function (o) { Laya.un(obj, o); });
        }
    };
    window.console = window.console || ({ log: function () { } });
    window.trace = window.console.log;
    Error.prototype.throwError = function () { throw arguments; };
    Object.defineProperty(Array.prototype, 'fixed', { enumerable: false });
    return Laya;
})(window, document);
(function (window, document, Laya) {
    var __un = Laya.un, __uns = Laya.uns, __static = Laya.static, __class = Laya.class, __getset = Laya.getset, __newvec = Laya.__newvec;
})(window, document, Laya);
(function (window, document, Laya) {
    var __un = Laya.un, __uns = Laya.uns, __static = Laya.static, __class = Laya.class, __getset = Laya.getset, __newvec = Laya.__newvec;
    Laya.interface('laya.runtime.IMarket');
    Laya.interface('laya.filters.IFilter');
    Laya.interface('laya.display.ILayout');
    Laya.interface('laya.resource.IDispose');
    Laya.interface('laya.runtime.IPlatform');
    Laya.interface('laya.resource.IDestroy');
    Laya.interface('laya.runtime.IConchNode');
    Laya.interface('laya.filters.IFilterAction');
    Laya.interface('laya.runtime.ICPlatformClass');
    Laya.interface('laya.resource.ICreateResource');
    Laya.interface('laya.runtime.IConchRenderObject');
    Laya.interface('laya.runtime.IPlatformClass', 'laya.runtime.IPlatform');
    var RunDriver = (function () {
        function RunDriver() { }
        __class(RunDriver, 'laya.utils.RunDriver');
        RunDriver.FILTER_ACTIONS = [];
        RunDriver.pixelRatio = -1;
        RunDriver._charSizeTestDiv = null;
        RunDriver.now = function () {
            return Date.now();
        };
        RunDriver.getWindow = function () {
            return window;
        };
        RunDriver.getPixelRatio = function () {
            if (RunDriver.pixelRatio < 0) {
                var ctx = Browser.context;
                var backingStore = ctx.backingStorePixelRatio || ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;
                RunDriver.pixelRatio = (Browser.window.devicePixelRatio || 1) / backingStore;
                if (RunDriver.pixelRatio < 1)
                    RunDriver.pixelRatio = 1;
            }
            return RunDriver.pixelRatio;
        };
        RunDriver.getIncludeStr = function (name) {
            return null;
        };
        RunDriver.createShaderCondition = function (conditionScript) {
            var fn = "(function() {return " + conditionScript + ";})";
            return Browser.window.eval(fn);
        };
        RunDriver.fontMap = [];
        RunDriver.measureText = function (txt, font) {
            var isChinese = RunDriver.hanzi.test(txt);
            if (isChinese && RunDriver.fontMap[font]) {
                return RunDriver.fontMap[font];
            }
            ;
            var ctx = Browser.context;
            ctx.font = font;
            var r = ctx.measureText(txt);
            if (isChinese)
                RunDriver.fontMap[font] = r;
            return r;
        };
        RunDriver.getWebGLContext = function (canvas) {
        };
        RunDriver.beginFlush = function () {
        };
        RunDriver.endFinish = function () {
        };
        RunDriver.addToAtlas = null;
        RunDriver.flashFlushImage = function (atlasWebGLCanvas) {
        };
        RunDriver.drawToCanvas = function (sprite, _renderType, canvasWidth, canvasHeight, offsetX, offsetY) {
            var canvas = HTMLCanvas.create("2D");
            var context = new RenderContext(canvasWidth, canvasHeight, canvas);
            RenderSprite.renders[_renderType]._fun(sprite, context, offsetX, offsetY);
            return canvas;
        };
        RunDriver.createParticleTemplate2D = null;
        RunDriver.createGLTextur = null;
        RunDriver.createWebGLContext2D = null;
        RunDriver.changeWebGLSize = function (w, h) {
        };
        RunDriver.createRenderSprite = function (type, next) {
            return new RenderSprite(type, next);
        };
        RunDriver.createFilterAction = function (type) {
            return new ColorFilterAction();
        };
        RunDriver.createGraphics = function () {
            return new Graphics();
        };
        RunDriver.clear = function (value) {
            Render._context.ctx.clear();
        };
        RunDriver.cancelLoadByUrl = function (url) {
        };
        RunDriver.clearAtlas = function (value) {
        };
        RunDriver.isAtlas = function (bitmap) {
            return false;
        };
        RunDriver.addTextureToAtlas = function (value) {
        };
        RunDriver.getTexturePixels = function (value, x, y, width, height) {
            return null;
        };
        RunDriver.skinAniSprite = function () {
            return null;
        };
        RunDriver.update3DLoop = function () {
        };
        __static(RunDriver, ['hanzi', function () { return this.hanzi = new RegExp("^[\u4E00-\u9FA5]$"); }
        ]);
        return RunDriver;
    })();
    var ___The3 = (function () {
        __getset(1, Laya, 'alertGlobalError', null, function (value) {
            var erralert = 0;
            if (value) {
                Browser.window.onerror = function (msg, url, line, column, detail) {
                    if (erralert++ < 5 && detail)
                        alert("出错啦，请把此信息截图给研发商\n" + msg + "\n" + detail.stack || detail);
                };
            }
            else {
                Browser.window.onerror = null;
            }
        });
        Laya.init = function (width, height, __plugins) {
            var plugins = [];
            for (var i = 2, sz = arguments.length; i < sz; i++)
                plugins.push(arguments[i]);
            if (Laya._isinit)
                return;
            ArrayBuffer.prototype.slice || (ArrayBuffer.prototype.slice = Laya._arrayBufferSlice);
            Laya._isinit = true;
            Browser.__init__();
            Context.__init__();
            Graphics.__init__();
            Laya.timer = new Timer();
            Laya.scaleTimer = new Timer();
            Laya.loader = new LoaderManager();
            WeakObject.__init__();
            for (var i = 0, n = plugins.length; i < n; i++) {
                if (plugins[i].enable)
                    plugins[i].enable();
            }
            Font.__init__();
            Style.__init__();
            ResourceManager.__init__();
            CacheManager.beginCheck();
            Laya._currentStage = Laya.stage = new Stage();
            Laya.stage.conchModel && Laya.stage.conchModel.setRootNode();
            Laya.getUrlPath();
            Laya.render = new Render(0, 0);
            Laya.stage.size(width, height);
            RenderSprite.__init__();
            KeyBoardManager.__init__();
            MouseManager.instance.__init__(Laya.stage, Render.canvas);
            Input.__init__();
            SoundManager.autoStopMusic = true;
            LocalStorage.__init__();
            return Render.canvas;
        };
        Laya.getUrlPath = function () {
            var location = Browser.window.location;
            var pathName = location.pathname;
            pathName = pathName.charAt(2) == ':' ? pathName.substring(1) : pathName;
            URL.rootPath = URL.basePath = URL.getPath(location.protocol == "file:" ? pathName : location.protocol + "//" + location.host + location.pathname);
        };
        Laya._arrayBufferSlice = function (start, end) {
            var arr = this;
            var arrU8List = new Uint8Array(arr, start, end - start);
            var newU8List = new Uint8Array(arrU8List.length);
            newU8List.set(arrU8List);
            return newU8List.buffer;
        };
        Laya.stage = null;
        Laya.timer = null;
        Laya.scaleTimer = null;
        Laya.loader = null;
        Laya.version = "1.7.17beta";
        Laya.render = null;
        Laya._currentStage = null;
        Laya._isinit = false;
        Laya.MiniAdpter = {
            init: function () {
                if (window.navigator && window.navigator.userAgent && window.navigator.userAgent.indexOf("MiniGame") > -1)
                    console_error("请先引用小游戏适配库laya.wxmini.js,详细教程：https://ldc.the3box.com/doc/?nav=zh-ts-5-0-0");
            }
        };
        __static(Laya, ['conchMarket', function () { return this.conchMarket = window.conch ? conchMarket : null; }, 'PlatformClass', function () { return this.PlatformClass = window.PlatformClass; }
        ]);
        return Laya;
    })();
    var Config = (function () {
        function Config() { }
        __class(Config, 'Config');
        Config.WebGLTextCacheCount = 500;
        Config.atlasEnable = false;
        Config.showCanvasMark = false;
        Config.animationInterval = 50;
        Config.isAntialias = false;
        Config.isAlpha = false;
        Config.premultipliedAlpha = true;
        Config.isStencil = true;
        Config.preserveDrawingBuffer = false;
        return Config;
    })();
    var EventDispatcher = (function () {
        var EventHandler;
        function EventDispatcher() {
            this._events = null;
        }
        __class(EventDispatcher, 'laya.events.EventDispatcher');
        var __proto = EventDispatcher.prototype;
        __proto.hasListener = function (type) {
            var listener = this._events && this._events[type];
            var allnone = true;
            for (var i in listener) {
                if (listener[i]) {
                    allnone = false;
                    break;
                }
            }
            if (allnone)
                return false;
            return !!listener;
        };
        __proto.event = function (type, data) {
            if (!this._events || !this._events[type])
                return false;
            var listeners = this._events[type];
            if (listeners.run) {
                if (listeners.once)
                    delete this._events[type];
                data != null ? listeners.runWith(data) : listeners.run();
            }
            else {
                for (var i = 0, n = listeners.length; i < n; i++) {
                    var listener = listeners[i];
                    if (listener) {
                        (data != null) ? listener.runWith(data) : listener.run();
                    }
                    if (!listener || listener.once) {
                        listeners.splice(i, 1);
                        i--;
                        n--;
                    }
                }
                if (listeners.length === 0 && this._events)
                    delete this._events[type];
            }
            return true;
        };
        __proto.on = function (type, caller, listener, args) {
            return this._createListener(type, caller, listener, args, false);
        };
        __proto.once = function (type, caller, listener, args) {
            return this._createListener(type, caller, listener, args, true);
        };
        __proto._createListener = function (type, caller, listener, args, once, offBefore) {
            (offBefore === void 0) && (offBefore = true);
            offBefore && this.off(type, caller, listener, once);
            var handler = EventHandler.create(caller || this, listener, args, once);
            this._events || (this._events = {});
            var events = this._events;
            if (!events[type])
                events[type] = handler;
            else {
                if (!events[type].run)
                    events[type].push(handler);
                else
                    events[type] = [events[type], handler];
            }
            return this;
        };
        __proto.off = function (type, caller, listener, onceOnly) {
            (onceOnly === void 0) && (onceOnly = false);
            if (!this._events || !this._events[type])
                return this;
            var listeners = this._events[type];
            if (listener != null) {
                if (listeners.run) {
                    if ((!caller || listeners.caller === caller) && listeners.method === listener && (!onceOnly || listeners.once)) {
                        delete this._events[type];
                        listeners.recover();
                    }
                }
                else {
                    var count = 0;
                    for (var i = 0, n = listeners.length; i < n; i++) {
                        var item = listeners[i];
                        if (item && (!caller || item.caller === caller) && item.method === listener && (!onceOnly || item.once)) {
                            count++;
                            listeners[i] = null;
                            item.recover();
                        }
                    }
                    if (count === n)
                        delete this._events[type];
                }
            }
            return this;
        };
        __proto.offAll = function (type) {
            var events = this._events;
            if (!events)
                return this;
            if (type) {
                this._recoverHandlers(events[type]);
                delete events[type];
            }
            else {
                for (var name in events) {
                    this._recoverHandlers(events[name]);
                }
                this._events = null;
            }
            return this;
        };
        __proto._recoverHandlers = function (arr) {
            if (!arr)
                return;
            if (arr.run) {
                arr.recover();
            }
            else {
                for (var i = arr.length - 1; i > -1; i--) {
                    if (arr[i]) {
                        arr[i].recover();
                        arr[i] = null;
                    }
                }
            }
        };
        __proto.isMouseEvent = function (type) {
            return EventDispatcher.MOUSE_EVENTS[type];
        };
        EventDispatcher.MOUSE_EVENTS = { "rightmousedown": true, "rightmouseup": true, "rightclick": true, "mousedown": true, "mouseup": true, "mousemove": true, "mouseover": true, "mouseout": true, "click": true, "doubleclick": true };
        EventDispatcher.__init$ = function () {
            Object.defineProperty(laya.events.EventDispatcher.prototype, "_events", { enumerable: false, writable: true });
            EventHandler = (function (_super) {
                function EventHandler(caller, method, args, once) {
                    EventHandler.__super.call(this, caller, method, args, once);
                }
                __class(EventHandler, '', _super);
                var __proto = EventHandler.prototype;
                __proto.recover = function () {
                    if (this._id > 0) {
                        this._id = 0;
                        EventHandler._pool.push(this.clear());
                    }
                };
                EventHandler.create = function (caller, method, args, once) {
                    (once === void 0) && (once = true);
                    if (EventHandler._pool.length)
                        return EventHandler._pool.pop().setTo(caller, method, args, once);
                    return new EventHandler(caller, method, args, once);
                };
                EventHandler._pool = [];
                return EventHandler;
            })(Handler);
        };
        return EventDispatcher;
    })();
    var Handler = (function () {
        function Handler(caller, method, args, once) {
            this.once = false;
            this._id = 0;
            (once === void 0) && (once = false);
            this.setTo(caller, method, args, once);
        }
        __class(Handler, 'laya.utils.Handler');
        var __proto = Handler.prototype;
        __proto.setTo = function (caller, method, args, once) {
            this._id = Handler._gid++;
            this.caller = caller;
            this.method = method;
            this.args = args;
            this.once = once;
            return this;
        };
        __proto.run = function () {
            if (this.method == null)
                return null;
            var id = this._id;
            var result = this.method.apply(this.caller, this.args);
            this._id === id && this.once && this.recover();
            return result;
        };
        __proto.runWith = function (data) {
            if (this.method == null)
                return null;
            var id = this._id;
            if (data == null)
                var result = this.method.apply(this.caller, this.args);
            else if (!this.args && !data.unshift)
                result = this.method.call(this.caller, data);
            else if (this.args)
                result = this.method.apply(this.caller, this.args.concat(data));
            else
                result = this.method.apply(this.caller, data);
            this._id === id && this.once && this.recover();
            return result;
        };
        __proto.clear = function () {
            this.caller = null;
            this.method = null;
            this.args = null;
            return this;
        };
        __proto.recover = function () {
            if (this._id > 0) {
                this._id = 0;
                Handler._pool.push(this.clear());
            }
        };
        Handler.create = function (caller, method, args, once) {
            (once === void 0) && (once = true);
            if (Handler._pool.length)
                return Handler._pool.pop().setTo(caller, method, args, once);
            return new Handler(caller, method, args, once);
        };
        Handler._pool = [];
        Handler._gid = 1;
        return Handler;
    })();
    var BitmapFont = (function () {
        function BitmapFont() {
            this._texture = null;
            this._fontCharDic = {};
            this._fontWidthMap = {};
            this._complete = null;
            this._path = null;
            this._maxWidth = 0;
            this._spaceWidth = 10;
            this._padding = null;
            this.fontSize = 12;
            this.autoScaleSize = false;
            this.letterSpacing = 0;
        }
        __class(BitmapFont, 'laya.display.BitmapFont');
        var __proto = BitmapFont.prototype;
        __proto.loadFont = function (path, complete) {
            this._path = path;
            this._complete = complete;
            Laya.loader.load([{ url: this._path, type: "xml" }, { url: this._path.replace(".fnt", ".png"), type: "image" }], Handler.create(this, this.onLoaded));
        };
        __proto.onLoaded = function () {
            this.parseFont(Loader.getRes(this._path), Loader.getRes(this._path.replace(".fnt", ".png")));
            this._complete && this._complete.runWith(this._texture ? this : null);
        };
        __proto.parseFont = function (xml, texture) {
            if (xml == null || texture == null)
                return;
            this._texture = texture;
            var tX = 0;
            var tScale = 1;
            var tInfo = xml.getElementsByTagName("info");
            if (!tInfo[0].getAttributeNode) {
                return this.parseFont2(xml, texture);
            }
            this.fontSize = parseInt(tInfo[0].getAttributeNode("size").nodeValue);
            var tPadding = tInfo[0].getAttributeNode("padding").nodeValue;
            var tPaddingArray = tPadding.split(",");
            this._padding = [parseInt(tPaddingArray[0]), parseInt(tPaddingArray[1]), parseInt(tPaddingArray[2]), parseInt(tPaddingArray[3])];
            var chars;
            chars = xml.getElementsByTagName("char");
            var i = 0;
            for (i = 0; i < chars.length; i++) {
                var tAttribute = chars[i];
                var tId = parseInt(tAttribute.getAttributeNode("id").nodeValue);
                var xOffset = parseInt(tAttribute.getAttributeNode("xoffset").nodeValue) / tScale;
                var yOffset = parseInt(tAttribute.getAttributeNode("yoffset").nodeValue) / tScale;
                var xAdvance = parseInt(tAttribute.getAttributeNode("xadvance").nodeValue) / tScale;
                var region = new Rectangle();
                region.x = parseInt(tAttribute.getAttributeNode("x").nodeValue);
                region.y = parseInt(tAttribute.getAttributeNode("y").nodeValue);
                region.width = parseInt(tAttribute.getAttributeNode("width").nodeValue);
                region.height = parseInt(tAttribute.getAttributeNode("height").nodeValue);
                var tTexture = Texture.create(texture, region.x, region.y, region.width, region.height, xOffset, yOffset);
                this._maxWidth = Math.max(this._maxWidth, xAdvance + this.letterSpacing);
                this._fontCharDic[tId] = tTexture;
                this._fontWidthMap[tId] = xAdvance;
            }
        };
        __proto.parseFont2 = function (xml, texture) {
            if (xml == null || texture == null)
                return;
            this._texture = texture;
            var tX = 0;
            var tScale = 1;
            var tInfo = xml.getElementsByTagName("info");
            this.fontSize = parseInt(tInfo[0].attributes["size"].nodeValue);
            var tPadding = tInfo[0].attributes["padding"].nodeValue;
            var tPaddingArray = tPadding.split(",");
            this._padding = [parseInt(tPaddingArray[0]), parseInt(tPaddingArray[1]), parseInt(tPaddingArray[2]), parseInt(tPaddingArray[3])];
            var chars = xml.getElementsByTagName("char");
            var i = 0;
            for (i = 0; i < chars.length; i++) {
                var tAttribute = chars[i].attributes;
                var tId = parseInt(tAttribute["id"].nodeValue);
                var xOffset = parseInt(tAttribute["xoffset"].nodeValue) / tScale;
                var yOffset = parseInt(tAttribute["yoffset"].nodeValue) / tScale;
                var xAdvance = parseInt(tAttribute["xadvance"].nodeValue) / tScale;
                var region = new Rectangle();
                region.x = parseInt(tAttribute["x"].nodeValue);
                region.y = parseInt(tAttribute["y"].nodeValue);
                region.width = parseInt(tAttribute["width"].nodeValue);
                region.height = parseInt(tAttribute["height"].nodeValue);
                var tTexture = Texture.create(texture, region.x, region.y, region.width, region.height, xOffset, yOffset);
                this._maxWidth = Math.max(this._maxWidth, xAdvance + this.letterSpacing);
                this._fontCharDic[tId] = tTexture;
                this._fontWidthMap[tId] = xAdvance;
            }
        };
        __proto.getCharTexture = function (char) {
            return this._fontCharDic[char.charCodeAt(0)];
        };
        __proto.destroy = function () {
            if (this._texture) {
                for (var p in this._fontCharDic) {
                    var tTexture = this._fontCharDic[p];
                    if (tTexture)
                        tTexture.destroy();
                }
                this._texture.destroy();
                this._fontCharDic = null;
                this._fontWidthMap = null;
                this._texture = null;
            }
        };
        __proto.setSpaceWidth = function (spaceWidth) {
            this._spaceWidth = spaceWidth;
        };
        __proto.getCharWidth = function (char) {
            var code = char.charCodeAt(0);
            if (this._fontWidthMap[code])
                return this._fontWidthMap[code] + this.letterSpacing;
            if (char == " ")
                return this._spaceWidth + this.letterSpacing;
            return 0;
        };
        __proto.getTextWidth = function (text) {
            var tWidth = 0;
            for (var i = 0, n = text.length; i < n; i++) {
                tWidth += this.getCharWidth(text.charAt(i));
            }
            return tWidth;
        };
        __proto.getMaxWidth = function () {
            return this._maxWidth;
        };
        __proto.getMaxHeight = function () {
            return this.fontSize;
        };
        __proto.drawText = function (text, sprite, drawX, drawY, align, width) {
            var tWidth = this.getTextWidth(text);
            var tTexture;
            var dx = 0;
            align === "center" && (dx = (width - tWidth) / 2);
            align === "right" && (dx = (width - tWidth));
            var tX = 0;
            for (var i = 0, n = text.length; i < n; i++) {
                tTexture = this.getCharTexture(text.charAt(i));
                if (tTexture) {
                    sprite.graphics.drawTexture(tTexture, drawX + tX + dx + this.letterSpacing, drawY);
                    tX += this.getCharWidth(text.charAt(i));
                }
            }
        };
        return BitmapFont;
    })();
    var Style = (function () {
        function Style() {
            this.alpha = 1;
            this.visible = true;
            this.scrollRect = null;
            this.blendMode = null;
            this._type = 0;
            this._tf = Style._TF_EMPTY;
        }
        __class(Style, 'laya.display.css.Style');
        var __proto = Style.prototype;
        __proto.getTransform = function () {
            return this._tf;
        };
        __proto.setTransform = function (value) {
            this._tf = value === 'none' || !value ? Style._TF_EMPTY : value;
        };
        __proto.setTranslateX = function (value) {
            this._tf === Style._TF_EMPTY && (this._tf = new TransformInfo());
            this._tf.translateX = value;
        };
        __proto.setTranslateY = function (value) {
            this._tf === Style._TF_EMPTY && (this._tf = new TransformInfo());
            this._tf.translateY = value;
        };
        __proto.setScaleX = function (value) {
            this._tf === Style._TF_EMPTY && (this._tf = new TransformInfo());
            this._tf.scaleX = value;
        };
        __proto.setScale = function (x, y) {
            this._tf === Style._TF_EMPTY && (this._tf = new TransformInfo());
            this._tf.scaleX = x;
            this._tf.scaleY = y;
        };
        __proto.setScaleY = function (value) {
            this._tf === Style._TF_EMPTY && (this._tf = new TransformInfo());
            this._tf.scaleY = value;
        };
        __proto.setRotate = function (value) {
            this._tf === Style._TF_EMPTY && (this._tf = new TransformInfo());
            this._tf.rotate = value;
        };
        __proto.setSkewX = function (value) {
            this._tf === Style._TF_EMPTY && (this._tf = new TransformInfo());
            this._tf.skewX = value;
        };
        __proto.setSkewY = function (value) {
            this._tf === Style._TF_EMPTY && (this._tf = new TransformInfo());
            this._tf.skewY = value;
        };
        __proto.destroy = function () {
            this.scrollRect = null;
        };
        __proto.render = function (sprite, context, x, y) { };
        __proto.getCSSStyle = function () {
            return CSSStyle.EMPTY;
        };
        __proto._enableLayout = function () {
            return false;
        };
        __getset(0, __proto, 'scaleX', function () {
            return this._tf.scaleX;
        }, function (value) {
            this.setScaleX(value);
        });
        __getset(0, __proto, 'transform', function () {
            return this.getTransform();
        }, function (value) {
            this.setTransform(value);
        });
        __getset(0, __proto, 'translateX', function () {
            return this._tf.translateX;
        }, function (value) {
            this.setTranslateX(value);
        });
        __getset(0, __proto, 'translateY', function () {
            return this._tf.translateY;
        }, function (value) {
            this.setTranslateY(value);
        });
        __getset(0, __proto, 'scaleY', function () {
            return this._tf.scaleY;
        }, function (value) {
            this.setScaleY(value);
        });
        __getset(0, __proto, 'block', function () {
            return (this._type & 0x1) != 0;
        });
        __getset(0, __proto, 'skewY', function () {
            return this._tf.skewY;
        }, function (value) {
            this.setSkewY(value);
        });
        __getset(0, __proto, 'rotate', function () {
            return this._tf.rotate;
        }, function (value) {
            this.setRotate(value);
        });
        __getset(0, __proto, 'skewX', function () {
            return this._tf.skewX;
        }, function (value) {
            this.setSkewX(value);
        });
        __getset(0, __proto, 'paddingLeft', function () {
            return 0;
        });
        __getset(0, __proto, 'paddingTop', function () {
            return 0;
        });
        __getset(0, __proto, 'absolute', function () {
            return true;
        });
        Style.__init__ = function () {
            Style._TF_EMPTY = new TransformInfo();
            Style.EMPTY = new Style();
        };
        Style.EMPTY = null;
        Style._TF_EMPTY = null;
        return Style;
    })();
    var Font = (function () {
        function Font(src) {
            this._type = 0;
            this._weight = 0;
            this._decoration = null;
            this._text = null;
            this.indent = 0;
            this._color = Color.create(Font.defaultColor);
            this.family = Font.defaultFamily;
            this.stroke = Font._STROKE;
            this.size = Font.defaultSize;
            src && src !== Font.EMPTY && src.copyTo(this);
        }
        __class(Font, 'laya.display.css.Font');
        var __proto = Font.prototype;
        __proto.set = function (value) {
            this._text = null;
            var strs = value.split(' ');
            for (var i = 0, n = strs.length; i < n; i++) {
                var str = strs[i];
                switch (str) {
                    case 'italic':
                        this.italic = true;
                        continue;
                    case 'bold':
                        this.bold = true;
                        continue;
                }
                if (str.indexOf('px') > 0) {
                    this.size = parseInt(str);
                    this.family = strs[i + 1];
                    i++;
                    continue;
                }
            }
        };
        __proto.toString = function () {
            this._text = "";
            this.italic && (this._text += "italic ");
            this.bold && (this._text += "bold ");
            return this._text += this.size + "px " + this.family;
        };
        __proto.copyTo = function (dec) {
            dec._type = this._type;
            dec._text = this._text;
            dec._weight = this._weight;
            dec._color = this._color;
            dec.family = this.family;
            dec.stroke = this.stroke != Font._STROKE ? this.stroke.slice() : Font._STROKE;
            dec.indent = this.indent;
            dec.size = this.size;
        };
        __getset(0, __proto, 'password', function () {
            return (this._type & 0x400) !== 0;
        }, function (value) {
            value ? (this._type |= 0x400) : (this._type &= ~0x400);
        });
        __getset(0, __proto, 'color', function () {
            return this._color.strColor;
        }, function (value) {
            this._color = Color.create(value);
        });
        __getset(0, __proto, 'italic', function () {
            return (this._type & 0x200) !== 0;
        }, function (value) {
            value ? (this._type |= 0x200) : (this._type &= ~0x200);
        });
        __getset(0, __proto, 'bold', function () {
            return (this._type & 0x800) !== 0;
        }, function (value) {
            value ? (this._type |= 0x800) : (this._type &= ~0x800);
        });
        __getset(0, __proto, 'weight', function () {
            return "" + this._weight;
        }, function (value) {
            var weight = 0;
            switch (value) {
                case 'normal':
                    break;
                case 'bold':
                    this.bold = true;
                    weight = 700;
                    break;
                case 'bolder':
                    weight = 800;
                    break;
                case 'lighter':
                    weight = 100;
                    break;
                default:
                    weight = parseInt(value);
            }
            this._weight = weight;
            this._text = null;
        });
        __getset(0, __proto, 'decoration', function () {
            return this._decoration ? this._decoration.value : "none";
        }, function (value) {
            var strs = value.split(' ');
            this._decoration || (this._decoration = {});
            switch (strs[0]) {
                case '_':
                    this._decoration.type = 'underline';
                    break;
                case '-':
                    this._decoration.type = 'line-through';
                    break;
                case 'overline':
                    this._decoration.type = 'overline';
                    break;
                default:
                    this._decoration.type = strs[0];
            }
            strs[1] && (this._decoration.color = Color.create(strs));
            this._decoration.value = value;
        });
        Font.__init__ = function () {
            Font.EMPTY = new Font(null);
        };
        Font.EMPTY = null;
        Font.defaultColor = "#000000";
        Font.defaultSize = 12;
        Font.defaultFamily = "Arial";
        Font.defaultFont = "Arial";
        Font._STROKE = [0, "#000000"];
        Font._ITALIC = 0x200;
        Font._PASSWORD = 0x400;
        Font._BOLD = 0x800;
        return Font;
    })();
    var TransformInfo = (function () {
        function TransformInfo() {
            this.translateX = 0;
            this.translateY = 0;
            this.scaleX = 1;
            this.scaleY = 1;
            this.rotate = 0;
            this.skewX = 0;
            this.skewY = 0;
        }
        __class(TransformInfo, 'laya.display.css.TransformInfo');
        return TransformInfo;
    })();
    var Graphics = (function () {
        function Graphics() {
            this._one = null;
            this._cmds = null;
            this._render = this._renderEmpty;
            if (Render.isConchNode) {
                var _this_ = this;
                _this_._nativeObj = new (window)._conchGraphics();
                _this_.id = _this_._nativeObj.conchID;
            }
        }
        __class(Graphics, 'laya.display.Graphics');
        var __proto = Graphics.prototype;
        __proto.destroy = function () {
            this.clear();
            if (this._graphicBounds)
                this._graphicBounds.destroy();
            this._graphicBounds = null;
            this._vectorgraphArray = null;
            this._sp && (this._sp._renderType = 0);
            this._sp = null;
        };
        __proto.clear = function (recoverCmds) {
            (recoverCmds === void 0) && (recoverCmds = false);
            var i = 0, len = 0;
            if (recoverCmds) {
                var tCmd = this._one;
                if (this._cmds) {
                    len = this._cmds.length;
                    for (i = 0; i < len; i++) {
                        tCmd = this._cmds[i];
                        if (tCmd && (tCmd.callee === Render._context._drawTexture || tCmd.callee === Render._context._drawTextureWithTransform)) {
                            tCmd[0] = null;
                            Graphics._cache.push(tCmd);
                        }
                    }
                    this._cmds.length = 0;
                }
                else if (tCmd) {
                    if (tCmd && (tCmd.callee === Render._context._drawTexture || tCmd.callee === Render._context._drawTextureWithTransform)) {
                        tCmd[0] = null;
                        Graphics._cache.push(tCmd);
                    }
                }
            }
            else {
                this._cmds = null;
            }
            this._one = null;
            this._render = this._renderEmpty;
            this._sp && (this._sp._renderType &= ~0x01 & ~0x200);
            this._repaint();
            if (this._vectorgraphArray) {
                for (i = 0, len = this._vectorgraphArray.length; i < len; i++) {
                    VectorGraphManager.getInstance().deleteShape(this._vectorgraphArray[i]);
                }
                this._vectorgraphArray.length = 0;
            }
        };
        __proto._clearBoundsCache = function () {
            if (this._graphicBounds)
                this._graphicBounds.reset();
        };
        __proto._initGraphicBounds = function () {
            if (!this._graphicBounds) {
                this._graphicBounds = new GraphicsBounds();
                this._graphicBounds._graphics = this;
            }
        };
        __proto._repaint = function () {
            this._clearBoundsCache();
            this._sp && this._sp.repaint();
        };
        __proto._isOnlyOne = function () {
            return !this._cmds || this._cmds.length === 0;
        };
        __proto.getBounds = function (realSize) {
            (realSize === void 0) && (realSize = false);
            this._initGraphicBounds();
            return this._graphicBounds.getBounds(realSize);
        };
        __proto.getBoundPoints = function (realSize) {
            (realSize === void 0) && (realSize = false);
            this._initGraphicBounds();
            return this._graphicBounds.getBoundPoints(realSize);
        };
        __proto._addCmd = function (a) {
            this._cmds = this._cmds || [];
            a.callee = a.shift();
            this._cmds.push(a);
        };
        __proto.setFilters = function (fs) {
            this._saveToCmd(Render._context._setFilters, fs);
        };
        __proto.drawTexture = function (tex, x, y, width, height, m, alpha) {
            (x === void 0) && (x = 0);
            (y === void 0) && (y = 0);
            (width === void 0) && (width = 0);
            (height === void 0) && (height = 0);
            (alpha === void 0) && (alpha = 1);
            if (!tex || alpha < 0.01)
                return null;
            if (!width)
                width = tex.sourceWidth;
            if (!height)
                height = tex.sourceHeight;
            alpha = alpha < 0 ? 0 : (alpha > 1 ? 1 : alpha);
            var offset = (!Render.isWebGL && (Browser.onFirefox || Browser.onEdge || Browser.onIE)) ? 0.5 : 0;
            var wRate = width / tex.sourceWidth;
            var hRate = height / tex.sourceHeight;
            width = tex.width * wRate;
            height = tex.height * hRate;
            if (tex.loaded && (width <= 0 || height <= 0))
                return null;
            x += tex.offsetX * wRate;
            y += tex.offsetY * hRate;
            this._sp && (this._sp._renderType |= 0x200);
            var args;
            x -= offset;
            y -= offset;
            width += 2 * offset;
            height += 2 * offset;
            if (Graphics._cache.length) {
                args = Graphics._cache.pop();
                args[0] = tex;
                args[1] = x;
                args[2] = y;
                args[3] = width;
                args[4] = height;
                args[5] = m;
                args[6] = alpha;
            }
            else {
                args = [tex, x, y, width, height, m, alpha];
            }
            args.callee = (m || alpha != 1) ? Render._context._drawTextureWithTransform : Render._context._drawTexture;
            if (this._one == null && !m && alpha == 1) {
                this._one = args;
                this._render = this._renderOneImg;
            }
            else {
                this._saveToCmd(args.callee, args);
            }
            if (!tex.loaded) {
                tex.once("loaded", this, this._textureLoaded, [tex, args]);
            }
            this._repaint();
            return args;
        };
        __proto.cleanByTexture = function (tex, x, y, width, height) {
            (width === void 0) && (width = 0);
            (height === void 0) && (height = 0);
            if (!tex)
                return this.clear();
            if (this._one && this._render === this._renderOneImg) {
                if (!width)
                    width = tex.sourceWidth;
                if (!height)
                    height = tex.sourceHeight;
                var wRate = width / tex.sourceWidth;
                var hRate = height / tex.sourceHeight;
                width = tex.width * wRate;
                height = tex.height * hRate;
                x += tex.offsetX * wRate;
                y += tex.offsetY * hRate;
                this._one[0] = tex;
                this._one[1] = x;
                this._one[2] = y;
                this._one[3] = width;
                this._one[4] = height;
            }
            else {
                this.clear();
                tex && this.drawTexture(tex, x, y, width, height);
            }
        };
        __proto.drawTextures = function (tex, pos) {
            if (!tex)
                return;
            this._saveToCmd(Render._context._drawTextures, [tex, pos]);
        };
        __proto.fillTexture = function (tex, x, y, width, height, type, offset) {
            (width === void 0) && (width = 0);
            (height === void 0) && (height = 0);
            (type === void 0) && (type = "repeat");
            if (!tex)
                return;
            var args = [tex, x, y, width, height, type, offset || Point.EMPTY, {}];
            if (!tex.loaded) {
                tex.once("loaded", this, this._textureLoaded, [tex, args]);
            }
            this._saveToCmd(Render._context._fillTexture, args);
        };
        __proto._textureLoaded = function (tex, param) {
            param[3] = param[3] || tex.width;
            param[4] = param[4] || tex.height;
            this._repaint();
        };
        __proto.fillCircle = function (x, y, tex, cx, cy, radius, segNum) {
            tex.bitmap.enableMerageInAtlas = false;
            var verts = new Float32Array((segNum + 1) * 2);
            var uvs = new Float32Array((segNum + 1) * 2);
            var indices = new Uint16Array(segNum * 3);
            var dang = 2 * Math.PI / segNum;
            var cang = 0;
            verts[0] = cx;
            verts[1] = cy;
            uvs[0] = cx / tex.width;
            uvs[1] = cy / tex.height;
            var idx = 2;
            for (var i = 0; i < segNum; i++) {
                var px = radius * Math.cos(cang) + cx;
                var py = radius * Math.sin(cang) + cy;
                verts[idx] = px;
                verts[idx + 1] = py;
                uvs[idx] = px / tex.width;
                uvs[idx + 1] = py / tex.height;
                cang += dang;
                idx += 2;
            }
            idx = 0;
            for (i = 0; i < segNum; i++) {
                indices[idx++] = 0;
                indices[idx++] = i + 1;
                indices[idx++] = (i + 2 >= segNum + 1) ? 1 : (i + 2);
            }
            this.drawTriangles(tex, x, y, verts, uvs, indices);
        };
        __proto.drawTriangles = function (texture, x, y, vertices, uvs, indices, matrix, alpha, color, blendMode) {
            (alpha === void 0) && (alpha = 1);
            this._saveToCmd(Render._context.drawTriangles, [texture, x, y, vertices, uvs, indices, matrix, alpha, color, blendMode]);
        };
        __proto._saveToCmd = function (fun, args) {
            this._sp && (this._sp._renderType |= 0x200);
            if (this._one == null) {
                this._one = args;
                this._render = this._renderOne;
            }
            else {
                this._sp && (this._sp._renderType &= ~0x01);
                this._render = this._renderAll;
                (this._cmds || (this._cmds = [])).length === 0 && this._cmds.push(this._one);
                this._cmds.push(args);
            }
            args.callee = fun;
            this._repaint();
            return args;
        };
        __proto.clipRect = function (x, y, width, height) {
            this._saveToCmd(Render._context._clipRect, [x, y, width, height]);
        };
        __proto.fillText = function (text, x, y, font, color, textAlign, underLine) {
            (underLine === void 0) && (underLine = 0);
            this._saveToCmd(Render._context._fillText, [text, x, y, font || Font.defaultFont, color, textAlign]);
        };
        __proto.fillBorderText = function (text, x, y, font, fillColor, borderColor, lineWidth, textAlign) {
            this._saveToCmd(Render._context._fillBorderText, [text, x, y, font || Font.defaultFont, fillColor, borderColor, lineWidth, textAlign]);
        };
        __proto.strokeText = function (text, x, y, font, color, lineWidth, textAlign) {
            this._saveToCmd(Render._context._strokeText, [text, x, y, font || Font.defaultFont, color, lineWidth, textAlign]);
        };
        __proto.alpha = function (value) {
            value = value < 0 ? 0 : (value > 1 ? 1 : value);
            this._saveToCmd(Render._context._alpha, [value]);
        };
        __proto.setAlpha = function (value) {
            value = value < 0 ? 0 : (value > 1 ? 1 : value);
            this._saveToCmd(Render._context._setAlpha, [value]);
        };
        __proto.transform = function (matrix, pivotX, pivotY) {
            (pivotX === void 0) && (pivotX = 0);
            (pivotY === void 0) && (pivotY = 0);
            this._saveToCmd(Render._context._transform, [matrix, pivotX, pivotY]);
        };
        __proto.rotate = function (angle, pivotX, pivotY) {
            (pivotX === void 0) && (pivotX = 0);
            (pivotY === void 0) && (pivotY = 0);
            this._saveToCmd(Render._context._rotate, [angle, pivotX, pivotY]);
        };
        __proto.scale = function (scaleX, scaleY, pivotX, pivotY) {
            (pivotX === void 0) && (pivotX = 0);
            (pivotY === void 0) && (pivotY = 0);
            this._saveToCmd(Render._context._scale, [scaleX, scaleY, pivotX, pivotY]);
        };
        __proto.translate = function (x, y) {
            this._saveToCmd(Render._context._translate, [x, y]);
        };
        __proto.save = function () {
            this._saveToCmd(Render._context._save, []);
        };
        __proto.restore = function () {
            this._saveToCmd(Render._context._restore, []);
        };
        __proto.replaceText = function (text) {
            this._repaint();
            var cmds = this._cmds;
            if (!cmds) {
                if (this._one && this._isTextCmd(this._one.callee)) {
                    if (this._one[0].toUpperCase)
                        this._one[0] = text;
                    else
                        this._one[0].setText(text);
                    return true;
                }
            }
            else {
                for (var i = cmds.length - 1; i > -1; i--) {
                    if (this._isTextCmd(cmds[i].callee)) {
                        if (cmds[i][0].toUpperCase)
                            cmds[i][0] = text;
                        else
                            cmds[i][0].setText(text);
                        return true;
                    }
                }
            }
            return false;
        };
        __proto._isTextCmd = function (fun) {
            return fun === Render._context._fillText || fun === Render._context._fillBorderText || fun === Render._context._strokeText;
        };
        __proto.replaceTextColor = function (color) {
            this._repaint();
            var cmds = this._cmds;
            if (!cmds) {
                if (this._one && this._isTextCmd(this._one.callee)) {
                    this._one[4] = color;
                    if (!this._one[0].toUpperCase)
                        this._one[0].changed = true;
                }
            }
            else {
                for (var i = cmds.length - 1; i > -1; i--) {
                    if (this._isTextCmd(cmds[i].callee)) {
                        cmds[i][4] = color;
                        if (!cmds[i][0].toUpperCase)
                            cmds[i][0].changed = true;
                    }
                }
            }
        };
        __proto.loadImage = function (url, x, y, width, height, complete) {
            var _$this = this;
            (x === void 0) && (x = 0);
            (y === void 0) && (y = 0);
            (width === void 0) && (width = 0);
            (height === void 0) && (height = 0);
            var tex = Loader.getRes(url);
            if (tex)
                onloaded(tex);
            else
                Laya.loader.load(url, Handler.create(null, onloaded), null, "image");
            function onloaded(tex) {
                if (tex) {
                    _$this.drawTexture(tex, x, y, width, height);
                    if (complete != null)
                        complete.call(_$this._sp, tex);
                }
            }
        };
        __proto._renderEmpty = function (sprite, context, x, y) { };
        __proto._renderAll = function (sprite, context, x, y) {
            var cmds = this._cmds, cmd;
            for (var i = 0, n = cmds.length; i < n; i++) {
                (cmd = cmds[i]).callee.call(context, x, y, cmd);
            }
        };
        __proto._renderOne = function (sprite, context, x, y) {
            this._one.callee.call(context, x, y, this._one);
        };
        __proto._renderOneImg = function (sprite, context, x, y) {
            this._one.callee.call(context, x, y, this._one);
            if (sprite._renderType !== 2305) {
                sprite._renderType |= 0x01;
            }
        };
        __proto.drawLine = function (fromX, fromY, toX, toY, lineColor, lineWidth) {
            (lineWidth === void 0) && (lineWidth = 1);
            var tId = 0;
            if (Render.isWebGL) {
                tId = VectorGraphManager.getInstance().getId();
                if (this._vectorgraphArray == null)
                    this._vectorgraphArray = [];
                this._vectorgraphArray.push(tId);
            }
            ;
            var offset = lineWidth % 2 === 0 ? 0 : 0.5;
            var arr = [fromX + offset, fromY + offset, toX + offset, toY + offset, lineColor, lineWidth, tId];
            // var arr = [fromX, fromY, toX, toY, lineColor, lineWidth, tId];
            this._saveToCmd(Render._context._drawLine, arr);
        };
        __proto.drawLines = function (x, y, points, lineColor, lineWidth) {
            (lineWidth === void 0) && (lineWidth = 1);
            var tId = 0;
            if (!points || points.length < 4)
                return;
            if (Render.isWebGL) {
                tId = VectorGraphManager.getInstance().getId();
                if (this._vectorgraphArray == null)
                    this._vectorgraphArray = [];
                this._vectorgraphArray.push(tId);
            }
            // var offset = lineWidth % 2 === 0 ? 0 : 0.5;
            // var __scaleX = this._sp ? this._sp.scaleX : 1;
            // var __scaleY = this._sp ? this._sp.scaleY : 1;
            // var arr = [x + (offset / __scaleX), y + (offset / __scaleY), points, lineColor, lineWidth, tId];
            var arr = [x, y, points, lineColor, lineWidth, tId];
            this._saveToCmd(Render._context._drawLines, arr);
        };
        __proto.drawCurves = function (x, y, points, lineColor, lineWidth) {
            (lineWidth === void 0) && (lineWidth = 1);
            var arr = [x, y, points, lineColor, lineWidth];
            this._saveToCmd(Render._context._drawCurves, arr);
        };
        __proto.drawRect = function (x, y, width, height, fillColor, lineColor, lineWidth) {
            (lineWidth === void 0) && (lineWidth = 1);
            var offset = lineColor ? lineWidth / 2 : 0;
            var lineOffset = lineColor ? lineWidth : 0;
            var arr = [x + offset, y + offset, width - lineOffset, height - lineOffset, fillColor, lineColor, lineWidth];
            this._saveToCmd(Render._context._drawRect, arr);
        };
        __proto.drawCircle = function (x, y, radius, fillColor, lineColor, lineWidth) {
            (lineWidth === void 0) && (lineWidth = 1);
            var offset = lineColor ? lineWidth / 2 : 0;
            var tId = 0;
            if (Render.isWebGL) {
                tId = VectorGraphManager.getInstance().getId();
                if (this._vectorgraphArray == null)
                    this._vectorgraphArray = [];
                this._vectorgraphArray.push(tId);
            }
            ;
            var arr = [x, y, radius - offset, fillColor, lineColor, lineWidth, tId];
            this._saveToCmd(Render._context._drawCircle, arr);
        };
        __proto.drawPie = function (x, y, radius, startAngle, endAngle, fillColor, lineColor, lineWidth) {
            (lineWidth === void 0) && (lineWidth = 1);
            var offset = lineColor ? lineWidth / 2 : 0;
            var lineOffset = lineColor ? lineWidth : 0;
            var tId = 0;
            if (Render.isWebGL) {
                tId = VectorGraphManager.getInstance().getId();
                if (this._vectorgraphArray == null)
                    this._vectorgraphArray = [];
                this._vectorgraphArray.push(tId);
            }
            ;
            var arr = [x + offset, y + offset, radius - lineOffset, startAngle, endAngle, fillColor, lineColor, lineWidth, tId];
            arr[3] = Utils.toRadian(startAngle);
            arr[4] = Utils.toRadian(endAngle);
            this._saveToCmd(Render._context._drawPie, arr);
        };
        __proto.drawPoly = function (x, y, points, fillColor, lineColor, lineWidth) {
            (lineWidth === void 0) && (lineWidth = 1);
            var tId = 0;
            var tIsConvexPolygon = false;
            if (Render.isWebGL) {
                tId = VectorGraphManager.getInstance().getId();
                if (this._vectorgraphArray == null)
                    this._vectorgraphArray = [];
                this._vectorgraphArray.push(tId);
                if (points.length > 6) {
                    tIsConvexPolygon = false;
                }
                else {
                    tIsConvexPolygon = true;
                }
            }
            ;
            var offset = lineColor ? (lineWidth % 2 === 0 ? 0 : 0.5) : 0;
            var arr = [x + offset, y + offset, points, fillColor, lineColor, lineWidth, tId, tIsConvexPolygon];
            this._saveToCmd(Render._context._drawPoly, arr);
        };
        __proto.drawPath = function (x, y, paths, brush, pen) {
            var arr = [x, y, paths, brush, pen];
            this._saveToCmd(Render._context._drawPath, arr);
        };
        __getset(0, __proto, 'cmds', function () {
            return this._cmds;
        }, function (value) {
            this._sp && (this._sp._renderType |= 0x200);
            this._cmds = value;
            this._render = this._renderAll;
            this._repaint();
        });
        Graphics.__init__ = function () {
            if (Render.isConchNode) {
                var from = laya.display.Graphics.prototype;
                var to = Browser.window.ConchGraphics.prototype;
                var list = ["clear", "destroy", "alpha", "rotate", "transform", "scale", "translate", "save", "restore", "clipRect", "blendMode", "fillText", "fillBorderText", "_fands", "drawRect", "drawCircle", "drawPie", "drawPoly", "drawPath", "drawImageM", "drawLine", "drawLines", "_drawPs", "drawCurves", "replaceText", "replaceTextColor", "_fillImage", "fillTexture", "setSkinMesh", "drawParticle", "drawImageS"];
                for (var i = 0, len = list.length; i <= len; i++) {
                    var temp = list[i];
                    from[temp] = to[temp];
                }
                from._saveToCmd = null;
                if (to.drawImageS) {
                    from.drawTextures = function (tex, pos) {
                        if (!tex)
                            return;
                        if (!(tex.loaded && tex.bitmap && tex.source)) {
                            return;
                        }
                        ;
                        var uv = tex.uv, w = tex.bitmap.width, h = tex.bitmap.height;
                        this.drawImageS(tex.bitmap.source, uv[0] * w, uv[1] * h, (uv[2] - uv[0]) * w, (uv[5] - uv[3]) * h, tex.offsetX, tex.offsetY, tex.width, tex.height, pos);
                    };
                }
                from.drawTexture = function (tex, x, y, width, height, m, alpha) {
                    (x === void 0) && (x = 0);
                    (y === void 0) && (y = 0);
                    (width === void 0) && (width = 0);
                    (height === void 0) && (height = 0);
                    (alpha === void 0) && (alpha = 1);
                    if (!tex)
                        return;
                    if (!tex.loaded) {
                        tex.once("loaded", this, function () {
                            this.drawTexture(tex, x, y, width, height, m);
                        });
                        return;
                    }
                    if (!(tex.loaded && tex.bitmap && tex.source)) {
                        return;
                    }
                    if (!width)
                        width = tex.sourceWidth;
                    if (!height)
                        height = tex.sourceHeight;
                    alpha = alpha < 0 ? 0 : (alpha > 1 ? 1 : alpha);
                    width = width - tex.sourceWidth + tex.width;
                    height = height - tex.sourceHeight + tex.height;
                    if (width <= 0 || height <= 0)
                        return;
                    x += tex.offsetX;
                    y += tex.offsetY;
                    var uv = tex.uv, w = tex.bitmap.width, h = tex.bitmap.height;
                    this.drawImageM(tex.bitmap.source, uv[0] * w, uv[1] * h, (uv[2] - uv[0]) * w, (uv[5] - uv[3]) * h, x, y, width, height, m, alpha);
                    this._repaint();
                };
                from.fillTexture = function (tex, x, y, width, height, type, offset) {
                    (width === void 0) && (width = 0);
                    (height === void 0) && (height = 0);
                    (type === void 0) && (type = "repeat");
                    if (!tex)
                        return;
                    if (tex.loaded) {
                        var ctxi = Render._context.ctx;
                        var w = tex.bitmap.width, h = tex.bitmap.height, uv = tex.uv;
                        var pat;
                        if (tex.uv != Texture.DEF_UV) {
                            pat = ctxi.createPattern(tex.bitmap.source, type, uv[0] * w, uv[1] * h, (uv[2] - uv[0]) * w, (uv[5] - uv[3]) * h);
                        }
                        else {
                            pat = ctxi.createPattern(tex.bitmap.source, type);
                        }
                        ;
                        var sX = 0, sY = 0;
                        if (offset) {
                            x += offset.x % tex.width;
                            y += offset.y % tex.height;
                            sX -= offset.x % tex.width;
                            sY -= offset.y % tex.height;
                        }
                        this._fillImage(pat, x, y, sX, sY, width, height);
                    }
                };
            }
        };
        Graphics._cache = [];
        return Graphics;
    })();
    var GraphicsBounds = (function () {
        function GraphicsBounds() {
            this._cacheBoundsType = false;
        }
        __class(GraphicsBounds, 'laya.display.GraphicsBounds');
        var __proto = GraphicsBounds.prototype;
        __proto.destroy = function () {
            this._graphics = null;
            this._temp = null;
            this._rstBoundPoints = null;
            this._bounds = null;
        };
        __proto.reset = function () {
            this._temp && (this._temp.length = 0);
        };
        __proto.getBounds = function (realSize) {
            (realSize === void 0) && (realSize = false);
            if (!this._bounds || !this._temp || this._temp.length < 1 || realSize != this._cacheBoundsType) {
                this._bounds = Rectangle._getWrapRec(this.getBoundPoints(realSize), this._bounds);
            }
            this._cacheBoundsType = realSize;
            return this._bounds;
        };
        __proto.getBoundPoints = function (realSize) {
            (realSize === void 0) && (realSize = false);
            if (!this._temp || this._temp.length < 1 || realSize != this._cacheBoundsType)
                this._temp = this._getCmdPoints(realSize);
            this._cacheBoundsType = realSize;
            return this._rstBoundPoints = Utils.copyArray(this._rstBoundPoints, this._temp);
        };
        __proto._getCmdPoints = function (realSize) {
            (realSize === void 0) && (realSize = false);
            var context = Render._context;
            var cmds = this._graphics.cmds;
            var rst;
            rst = this._temp || (this._temp = []);
            rst.length = 0;
            if (!cmds && this._graphics._one != null) {
                GraphicsBounds._tempCmds.length = 0;
                GraphicsBounds._tempCmds.push(this._graphics._one);
                cmds = GraphicsBounds._tempCmds;
            }
            if (!cmds)
                return rst;
            var matrixs;
            matrixs = GraphicsBounds._tempMatrixArrays;
            matrixs.length = 0;
            var tMatrix = GraphicsBounds._initMatrix;
            tMatrix.identity();
            var tempMatrix = GraphicsBounds._tempMatrix;
            var cmd;
            var tex;
            var wRate = NaN;
            var hRate = NaN;
            var oWidth = NaN;
            var oHeight = NaN;
            var offX = NaN;
            var offY = NaN;
            for (var i = 0, n = cmds.length; i < n; i++) {
                cmd = cmds[i];
                if (!cmd.callee)
                    continue;
                switch (cmd.callee) {
                    case context._save:
                    case 7:
                        matrixs.push(tMatrix);
                        tMatrix = tMatrix.clone();
                        break;
                    case context._restore:
                    case 8:
                        tMatrix = matrixs.pop();
                        break;
                    case context._scale:
                    case 5:
                        tempMatrix.identity();
                        tempMatrix.translate(-cmd[2], -cmd[3]);
                        tempMatrix.scale(cmd[0], cmd[1]);
                        tempMatrix.translate(cmd[2], cmd[3]);
                        this._switchMatrix(tMatrix, tempMatrix);
                        break;
                    case context._rotate:
                    case 3:
                        tempMatrix.identity();
                        tempMatrix.translate(-cmd[1], -cmd[2]);
                        tempMatrix.rotate(cmd[0]);
                        tempMatrix.translate(cmd[1], cmd[2]);
                        this._switchMatrix(tMatrix, tempMatrix);
                        break;
                    case context._translate:
                    case 6:
                        tempMatrix.identity();
                        tempMatrix.translate(cmd[0], cmd[1]);
                        this._switchMatrix(tMatrix, tempMatrix);
                        break;
                    case context._transform:
                    case 4:
                        tempMatrix.identity();
                        tempMatrix.translate(-cmd[1], -cmd[2]);
                        tempMatrix.concat(cmd[0]);
                        tempMatrix.translate(cmd[1], cmd[2]);
                        this._switchMatrix(tMatrix, tempMatrix);
                        break;
                    case 16:
                    case 24:
                        GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd[0], cmd[1], cmd[2], cmd[3]), tMatrix);
                        break;
                    case 17:
                        tMatrix.copyTo(tempMatrix);
                        tempMatrix.concat(cmd[4]);
                        GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd[0], cmd[1], cmd[2], cmd[3]), tempMatrix);
                        break;
                    case context._drawTexture:
                        tex = cmd[0];
                        if (realSize) {
                            if (cmd[3] && cmd[4]) {
                                GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd[1], cmd[2], cmd[3], cmd[4]), tMatrix);
                            }
                            else {
                                tex = cmd[0];
                                GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd[1], cmd[2], tex.width, tex.height), tMatrix);
                            }
                        }
                        else {
                            wRate = (cmd[3] || tex.sourceWidth) / tex.width;
                            hRate = (cmd[4] || tex.sourceHeight) / tex.height;
                            oWidth = wRate * tex.sourceWidth;
                            oHeight = hRate * tex.sourceHeight;
                            offX = tex.offsetX > 0 ? tex.offsetX : 0;
                            offY = tex.offsetY > 0 ? tex.offsetY : 0;
                            offX *= wRate;
                            offY *= hRate;
                            GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd[1] - offX, cmd[2] - offY, oWidth, oHeight), tMatrix);
                        }
                        break;
                    case context._fillTexture:
                        if (cmd[3] && cmd[4]) {
                            GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd[1], cmd[2], cmd[3], cmd[4]), tMatrix);
                        }
                        else {
                            tex = cmd[0];
                            GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd[1], cmd[2], tex.width, tex.height), tMatrix);
                        }
                        break;
                    case context._drawTextureWithTransform:
                        ;
                        var drawMatrix;
                        if (cmd[5]) {
                            tMatrix.copyTo(tempMatrix);
                            tempMatrix.concat(cmd[5]);
                            drawMatrix = tempMatrix;
                        }
                        else {
                            drawMatrix = tMatrix;
                        }
                        if (realSize) {
                            if (cmd[3] && cmd[4]) {
                                GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd[1], cmd[2], cmd[3], cmd[4]), drawMatrix);
                            }
                            else {
                                tex = cmd[0];
                                GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd[1], cmd[2], tex.width, tex.height), drawMatrix);
                            }
                        }
                        else {
                            tex = cmd[0];
                            wRate = (cmd[3] || tex.sourceWidth) / tex.width;
                            hRate = (cmd[4] || tex.sourceHeight) / tex.height;
                            oWidth = wRate * tex.sourceWidth;
                            oHeight = hRate * tex.sourceHeight;
                            offX = tex.offsetX > 0 ? tex.offsetX : 0;
                            offY = tex.offsetY > 0 ? tex.offsetY : 0;
                            offX *= wRate;
                            offY *= hRate;
                            GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd[1] - offX, cmd[2] - offY, oWidth, oHeight), drawMatrix);
                        }
                        break;
                    case context._drawRect:
                    case 13:
                        GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd[0], cmd[1], cmd[2], cmd[3]), tMatrix);
                        break;
                    case context._drawCircle:
                    case context._fillCircle:
                    case 14:
                        GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd[0] - cmd[2], cmd[1] - cmd[2], cmd[2] + cmd[2], cmd[2] + cmd[2]), tMatrix);
                        break;
                    case context._drawLine:
                    case 20:
                        GraphicsBounds._tempPoints.length = 0;
                        var lineWidth = NaN;
                        lineWidth = cmd[5] * 0.5;
                        if (cmd[0] == cmd[2]) {
                            GraphicsBounds._tempPoints.push(cmd[0] + lineWidth, cmd[1], cmd[2] + lineWidth, cmd[3], cmd[0] - lineWidth, cmd[1], cmd[2] - lineWidth, cmd[3]);
                        }
                        else if (cmd[1] == cmd[3]) {
                            GraphicsBounds._tempPoints.push(cmd[0], cmd[1] + lineWidth, cmd[2], cmd[3] + lineWidth, cmd[0], cmd[1] - lineWidth, cmd[2], cmd[3] - lineWidth);
                        }
                        else {
                            GraphicsBounds._tempPoints.push(cmd[0], cmd[1], cmd[2], cmd[3]);
                        }
                        GraphicsBounds._addPointArrToRst(rst, GraphicsBounds._tempPoints, tMatrix);
                        break;
                    case context._drawCurves:
                    case 22:
                        GraphicsBounds._addPointArrToRst(rst, Bezier.I.getBezierPoints(cmd[2]), tMatrix, cmd[0], cmd[1]);
                        break;
                    case context._drawPoly:
                    case context._drawLines:
                    case 18:
                        GraphicsBounds._addPointArrToRst(rst, cmd[2], tMatrix, cmd[0], cmd[1]);
                        break;
                    case context._drawPath:
                    case 19:
                        GraphicsBounds._addPointArrToRst(rst, this._getPathPoints(cmd[2]), tMatrix, cmd[0], cmd[1]);
                        break;
                    case context._drawPie:
                    case 15:
                        GraphicsBounds._addPointArrToRst(rst, this._getPiePoints(cmd[0], cmd[1], cmd[2], cmd[3], cmd[4]), tMatrix);
                        break;
                }
            }
            if (rst.length > 200) {
                rst = Utils.copyArray(rst, Rectangle._getWrapRec(rst)._getBoundPoints());
            }
            else if (rst.length > 8)
                rst = GrahamScan.scanPList(rst);
            return rst;
        };
        __proto._switchMatrix = function (tMatix, tempMatrix) {
            tempMatrix.concat(tMatix);
            tempMatrix.copyTo(tMatix);
        };
        __proto._getPiePoints = function (x, y, radius, startAngle, endAngle) {
            var rst = GraphicsBounds._tempPoints;
            GraphicsBounds._tempPoints.length = 0;
            rst.push(x, y);
            var delta = (endAngle - startAngle) % (2 * Math.PI);
            var segnum = 10;
            var step = delta / segnum;
            var i = NaN;
            var angle = startAngle;
            for (i = 0; i <= segnum; i++) {
                rst.push(x + radius * Math.cos(angle), y + radius * Math.sin(angle));
                angle += step;
            }
            return rst;
        };
        __proto._getPathPoints = function (paths) {
            var i = 0, len = 0;
            var rst = GraphicsBounds._tempPoints;
            rst.length = 0;
            len = paths.length;
            var tCMD;
            for (i = 0; i < len; i++) {
                tCMD = paths[i];
                if (tCMD.length > 1) {
                    rst.push(tCMD[1], tCMD[2]);
                    if (tCMD.length > 3) {
                        rst.push(tCMD[3], tCMD[4]);
                    }
                }
            }
            return rst;
        };
        GraphicsBounds._addPointArrToRst = function (rst, points, matrix, dx, dy) {
            (dx === void 0) && (dx = 0);
            (dy === void 0) && (dy = 0);
            var i = 0, len = 0;
            len = points.length;
            for (i = 0; i < len; i += 2) {
                GraphicsBounds._addPointToRst(rst, points[i] + dx, points[i + 1] + dy, matrix);
            }
        };
        GraphicsBounds._addPointToRst = function (rst, x, y, matrix) {
            var _tempPoint = Point.TEMP;
            _tempPoint.setTo(x ? x : 0, y ? y : 0);
            matrix.transformPoint(_tempPoint);
            rst.push(_tempPoint.x, _tempPoint.y);
        };
        GraphicsBounds._tempPoints = [];
        GraphicsBounds._tempMatrixArrays = [];
        GraphicsBounds._tempCmds = [];
        __static(GraphicsBounds, ['_tempMatrix', function () { return this._tempMatrix = new Matrix(); }, '_initMatrix', function () { return this._initMatrix = new Matrix(); }
        ]);
        return GraphicsBounds;
    })();
    var Event = (function () {
        function Event() {
        }
        __class(Event, 'laya.events.Event');
        var __proto = Event.prototype;
        __proto.setTo = function (type, currentTarget, target) {
            this.type = type;
            this.currentTarget = currentTarget;
            this.target = target;
            return this;
        };
        __proto.stopPropagation = function () {
            this._stoped = true;
        };
        __getset(0, __proto, 'stageY', function () {
            return Laya.stage.mouseY;
        });
        __getset(0, __proto, 'charCode', function () {
            return this.nativeEvent.charCode;
        });
        __getset(0, __proto, 'touches', function () {
            var arr = this.nativeEvent.touches;
            if (arr) {
                var stage = Laya.stage;
                for (var i = 0, n = arr.length; i < n; i++) {
                    var e = arr[i];
                    var point = Point.TEMP;
                    point.setTo(e.clientX, e.clientY);
                    stage._canvasTransform.invertTransformPoint(point);
                    stage.transform.invertTransformPoint(point);
                    e.stageX = point.x;
                    e.stageY = point.y;
                }
            }
            return arr;
        });
        __getset(0, __proto, 'keyLocation', function () {
            return this.nativeEvent.keyLocation;
        });
        __getset(0, __proto, 'ctrlKey', function () {
            return this.nativeEvent.ctrlKey;
        });
        __getset(0, __proto, 'altKey', function () {
            return this.nativeEvent.altKey;
        });
        __getset(0, __proto, 'shiftKey', function () {
            return this.nativeEvent.shiftKey;
        });
        __getset(0, __proto, 'stageX', function () {
            return Laya.stage.mouseX;
        });
        Event.EMPTY = new Event();
        Event.MOUSE_DOWN = "mousedown";
        Event.MOUSE_UP = "mouseup";
        Event.CLICK = "click";
        Event.RIGHT_MOUSE_DOWN = "rightmousedown";
        Event.RIGHT_MOUSE_UP = "rightmouseup";
        Event.RIGHT_CLICK = "rightclick";
        Event.MOUSE_MOVE = "mousemove";
        Event.MOUSE_OVER = "mouseover";
        Event.MOUSE_OUT = "mouseout";
        Event.MOUSE_WHEEL = "mousewheel";
        Event.ROLL_OVER = "mouseover";
        Event.ROLL_OUT = "mouseout";
        Event.DOUBLE_CLICK = "doubleclick";
        Event.CHANGE = "change";
        Event.CHANGED = "changed";
        Event.RESIZE = "resize";
        Event.ADDED = "added";
        Event.REMOVED = "removed";
        Event.DISPLAY = "display";
        Event.UNDISPLAY = "undisplay";
        Event.ERROR = "error";
        Event.COMPLETE = "complete";
        Event.LOADED = "loaded";
        Event.PROGRESS = "progress";
        Event.INPUT = "input";
        Event.RENDER = "render";
        Event.OPEN = "open";
        Event.MESSAGE = "message";
        Event.CLOSE = "close";
        Event.KEY_DOWN = "keydown";
        Event.KEY_PRESS = "keypress";
        Event.KEY_UP = "keyup";
        Event.FRAME = "enterframe";
        Event.DRAG_START = "dragstart";
        Event.DRAG_MOVE = "dragmove";
        Event.DRAG_END = "dragend";
        Event.ENTER = "enter";
        Event.SELECT = "select";
        Event.BLUR = "blur";
        Event.FOCUS = "focus";
        Event.VISIBILITY_CHANGE = "visibilitychange";
        Event.FOCUS_CHANGE = "focuschange";
        Event.PLAYED = "played";
        Event.PAUSED = "paused";
        Event.STOPPED = "stopped";
        Event.START = "start";
        Event.END = "end";
        Event.ENABLE_CHANGED = "enablechanged";
        Event.ACTIVE_IN_HIERARCHY_CHANGED = "activeinhierarchychanged";
        Event.COMPONENT_ADDED = "componentadded";
        Event.COMPONENT_REMOVED = "componentremoved";
        Event.LAYER_CHANGED = "layerchanged";
        Event.HIERARCHY_LOADED = "hierarchyloaded";
        Event.RECOVERED = "recovered";
        Event.RELEASED = "released";
        Event.LINK = "link";
        Event.LABEL = "label";
        Event.FULL_SCREEN_CHANGE = "fullscreenchange";
        Event.DEVICE_LOST = "devicelost";
        Event.MESH_CHANGED = "meshchanged";
        Event.MATERIAL_CHANGED = "materialchanged";
        Event.WORLDMATRIX_NEEDCHANGE = "worldmatrixneedchanged";
        Event.ANIMATION_CHANGED = "animationchanged";
        Event.TRIGGER_ENTER = "triggerenter";
        Event.TRIGGER_STAY = "triggerstay";
        Event.TRIGGER_EXIT = "triggerexit";
        Event.TRAIL_FILTER_CHANGE = "trailfilterchange";
        Event.DOMINO_FILTER_CHANGE = "dominofilterchange";
        return Event;
    })();
    var Keyboard = (function () {
        function Keyboard() { }
        __class(Keyboard, 'laya.events.Keyboard');
        Keyboard.NUMBER_0 = 48;
        Keyboard.NUMBER_1 = 49;
        Keyboard.NUMBER_2 = 50;
        Keyboard.NUMBER_3 = 51;
        Keyboard.NUMBER_4 = 52;
        Keyboard.NUMBER_5 = 53;
        Keyboard.NUMBER_6 = 54;
        Keyboard.NUMBER_7 = 55;
        Keyboard.NUMBER_8 = 56;
        Keyboard.NUMBER_9 = 57;
        Keyboard.A = 65;
        Keyboard.B = 66;
        Keyboard.C = 67;
        Keyboard.D = 68;
        Keyboard.E = 69;
        Keyboard.F = 70;
        Keyboard.G = 71;
        Keyboard.H = 72;
        Keyboard.I = 73;
        Keyboard.J = 74;
        Keyboard.K = 75;
        Keyboard.L = 76;
        Keyboard.M = 77;
        Keyboard.N = 78;
        Keyboard.O = 79;
        Keyboard.P = 80;
        Keyboard.Q = 81;
        Keyboard.R = 82;
        Keyboard.S = 83;
        Keyboard.T = 84;
        Keyboard.U = 85;
        Keyboard.V = 86;
        Keyboard.W = 87;
        Keyboard.X = 88;
        Keyboard.Y = 89;
        Keyboard.Z = 90;
        Keyboard.F1 = 112;
        Keyboard.F2 = 113;
        Keyboard.F3 = 114;
        Keyboard.F4 = 115;
        Keyboard.F5 = 116;
        Keyboard.F6 = 117;
        Keyboard.F7 = 118;
        Keyboard.F8 = 119;
        Keyboard.F9 = 120;
        Keyboard.F10 = 121;
        Keyboard.F11 = 122;
        Keyboard.F12 = 123;
        Keyboard.F13 = 124;
        Keyboard.F14 = 125;
        Keyboard.F15 = 126;
        Keyboard.NUMPAD = 21;
        Keyboard.NUMPAD_0 = 96;
        Keyboard.NUMPAD_1 = 97;
        Keyboard.NUMPAD_2 = 98;
        Keyboard.NUMPAD_3 = 99;
        Keyboard.NUMPAD_4 = 100;
        Keyboard.NUMPAD_5 = 101;
        Keyboard.NUMPAD_6 = 102;
        Keyboard.NUMPAD_7 = 103;
        Keyboard.NUMPAD_8 = 104;
        Keyboard.NUMPAD_9 = 105;
        Keyboard.NUMPAD_ADD = 107;
        Keyboard.NUMPAD_DECIMAL = 110;
        Keyboard.NUMPAD_DIVIDE = 111;
        Keyboard.NUMPAD_ENTER = 108;
        Keyboard.NUMPAD_MULTIPLY = 106;
        Keyboard.NUMPAD_SUBTRACT = 109;
        Keyboard.SEMICOLON = 186;
        Keyboard.EQUAL = 187;
        Keyboard.COMMA = 188;
        Keyboard.MINUS = 189;
        Keyboard.PERIOD = 190;
        Keyboard.SLASH = 191;
        Keyboard.BACKQUOTE = 192;
        Keyboard.LEFTBRACKET = 219;
        Keyboard.BACKSLASH = 220;
        Keyboard.RIGHTBRACKET = 221;
        Keyboard.QUOTE = 222;
        Keyboard.ALTERNATE = 18;
        Keyboard.BACKSPACE = 8;
        Keyboard.CAPS_LOCK = 20;
        Keyboard.COMMAND = 15;
        Keyboard.CONTROL = 17;
        Keyboard.DELETE = 46;
        Keyboard.ENTER = 13;
        Keyboard.ESCAPE = 27;
        Keyboard.PAGE_UP = 33;
        Keyboard.PAGE_DOWN = 34;
        Keyboard.END = 35;
        Keyboard.HOME = 36;
        Keyboard.LEFT = 37;
        Keyboard.UP = 38;
        Keyboard.RIGHT = 39;
        Keyboard.DOWN = 40;
        Keyboard.SHIFT = 16;
        Keyboard.SPACE = 32;
        Keyboard.TAB = 9;
        Keyboard.INSERT = 45;
        return Keyboard;
    })();
    var KeyBoardManager = (function () {
        function KeyBoardManager() { }
        __class(KeyBoardManager, 'laya.events.KeyBoardManager');
        KeyBoardManager.__init__ = function () {
            KeyBoardManager._addEvent("keydown");
            KeyBoardManager._addEvent("keypress");
            KeyBoardManager._addEvent("keyup");
        };
        KeyBoardManager._addEvent = function (type) {
            Browser.document.addEventListener(type, function (e) {
                laya.events.KeyBoardManager._dispatch(e, type);
            }, true);
        };
        KeyBoardManager._dispatch = function (e, type) {
            if (!KeyBoardManager.enabled)
                return;
            KeyBoardManager._event._stoped = false;
            KeyBoardManager._event.nativeEvent = e;
            KeyBoardManager._event.keyCode = e.keyCode || e.which || e.charCode;
            if (type === "keydown")
                KeyBoardManager._pressKeys[KeyBoardManager._event.keyCode] = true;
            else if (type === "keyup")
                KeyBoardManager._pressKeys[KeyBoardManager._event.keyCode] = null;
            var target = (Laya.stage.focus && (Laya.stage.focus.event != null) && Laya.stage.focus.displayedInStage) ? Laya.stage.focus : Laya.stage;
            var ct = target;
            while (ct) {
                ct.event(type, KeyBoardManager._event.setTo(type, ct, target));
                ct = ct.parent;
            }
        };
        KeyBoardManager.hasKeyDown = function (key) {
            return KeyBoardManager._pressKeys[key];
        };
        KeyBoardManager._pressKeys = {};
        KeyBoardManager.enabled = true;
        __static(KeyBoardManager, ['_event', function () { return this._event = new Event(); }
        ]);
        return KeyBoardManager;
    })();
    var KeyLocation = (function () {
        function KeyLocation() { }
        __class(KeyLocation, 'laya.events.KeyLocation');
        KeyLocation.STANDARD = 0;
        KeyLocation.LEFT = 1;
        KeyLocation.RIGHT = 2;
        KeyLocation.NUM_PAD = 3;
        return KeyLocation;
    })();
    var MouseManager = (function () {
        function MouseManager() {
            this.mouseX = 0;
            this.mouseY = 0;
            this.disableMouseEvent = false;
            this.mouseDownTime = 0;
            this.mouseMoveAccuracy = 2;
            this._stage = null;
            this._target = null;
            this._lastMoveTimer = 0;
            this._isLeftMouse = false;
            this._eventList = [];
            this._touchIDs = {};
            this._id = 1;
            this._tTouchID = 0;
            this._event = new Event();
            this._matrix = new Matrix();
            this._point = new Point();
            this._rect = new Rectangle();
            this._prePoint = new Point();
            this._curTouchID = NaN;
        }
        __class(MouseManager, 'laya.events.MouseManager');
        var __proto = MouseManager.prototype;
        __proto.__init__ = function (stage, canvas) {
            var _$this = this;
            this._stage = stage;
            var _this = this;
            var list = this._eventList;
            canvas.oncontextmenu = function (e) {
                if (MouseManager.enabled)
                    return false;
            };
            canvas.addEventListener('mousedown', function (e) {
                if (MouseManager.enabled) {
                    if (!Browser.onIE)
                        e.preventDefault();
                    list.push(e);
                    _this.mouseDownTime = Browser.now();
                }
            });
            canvas.addEventListener('mouseup', function (e) {
                if (MouseManager.enabled) {
                    e.preventDefault();
                    list.push(e);
                    _this.mouseDownTime = -Browser.now();
                }
            }, true);
            canvas.addEventListener('mousemove', function (e) {
                if (MouseManager.enabled) {
                    e.preventDefault();
                    var now = Browser.now();
                    if (now - _this._lastMoveTimer < 10)
                        return;
                    _this._lastMoveTimer = now;
                    list.push(e);
                }
            }, true);
            canvas.addEventListener("mouseout", function (e) {
                if (MouseManager.enabled)
                    list.push(e);
            });
            canvas.addEventListener("mouseover", function (e) {
                if (MouseManager.enabled)
                    list.push(e);
            });
            canvas.addEventListener("touchstart", function (e) {
                if (MouseManager.enabled) {
                    list.push(e);
                    if (!MouseManager._isFirstTouch && !Input.isInputting)
                        e.preventDefault();
                    _this.mouseDownTime = Browser.now();
                }
            });
            canvas.addEventListener("touchend", function (e) {
                if (MouseManager.enabled) {
                    if (!MouseManager._isFirstTouch && !Input.isInputting)
                        e.preventDefault();
                    MouseManager._isFirstTouch = false;
                    list.push(e);
                    _this.mouseDownTime = -Browser.now();
                }
                else {
                    _$this._curTouchID = NaN;
                }
            }, true);
            canvas.addEventListener("touchmove", function (e) {
                if (MouseManager.enabled) {
                    e.preventDefault();
                    list.push(e);
                }
            }, true);
            canvas.addEventListener("touchcancel", function (e) {
                if (MouseManager.enabled) {
                    e.preventDefault();
                    list.push(e);
                }
                else {
                    _$this._curTouchID = NaN;
                }
            }, true);
            canvas.addEventListener('mousewheel', function (e) {
                if (MouseManager.enabled)
                    list.push(e);
            });
            canvas.addEventListener('DOMMouseScroll', function (e) {
                if (MouseManager.enabled)
                    list.push(e);
            });
        };
        __proto.initEvent = function (e, nativeEvent) {
            var _this = this;
            _this._event._stoped = false;
            _this._event.nativeEvent = nativeEvent || e;
            _this._target = null;
            this._point.setTo(e.pageX || e.clientX, e.pageY || e.clientY);
            this._stage._canvasTransform.invertTransformPoint(this._point);
            _this.mouseX = this._point.x;
            _this.mouseY = this._point.y;
            _this._event.touchId = e.identifier || 0;
            this._tTouchID = _this._event.touchId;
            var evt;
            evt = TouchManager.I._event;
            evt._stoped = false;
            evt.nativeEvent = _this._event.nativeEvent;
            evt.touchId = _this._event.touchId;
        };
        __proto.checkMouseWheel = function (e) {
            var _lastOvers = TouchManager.I.getLastOvers();
            for (var i = 0, n = _lastOvers.length; i < n; i++) {
                var ele = _lastOvers[i];
                if (!ele) {
                    continue;
                }
                if (!ele.stage) {
                    var lastEvent = this._event;
                    this._prePoint.x = e.clientX;
                    this._prePoint.y = e.clientY;
                    this.initEvent(e);
                    var hit = this.check(this._stage, this.mouseX, this.mouseY, this.onMouseWheelAndMove);
                    if (hit) this.onMouseWheel(lastEvent, e);
                } else {
                    this._event.delta = e.wheelDelta ? e.wheelDelta * 0.025 : -e.detail;
                    ele.event("mousewheel", this._event.setTo("mousewheel", ele, this._target));
                }
            }
        };
        __proto.onMouseWheelAndMove = function (ele) {
            TouchManager.I.onMouseMove(ele, this._tTouchID, true);
        }
        __proto.onMouseWheel = function (lastEvt, evt) {
            this._prePoint.x = this._prePoint.y = -1000000;
            this._event = lastEvt;
            this.checkMouseWheel(evt);
        };
        __proto.onMouseMove = function (ele) {
            TouchManager.I.onMouseMove(ele, this._tTouchID);
        };
        __proto.onMouseDown = function (ele) {
            if (Input.isInputting && Laya.stage.focus && Laya.stage.focus["focus"] && !Laya.stage.focus.contains(this._target)) {
                var pre_input = Laya.stage.focus['_tf'] || Laya.stage.focus;
                var new_input = ele['_tf'] || ele;
                if ((new_input instanceof laya.display.Input) && new_input.multiline == pre_input.multiline)
                    pre_input['_focusOut']();
                else
                    pre_input.focus = false;
            }
            TouchManager.I.onMouseDown(ele, this._tTouchID, this._isLeftMouse);
        };
        __proto.onMouseUp = function (ele) {
            TouchManager.I.onMouseUp(ele, this._tTouchID, this._isLeftMouse);
        };
        __proto.check = function (sp, mouseX, mouseY, callBack) {
            this._point.setTo(mouseX, mouseY);
            sp.fromParentPoint(this._point);
            mouseX = this._point.x;
            mouseY = this._point.y;
            var scrollRect = sp.scrollRect;
            if (scrollRect) {
                this._rect.setTo(scrollRect.x, scrollRect.y, scrollRect.width, scrollRect.height);
                if (!this._rect.contains(mouseX, mouseY))
                    return false;
            }
            if (!this.disableMouseEvent) {
                if (sp.hitTestPrior && !sp.mouseThrough && !this.hitTest(sp, mouseX, mouseY)) {
                    return false;
                }
                for (var i = sp._childs.length - 1; i > -1; i--) {
                    var child = sp._childs[i];
                    if (!child.destroyed && child.mouseEnabled && child.visible) {
                        if (this.check(child, mouseX, mouseY, callBack))
                            return true;
                    }
                }
            }
            var isHit = (sp.hitTestPrior && !sp.mouseThrough && !this.disableMouseEvent) ? true : this.hitTest(sp, mouseX, mouseY);
            if (isHit) {
                this._target = sp;
                if (callBack) callBack.call(this, sp);
            }
            else if (callBack === this.onMouseUp && sp === this._stage) {
                this._target = this._stage;
                if (callBack) callBack.call(this, this._target);
            }
            return isHit;
        };
        __proto.hitTest = function (sp, mouseX, mouseY) {
            var isHit = false;
            if (sp.scrollRect) {
                mouseX -= sp.scrollRect.x;
                mouseY -= sp.scrollRect.y;
            }
            if ((sp.hitArea instanceof laya.utils.HitArea)) {
                return sp.hitArea.isHit(mouseX, mouseY);
            }
            if (!sp.mouseThrough) {
                var hitRect = this._rect;
                if (sp.hitArea)
                    hitRect = sp.hitArea;
                else {
                    if (sp.width < 0 || sp.height < 0) {
                        var __x = sp.width < 0 ? -Math.abs(sp.width) : 0;
                        var __y = sp.height < 0 ? -Math.abs(sp.height) : 0;
                        hitRect.setTo(__x, __y, Math.abs(sp.width), Math.abs(sp.height));
                    } else {
                        hitRect.setTo(0, 0, sp.width, sp.height);
                    }
                }
                isHit = hitRect.contains(mouseX, mouseY);
            }
            else {
                isHit = sp.getGraphicBounds().contains(mouseX, mouseY);
            }
            return isHit;
        };
        __proto.runEvent = function () {
            var len = this._eventList.length;
            if (!len)
                return;
            var _this = this;
            var i = 0, j = 0, n = 0, touch;
            while (i < len) {
                var evt = this._eventList[i];
                if (evt.type !== 'mousemove')
                    this._prePoint.x = this._prePoint.y = -1000000;
                switch (evt.type) {
                    case 'mousedown':
                        this._touchIDs[0] = this._id++;
                        if (!MouseManager._isTouchRespond) {
                            _this._isLeftMouse = evt.button === 0;
                            _this.initEvent(evt);
                            _this.check(_this._stage, _this.mouseX, _this.mouseY, _this.onMouseDown);
                        }
                        else
                            MouseManager._isTouchRespond = false;
                        break;
                    case 'mouseup':
                        _this._isLeftMouse = evt.button === 0;
                        _this.initEvent(evt);
                        _this.check(_this._stage, _this.mouseX, _this.mouseY, _this.onMouseUp);
                        break;
                    case 'mousemove':
                        if ((Math.abs(this._prePoint.x - evt.clientX) + Math.abs(this._prePoint.y - evt.clientY)) >= this.mouseMoveAccuracy) {
                            this._prePoint.x = evt.clientX;
                            this._prePoint.y = evt.clientY;
                            _this.initEvent(evt);
                            _this.check(_this._stage, _this.mouseX, _this.mouseY, _this.onMouseMove);
                        }
                        break;
                    case "touchstart":
                        MouseManager._isTouchRespond = true;
                        _this._isLeftMouse = true;
                        var touches = evt.changedTouches;
                        for (j = 0, n = touches.length; j < n; j++) {
                            touch = touches[j];
                            if (MouseManager.multiTouchEnabled || isNaN(this._curTouchID)) {
                                this._curTouchID = touch.identifier;
                                if (this._id % 200 === 0)
                                    this._touchIDs = {};
                                this._touchIDs[touch.identifier] = this._id++;
                                _this.initEvent(touch, evt);
                                _this.check(_this._stage, _this.mouseX, _this.mouseY, _this.onMouseDown);
                            }
                        }
                        break;
                    case "touchend":
                    case "touchcancel":
                        MouseManager._isTouchRespond = true;
                        _this._isLeftMouse = true;
                        var touchends = evt.changedTouches;
                        for (j = 0, n = touchends.length; j < n; j++) {
                            touch = touchends[j];
                            if (MouseManager.multiTouchEnabled || touch.identifier == this._curTouchID) {
                                this._curTouchID = NaN;
                                _this.initEvent(touch, evt);
                                var isChecked = false;
                                isChecked = _this.check(_this._stage, _this.mouseX, _this.mouseY, _this.onMouseUp);
                                if (!isChecked) {
                                    _this.onMouseUp(null);
                                }
                            }
                        }
                        break;
                    case "touchmove":
                        ;
                        var touchemoves = evt.changedTouches;
                        for (j = 0, n = touchemoves.length; j < n; j++) {
                            touch = touchemoves[j];
                            if (MouseManager.multiTouchEnabled || touch.identifier == this._curTouchID) {
                                _this.initEvent(touch, evt);
                                _this.check(_this._stage, _this.mouseX, _this.mouseY, _this.onMouseMove);
                            }
                        }
                        break;
                    case "wheel":
                    case "mousewheel":
                    case "DOMMouseScroll":
                        _this.checkMouseWheel(evt);
                        break;
                    case "mouseout":
                        TouchManager.I.stageMouseOut();
                        break;
                    case "mouseover":
                        _this._stage.event("mouseover", _this._event.setTo("mouseover", _this._stage, _this._stage));
                        break;
                }
                i++;
            }
            this._eventList.length = 0;
        };
        MouseManager.enabled = true;
        MouseManager.multiTouchEnabled = true;
        MouseManager._isTouchRespond = false;
        MouseManager._isFirstTouch = true;
        __static(MouseManager, ['instance', function () { return this.instance = new MouseManager(); }
        ]);
        return MouseManager;
    })();
    var TouchManager = (function () {
        function TouchManager() {
            this.preOvers = [];
            this.preDowns = [];
            this.preRightDowns = [];
            this.enable = true;
            this._lastClickTime = 0;
            this._event = new Event();
        }
        __class(TouchManager, 'laya.events.TouchManager');
        var __proto = TouchManager.prototype;
        __proto._clearTempArrs = function () {
            TouchManager._oldArr.length = 0;
            TouchManager._newArr.length = 0;
            TouchManager._tEleArr.length = 0;
        };
        __proto.getTouchFromArr = function (touchID, arr) {
            var i = 0, len = 0;
            len = arr.length;
            var tTouchO;
            for (i = 0; i < len; i++) {
                tTouchO = arr[i];
                if (tTouchO.id == touchID) {
                    return tTouchO;
                }
            }
            return null;
        };
        __proto.removeTouchFromArr = function (touchID, arr) {
            var i = 0;
            for (i = arr.length - 1; i >= 0; i--) {
                if (arr[i].id == touchID) {
                    arr.splice(i, 1);
                }
            }
        };
        __proto.createTouchO = function (ele, touchID) {
            var rst;
            rst = Pool.getItem("TouchData") || {};
            rst.id = touchID;
            rst.tar = ele;
            return rst;
        };
        __proto.onMouseDown = function (ele, touchID, isLeft) {
            (isLeft === void 0) && (isLeft = false);
            if (!this.enable)
                return;
            var preO;
            var tO;
            var arrs;
            preO = this.getTouchFromArr(touchID, this.preOvers);
            arrs = this.getEles(ele, null, TouchManager._tEleArr);
            if (!preO) {
                tO = this.createTouchO(ele, touchID);
                this.preOvers.push(tO);
            }
            else {
                preO.tar = ele;
            }
            if (Browser.onMobile)
                this.sendEvents(arrs, "mouseover", touchID);
            var preDowns;
            preDowns = isLeft ? this.preDowns : this.preRightDowns;
            preO = this.getTouchFromArr(touchID, preDowns);
            if (!preO) {
                tO = this.createTouchO(ele, touchID);
                preDowns.push(tO);
            }
            else {
                preO.tar = ele;
            }
            this.sendEvents(arrs, isLeft ? "mousedown" : "rightmousedown", touchID);
            this._clearTempArrs();
        };
        __proto.sendEvents = function (eles, type, touchID) {
            (touchID === void 0) && (touchID = 0);
            var i = 0, len = 0;
            len = eles.length;
            this._event._stoped = false;
            var _target;
            _target = eles[0];
            var tE;
            for (i = 0; i < len; i++) {
                tE = eles[i];
                if (!tE) continue;
                if (tE.destroyed)
                    return;
                tE.event(type, this._event.setTo(type, tE, _target));
                if (this._event._stoped)
                    break;
            }
        };
        __proto.getEles = function (start, end, rst) {
            if (!rst) {
                rst = [];
            }
            else {
                rst.length = 0;
            }
            while (start && start != end) {
                rst.push(start);
                start = start.parent;
            }
            return rst;
        };
        __proto.checkMouseOutAndOverOfMove = function (eleNew, elePre, touchID, limit) {
            (touchID === void 0) && (touchID = 0);
            (limit === void 0) && (limit = false);
            if (elePre == eleNew)
                return;
            var tar;
            var arrs;
            var i = 0, len = 0;
            if (elePre.contains(eleNew)) {
                arrs = this.getEles(eleNew, elePre, TouchManager._tEleArr);
                if (!limit) this.sendEvents(arrs, "mouseover", touchID);
            }
            else if (eleNew.contains(elePre)) {
                arrs = this.getEles(elePre, eleNew, TouchManager._tEleArr);
                if (!limit) this.sendEvents(arrs, "mouseout", touchID);
            }
            else {
                arrs = TouchManager._tEleArr;
                arrs.length = 0;
                var oldArr;
                oldArr = this.getEles(elePre, null, TouchManager._oldArr);
                var newArr;
                newArr = this.getEles(eleNew, null, TouchManager._newArr);
                len = oldArr.length;
                var tIndex = 0;
                for (i = 0; i < len; i++) {
                    tar = oldArr[i];
                    tIndex = newArr.indexOf(tar);
                    if (tIndex >= 0) {
                        newArr.splice(tIndex, newArr.length - tIndex);
                        break;
                    }
                    else {
                        arrs.push(tar);
                    }
                }
                if (arrs.length > 0) {
                    if (!limit) this.sendEvents(arrs, "mouseout", touchID);
                }
                if (newArr.length > 0) {
                    if (!limit) this.sendEvents(newArr, "mouseover", touchID);
                }
            }
        };
        __proto.onMouseMove = function (ele, touchID, limit) {
            (limit === void 0) && (limit = false);
            if (!this.enable)
                return;
            var preO;
            preO = this.getTouchFromArr(touchID, this.preOvers);
            var arrs;
            var tO;
            if (!preO) {
                arrs = this.getEles(ele, null, TouchManager._tEleArr);
                if (!limit) this.sendEvents(arrs, "mouseover", touchID);
                this.preOvers.push(this.createTouchO(ele, touchID));
            }
            else {
                this.checkMouseOutAndOverOfMove(ele, preO.tar, 0, limit);
                preO.tar = ele;
                arrs = this.getEles(ele, null, TouchManager._tEleArr);
            }
            if (!limit) this.sendEvents(arrs, "mousemove", touchID);
            this._clearTempArrs();
        };
        __proto.getLastOvers = function () {
            TouchManager._tEleArr.length = 0;
            if (this.preOvers.length > 0 && this.preOvers[0].tar) {
                return this.getEles(this.preOvers[0].tar, null, TouchManager._tEleArr);
            }
            TouchManager._tEleArr.push(Laya.stage);
            return TouchManager._tEleArr;
        };
        __proto.stageMouseOut = function () {
            var lastOvers;
            lastOvers = this.getLastOvers();
            this.preOvers.length = 0;
            this.sendEvents(lastOvers, "mouseout", 0);
        };
        __proto.onMouseUp = function (ele, touchID, isLeft) {
            (isLeft === void 0) && (isLeft = false);
            if (!this.enable)
                return;
            var preO;
            var tO;
            var arrs;
            var oldArr;
            var i = 0, len = 0;
            var tar;
            var sendArr;
            var onMobile = Browser.onMobile;
            arrs = this.getEles(ele, null, TouchManager._tEleArr);
            this.sendEvents(arrs, isLeft ? "mouseup" : "rightmouseup", touchID);
            var preDowns;
            preDowns = isLeft ? this.preDowns : this.preRightDowns;
            preO = this.getTouchFromArr(touchID, preDowns);
            if (!preO) {
            }
            else {
                var isDouble = false;
                var now = Browser.now();
                isDouble = now - this._lastClickTime < 300;
                this._lastClickTime = now;
                if (ele == preO.tar) {
                    sendArr = arrs;
                }
                else {
                    oldArr = this.getEles(preO.tar, null, TouchManager._oldArr);
                    sendArr = TouchManager._newArr;
                    sendArr.length = 0;
                    len = oldArr.length;
                    for (i = 0; i < len; i++) {
                        tar = oldArr[i];
                        if (arrs.indexOf(tar) >= 0) {
                            sendArr.push(tar);
                        }
                    }
                }
                if (sendArr.length > 0) {
                    this.sendEvents(sendArr, isLeft ? "click" : "rightclick", touchID);
                }
                if (isLeft && isDouble) {
                    this.sendEvents(sendArr, "doubleclick", touchID);
                }
                this.removeTouchFromArr(touchID, preDowns);
                preO.tar = null;
                Pool.recover("TouchData", preO);
            }
            preO = this.getTouchFromArr(touchID, this.preOvers);
            if (!preO) {
            }
            else {
                if (onMobile) {
                    sendArr = this.getEles(preO.tar, null, sendArr);
                    if (sendArr && sendArr.length > 0) {
                        this.sendEvents(sendArr, "mouseout", touchID);
                    }
                    this.removeTouchFromArr(touchID, this.preOvers);
                    preO.tar = null;
                    Pool.recover("TouchData", preO);
                }
            }
            this._clearTempArrs();
        };
        TouchManager._oldArr = [];
        TouchManager._newArr = [];
        TouchManager._tEleArr = [];
        __static(TouchManager, ['I', function () { return this.I = new TouchManager(); }
        ]);
        return TouchManager;
    })();
    var Filter = (function () {
        function Filter() {
            this._action = null;
        }
        __class(Filter, 'laya.filters.Filter');
        var __proto = Filter.prototype;
        Laya.imps(__proto, { "laya.filters.IFilter": true });
        __proto.callNative = function (sp) { };
        __getset(0, __proto, 'type', function () { return -1; });
        __getset(0, __proto, 'action', function () { return this._action; });
        Filter.BLUR = 0x10;
        Filter.COLOR = 0x20;
        Filter.GLOW = 0x08;
        // Filter.KDS = 0x800;
        Filter._filterStart = null;
        Filter._filterEnd = null;
        Filter._EndTarget = null;
        Filter._recycleScope = null;
        Filter._filter = null;
        Filter._useSrc = null;
        Filter._endSrc = null;
        Filter._useOut = null;
        Filter._endOut = null;
        return Filter;
    })();
    var ColorFilterAction = (function () {
        function ColorFilterAction() {
            this.data = null;
        }
        __class(ColorFilterAction, 'laya.filters.ColorFilterAction');
        var __proto = ColorFilterAction.prototype;
        Laya.imps(__proto, { "laya.filters.IFilterAction": true });
        __proto.apply = function (srcCanvas) {
            var ctx = srcCanvas.ctx.ctx;
            var canvas = srcCanvas.ctx.ctx.canvas;
            if (canvas.width == 0 || canvas.height == 0)
                return canvas;
            var imgdata = ctx.getImageData(0, 0, canvas.width, canvas.height);
            var data = imgdata.data;
            var nData;
            for (var i = 0, n = data.length; i < n; i += 4) {
                nData = this.getColor(data[i], data[i + 1], data[i + 2], data[i + 3]);
                if (data[i + 3] == 0)
                    continue;
                data[i] = nData[0];
                data[i + 1] = nData[1];
                data[i + 2] = nData[2];
                data[i + 3] = nData[3];
            }
            ctx.putImageData(imgdata, 0, 0);
            return srcCanvas;
        };
        __proto.getColor = function (red, green, blue, alpha) {
            var rst = [];
            if (this.data._mat && this.data._alpha) {
                var mat = this.data._mat;
                var tempAlpha = this.data._alpha;
                rst[0] = mat[0] * red + mat[1] * green + mat[2] * blue + mat[3] * alpha + tempAlpha[0];
                rst[1] = mat[4] * red + mat[5] * green + mat[6] * blue + mat[7] * alpha + tempAlpha[1];
                rst[2] = mat[8] * red + mat[9] * green + mat[10] * blue + mat[11] * alpha + tempAlpha[2];
                rst[3] = mat[12] * red + mat[13] * green + mat[14] * blue + mat[15] * alpha + tempAlpha[3];
            }
            return rst;
        };
        return ColorFilterAction;
    })();
    var Arith = (function () {
        function Arith() { }
        __class(Arith, 'laya.maths.Arith');
        Arith.formatR = function (r) {
            if (r > Math.PI)
                r -= Math.PI * 2;
            if (r < -Math.PI)
                r += Math.PI * 2;
            return r;
        };
        Arith.isPOT = function (w, h) {
            return (w > 0 && (w & (w - 1)) === 0 && h > 0 && (h & (h - 1)) === 0);
        };
        Arith.setMatToArray = function (mat, array) {
            mat.a, mat.b, 0, 0, mat.c, mat.d, 0, 0, 0, 0, 1, 0, mat.tx + 20, mat.ty + 20, 0, 1;
            array[0] = mat.a;
            array[1] = mat.b;
            array[4] = mat.c;
            array[5] = mat.d;
            array[12] = mat.tx;
            array[13] = mat.ty;
        };
        return Arith;
    })();
    var Bezier = (function () {
        function Bezier() {
            this._controlPoints = [new Point(), new Point(), new Point()];
            this._calFun = this.getPoint2;
        }
        __class(Bezier, 'laya.maths.Bezier');
        var __proto = Bezier.prototype;
        __proto._switchPoint = function (x, y) {
            var tPoint = this._controlPoints.shift();
            tPoint.setTo(x, y);
            this._controlPoints.push(tPoint);
        };
        __proto.getPoint2 = function (t, rst) {
            var p1 = this._controlPoints[0];
            var p2 = this._controlPoints[1];
            var p3 = this._controlPoints[2];
            var lineX = Math.pow((1 - t), 2) * p1.x + 2 * t * (1 - t) * p2.x + Math.pow(t, 2) * p3.x;
            var lineY = Math.pow((1 - t), 2) * p1.y + 2 * t * (1 - t) * p2.y + Math.pow(t, 2) * p3.y;
            rst.push(lineX, lineY);
        };
        __proto.getPoint3 = function (t, rst) {
            var p1 = this._controlPoints[0];
            var p2 = this._controlPoints[1];
            var p3 = this._controlPoints[2];
            var p4 = this._controlPoints[3];
            var lineX = Math.pow((1 - t), 3) * p1.x + 3 * p2.x * t * (1 - t) * (1 - t) + 3 * p3.x * t * t * (1 - t) + p4.x * Math.pow(t, 3);
            var lineY = Math.pow((1 - t), 3) * p1.y + 3 * p2.y * t * (1 - t) * (1 - t) + 3 * p3.y * t * t * (1 - t) + p4.y * Math.pow(t, 3);
            rst.push(lineX, lineY);
        };
        __proto.insertPoints = function (count, rst) {
            var i = NaN;
            count = count > 0 ? count : 5;
            var dLen = NaN;
            dLen = 1 / count;
            for (i = 0; i <= 1; i += dLen) {
                this._calFun(i, rst);
            }
        };
        __proto.getBezierPoints = function (pList, inSertCount, count) {
            (inSertCount === void 0) && (inSertCount = 5);
            (count === void 0) && (count = 2);
            var i = 0, len = 0;
            len = pList.length;
            if (len < (count + 1) * 2)
                return [];
            var rst;
            rst = [];
            switch (count) {
                case 2:
                    this._calFun = this.getPoint2;
                    break;
                case 3:
                    this._calFun = this.getPoint3;
                    break;
                default:
                    return [];
            }
            while (this._controlPoints.length <= count) {
                this._controlPoints.push(new Point());
            }
            for (i = 0; i < count * 2; i += 2) {
                this._switchPoint(pList[i], pList[i + 1]);
            }
            for (i = count * 2; i < len; i += 2) {
                this._switchPoint(pList[i], pList[i + 1]);
                if ((i / 2) % count == 0)
                    this.insertPoints(inSertCount, rst);
            }
            return rst;
        };
        __static(Bezier, ['I', function () { return this.I = new Bezier(); }
        ]);
        return Bezier;
    })();
    var GrahamScan = (function () {
        function GrahamScan() { }
        __class(GrahamScan, 'laya.maths.GrahamScan');
        GrahamScan.multiply = function (p1, p2, p0) {
            return ((p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y));
        };
        GrahamScan.dis = function (p1, p2) {
            return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);
        };
        GrahamScan._getPoints = function (count, tempUse, rst) {
            (tempUse === void 0) && (tempUse = false);
            if (!GrahamScan._mPointList)
                GrahamScan._mPointList = [];
            while (GrahamScan._mPointList.length < count)
                GrahamScan._mPointList.push(new Point());
            if (!rst)
                rst = [];
            rst.length = 0;
            if (tempUse) {
                GrahamScan.getFrom(rst, GrahamScan._mPointList, count);
            }
            else {
                GrahamScan.getFromR(rst, GrahamScan._mPointList, count);
            }
            return rst;
        };
        GrahamScan.getFrom = function (rst, src, count) {
            var i = 0;
            for (i = 0; i < count; i++) {
                rst.push(src[i]);
            }
            return rst;
        };
        GrahamScan.getFromR = function (rst, src, count) {
            var i = 0;
            for (i = 0; i < count; i++) {
                rst.push(src.pop());
            }
            return rst;
        };
        GrahamScan.pListToPointList = function (pList, tempUse) {
            (tempUse === void 0) && (tempUse = false);
            var i = 0, len = pList.length / 2, rst = GrahamScan._getPoints(len, tempUse, GrahamScan._tempPointList);
            for (i = 0; i < len; i++) {
                rst[i].setTo(pList[i + i], pList[i + i + 1]);
            }
            return rst;
        };
        GrahamScan.pointListToPlist = function (pointList) {
            var i = 0, len = pointList.length, rst = GrahamScan._temPList, tPoint;
            rst.length = 0;
            for (i = 0; i < len; i++) {
                tPoint = pointList[i];
                rst.push(tPoint.x, tPoint.y);
            }
            return rst;
        };
        GrahamScan.scanPList = function (pList) {
            return Utils.copyArray(pList, GrahamScan.pointListToPlist(GrahamScan.scan(GrahamScan.pListToPointList(pList, true))));
        };
        GrahamScan.scan = function (PointSet) {
            var i = 0, j = 0, k = 0, top = 2, tmp, n = PointSet.length, ch;
            var _tmpDic = {};
            var key;
            ch = GrahamScan._temArr;
            ch.length = 0;
            n = PointSet.length;
            for (i = n - 1; i >= 0; i--) {
                tmp = PointSet[i];
                key = tmp.x + "_" + tmp.y;
                if (!_tmpDic.hasOwnProperty(key)) {
                    _tmpDic[key] = true;
                    ch.push(tmp);
                }
            }
            n = ch.length;
            Utils.copyArray(PointSet, ch);
            for (i = 1; i < n; i++)
                if ((PointSet[i].y < PointSet[k].y) || ((PointSet[i].y == PointSet[k].y) && (PointSet[i].x < PointSet[k].x)))
                    k = i;
            tmp = PointSet[0];
            PointSet[0] = PointSet[k];
            PointSet[k] = tmp;
            for (i = 1; i < n - 1; i++) {
                k = i;
                for (j = i + 1; j < n; j++)
                    if ((GrahamScan.multiply(PointSet[j], PointSet[k], PointSet[0]) > 0) || ((GrahamScan.multiply(PointSet[j], PointSet[k], PointSet[0]) == 0) && (GrahamScan.dis(PointSet[0], PointSet[j]) < GrahamScan.dis(PointSet[0], PointSet[k]))))
                        k = j;
                tmp = PointSet[i];
                PointSet[i] = PointSet[k];
                PointSet[k] = tmp;
            }
            ch = GrahamScan._temArr;
            ch.length = 0;
            if (PointSet.length < 3) {
                return Utils.copyArray(ch, PointSet);
            }
            ch.push(PointSet[0], PointSet[1], PointSet[2]);
            for (i = 3; i < n; i++) {
                while (ch.length >= 2 && GrahamScan.multiply(PointSet[i], ch[ch.length - 1], ch[ch.length - 2]) >= 0)
                    ch.pop();
                PointSet[i] && ch.push(PointSet[i]);
            }
            return ch;
        };
        GrahamScan._mPointList = null;
        GrahamScan._tempPointList = [];
        GrahamScan._temPList = [];
        GrahamScan._temArr = [];
        return GrahamScan;
    })();
    var MathUtil = (function () {
        function MathUtil() { }
        __class(MathUtil, 'laya.maths.MathUtil');
        MathUtil.subtractVector3 = function (l, r, o) {
            o[0] = l[0] - r[0];
            o[1] = l[1] - r[1];
            o[2] = l[2] - r[2];
        };
        MathUtil.lerp = function (left, right, amount) {
            return left * (1 - amount) + right * amount;
        };
        MathUtil.scaleVector3 = function (f, b, e) {
            e[0] = f[0] * b;
            e[1] = f[1] * b;
            e[2] = f[2] * b;
        };
        MathUtil.lerpVector3 = function (l, r, t, o) {
            var ax = l[0], ay = l[1], az = l[2];
            o[0] = ax + t * (r[0] - ax);
            o[1] = ay + t * (r[1] - ay);
            o[2] = az + t * (r[2] - az);
        };
        MathUtil.lerpVector4 = function (l, r, t, o) {
            var ax = l[0], ay = l[1], az = l[2], aw = l[3];
            o[0] = ax + t * (r[0] - ax);
            o[1] = ay + t * (r[1] - ay);
            o[2] = az + t * (r[2] - az);
            o[3] = aw + t * (r[3] - aw);
        };
        MathUtil.slerpQuaternionArray = function (a, Offset1, b, Offset2, t, out, Offset3) {
            var ax = a[Offset1 + 0], ay = a[Offset1 + 1], az = a[Offset1 + 2], aw = a[Offset1 + 3], bx = b[Offset2 + 0], by = b[Offset2 + 1], bz = b[Offset2 + 2], bw = b[Offset2 + 3];
            var omega, cosom, sinom, scale0, scale1;
            cosom = ax * bx + ay * by + az * bz + aw * bw;
            if (cosom < 0.0) {
                cosom = -cosom;
                bx = -bx;
                by = -by;
                bz = -bz;
                bw = -bw;
            }
            if ((1.0 - cosom) > 0.000001) {
                omega = Math.acos(cosom);
                sinom = Math.sin(omega);
                scale0 = Math.sin((1.0 - t) * omega) / sinom;
                scale1 = Math.sin(t * omega) / sinom;
            }
            else {
                scale0 = 1.0 - t;
                scale1 = t;
            }
            out[Offset3 + 0] = scale0 * ax + scale1 * bx;
            out[Offset3 + 1] = scale0 * ay + scale1 * by;
            out[Offset3 + 2] = scale0 * az + scale1 * bz;
            out[Offset3 + 3] = scale0 * aw + scale1 * bw;
            return out;
        };
        MathUtil.getRotation = function (x0, y0, x1, y1) {
            return Math.atan2(y1 - y0, x1 - x0) / Math.PI * 180;
        };
        MathUtil.sortBigFirst = function (a, b) {
            if (a == b)
                return 0;
            return b > a ? 1 : -1;
        };
        MathUtil.sortSmallFirst = function (a, b) {
            if (a == b)
                return 0;
            return b > a ? -1 : 1;
        };
        MathUtil.sortNumBigFirst = function (a, b) {
            return parseFloat(b) - parseFloat(a);
        };
        MathUtil.sortNumSmallFirst = function (a, b) {
            return parseFloat(a) - parseFloat(b);
        };
        MathUtil.sortByKey = function (key, bigFirst, forceNum) {
            (bigFirst === void 0) && (bigFirst = false);
            (forceNum === void 0) && (forceNum = true);
            var _sortFun;
            if (bigFirst) {
                _sortFun = forceNum ? MathUtil.sortNumBigFirst : MathUtil.sortBigFirst;
            }
            else {
                _sortFun = forceNum ? MathUtil.sortNumSmallFirst : MathUtil.sortSmallFirst;
            }
            return function (a, b) {
                return _sortFun(a[key], b[key]);
            };
        };
        return MathUtil;
    })();
    var Matrix = (function () {
        function Matrix(a, b, c, d, tx, ty) {
            this.inPool = false;
            this.bTransform = false;
            (a === void 0) && (a = 1);
            (b === void 0) && (b = 0);
            (c === void 0) && (c = 0);
            (d === void 0) && (d = 1);
            (tx === void 0) && (tx = 0);
            (ty === void 0) && (ty = 0);
            this.a = a;
            this.b = b;
            this.c = c;
            this.d = d;
            this.tx = tx;
            this.ty = ty;
            this._checkTransform();
        }
        __class(Matrix, 'laya.maths.Matrix');
        var __proto = Matrix.prototype;
        __proto.identity = function () {
            this.a = this.d = 1;
            this.b = this.tx = this.ty = this.c = 0;
            this.bTransform = false;
            return this;
        };
        __proto._checkTransform = function () {
            return this.bTransform = (this.a !== 1 || this.b !== 0 || this.c !== 0 || this.d !== 1);
        };
        __proto.setTranslate = function (x, y) {
            this.tx = x;
            this.ty = y;
            return this;
        };
        __proto.translate = function (x, y) {
            this.tx += x;
            this.ty += y;
            return this;
        };
        __proto.scale = function (x, y) {
            this.a *= x;
            this.d *= y;
            this.c *= x;
            this.b *= y;
            this.tx *= x;
            this.ty *= y;
            this.bTransform = true;
        };
        __proto.rotate = function (angle) {
            var cos = Math.cos(angle);
            var sin = Math.sin(angle);
            var a1 = this.a;
            var c1 = this.c;
            var tx1 = this.tx;
            this.a = a1 * cos - this.b * sin;
            this.b = a1 * sin + this.b * cos;
            this.c = c1 * cos - this.d * sin;
            this.d = c1 * sin + this.d * cos;
            this.tx = tx1 * cos - this.ty * sin;
            this.ty = tx1 * sin + this.ty * cos;
            this.bTransform = true;
        };
        __proto.skew = function (x, y) {
            var tanX = Math.tan(x);
            var tanY = Math.tan(y);
            var a1 = this.a;
            var b1 = this.b;
            this.a += tanY * this.c;
            this.b += tanY * this.d;
            this.c += tanX * a1;
            this.d += tanX * b1;
            return this;
        };
        __proto.invertTransformPoint = function (out) {
            var a1 = this.a;
            var b1 = this.b;
            var c1 = this.c;
            var d1 = this.d;
            var tx1 = this.tx;
            var n = a1 * d1 - b1 * c1;
            var a2 = d1 / n;
            var b2 = -b1 / n;
            var c2 = -c1 / n;
            var d2 = a1 / n;
            var tx2 = (c1 * this.ty - d1 * tx1) / n;
            var ty2 = -(a1 * this.ty - b1 * tx1) / n;
            return out.setTo(a2 * out.x + c2 * out.y + tx2, b2 * out.x + d2 * out.y + ty2);
        };
        __proto.transformPoint = function (out) {
            return out.setTo(this.a * out.x + this.c * out.y + this.tx, this.b * out.x + this.d * out.y + this.ty);
        };
        __proto.transformPointN = function (out) {
            return out.setTo(this.a * out.x + this.c * out.y, this.b * out.x + this.d * out.y);
        };
        __proto.transformPointArray = function (data, out) {
            var len = data.length;
            for (var i = 0; i < len; i += 2) {
                var x = data[i], y = data[i + 1];
                out[i] = this.a * x + this.c * y + this.tx;
                out[i + 1] = this.b * x + this.d * y + this.ty;
            }
            return out;
        };
        __proto.transformPointArrayScale = function (data, out) {
            var len = data.length;
            for (var i = 0; i < len; i += 2) {
                var x = data[i], y = data[i + 1];
                out[i] = this.a * x + this.c * y;
                out[i + 1] = this.b * x + this.d * y;
            }
            return out;
        };
        __proto.getScaleX = function () {
            return this.b === 0 ? this.a : Math.sqrt(this.a * this.a + this.b * this.b);
        };
        __proto.getScaleY = function () {
            return this.c === 0 ? this.d : Math.sqrt(this.c * this.c + this.d * this.d);
        };
        __proto.invert = function () {
            var a1 = this.a;
            var b1 = this.b;
            var c1 = this.c;
            var d1 = this.d;
            var tx1 = this.tx;
            var n = a1 * d1 - b1 * c1;
            this.a = d1 / n;
            this.b = -b1 / n;
            this.c = -c1 / n;
            this.d = a1 / n;
            this.tx = (c1 * this.ty - d1 * tx1) / n;
            this.ty = -(a1 * this.ty - b1 * tx1) / n;
            return this;
        };
        __proto.setTo = function (a, b, c, d, tx, ty) {
            this.a = a, this.b = b, this.c = c, this.d = d, this.tx = tx, this.ty = ty;
            return this;
        };
        __proto.concat = function (matrix) {
            var a = this.a;
            var c = this.c;
            var tx = this.tx;
            this.a = a * matrix.a + this.b * matrix.c;
            this.b = a * matrix.b + this.b * matrix.d;
            this.c = c * matrix.a + this.d * matrix.c;
            this.d = c * matrix.b + this.d * matrix.d;
            this.tx = tx * matrix.a + this.ty * matrix.c + matrix.tx;
            this.ty = tx * matrix.b + this.ty * matrix.d + matrix.ty;
            return this;
        };
        __proto.scaleEx = function (x, y) {
            var ba = this.a, bb = this.b, bc = this.c, bd = this.d;
            if (bb !== 0 || bc !== 0) {
                this.a = x * ba;
                this.b = x * bb;
                this.c = y * bc;
                this.d = y * bd;
            }
            else {
                this.a = x * ba;
                this.b = 0 * bd;
                this.c = 0 * ba;
                this.d = y * bd;
            }
            this.bTransform = true;
        };
        __proto.rotateEx = function (angle) {
            var cos = Math.cos(angle);
            var sin = Math.sin(angle);
            var ba = this.a, bb = this.b, bc = this.c, bd = this.d;
            if (bb !== 0 || bc !== 0) {
                this.a = cos * ba + sin * bc;
                this.b = cos * bb + sin * bd;
                this.c = -sin * ba + cos * bc;
                this.d = -sin * bb + cos * bd;
            }
            else {
                this.a = cos * ba;
                this.b = sin * bd;
                this.c = -sin * ba;
                this.d = cos * bd;
            }
            this.bTransform = true;
        };
        __proto.clone = function () {
            var dec = Matrix.create();
            dec.a = this.a;
            dec.b = this.b;
            dec.c = this.c;
            dec.d = this.d;
            dec.tx = this.tx;
            dec.ty = this.ty;
            dec.bTransform = this.bTransform;
            return dec;
        };
        __proto.copyTo = function (dec) {
            dec.a = this.a;
            dec.b = this.b;
            dec.c = this.c;
            dec.d = this.d;
            dec.tx = this.tx;
            dec.ty = this.ty;
            dec.bTransform = this.bTransform;
            return dec;
        };
        __proto.toString = function () {
            return this.a + "," + this.b + "," + this.c + "," + this.d + "," + this.tx + "," + this.ty;
        };
        __proto.destroy = function () {
            if (this.inPool)
                return;
            var cache = Matrix._cache;
            this.inPool = true;
            cache._length || (cache._length = 0);
            cache[cache._length++] = this;
            this.a = this.d = 1;
            this.b = this.c = this.tx = this.ty = 0;
            this.bTransform = false;
        };
        Matrix.mul = function (m1, m2, out) {
            var aa = m1.a, ab = m1.b, ac = m1.c, ad = m1.d, atx = m1.tx, aty = m1.ty;
            var ba = m2.a, bb = m2.b, bc = m2.c, bd = m2.d, btx = m2.tx, bty = m2.ty;
            if (bb !== 0 || bc !== 0) {
                out.a = aa * ba + ab * bc;
                out.b = aa * bb + ab * bd;
                out.c = ac * ba + ad * bc;
                out.d = ac * bb + ad * bd;
                out.tx = ba * atx + bc * aty + btx;
                out.ty = bb * atx + bd * aty + bty;
            }
            else {
                out.a = aa * ba;
                out.b = ab * bd;
                out.c = ac * ba;
                out.d = ad * bd;
                out.tx = ba * atx + btx;
                out.ty = bd * aty + bty;
            }
            return out;
        };
        Matrix.mul16 = function (m1, m2, out) {
            var aa = m1.a, ab = m1.b, ac = m1.c, ad = m1.d, atx = m1.tx, aty = m1.ty;
            var ba = m2.a, bb = m2.b, bc = m2.c, bd = m2.d, btx = m2.tx, bty = m2.ty;
            if (bb !== 0 || bc !== 0) {
                out[0] = aa * ba + ab * bc;
                out[1] = aa * bb + ab * bd;
                out[4] = ac * ba + ad * bc;
                out[5] = ac * bb + ad * bd;
                out[12] = ba * atx + bc * aty + btx;
                out[13] = bb * atx + bd * aty + bty;
            }
            else {
                out[0] = aa * ba;
                out[1] = ab * bd;
                out[4] = ac * ba;
                out[5] = ad * bd;
                out[12] = ba * atx + btx;
                out[13] = bd * aty + bty;
            }
            return out;
        };
        Matrix.mulPre = function (m1, ba, bb, bc, bd, btx, bty, out) {
            var aa = m1.a, ab = m1.b, ac = m1.c, ad = m1.d, atx = m1.tx, aty = m1.ty;
            if (bb !== 0 || bc !== 0) {
                out.a = aa * ba + ab * bc;
                out.b = aa * bb + ab * bd;
                out.c = ac * ba + ad * bc;
                out.d = ac * bb + ad * bd;
                out.tx = ba * atx + bc * aty + btx;
                out.ty = bb * atx + bd * aty + bty;
            }
            else {
                out.a = aa * ba;
                out.b = ab * bd;
                out.c = ac * ba;
                out.d = ad * bd;
                out.tx = ba * atx + btx;
                out.ty = bd * aty + bty;
            }
            return out;
        };
        Matrix.mulPos = function (m1, aa, ab, ac, ad, atx, aty, out) {
            var ba = m1.a, bb = m1.b, bc = m1.c, bd = m1.d, btx = m1.tx, bty = m1.ty;
            if (bb !== 0 || bc !== 0) {
                out.a = aa * ba + ab * bc;
                out.b = aa * bb + ab * bd;
                out.c = ac * ba + ad * bc;
                out.d = ac * bb + ad * bd;
                out.tx = ba * atx + bc * aty + btx;
                out.ty = bb * atx + bd * aty + bty;
            }
            else {
                out.a = aa * ba;
                out.b = ab * bd;
                out.c = ac * ba;
                out.d = ad * bd;
                out.tx = ba * atx + btx;
                out.ty = bd * aty + bty;
            }
            return out;
        };
        Matrix.preMul = function (parent, self, out) {
            var pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;
            var na = self.a, nb = self.b, nc = self.c, nd = self.d, ntx = self.tx, nty = self.ty;
            out.a = na * pa;
            out.b = out.c = 0;
            out.d = nd * pd;
            out.tx = ntx * pa + parent.tx;
            out.ty = nty * pd + parent.ty;
            if (nb !== 0 || nc !== 0 || pb !== 0 || pc !== 0) {
                out.a += nb * pc;
                out.d += nc * pb;
                out.b += na * pb + nb * pd;
                out.c += nc * pa + nd * pc;
                out.tx += nty * pc;
                out.ty += ntx * pb;
            }
            return out;
        };
        Matrix.preMulXY = function (parent, x, y, out) {
            var pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;
            out.a = pa;
            out.b = pb;
            out.c = pc;
            out.d = pd;
            out.tx = x * pa + parent.tx + y * pc;
            out.ty = y * pd + parent.ty + x * pb;
            return out;
        };
        Matrix.create = function () {
            var cache = Matrix._cache;
            var mat = !cache._length ? (new Matrix()) : cache[--cache._length];
            mat.inPool = false;
            return mat;
        };
        Matrix.EMPTY = new Matrix();
        Matrix.TEMP = new Matrix();
        Matrix._cache = [];
        return Matrix;
    })();
    var Point = (function () {
        function Point(x, y) {
            (x === void 0) && (x = 0);
            (y === void 0) && (y = 0);
            this.x = x;
            this.y = y;
        }
        __class(Point, 'laya.maths.Point');
        var __proto = Point.prototype;
        __proto.setTo = function (x, y) {
            this.x = x;
            this.y = y;
            return this;
        };
        __proto.distance = function (x, y) {
            return Math.sqrt((this.x - x) * (this.x - x) + (this.y - y) * (this.y - y));
        };
        __proto.toString = function () {
            return this.x + "," + this.y;
        };
        __proto.normalize = function () {
            var d = Math.sqrt(this.x * this.x + this.y * this.y);
            if (d > 0) {
                var id = 1.0 / d;
                this.x *= id;
                this.y *= id;
            }
        };
        Point.TEMP = new Point();
        Point.EMPTY = new Point();
        return Point;
    })();
    var Rectangle = (function () {
        function Rectangle(x, y, width, height) {
            (x === void 0) && (x = 0);
            (y === void 0) && (y = 0);
            (width === void 0) && (width = 0);
            (height === void 0) && (height = 0);
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
        }
        __class(Rectangle, 'laya.maths.Rectangle');
        var __proto = Rectangle.prototype;
        __proto.setTo = function (x, y, width, height) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            return this;
        };
        __proto.copyFrom = function (source) {
            this.x = source.x;
            this.y = source.y;
            this.width = source.width;
            this.height = source.height;
            return this;
        };
        __proto.contains = function (x, y) {
            if (this.width <= 0 || this.height <= 0)
                return false;
            if (x >= this.x && x < this.right) {
                if (y >= this.y && y < this.bottom) {
                    return true;
                }
            }
            return false;
        };
        __proto.intersects = function (rect) {
            return !(rect.x > (this.x + this.width) || (rect.x + rect.width) < this.x || rect.y > (this.y + this.height) || (rect.y + rect.height) < this.y);
        };
        __proto.intersection = function (rect, out) {
            if (!this.intersects(rect))
                return null;
            out || (out = new Rectangle());
            out.x = Math.max(this.x, rect.x);
            out.y = Math.max(this.y, rect.y);
            out.width = Math.min(this.right, rect.right) - out.x;
            out.height = Math.min(this.bottom, rect.bottom) - out.y;
            return out;
        };
        __proto.union = function (source, out) {
            out || (out = new Rectangle());
            this.clone(out);
            if (source.width <= 0 || source.height <= 0)
                return out;
            out.addPoint(source.x, source.y);
            out.addPoint(source.right, source.bottom);
            return this;
        };
        __proto.clone = function (out) {
            out || (out = new Rectangle());
            out.x = this.x;
            out.y = this.y;
            out.width = this.width;
            out.height = this.height;
            return out;
        };
        __proto.toString = function () {
            return this.x + "," + this.y + "," + this.width + "," + this.height;
        };
        __proto.equals = function (rect) {
            if (!rect || rect.x !== this.x || rect.y !== this.y || rect.width !== this.width || rect.height !== this.height)
                return false;
            return true;
        };
        __proto.addPoint = function (x, y) {
            this.x > x && (this.width += this.x - x, this.x = x);
            this.y > y && (this.height += this.y - y, this.y = y);
            if (this.width < x - this.x)
                this.width = x - this.x;
            if (this.height < y - this.y)
                this.height = y - this.y;
            return this;
        };
        __proto._getBoundPoints = function () {
            var rst = Rectangle._temB;
            rst.length = 0;
            if (this.width == 0 || this.height == 0)
                return rst;
            rst.push(this.x, this.y, this.x + this.width, this.y, this.x, this.y + this.height, this.x + this.width, this.y + this.height);
            return rst;
        };
        __proto.isEmpty = function () {
            if (this.width <= 0 || this.height <= 0)
                return true;
            return false;
        };
        __getset(0, __proto, 'right', function () {
            return this.x + this.width;
        });
        __getset(0, __proto, 'bottom', function () {
            return this.y + this.height;
        });
        Rectangle._getBoundPointS = function (x, y, width, height) {
            var rst = Rectangle._temA;
            rst.length = 0;
            if (width == 0 || height == 0)
                return rst;
            rst.push(x, y, x + width, y, x, y + height, x + width, y + height);
            return rst;
        };
        Rectangle._getWrapRec = function (pointList, rst) {
            if (!pointList || pointList.length < 1)
                return rst ? rst.setTo(0, 0, 0, 0) : Rectangle.TEMP.setTo(0, 0, 0, 0);
            rst = rst ? rst : new Rectangle();
            var i, len = pointList.length, minX, maxX, minY, maxY, tPoint = Point.TEMP;
            minX = minY = 99999;
            maxX = maxY = -minX;
            for (i = 0; i < len; i += 2) {
                tPoint.x = pointList[i];
                tPoint.y = pointList[i + 1];
                minX = minX < tPoint.x ? minX : tPoint.x;
                minY = minY < tPoint.y ? minY : tPoint.y;
                maxX = maxX > tPoint.x ? maxX : tPoint.x;
                maxY = maxY > tPoint.y ? maxY : tPoint.y;
            }
            return rst.setTo(minX, minY, maxX - minX, maxY - minY);
        };
        Rectangle.EMPTY = new Rectangle();
        Rectangle.TEMP = new Rectangle();
        Rectangle._temB = [];
        Rectangle._temA = [];
        return Rectangle;
    })();
    var SoundManager = (function () {
        function SoundManager() { }
        __class(SoundManager, 'laya.media.SoundManager');
        __getset(1, SoundManager, 'useAudioMusic', function () {
            return SoundManager._useAudioMusic;
        }, function (value) {
            SoundManager._useAudioMusic = value;
            if (value)
                SoundManager._musicClass = AudioSound;
        });
        __getset(1, SoundManager, 'autoStopMusic', function () {
            return SoundManager._autoStopMusic;
        }, function (v) {
            Laya.stage.off("blur", null, SoundManager._stageOnBlur);
            Laya.stage.off("focus", null, SoundManager._stageOnFocus);
            Laya.stage.off("visibilitychange", null, SoundManager._visibilityChange);
            SoundManager._autoStopMusic = v;
            if (v) {
                Laya.stage.on("blur", null, SoundManager._stageOnBlur);
                Laya.stage.on("focus", null, SoundManager._stageOnFocus);
                Laya.stage.on("visibilitychange", null, SoundManager._visibilityChange);
            }
        });
        __getset(1, SoundManager, 'muted', function () {
            return SoundManager._muted;
        }, function (value) {
            if (value == SoundManager._muted)
                return;
            if (value) {
                SoundManager.stopAllSound();
            }
            SoundManager.musicMuted = value;
            SoundManager._muted = value;
        });
        __getset(1, SoundManager, 'musicMuted', function () {
            return SoundManager._musicMuted;
        }, function (value) {
            if (value == SoundManager._musicMuted)
                return;
            if (value) {
                if (SoundManager._tMusic) {
                    if (SoundManager._musicChannel && !SoundManager._musicChannel.isStopped) {
                        SoundManager._musicChannel.pause();
                    }
                    else {
                        SoundManager._musicChannel = null;
                    }
                }
                else {
                    SoundManager._musicChannel = null;
                }
                SoundManager._musicMuted = value;
            }
            else {
                SoundManager._musicMuted = value;
                if (SoundManager._tMusic) {
                    if (SoundManager._musicChannel) {
                        SoundManager._musicChannel.resume();
                    }
                }
            }
        });
        __getset(1, SoundManager, 'soundMuted', function () {
            return SoundManager._soundMuted;
        }, function (value) {
            SoundManager._soundMuted = value;
        });
        SoundManager.addChannel = function (channel) {
            if (SoundManager._channels.indexOf(channel) >= 0)
                return;
            SoundManager._channels.push(channel);
        };
        SoundManager.removeChannel = function (channel) {
            var i = 0;
            for (i = SoundManager._channels.length - 1; i >= 0; i--) {
                if (SoundManager._channels[i] == channel) {
                    SoundManager._channels.splice(i, 1);
                }
            }
        };
        SoundManager.disposeSoundIfNotUsed = function (url) {
            var i = 0;
            for (i = SoundManager._channels.length - 1; i >= 0; i--) {
                if (SoundManager._channels[i].url == url) {
                    return;
                }
            }
            SoundManager.destroySound(url);
        };
        SoundManager._visibilityChange = function () {
            if (Laya.stage.isVisibility) {
                SoundManager._stageOnFocus();
            }
            else {
                SoundManager._stageOnBlur();
            }
        };
        SoundManager._stageOnBlur = function () {
            SoundManager._isActive = false;
            if (SoundManager._musicChannel) {
                if (!SoundManager._musicChannel.isStopped) {
                    SoundManager._blurPaused = true;
                    SoundManager._musicChannel.pause();
                    Laya.stage.once("mousedown", null, SoundManager._stageOnFocus);
                }
            }
            SoundManager.stopAllSound();
        };
        SoundManager._stageOnFocus = function () {
            SoundManager._isActive = true;
            Laya.stage.off("mousedown", null, SoundManager._stageOnFocus);
            if (SoundManager._blurPaused) {
                if (SoundManager._musicChannel && SoundManager._musicChannel.isStopped) {
                    SoundManager._blurPaused = false;
                    SoundManager._musicChannel.resume();
                }
            }
        };
        SoundManager.playSound = function (url, loops, playbackRate, complete, soundClass, startTime) {
            (loops === void 0) && (loops = 1);
            (startTime === void 0) && (startTime = 0);
            (playbackRate === void 0) && (playbackRate = 1);
            if (!SoundManager._isActive || !url)
                return null;
            if (SoundManager._muted)
                return null;
            url = URL.formatURL(url);
            if (url == SoundManager._tMusic) {
                if (SoundManager._musicMuted)
                    return null;
            }
            else {
                if (Render.isConchApp) {
                    var ext = Utils.getFileExtension(url);
                    if (ext != "wav" && ext != "ogg") {
                        alert("The sound only supports wav or ogg format,for optimal performance reason,please refer to the official website document.");
                        return null;
                    }
                }
                if (SoundManager._soundMuted)
                    return null;
            }
            ;
            var tSound;
            if (!Browser.onMiniGame) {
                tSound = Laya.loader.getRes(url);
            }
            if (!soundClass)
                soundClass = SoundManager._soundClass;
            if (!tSound) {
                tSound = new soundClass();
                tSound.load(url);
                Loader.cacheRes(url, tSound);
            }
            ;
            var channel;
            channel = tSound.play(startTime, loops, playbackRate);
            if (!channel)
                return null;
            tSound.once(EventObject.ERROR, this, function (channel) {
                channel.event(EventObject.ERROR);
            }, [channel]);
            channel.url = url;
            channel.volume = (url == SoundManager._tMusic) ? SoundManager.musicVolume : SoundManager.soundVolume;
            channel.completeHandler = complete;
            return channel;
        };
        SoundManager.destroySound = function (url) {
            var tSound = Laya.loader.getRes(url);
            if (tSound) {
                Loader.clearRes(url);
                tSound.dispose();
            }
        };
        SoundManager.playMusic = function (url, loops, complete, startTime) {
            (loops === void 0) && (loops = 0);
            (startTime === void 0) && (startTime = 0);
            url = URL.formatURL(url);
            SoundManager._tMusic = url;
            if (SoundManager._musicChannel)
                SoundManager._musicChannel.stop();
            return SoundManager._musicChannel = SoundManager.playSound(url, loops, complete, SoundManager._musicClass, startTime);
        };
        SoundManager.stopSound = function (url) {
            url = URL.formatURL(url);
            var i = 0;
            var channel;
            for (i = SoundManager._channels.length - 1; i >= 0; i--) {
                channel = SoundManager._channels[i];
                if (channel.url == url) {
                    channel.stop();
                }
            }
        };
        SoundManager.stopAll = function () {
            SoundManager._tMusic = null;
            var i = 0;
            var channel;
            for (i = SoundManager._channels.length - 1; i >= 0; i--) {
                channel = SoundManager._channels[i];
                channel.stop();
            }
        };
        SoundManager.stopAllSound = function () {
            var i = 0;
            var channel;
            for (i = SoundManager._channels.length - 1; i >= 0; i--) {
                channel = SoundManager._channels[i];
                if (channel.url != SoundManager._tMusic) {
                    channel.stop();
                }
            }
        };
        SoundManager.stopMusic = function () {
            if (SoundManager._musicChannel)
                SoundManager._musicChannel.stop();
            SoundManager._tMusic = null;
        };
        SoundManager.setSoundVolume = function (volume, url) {
            if (url) {
                url = URL.formatURL(url);
                SoundManager._setVolume(url, volume);
            }
            else {
                SoundManager.soundVolume = volume;
                var i = 0;
                var channel;
                for (i = SoundManager._channels.length - 1; i >= 0; i--) {
                    channel = SoundManager._channels[i];
                    if (channel.url != SoundManager._tMusic) {
                        channel.volume = volume;
                    }
                }
            }
        };
        SoundManager.setMusicVolume = function (volume) {
            SoundManager.musicVolume = volume;
            SoundManager._setVolume(SoundManager._tMusic, volume);
        };
        SoundManager._setVolume = function (url, volume) {
            url = URL.formatURL(url);
            var i = 0;
            var channel;
            for (i = SoundManager._channels.length - 1; i >= 0; i--) {
                channel = SoundManager._channels[i];
                if (channel.url == url) {
                    channel.volume = volume;
                }
            }
        };
        SoundManager.musicVolume = 1;
        SoundManager.soundVolume = 1;
        SoundManager.playbackRate = 1;
        SoundManager._useAudioMusic = true;
        SoundManager._muted = false;
        SoundManager._soundMuted = false;
        SoundManager._musicMuted = false;
        SoundManager._tMusic = null;
        SoundManager._musicChannel = null;
        SoundManager._channels = [];
        SoundManager._autoStopMusic = false;
        SoundManager._blurPaused = false;
        SoundManager._isActive = true;
        SoundManager._soundClass = null;
        SoundManager._musicClass = null;
        SoundManager.autoReleaseSound = true;
        return SoundManager;
    })();
    var LocalStorage = (function () {
        var Storage;
        function LocalStorage() { }
        __class(LocalStorage, 'laya.net.LocalStorage');
        LocalStorage.__init__ = function () {
            if (!LocalStorage._baseClass) {
                LocalStorage._baseClass = Storage;
                Storage.init();
            }
            LocalStorage.items = LocalStorage._baseClass.items;
            LocalStorage.support = LocalStorage._baseClass.support;
        };
        LocalStorage.setItem = function (key, value) {
            LocalStorage._baseClass.setItem(key, value);
        };
        LocalStorage.getItem = function (key) {
            return LocalStorage._baseClass.getItem(key);
        };
        LocalStorage.setJSON = function (key, value) {
            LocalStorage._baseClass.setJSON(key, value);
        };
        LocalStorage.getJSON = function (key) {
            return LocalStorage._baseClass.getJSON(key);
        };
        LocalStorage.removeItem = function (key) {
            LocalStorage._baseClass.removeItem(key);
        };
        LocalStorage.clear = function () {
            LocalStorage._baseClass.clear();
        };
        LocalStorage._baseClass = null;
        LocalStorage.items = null;
        LocalStorage.support = false;
        LocalStorage.__init$ = function () {
            Storage = (function () {
                function Storage() { }
                __class(Storage, '');
                Storage.init = function () {
                    try {
                        Storage.items = window.localStorage;
                        Storage.setItem('laya', '1');
                        Storage.removeItem('laya');
                        Storage.support = true;
                    }
                    catch (e) { }
                    if (!Storage.support)
                        console_log('LocalStorage is not supprot or browser is private mode.');
                };
                Storage.setItem = function (key, value) {
                    try {
                        Storage.support && Storage.items.setItem(key, value);
                    }
                    catch (e) {
                        console_warn("set localStorage failed", e);
                    }
                };
                Storage.getItem = function (key) {
                    return Storage.support ? Storage.items.getItem(key) : null;
                };
                Storage.setJSON = function (key, value) {
                    try {
                        Storage.support && Storage.items.setItem(key, JSON.stringify(value));
                    }
                    catch (e) {
                        console_warn("set localStorage failed", e);
                    }
                };
                Storage.getJSON = function (key) {
                    return JSON.parse(Storage.support ? Storage.items.getItem(key) : null);
                };
                Storage.removeItem = function (key) {
                    Storage.support && Storage.items.removeItem(key);
                };
                Storage.clear = function () {
                    Storage.support && Storage.items.clear();
                };
                Storage.items = null;
                Storage.support = false;
                return Storage;
            })();
        };
        return LocalStorage;
    })();
    var ResourceVersion = (function () {
        function ResourceVersion() { }
        __class(ResourceVersion, 'laya.net.ResourceVersion');
        ResourceVersion.enable = function (manifestFile, callback, type) {
            (type === void 0) && (type = 2);
            laya.net.ResourceVersion.type = type;
            Laya.loader.load(manifestFile, Handler.create(null, ResourceVersion.onManifestLoaded, [callback]), null, "json");
            URL.customFormat = ResourceVersion.addVersionPrefix;
        };
        ResourceVersion.onManifestLoaded = function (callback, data) {
            ResourceVersion.manifest = data;
            callback.run();
            if (!data) {
                console_warn("资源版本清单文件不存在，不使用资源版本管理。忽略ERR_FILE_NOT_FOUND错误。");
            }
        };
        ResourceVersion.addVersionPrefix = function (originURL) {
            if (ResourceVersion.manifest && ResourceVersion.manifest[originURL]) {
                if (ResourceVersion.type == 2)
                    return ResourceVersion.manifest[originURL];
                return ResourceVersion.manifest[originURL] + "/" + originURL;
            }
            return originURL;
        };
        ResourceVersion.FOLDER_VERSION = 1;
        ResourceVersion.FILENAME_VERSION = 2;
        ResourceVersion.manifest = null;
        ResourceVersion.type = 1;
        return ResourceVersion;
    })();
    var TTFLoader = (function () {
        function TTFLoader() {
            this.fontName = null;
            this.complete = null;
            this.err = null;
            this._fontTxt = null;
            this._url = null;
            this._div = null;
            this._txtWidth = NaN;
            this._http = null;
        }
        __class(TTFLoader, 'laya.net.TTFLoader');
        var __proto = TTFLoader.prototype;
        __proto.load = function (fontPath) {
            this._url = fontPath;
            var tArr = fontPath.split(".ttf")[0].split("/");
            this.fontName = tArr[tArr.length - 1];
            if (Browser.window.conch) {
                this._loadConch();
            }
            else if (Browser.window.FontFace) {
                this._loadWithFontFace();
            }
            else {
                this._loadWithCSS();
            }
        };
        __proto._loadConch = function () {
            this._http = new HttpRequest();
            this._http.on("error", this, this._onErr);
            this._http.on("complete", this, this._onHttpLoaded);
            this._http.send(this._url, null, "get", "arraybuffer");
        };
        __proto._onHttpLoaded = function (data) {
            Browser.window.conch.setFontFaceFromBuffer(this.fontName, data);
            this._clearHttp();
            this._complete();
        };
        __proto._clearHttp = function () {
            if (this._http) {
                this._http.off("error", this, this._onErr);
                this._http.off("complete", this, this._onHttpLoaded);
                this._http = null;
            }
        };
        __proto._onErr = function () {
            this._clearHttp();
            if (this.err) {
                this.err.runWith("fail:" + this._url);
                this.err = null;
            }
        };
        __proto._complete = function () {
            Laya.timer.clear(this, this._complete);
            Laya.timer.clear(this, this._checkComplete);
            if (this._div && this._div.parentNode) {
                this._div.parentNode.removeChild(this._div);
                this._div = null;
            }
            if (this.complete) {
                this.complete.runWith(this);
                this.complete = null;
            }
        };
        __proto._checkComplete = function () {
            if (RunDriver.measureText("The3TTFFont", this._fontTxt).width != this._txtWidth) {
                this._complete();
            }
        };
        __proto._loadWithFontFace = function () {
            var fontFace = new Browser.window.FontFace(this.fontName, "url('" + this._url + "')");
            Browser.window.document.fonts.add(fontFace);
            var self = this;
            fontFace.loaded.then((function () {
                self._complete();
            }));
            fontFace.load();
        };
        __proto._createDiv = function () {
            this._div = Browser.createElement("div");
            this._div.innerHTML = "laya";
            var _style = this._div.style;
            _style.fontFamily = this.fontName;
            _style.position = "absolute";
            _style.left = "-100px";
            _style.top = "-100px";
            Browser.document.body.appendChild(this._div);
        };
        __proto._loadWithCSS = function () {
            var _$this = this;
            var fontStyle = Browser.createElement("style");
            fontStyle.type = "text/css";
            Browser.document.body.appendChild(fontStyle);
            fontStyle.textContent = "@font-face { font-family:'" + this.fontName + "'; src:url('" + this._url + "');}";
            this._fontTxt = "40px " + this.fontName;
            this._txtWidth = RunDriver.measureText("The3TTFFont", this._fontTxt).width;
            var self = this;
            fontStyle.onload = function () {
                Laya.timer.once(10000, self, _$this._complete);
            };
            Laya.timer.loop(20, this, this._checkComplete);
            this._createDiv();
        };
        TTFLoader._testString = "The3TTFFont";
        return TTFLoader;
    })();
    var URL = (function () {
        function URL(url) {
            this._url = null;
            this._path = null;
            this._url = URL.formatURL(url);
            this._path = URL.getPath(url);
        }
        __class(URL, 'laya.net.URL');
        var __proto = URL.prototype;
        __getset(0, __proto, 'path', function () {
            return this._path;
        });
        __getset(0, __proto, 'url', function () {
            return this._url;
        });
        URL.formatURL = function (url, base) {
            if (!url)
                return "null path";
            if (url.indexOf(":") > 0)
                return url;
            if (URL.customFormat != null)
                url = URL.customFormat(url, base);
            var char1 = url.charAt(0);
            if (char1 === ".") {
                return URL.formatRelativePath((base || URL.basePath) + url);
            }
            else if (char1 === '~') {
                return URL.rootPath + url.substring(1);
            }
            else if (char1 === "d") {
                if (url.indexOf("data:image") === 0)
                    return url;
            }
            else if (char1 === "/") {
                return url;
            }
            return (base || URL.basePath) + url;
        };
        URL.formatRelativePath = function (value) {
            var parts = value.split("/");
            for (var i = 0, len = parts.length; i < len; i++) {
                if (parts[i] == '..') {
                    parts.splice(i - 1, 2);
                    i -= 2;
                }
            }
            return parts.join('/');
        };
        URL.isAbsolute = function (url) {
            return url.indexOf(":") > 0 || url.charAt(0) == '/';
        };
        URL.getPath = function (url) {
            var ofs = url.lastIndexOf('/');
            return ofs > 0 ? url.substr(0, ofs + 1) : "";
        };
        URL.getFileName = function (url) {
            var ofs = url.lastIndexOf('/');
            return ofs > 0 ? url.substr(ofs + 1) : url;
        };
        URL.version = {};
        URL.basePath = "";
        URL.rootPath = "";
        URL.customFormat = function (url) {
            var newUrl = URL.version[url];
            if (!Render.isConchApp && newUrl)
                url += "?v=" + newUrl;
            return url;
        };
        return URL;
    })();
    var Render = (function () {
        function Render(width, height) {
            this._timeId = 0;
            var style = Render._mainCanvas.source.style;
            style.position = 'absolute';
            style.top = style.left = "0px";
            style.background = "#000000";
            Render._mainCanvas.source.id = "gcCanvas";
            var isWebGl = laya.renders.Render.isWebGL;
            Render._mainCanvas.source.width = width;
            Render._mainCanvas.source.height = height;
            isWebGl && Render.WebGL.init(Render._mainCanvas, width, height);
            Browser.container.appendChild(Render._mainCanvas.source);
            Render._context = new RenderContext(width, height, isWebGl ? null : Render._mainCanvas);
            Render._context.ctx.setIsMainContext();
            var callbackBeforeRenderFunc = null;
            if (typeof Callback != "undefined") {
                callbackBeforeRenderFunc = function () {
                    var beforeRenderFuncs = Callback.beforeRenderFuncs.concat();
                    Callback.beforeRenderFuncs.length = 0;
                    for (var i in beforeRenderFuncs) {
                        var cb = beforeRenderFuncs[i];
                        var caller = cb.caller;
                        caller.____clks2.clear();
                    }
                    for (var i in beforeRenderFuncs) {
                        beforeRenderFuncs[i].run();
                    }
                }
            }
            else {
                callbackBeforeRenderFunc = function () { };
            }
            window.___callbackBeforeRenderFunc = callbackBeforeRenderFunc;
            Browser.window.requestAnimationFrame(loop);
            function loop() {
                // 当前帧允许刷新(调用过enterframe)
                if (os.callEnterFrame == os.enterFrameCount) {
                    Laya.stage._loop();
                }
                Browser.window.requestAnimationFrame(loop);
            }
            Laya.stage.on("visibilitychange", this, this._onVisibilitychange);
        }
        __class(Render, 'laya.renders.Render');
        var __proto = Render.prototype;
        __proto._onVisibilitychange = function () {
            if (!Browser.window.setInterval)
                return;
            if (!Laya.stage.isVisibility) {
                this._timeId = Browser.window.setInterval(this._enterFrame, 1000);
            }
            else if (this._timeId != 0) {
                Browser.window.clearInterval(this._timeId);
            }
        };
        __proto._enterFrame = function (e) {
            Laya.stage._loop();
        };
        __getset(1, Render, 'context', function () {
            return Render._context;
        });
        __getset(1, Render, 'canvas', function () {
            return Render._mainCanvas.source;
        });
        Render._context = null;
        Render._mainCanvas = null;
        Render.WebGL = null;
        Render.isConchNode = false;
        Render.isConchApp = false;
        Render.isConchWebGL = false;
        Render.isWebGL = false;
        Render.is3DMode = false;
        Render.optimizeTextureMemory = function (url, texture) {
            return true;
        };
        Render.__init$ = function () {
            window.ConchRenderType = window.ConchRenderType || 1;
            window.ConchRenderType |= (!window.conch ? 0 : 0x04);
            ;
            {
                Render.isConchNode = (window.ConchRenderType & 5) == 5;
                Render.isConchApp = (window.ConchRenderType & 0x04) == 0x04;
                Render.isConchWebGL = window.ConchRenderType == 6;
            }
            ;
            ;
        };
        return Render;
    })();
    var RenderContext = (function () {
        function RenderContext(width, height, canvas) {
            this.x = 0;
            this.y = 0;
            this._drawTexture = function (x, y, args) {
                if (args[0].loaded)
                    this.ctx.drawTexture(args[0], args[1], args[2], args[3], args[4], x, y);
            };
            this._fillTexture = function (x, y, args) {
                if (args[0].loaded)
                    this.ctx.fillTexture(args[0], args[1] + x, args[2] + y, args[3], args[4], args[5], args[6], args[7]);
            };
            this._drawTextureWithTransform = function (x, y, args) {
                if (args[0].loaded)
                    this.ctx.drawTextureWithTransform(args[0], args[1], args[2], args[3], args[4], args[5], x, y, args[6]);
            };
            this._fillQuadrangle = function (x, y, args) {
                this.ctx.fillQuadrangle(args[0], args[1], args[2], args[3], args[4]);
            };
            this._drawRect = function (x, y, args) {
                var ctx = this.ctx;
                if (args[4] != null) {
                    ctx.fillStyle = args[4];
                    ctx.fillRect(x + args[0], y + args[1], args[2], args[3], null);
                }
                if (args[5] != null) {
                    ctx.strokeStyle = args[5];
                    ctx.lineWidth = args[6];
                    ctx.strokeRect(x + args[0], y + args[1], args[2], args[3], args[6]);
                }
            };
            this._drawPie = function (x, y, args) {
                var ctx = this.ctx;
                Render.isWebGL && ctx.setPathId(args[8]);
                ctx.beginPath();
                if (Render.isWebGL) {
                    ctx.movePath(args[0] + x, args[1] + y);
                    ctx.moveTo(0, 0);
                }
                else {
                    ctx.moveTo(x + args[0], y + args[1]);
                }
                ctx.arc(x + args[0], y + args[1], args[2], args[3], args[4]);
                ctx.closePath();
                this._fillAndStroke(args[5], args[6], args[7], true);
            };
            this._clipRect = function (x, y, args) {
                this.ctx.clipRect(x + args[0], y + args[1], args[2], args[3]);
            };
            this._fillRect = function (x, y, args) {
                this.ctx.fillRect(x + args[0], y + args[1], args[2], args[3], args[4]);
            };
            this._drawCircle = function (x, y, args) {
                var ctx = this.ctx;
                Render.isWebGL && ctx.setPathId(args[6]);
                Stat.drawCall++;
                ctx.beginPath();
                Render.isWebGL && ctx.movePath(args[0] + x, args[1] + y);
                ctx.arc(args[0] + x, args[1] + y, args[2], 0, RenderContext.PI2);
                ctx.closePath();
                this._fillAndStroke(args[3], args[4], args[5], true);
            };
            this._fillCircle = function (x, y, args) {
                Stat.drawCall++;
                var ctx = this.ctx;
                ctx.beginPath();
                ctx.fillStyle = args[3];
                ctx.arc(args[0] + x, args[1] + y, args[2], 0, RenderContext.PI2);
                ctx.fill();
            };
            this._setShader = function (x, y, args) {
                this.ctx.setShader(args[0]);
            };
            this._drawLine = function (x, y, args) {
                var ctx = this.ctx;
                Render.isWebGL && ctx.setPathId(args[6]);
                ctx.beginPath();
                ctx.strokeStyle = args[4];
                ctx.lineWidth = args[5];
                if (Render.isWebGL) {
                    ctx.movePath(x, y);
                    ctx.moveTo(args[0], args[1]);
                    ctx.lineTo(args[2], args[3]);
                }
                else {
                    ctx.moveTo(x + args[0], y + args[1]);
                    ctx.lineTo(x + args[2], y + args[3]);
                }
                ctx.stroke();
            };
            this._drawLines = function (x, y, args) {
                var ctx = this.ctx;
                Render.isWebGL && ctx.setPathId(args[5]);
                ctx.beginPath();
                x += args[0], y += args[1];
                Render.isWebGL && ctx.movePath(x, y);
                ctx.strokeStyle = args[3];
                ctx.lineWidth = args[4];
                var points = args[2];
                var i = 2, n = points.length;
                if (Render.isWebGL) {
                    ctx.moveTo(points[0], points[1]);
                    while (i < n) {
                        ctx.lineTo(points[i++], points[i++]);
                    }
                }
                else {
                    ctx.moveTo(x + points[0], y + points[1]);
                    while (i < n) {
                        ctx.lineTo(x + points[i++], y + points[i++]);
                    }
                }
                ctx.stroke();
            };
            this._drawLinesWebGL = function (x, y, args) {
                this.ctx.drawLines(x + this.x + args[0], y + this.y + args[1], args[2], args[3], args[4]);
            };
            this._drawCurves = function (x, y, args) {
                this.ctx.drawCurves(x, y, args);
            };
            this._draw = function (x, y, args) {
                args[0].call(null, this, x, y);
            };
            this._transformByMatrix = function (x, y, args) {
                this.ctx.transformByMatrix(args[0]);
            };
            this._setTransform = function (x, y, args) {
                this.ctx.setTransform(args[0], args[1], args[2], args[3], args[4], args[5]);
            };
            this._setTransformByMatrix = function (x, y, args) {
                this.ctx.setTransformByMatrix(args[0]);
            };
            this._save = function (x, y, args) {
                this.ctx.save();
            };
            this._restore = function (x, y, args) {
                this.ctx.restore();
            };
            this._translate = function (x, y, args) {
                this.ctx.translate(args[0], args[1]);
            };
            this._transform = function (x, y, args) {
                this.ctx.translate(args[1] + x, args[2] + y);
                var mat = args[0];
                this.ctx.transform(mat.a, mat.b, mat.c, mat.d, mat.tx, mat.ty);
                this.ctx.translate(-x - args[1], -y - args[2]);
            };
            this._rotate = function (x, y, args) {
                this.ctx.translate(args[1] + x, args[2] + y);
                this.ctx.rotate(args[0]);
                this.ctx.translate(-x - args[1], -y - args[2]);
            };
            this._scale = function (x, y, args) {
                this.ctx.translate(args[2] + x, args[3] + y);
                this.ctx.scale(args[0], args[1]);
                this.ctx.translate(-x - args[2], -y - args[3]);
            };
            this._alpha = function (x, y, args) {
                this.ctx.globalAlpha *= args[0];
            };
            this._setAlpha = function (x, y, args) {
                this.ctx.globalAlpha = args[0];
            };
            this._fillText = function (x, y, args) {
                this.ctx.fillText(args[0], args[1] + x, args[2] + y, args[3], args[4], args[5]);
            };
            this._strokeText = function (x, y, args) {
                this.ctx.strokeText(args[0], args[1] + x, args[2] + y, args[3], args[4], args[5], args[6]);
            };
            this._fillBorderText = function (x, y, args) {
                this.ctx.fillBorderText(args[0], args[1] + x, args[2] + y, args[3], args[4], args[5], args[6], args[7]);
            };
            this._blendMode = function (x, y, args) {
                this.ctx.globalCompositeOperation = args[0];
            };
            this._beginClip = function (x, y, args) {
                this.ctx.beginClip && this.ctx.beginClip(x + args[0], y + args[1], args[2], args[3]);
            };
            this._setIBVB = function (x, y, args) {
                this.ctx.setIBVB(args[0] + x, args[1] + y, args[2], args[3], args[4], args[5], args[6], args[7]);
            };
            this._fillTrangles = function (x, y, args) {
                this.ctx.fillTrangles(args[0], args[1] + x, args[2] + y, args[3], args[4]);
            };
            this._drawPath = function (x, y, args) {
                var ctx = this.ctx;
                Render.isWebGL && ctx.setPathId(-1);
                ctx.beginPath();
                x += args[0], y += args[1];
                Render.isWebGL && ctx.movePath(x, y);
                var paths = args[2];
                for (var i = 0, n = paths.length; i < n; i++) {
                    var path = paths[i];
                    switch (path[0]) {
                        case "moveTo":
                            Render.isWebGL ? ctx.moveTo(path[1], path[2]) : ctx.moveTo(x + path[1], y + path[2]);
                            break;
                        case "lineTo":
                            Render.isWebGL ? ctx.lineTo(path[1], path[2]) : ctx.lineTo(x + path[1], y + path[2]);
                            break;
                        case "arcTo":
                            Render.isWebGL ? ctx.arcTo(path[1], path[2], path[3], path[4], path[5]) : ctx.arcTo(x + path[1], y + path[2], x + path[3], y + path[4], path[5]);
                            break;
                        case "closePath":
                            ctx.closePath();
                            break;
                    }
                }
                ;
                var brush = args[3];
                if (brush != null) {
                    ctx.fillStyle = brush.fillStyle;
                    ctx.fill();
                }
                ;
                var pen = args[4];
                if (pen != null) {
                    ctx.strokeStyle = pen.strokeStyle;
                    ctx.lineWidth = pen.lineWidth || 1;
                    ctx.lineJoin = pen.lineJoin;
                    ctx.lineCap = pen.lineCap;
                    ctx.miterLimit = pen.miterLimit;
                    ctx.stroke();
                }
            };
            this.drawPoly = function (x, y, args) {
                this.ctx.drawPoly(x + this.x + args[0], y + this.y + args[1], args[2], args[3], args[4], args[5], args[6]);
            };
            this._drawPoly = function (x, y, args) {
                var ctx = this.ctx;
                var points = args[2];
                var i = 2, n = points.length;
                if (Render.isWebGL) {
                    ctx.setPathId(args[6]);
                    ctx.beginPath();
                    x += args[0], y += args[1];
                    ctx.movePath(x, y);
                    ctx.moveTo(points[0], points[1]);
                    while (i < n) {
                        ctx.lineTo(points[i++], points[i++]);
                    }
                }
                else {
                    ctx.beginPath();
                    x += args[0], y += args[1];
                    ctx.moveTo(x + points[0], y + points[1]);
                    while (i < n) {
                        ctx.lineTo(x + points[i++], y + points[i++]);
                    }
                }
                ctx.closePath();
                this._fillAndStroke(args[3], args[4], args[5], args[7]);
            };
            this._drawSkin = function (x, y, args) {
                var tSprite = args[0];
                if (tSprite) {
                    var ctx = this.ctx;
                    tSprite.render(ctx, x, y);
                }
            };
            this._drawParticle = function (x, y, args) {
                this.ctx.drawParticle(x + this.x, y + this.y, args[0]);
            };
            this._setFilters = function (x, y, args) {
                this.ctx.setFilters(args);
            };
            if (canvas) {
                this.ctx = canvas.getContext('2d');
            }
            else {
                canvas = HTMLCanvas.create("3D");
                this.ctx = RunDriver.createWebGLContext2D(canvas);
                canvas._setContext(this.ctx);
            }
            canvas.size(width, height);
            this.canvas = canvas;
        }
        __class(RenderContext, 'laya.renders.RenderContext');
        var __proto = RenderContext.prototype;
        __proto.destroy = function () {
            if (this.canvas) {
                this.canvas.destroy();
                this.canvas = null;
                this.ctx = null;
            }
            if (this.ctx) {
                this.ctx.destroy();
                this.ctx = null;
            }
        };
        __proto.drawTexture = function (tex, x, y, width, height) {
            if (tex.loaded)
                this.ctx.drawTexture(tex, x, y, width, height, this.x, this.y);
        };
        __proto._drawTextures = function (x, y, args) {
            if (args[0].loaded)
                this.ctx.drawTextures(args[0], args[1], x + this.x, y + this.y);
        };
        __proto.drawTextureWithTransform = function (tex, x, y, width, height, m, alpha) {
            if (tex.loaded)
                this.ctx.drawTextureWithTransform(tex, x, y, width, height, m, this.x, this.y, alpha);
        };
        __proto.fillQuadrangle = function (tex, x, y, point4, m) {
            this.ctx.fillQuadrangle(tex, x, y, point4, m);
        };
        __proto.drawCanvas = function (canvas, x, y, width, height) {
            this.ctx.drawCanvas(canvas, x + this.x, y + this.y, width, height);
        };
        __proto.drawRect = function (x, y, width, height, color, lineWidth) {
            (lineWidth === void 0) && (lineWidth = 1);
            var ctx = this.ctx;
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.strokeRect(x + this.x, y + this.y, width, height, lineWidth);
        };
        __proto._fillAndStroke = function (fillColor, strokeColor, lineWidth, isConvexPolygon) {
            (isConvexPolygon === void 0) && (isConvexPolygon = false);
            var ctx = this.ctx;
            if (fillColor != null) {
                ctx.fillStyle = fillColor;
                if (Render.isWebGL) {
                    ctx.fill(isConvexPolygon);
                }
                else {
                    ctx.fill();
                }
            }
            if (strokeColor != null && lineWidth > 0) {
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = lineWidth;
                ctx.stroke();
            }
        };
        __proto.clipRect = function (x, y, width, height) {
            this.ctx.clipRect(x + this.x, y + this.y, width, height);
        };
        __proto.fillRect = function (x, y, width, height, fillStyle) {
            this.ctx.fillRect(x + this.x, y + this.y, width, height, fillStyle);
        };
        __proto.drawCircle = function (x, y, radius, color, lineWidth) {
            (lineWidth === void 0) && (lineWidth = 1);
            Stat.drawCall++;
            var ctx = this.ctx;
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.arc(x + this.x, y + this.y, radius, 0, RenderContext.PI2);
            ctx.stroke();
        };
        __proto.drawTriangles = function (x, y, args) {
            if (Render.isWebGL) {
                this.ctx.drawTriangles(args[0], x + args[1], y + args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]);
            }
            else {
                var indices = args[5];
                var i = 0, len = indices.length;
                var ctx = this.ctx;
                for (i = 0; i < len; i += 3) {
                    var index0 = indices[i] * 2;
                    var index1 = indices[i + 1] * 2;
                    var index2 = indices[i + 2] * 2;
                    ctx.drawTriangle(args[0], args[3], args[4], index0, index1, index2, args[6], true);
                }
            }
        };
        __proto.fillCircle = function (x, y, radius, color) {
            Stat.drawCall++;
            var ctx = this.ctx;
            ctx.beginPath();
            ctx.fillStyle = color;
            ctx.arc(x + this.x, y + this.y, radius, 0, RenderContext.PI2);
            ctx.fill();
        };
        __proto.setShader = function (shader) {
            this.ctx.setShader(shader);
        };
        __proto.drawLine = function (fromX, fromY, toX, toY, color, lineWidth) {
            (lineWidth === void 0) && (lineWidth = 1);
            var ctx = this.ctx;
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.moveTo(this.x + fromX, this.y + fromY);
            ctx.lineTo(this.x + toX, this.y + toY);
            ctx.stroke();
        };
        __proto.clear = function () {
            this.ctx.clear();
        };
        __proto.transformByMatrix = function (value) {
            this.ctx.transformByMatrix(value);
        };
        __proto.setTransform = function (a, b, c, d, tx, ty) {
            this.ctx.setTransform(a, b, c, d, tx, ty);
        };
        __proto.setTransformByMatrix = function (value) {
            this.ctx.setTransformByMatrix(value);
        };
        __proto.save = function () {
            this.ctx.save();
        };
        __proto.restore = function () {
            this.ctx.restore();
        };
        __proto.translate = function (x, y) {
            this.ctx.translate(x, y);
        };
        __proto.transform = function (a, b, c, d, tx, ty) {
            this.ctx.transform(a, b, c, d, tx, ty);
        };
        __proto.rotate = function (angle) {
            this.ctx.rotate(angle);
        };
        __proto.scale = function (scaleX, scaleY) {
            this.ctx.scale(scaleX, scaleY);
        };
        __proto.alpha = function (value) {
            this.ctx.globalAlpha *= value;
        };
        __proto.setAlpha = function (value) {
            this.ctx.globalAlpha = value;
        };
        __proto.fillWords = function (words, x, y, font, color, underLine) {
            (underLine === void 0) && (underLine = 0);
            this.ctx.fillWords(words, x, y, font, color, underLine);
        };
        __proto.fillBorderWords = function (words, x, y, font, fillColor, borderColor, lineWidth) {
            this.ctx.fillBorderWords(words, x, y, font, fillColor, borderColor, lineWidth);
        };
        __proto.fillText = function (text, x, y, font, color, textAlign) {
            this.ctx.fillText(text, x + this.x, y + this.y, font, color, textAlign);
        };
        __proto.strokeText = function (text, x, y, font, color, lineWidth, textAlign) {
            this.ctx.strokeText(text, x + this.x, y + this.y, font, color, lineWidth, textAlign);
        };
        __proto.blendMode = function (type) {
            this.ctx.globalCompositeOperation = type;
        };
        __proto.flush = function () {
            this.ctx.flush && this.ctx.flush();
        };
        __proto.addRenderObject = function (o) {
            this.ctx.addRenderObject(o);
        };
        __proto.beginClip = function (x, y, w, h) {
            this.ctx.beginClip && this.ctx.beginClip(x, y, w, h);
        };
        __proto.endClip = function () {
            this.ctx.endClip && this.ctx.endClip();
        };
        __proto.fillTrangles = function (x, y, args) {
            this.ctx.fillTrangles(args[0], args[1], args[2], args[3], args.length > 4 ? args[4] : null);
        };
        RenderContext.PI2 = 2 * Math.PI;
        return RenderContext;
    })();
    var RenderSprite = (function () {
        function RenderSprite(type, next) {
            this._next = next || RenderSprite.NORENDER;
            switch (type) {
                case 0:
                    this._fun = this._no;
                    return;
                case 0x01:
                    this._fun = this._image;
                    return;
                case 0x02:
                    this._fun = this._alpha;
                    return;
                case 0x04:
                    this._fun = this._transform;
                    return;
                case 0x08:
                    this._fun = this._blend;
                    return;
                case 0x10:
                    this._fun = this._canvas;
                    return;
                case 0x40:
                    this._fun = this._mask;
                    return;
                case 0x80:
                    this._fun = this._clip;
                    return;
                case 0x100:
                    this._fun = this._style;
                    return;
                case 0x200:
                    this._fun = this._graphics;
                    return;
                case 0x800:
                    this._fun = this._childs;
                    return;
                case 0x400:
                    this._fun = this._custom;
                    return;
                case 0x01 | 0x200:
                    this._fun = this._image2;
                    return;
                case 0x01 | 0x04 | 0x200:
                    this._fun = this._image2;
                    return;
                case 0x20:
                    this._fun = Filter._filter;
                    return;
                case 0x11111:
                    this._fun = RenderSprite._initRenderFun;
                    return;
            }
            this.onCreate(type);
        }
        __class(RenderSprite, 'laya.renders.RenderSprite');
        var __proto = RenderSprite.prototype;
        __proto.onCreate = function (type) { };
        __proto._style = function (sprite, context, x, y) {
            sprite._style.render(sprite, context, x, y);
            var next = this._next;
            next._fun.call(next, sprite, context, x, y);
        };
        __proto._no = function (sprite, context, x, y) { };
        __proto._custom = function (sprite, context, x, y) {
            sprite.customRender(context, x, y);
            var tf = sprite._style._tf;
            this._next._fun.call(this._next, sprite, context, x - tf.translateX, y - tf.translateY);
        };
        __proto._clip = function (sprite, context, x, y) {
            var next = this._next;
            if (next == RenderSprite.NORENDER)
                return;
            var r = sprite._style.scrollRect;
            context.ctx.save();
            context.ctx.clipRect(x, y, r.width, r.height);
            next._fun.call(next, sprite, context, x - r.x, y - r.y);
            context.ctx.restore();
        };
        __proto._blend = function (sprite, context, x, y) {
            var style = sprite._style;
            if (style.blendMode) {
                context.ctx.globalCompositeOperation = style.blendMode;
            }
            ;
            var next = this._next;
            next._fun.call(next, sprite, context, x, y);
            context.ctx.globalCompositeOperation = "source-over";
        };
        __proto._mask = function (sprite, context, x, y) {
            var next = this._next;
            next._fun.call(next, sprite, context, x, y);
            var mask = sprite.mask;
            if (mask) {
                context.ctx.globalCompositeOperation = "destination-in";
                if (mask.numChildren > 0 || !mask.graphics._isOnlyOne()) {
                    mask.cacheAsBitmap = true;
                }
                mask.render(context, x - sprite.pivotX, y - sprite.pivotY);
            }
            context.ctx.globalCompositeOperation = "source-over";
        };
        __proto._graphics = function (sprite, context, x, y) {
            var tf = sprite._style._tf;
            sprite._graphics && sprite._graphics._render(sprite, context, x - tf.translateX, y - tf.translateY);
            var next = this._next;
            next._fun.call(next, sprite, context, x, y);
        };
        __proto._image = function (sprite, context, x, y) {
            var style = sprite._style;
            context.ctx.drawTexture2(x, y, style._tf.translateX, style._tf.translateY, sprite.transform, style.alpha, style.blendMode, sprite._graphics._one);
        };
        __proto._image2 = function (sprite, context, x, y) {
            var tf = sprite._style._tf;
            context.ctx.drawTexture2(x, y, tf.translateX, tf.translateY, sprite.transform, 1, null, sprite._graphics._one);
        };
        __proto._alpha = function (sprite, context, x, y) {
            var style = sprite._style;
            var alpha;
            if ((alpha = style.alpha) > 0.01 || sprite._needRepaint()) {
                var temp = context.ctx.globalAlpha;
                context.ctx.globalAlpha *= alpha;
                var next = this._next;
                next._fun.call(next, sprite, context, x, y);
                context.ctx.globalAlpha = temp;
            }
        };
        __proto._transform = function (sprite, context, x, y) {
            var transform = sprite.transform, _next = this._next;
            if (transform && _next != RenderSprite.NORENDER) {
                context.save();
                context.transform(transform.a, transform.b, transform.c, transform.d, transform.tx + x, transform.ty + y);
                _next._fun.call(_next, sprite, context, 0, 0);
                context.restore();
            }
            else
                _next._fun.call(_next, sprite, context, x, y);
        };
        __proto._childs = function (sprite, context, x, y) {
            var style = sprite._style;
            var tf = style._tf;
            x = x - tf.translateX + style.paddingLeft;
            y = y - tf.translateY + style.paddingTop;
            if (style._calculation) {
                var words = sprite._getWords();
                if (words) {
                    var tStyle = style;
                    if (tStyle) {
                        if (tStyle.stroke) {
                            context.fillBorderWords(words, x, y, tStyle.font, tStyle.color, tStyle.strokeColor, tStyle.stroke);
                        }
                        else {
                            context.fillWords(words, x, y, tStyle.font, tStyle.color, tStyle.underLine);
                        }
                    }
                }
            }
            ;
            var childs = sprite._childs, n = childs.length, ele;
            if (sprite.viewport || (sprite.optimizeScrollRect && sprite._style.scrollRect)) {
                var rect = sprite.viewport || sprite._style.scrollRect;
                var left = rect.x;
                var top = rect.y;
                var right = rect.right;
                var bottom = rect.bottom;
                var _x = NaN, _y = NaN;
                for (i = 0; i < n; ++i) {
                    if ((ele = childs[i]).visible && ((_x = ele._x) < right && (_x + ele.width) > left && (_y = ele._y) < bottom && (_y + ele.height) > top)) {
                        ele.render(context, x, y);
                    }
                }
            }
            else {
                for (var i = 0; i < n; ++i)
                    (ele = (childs[i]))._style.visible && ele.render(context, x, y);
            }
        };
        __proto._canvas = function (sprite, context, x, y) {
            var _cacheCanvas = sprite._$P.cacheCanvas;
            if (!_cacheCanvas) {
                this._next._fun.call(this._next, sprite, context, x, y);
                return;
            }
            _cacheCanvas.type === 'bitmap' ? (Stat.canvasBitmap++) : (Stat.canvasNormal++);
            var tx = _cacheCanvas.ctx;
            if (sprite._needRepaint() || !tx) {
                this._canvas_repaint(sprite, context, x, y);
            }
            else {
                var tRec = _cacheCanvas._cacheRec;
                context.drawCanvas(tx.canvas, x + tRec.x, y + tRec.y, tRec.width, tRec.height);
            }
        };
        __proto._canvas_repaint = function (sprite, context, x, y) {
            var _cacheCanvas = sprite._$P.cacheCanvas;
            var _next = this._next;
            if (!_cacheCanvas) {
                _next._fun.call(_next, sprite, tx, x, y);
                return;
            }
            ;
            var tx = _cacheCanvas.ctx;
            var _repaint = sprite._needRepaint() || (!tx);
            var canvas;
            var left;
            var top;
            var tRec;
            var tCacheType = _cacheCanvas.type;
            tCacheType === 'bitmap' ? (Stat.canvasBitmap++) : (Stat.canvasNormal++);
            if (_repaint) {
                if (!_cacheCanvas._cacheRec)
                    _cacheCanvas._cacheRec = new Rectangle();
                var w, h;
                if (!Render.isWebGL || tCacheType === "bitmap") {
                    tRec = sprite.getSelfBounds();
                    tRec.x = tRec.x - sprite.pivotX;
                    tRec.y = tRec.y - sprite.pivotY;
                    tRec.x = tRec.x - 16;
                    tRec.y = tRec.y - 16;
                    tRec.width = tRec.width + 32;
                    tRec.height = tRec.height + 32;
                    tRec.x = Math.floor(tRec.x + x) - x;
                    tRec.y = Math.floor(tRec.y + y) - y;
                    tRec.width = Math.floor(tRec.width);
                    tRec.height = Math.floor(tRec.height);
                    _cacheCanvas._cacheRec.copyFrom(tRec);
                }
                else {
                    _cacheCanvas._cacheRec.setTo(-sprite.pivotX, -sprite.pivotY, 1, 1);
                }
                tRec = _cacheCanvas._cacheRec;
                var scaleX = Render.isWebGL ? 1 : Browser.pixelRatio * Laya.stage.clientScaleX;
                var scaleY = Render.isWebGL ? 1 : Browser.pixelRatio * Laya.stage.clientScaleY;
                if (!Render.isWebGL) {
                    var chainScaleX = 1;
                    var chainScaleY = 1;
                    var tar;
                    tar = sprite;
                    while (tar && tar != Laya.stage) {
                        chainScaleX *= tar.scaleX;
                        chainScaleY *= tar.scaleY;
                        tar = tar.parent;
                    }
                    if (Render.isWebGL) {
                        if (chainScaleX < 1)
                            scaleX *= chainScaleX;
                        if (chainScaleY < 1)
                            scaleY *= chainScaleY;
                    }
                    else {
                        if (chainScaleX > 1)
                            scaleX *= chainScaleX;
                        if (chainScaleY > 1)
                            scaleY *= chainScaleY;
                    }
                }
                if (sprite.scrollRect) {
                    var scrollRect = sprite.scrollRect;
                    tRec.x -= scrollRect.x;
                    tRec.y -= scrollRect.y;
                }
                w = tRec.width * scaleX;
                h = tRec.height * scaleY;
                left = tRec.x;
                top = tRec.y;
                if (Render.isWebGL && tCacheType === 'bitmap' && (w > 4096 || h > 4096)) {
                    console_warn("cache bitmap size larger than 2048,cache ignored");
                    if (_cacheCanvas.ctx) {
                        Pool.recover("RenderContext", _cacheCanvas.ctx);
                        _cacheCanvas.ctx.canvas.size(0, 0);
                        _cacheCanvas.ctx = null;
                    }
                    _next._fun.call(_next, sprite, context, x, y);
                    return;
                }
                if (!tx) {
                    tx = _cacheCanvas.ctx = Pool.getItem("RenderContext") || new RenderContext(w, h, HTMLCanvas.create("AUTO"));
                }
                tx.ctx.sprite = sprite;
                canvas = tx.canvas;
                canvas.clear();
                (canvas.width != w || canvas.height != h) && canvas.size(w, h);
                if (tCacheType === 'bitmap')
                    canvas.context.asBitmap = true;
                else if (tCacheType === 'normal')
                    canvas.context.asBitmap = false;
                var t;
                if (scaleX != 1 || scaleY != 1) {
                    var ctx = (tx).ctx;
                    ctx.save();
                    ctx.scale(scaleX, scaleY);
                    if (!Render.isConchWebGL && Render.isConchApp) {
                        t = sprite._$P.cf;
                        t && ctx.setFilterMatrix && ctx.setFilterMatrix(t._mat, t._alpha);
                    }
                    _next._fun.call(_next, sprite, tx, -left, -top);
                    ctx.restore();
                    if (!Render.isConchApp || Render.isConchWebGL)
                        sprite._applyFilters();
                }
                else {
                    ctx = (tx).ctx;
                    if (!Render.isConchWebGL && Render.isConchApp) {
                        t = sprite._$P.cf;
                        t && ctx.setFilterMatrix && ctx.setFilterMatrix(t._mat, t._alpha);
                    }
                    _next._fun.call(_next, sprite, tx, -left, -top);
                    if (!Render.isConchApp || Render.isConchWebGL)
                        sprite._applyFilters();
                }
                if (sprite._$P.staticCache)
                    _cacheCanvas.reCache = false;
                Stat.canvasReCache++;
            }
            else {
                tRec = _cacheCanvas._cacheRec;
                left = tRec.x;
                top = tRec.y;
                canvas = tx.canvas;
            }
            context.drawCanvas(canvas, x + left, y + top, tRec.width, tRec.height);
        };
        RenderSprite.__init__ = function () {
            var i = 0, len = 0;
            var initRender;
            initRender = RunDriver.createRenderSprite(0x11111, null);
            len = RenderSprite.renders.length = 0x800 * 2;
            for (i = 0; i < len; i++)
                RenderSprite.renders[i] = initRender;
            RenderSprite.renders[0] = RunDriver.createRenderSprite(0, null);
            function _initSame(value, o) {
                var n = 0;
                for (var i = 0; i < value.length; i++) {
                    n |= value[i];
                    RenderSprite.renders[n] = o;
                }
            }
            _initSame([0x01, 0x200, 0x04, 0x02], new RenderSprite(0x01, null));
            RenderSprite.renders[0x01 | 0x200] = RunDriver.createRenderSprite(0x01 | 0x200, null);
            RenderSprite.renders[0x01 | 0x04 | 0x200] = new RenderSprite(0x01 | 0x04 | 0x200, null);
        };
        RenderSprite._initRenderFun = function (sprite, context, x, y) {
            var type = sprite._renderType;
            var r = RenderSprite.renders[type] = RenderSprite._getTypeRender(type);
            r._fun(sprite, context, x, y);
        };
        RenderSprite._getTypeRender = function (type) {
            var rst = null;
            var tType = 0x800;
            while (tType > 1) {
                if (tType & type)
                    rst = RunDriver.createRenderSprite(tType, rst);
                tType = tType >> 1;
            }
            return rst;
        };
        RenderSprite.IMAGE = 0x01;
        RenderSprite.ALPHA = 0x02;
        RenderSprite.TRANSFORM = 0x04;
        RenderSprite.BLEND = 0x08;
        RenderSprite.CANVAS = 0x10;
        RenderSprite.FILTERS = 0x20;
        RenderSprite.MASK = 0x40;
        RenderSprite.CLIP = 0x80;
        RenderSprite.STYLE = 0x100;
        RenderSprite.GRAPHICS = 0x200;
        RenderSprite.CUSTOM = 0x400;
        RenderSprite.CHILDS = 0x800;
        RenderSprite.INIT = 0x11111;
        RenderSprite.renders = [];
        RenderSprite.NORENDER = new RenderSprite(0, null);
        return RenderSprite;
    })();
    var Context = (function () {
        function Context() {
            this._repaint = false;
        }
        __class(Context, 'laya.resource.Context');
        var __proto = Context.prototype;
        __proto.replaceReset = function () {
            var i = 0, len = 0;
            len = Context.replaceKeys.length;
            var key;
            for (i = 0; i < len; i++) {
                key = Context.replaceKeys[i];
                this[Context.newKeys[i]] = this[key];
            }
        };
        __proto.replaceResotre = function () {
            this.__restore();
            this.__reset();
        };
        __proto.setIsMainContext = function () { };
        __proto.drawTextures = function (tex, pos, tx, ty) {
            Stat.drawCall += pos.length / 2;
            var w = tex.width;
            var h = tex.height;
            for (var i = 0, sz = pos.length; i < sz; i += 2) {
                this.drawTexture(tex, pos[i], pos[i + 1], w, h, tx, ty);
            }
        };
        __proto.drawCanvas = function (canvas, x, y, width, height) {
            Stat.drawCall++;
            this.drawImage(canvas.source, x, y, width, height);
        };
        __proto.fillRect = function (x, y, width, height, style) {
            Stat.drawCall++;
            style && (this.fillStyle = style);
            this.__fillRect(x, y, width, height);
        };
        __proto.fillText = function (text, x, y, font, color, textAlign) {
            Stat.drawCall++;
            if (arguments.length > 3 && font != null) {
                this.font = font;
                this.fillStyle = color;
                this.textAlign = textAlign;
                this.textBaseline = "top";
            }
            this.__fillText(text, x, y);
        };
        __proto.fillBorderText = function (text, x, y, font, fillColor, borderColor, lineWidth, textAlign) {
            Stat.drawCall++;
            this.font = font;
            this.fillStyle = fillColor;
            this.textBaseline = "top";
            this.strokeStyle = borderColor;
            this.lineWidth = lineWidth;
            this.textAlign = textAlign;
            this.__strokeText(text, x, y);
            this.__fillText(text, x, y);
        };
        __proto.strokeText = function (text, x, y, font, color, lineWidth, textAlign) {
            Stat.drawCall++;
            if (arguments.length > 3 && font != null) {
                this.font = font;
                this.strokeStyle = color;
                this.lineWidth = lineWidth;
                this.textAlign = textAlign;
                this.textBaseline = "top";
            }
            this.__strokeText(text, x, y);
        };
        __proto.transformByMatrix = function (value) {
            this.transform(value.a, value.b, value.c, value.d, value.tx, value.ty);
        };
        __proto.setTransformByMatrix = function (value) {
            this.setTransform(value.a, value.b, value.c, value.d, value.tx, value.ty);
        };
        __proto.clipRect = function (x, y, width, height) {
            Stat.drawCall++;
            this.beginPath();
            this.rect(x, y, width, height);
            this.clip();
        };
        __proto.drawTexture = function (tex, x, y, width, height, tx, ty) {
            Stat.drawCall++;
            var uv = tex.uv, w = tex.bitmap.width, h = tex.bitmap.height;
            this.drawImage(tex.source, uv[0] * w, uv[1] * h, (uv[2] - uv[0]) * w, (uv[5] - uv[3]) * h, x + tx, y + ty, width, height);
        };
        __proto.drawTextureWithTransform = function (tex, x, y, width, height, m, tx, ty, alpha) {
            Stat.drawCall++;
            var uv = tex.uv, w = tex.bitmap.width, h = tex.bitmap.height;
            this.save();
            alpha != 1 && (this.globalAlpha *= alpha);
            if (m) {
                this.transform(m.a, m.b, m.c, m.d, m.tx + tx, m.ty + ty);
                this.drawImage(tex.source, uv[0] * w, uv[1] * h, (uv[2] - uv[0]) * w, (uv[5] - uv[3]) * h, x, y, width, height);
            }
            else {
                this.drawImage(tex.source, uv[0] * w, uv[1] * h, (uv[2] - uv[0]) * w, (uv[5] - uv[3]) * h, x + tx, y + ty, width, height);
            }
            this.restore();
        };
        __proto.drawTexture2 = function (x, y, pivotX, pivotY, m, alpha, blendMode, args2) {
            'use strict';
            var tex = args2[0];
            if (!(tex.loaded && tex.bitmap && tex.source)) {
                return;
            }
            Stat.drawCall++;
            var alphaChanged = alpha !== 1;
            if (alphaChanged) {
                var temp = this.globalAlpha;
                this.globalAlpha *= alpha;
            }
            ;
            var uv = tex.uv, w = tex.bitmap.width, h = tex.bitmap.height;
            if (m) {
                this.save();
                this.transform(m.a, m.b, m.c, m.d, m.tx + x, m.ty + y);
                this.drawImage(tex.source, uv[0] * w, uv[1] * h, (uv[2] - uv[0]) * w, (uv[5] - uv[3]) * h, args2[1] - pivotX, args2[2] - pivotY, args2[3], args2[4]);
                this.restore();
            }
            else {
                this.drawImage(tex.source, uv[0] * w, uv[1] * h, (uv[2] - uv[0]) * w, (uv[5] - uv[3]) * h, args2[1] - pivotX + x, args2[2] - pivotY + y, args2[3], args2[4]);
            }
            if (alphaChanged)
                this.globalAlpha = temp;
        };
        __proto.fillTexture = function (texture, x, y, width, height, type, offset, other) {
            if (!other.pat) {
                if (texture.uv != Texture.DEF_UV) {
                    var canvas = new HTMLCanvas("2D");
                    canvas.getContext('2d');
                    canvas.size(texture.width, texture.height);
                    canvas.context.drawTexture(texture, 0, 0, texture.width, texture.height, 0, 0);
                    texture = new Texture(canvas);
                }
                other.pat = this.createPattern(texture.bitmap.source, type);
            }
            ;
            var oX = x, oY = y;
            var sX = 0, sY = 0;
            if (offset) {
                oX += offset.x % texture.width;
                oY += offset.y % texture.height;
                sX -= offset.x % texture.width;
                sY -= offset.y % texture.height;
            }
            this.translate(oX, oY);
            this.fillRect(sX, sY, width, height, other.pat);
            this.translate(-oX, -oY);
        };
        __proto.drawTriangle = function (texture, vertices, uvs, index0, index1, index2, matrix, canvasPadding) {
            var source = texture.bitmap;
            var textureSource = source.source;
            var textureWidth = texture.width;
            var textureHeight = texture.height;
            var sourceWidth = source.width;
            var sourceHeight = source.height;
            var u0 = uvs[index0] * sourceWidth;
            var u1 = uvs[index1] * sourceWidth;
            var u2 = uvs[index2] * sourceWidth;
            var v0 = uvs[index0 + 1] * sourceHeight;
            var v1 = uvs[index1 + 1] * sourceHeight;
            var v2 = uvs[index2 + 1] * sourceHeight;
            var x0 = vertices[index0];
            var x1 = vertices[index1];
            var x2 = vertices[index2];
            var y0 = vertices[index0 + 1];
            var y1 = vertices[index1 + 1];
            var y2 = vertices[index2 + 1];
            if (canvasPadding) {
                var paddingX = 1;
                var paddingY = 1;
                var centerX = (x0 + x1 + x2) / 3;
                var centerY = (y0 + y1 + y2) / 3;
                var normX = x0 - centerX;
                var normY = y0 - centerY;
                var dist = Math.sqrt((normX * normX) + (normY * normY));
                x0 = centerX + ((normX / dist) * (dist + paddingX));
                y0 = centerY + ((normY / dist) * (dist + paddingY));
                normX = x1 - centerX;
                normY = y1 - centerY;
                dist = Math.sqrt((normX * normX) + (normY * normY));
                x1 = centerX + ((normX / dist) * (dist + paddingX));
                y1 = centerY + ((normY / dist) * (dist + paddingY));
                normX = x2 - centerX;
                normY = y2 - centerY;
                dist = Math.sqrt((normX * normX) + (normY * normY));
                x2 = centerX + ((normX / dist) * (dist + paddingX));
                y2 = centerY + ((normY / dist) * (dist + paddingY));
            }
            this.save();
            if (matrix)
                this.transform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
            this.beginPath();
            this.moveTo(x0, y0);
            this.lineTo(x1, y1);
            this.lineTo(x2, y2);
            this.closePath();
            this.clip();
            var delta = (u0 * v1) + (v0 * u2) + (u1 * v2) - (v1 * u2) - (v0 * u1) - (u0 * v2);
            var dDelta = 1 / delta;
            var deltaA = (x0 * v1) + (v0 * x2) + (x1 * v2) - (v1 * x2) - (v0 * x1) - (x0 * v2);
            var deltaB = (u0 * x1) + (x0 * u2) + (u1 * x2) - (x1 * u2) - (x0 * u1) - (u0 * x2);
            var deltaC = (u0 * v1 * x2) + (v0 * x1 * u2) + (x0 * u1 * v2) - (x0 * v1 * u2) - (v0 * u1 * x2) - (u0 * x1 * v2);
            var deltaD = (y0 * v1) + (v0 * y2) + (y1 * v2) - (v1 * y2) - (v0 * y1) - (y0 * v2);
            var deltaE = (u0 * y1) + (y0 * u2) + (u1 * y2) - (y1 * u2) - (y0 * u1) - (u0 * y2);
            var deltaF = (u0 * v1 * y2) + (v0 * y1 * u2) + (y0 * u1 * v2) - (y0 * v1 * u2) - (v0 * u1 * y2) - (u0 * y1 * v2);
            this.transform(deltaA * dDelta, deltaD * dDelta, deltaB * dDelta, deltaE * dDelta, deltaC * dDelta, deltaF * dDelta);
            this.drawImage(textureSource, texture.uv[0] * sourceWidth, texture.uv[1] * sourceHeight, textureWidth, textureHeight, texture.uv[0] * sourceWidth, texture.uv[1] * sourceHeight, textureWidth, textureHeight);
            this.restore();
        };
        __proto.flush = function () {
            return 0;
        };
        __proto.fillWords = function (words, x, y, font, color, underLine) {
            font && (this.font = font);
            color && (this.fillStyle = color);
            var _this = this;
            this.textBaseline = "top";
            this.textAlign = 'left';
            for (var i = 0, n = words.length; i < n; i++) {
                var a = words[i];
                this.__fillText(a.char, a.x + x, a.y + y);
                if (underLine === 1) {
                    var tHeight = a.height;
                    var dX = a.style.letterSpacing * 0.5;
                    if (!dX)
                        dX = 0;
                    this.beginPath();
                    this.strokeStyle = color;
                    this.lineWidth = 1;
                    this.moveTo(x + a.x - dX + 0.5, y + a.y + tHeight + 0.5);
                    this.lineTo(x + a.x + a.width + dX + 0.5, y + a.y + tHeight + 0.5);
                    this.stroke();
                }
            }
        };
        __proto.fillBorderWords = function (words, x, y, font, color, borderColor, lineWidth) {
            font && (this.font = font);
            color && (this.fillStyle = color);
            this.textBaseline = "top";
            this.lineWidth = lineWidth;
            this.textAlign = 'left';
            this.strokeStyle = borderColor;
            for (var i = 0, n = words.length; i < n; i++) {
                var a = words[i];
                this.__strokeText(a.char, a.x + x, a.y + y);
                this.__fillText(a.char, a.x + x, a.y + y);
            }
        };
        __proto.destroy = function () {
            this.canvas.width = this.canvas.height = 0;
        };
        __proto.clear = function () {
            this.clearRect(0, 0, this._canvas.width, this._canvas.height);
            this._repaint = false;
        };
        __proto.drawCurves = function (x, y, args) {
            this.beginPath();
            this.strokeStyle = args[3];
            this.lineWidth = args[4];
            var points = args[2];
            x += args[0], y += args[1];
            this.moveTo(x + points[0], y + points[1]);
            var i = 2, n = points.length;
            while (i < n) {
                this.quadraticCurveTo(x + points[i++], y + points[i++], x + points[i++], y + points[i++]);
            }
            this.stroke();
        };
        Context.__init__ = function (to) {
            var from = laya.resource.Context.prototype;
            to = to || CanvasRenderingContext2D.prototype;
            if (to.inited)
                return;
            to.inited = true;
            to.__fillText = to.fillText;
            to.__fillRect = to.fillRect;
            to.__strokeText = to.strokeText;
            var funs = ['drawTextures', "drawTriangle", 'fillWords', 'fillBorderWords', 'setIsMainContext', 'fillRect', 'strokeText', 'fillTexture', 'fillText', 'transformByMatrix', 'setTransformByMatrix', 'clipRect', 'drawTexture', 'drawTexture2', 'drawTextureWithTransform', 'flush', 'clear', 'destroy', 'drawCanvas', 'fillBorderText', 'drawCurves'];
            funs.forEach(function (i) {
                to[i] = from[i];
            });
        };
        Context.replaceCanvasGetSet = function (tar, key) {
            var oldO = Object.getOwnPropertyDescriptor(tar, key);
            if (!oldO || !oldO.configurable)
                return false;
            var newO = {};
            var tkey;
            for (tkey in oldO) {
                if (tkey != "set") {
                    newO[tkey] = oldO[tkey];
                }
            }
            ;
            var preFun = oldO["set"];
            newO["set"] = function (v) {
                var _self = this;
                preFun.call(_self, v);
                var _ct = _self.getContext("2d");
                if (_ct && "__reset" in _ct) {
                    _ct.__reset();
                }
            };
            Object.defineProperty(tar, key, newO);
            return true;
        };
        Context.replaceGetSet = function (tar, key) {
            var oldO = Object.getOwnPropertyDescriptor(tar, key);
            if (!oldO || !oldO.configurable)
                return false;
            var newO = {};
            var tkey;
            for (tkey in oldO) {
                if (tkey != "set") {
                    newO[tkey] = oldO[tkey];
                }
            }
            ;
            var preFun = oldO["set"];
            var dataKey = "___" + key + "__";
            Context.newKeys.push(dataKey);
            newO["set"] = function (v) {
                var _self = this;
                if (v != _self[dataKey]) {
                    _self[dataKey] = v;
                    preFun.call(_self, v);
                }
            };
            Object.defineProperty(tar, key, newO);
            return true;
        };
        Context._default = new Context();
        Context.newKeys = [];
        __static(Context, ['replaceKeys', function () { return this.replaceKeys = ["font", "fillStyle", "textBaseline"]; }
        ]);
        return Context;
    })();
    var ResourceManager = (function () {
        function ResourceManager(name) {
            this._id = 0;
            this._name = null;
            this._resources = null;
            this._memorySize = 0;
            this._garbageCollectionRate = NaN;
            this._isOverflow = false;
            this.autoRelease = false;
            this.autoReleaseMaxSize = 0;
            this._id = ++ResourceManager._uniqueIDCounter;
            this._name = name ? name : "Content Manager";
            ResourceManager._isResourceManagersSorted = false;
            this._memorySize = 0;
            this._isOverflow = false;
            this.autoRelease = false;
            this.autoReleaseMaxSize = 1024 * 1024 * 512;
            this._garbageCollectionRate = 0.2;
            ResourceManager._resourceManagers.push(this);
            this._resources = [];
        }
        __class(ResourceManager, 'laya.resource.ResourceManager');
        var __proto = ResourceManager.prototype;
        Laya.imps(__proto, { "laya.resource.IDispose": true });
        __proto.getResourceByIndex = function (index) {
            return this._resources[index];
        };
        __proto.getResourcesLength = function () {
            return this._resources.length;
        };
        __proto.addResource = function (resource) {
            if (resource.resourceManager)
                resource.resourceManager.removeResource(resource);
            var index = this._resources.indexOf(resource);
            if (index === -1) {
                resource._resourceManager = this;
                this._resources.push(resource);
                this.addSize(resource.memorySize);
                return true;
            }
            return false;
        };
        __proto.removeResource = function (resource) {
            var index = this._resources.indexOf(resource);
            if (index !== -1) {
                this._resources.splice(index, 1);
                resource._resourceManager = null;
                this._memorySize -= resource.memorySize;
                return true;
            }
            return false;
        };
        __proto.unload = function () {
            var tempResources = this._resources.slice(0, this._resources.length);
            for (var i = 0; i < tempResources.length; i++) {
                var resource = tempResources[i];
                resource.destroy();
            }
            tempResources.length = 0;
        };
        __proto.dispose = function () {
            if (this === ResourceManager._systemResourceManager)
                throw new Error("systemResourceManager不能被释放！");
            ResourceManager._resourceManagers.splice(ResourceManager._resourceManagers.indexOf(this), 1);
            ResourceManager._isResourceManagersSorted = false;
            var tempResources = this._resources.slice(0, this._resources.length);
            for (var i = 0; i < tempResources.length; i++) {
                var resource = tempResources[i];
                resource.resourceManager.removeResource(resource);
                resource.destroy();
            }
            tempResources.length = 0;
        };
        __proto.addSize = function (add) {
            if (add) {
                if (this.autoRelease && add > 0)
                    ((this._memorySize + add) > this.autoReleaseMaxSize) && (this.garbageCollection((1 - this._garbageCollectionRate) * this.autoReleaseMaxSize));
                this._memorySize += add;
            }
        };
        __proto.garbageCollection = function (reserveSize) {
            var all = this._resources;
            all = all.slice();
            all.sort(function (a, b) {
                if (!a || !b)
                    throw new Error("a或b不能为空！");
                if (a.released && b.released)
                    return 0;
                else if (a.released)
                    return 1;
                else if (b.released)
                    return -1;
                return a._lastUseFrameCount - b._lastUseFrameCount;
            });
            var currentFrameCount = Stat.loopCount;
            for (var i = 0, n = all.length; i < n; i++) {
                var resou = all[i];
                if (currentFrameCount - resou._lastUseFrameCount > 1) {
                    resou.releaseResource();
                }
                else {
                    if (this._memorySize >= reserveSize)
                        this._isOverflow = true;
                    return;
                }
                if (this._memorySize < reserveSize) {
                    this._isOverflow = false;
                    return;
                }
            }
        };
        __getset(0, __proto, 'id', function () {
            return this._id;
        });
        __getset(0, __proto, 'name', function () {
            return this._name;
        }, function (value) {
            if ((value || value !== "") && this._name !== value) {
                this._name = value;
                ResourceManager._isResourceManagersSorted = false;
            }
        });
        __getset(0, __proto, 'memorySize', function () {
            return this._memorySize;
        });
        __getset(1, ResourceManager, 'systemResourceManager', function () {
            return ResourceManager._systemResourceManager;
        });
        ResourceManager.__init__ = function () {
            ResourceManager.currentResourceManager = ResourceManager.systemResourceManager;
        };
        ResourceManager.getLoadedResourceManagerByIndex = function (index) {
            return ResourceManager._resourceManagers[index];
        };
        ResourceManager.getLoadedResourceManagersCount = function () {
            return ResourceManager._resourceManagers.length;
        };
        ResourceManager.recreateContentManagers = function (force) {
            (force === void 0) && (force = false);
            var temp = ResourceManager.currentResourceManager;
            for (var i = 0; i < ResourceManager._resourceManagers.length; i++) {
                ResourceManager.currentResourceManager = ResourceManager._resourceManagers[i];
                for (var j = 0; j < ResourceManager.currentResourceManager._resources.length; j++) {
                    ResourceManager.currentResourceManager._resources[j].releaseResource(force);
                    ResourceManager.currentResourceManager._resources[j].activeResource(force);
                }
            }
            ResourceManager.currentResourceManager = temp;
        };
        ResourceManager.releaseContentManagers = function (force) {
            (force === void 0) && (force = false);
            var temp = ResourceManager.currentResourceManager;
            for (var i = 0; i < ResourceManager._resourceManagers.length; i++) {
                ResourceManager.currentResourceManager = ResourceManager._resourceManagers[i];
                for (var j = 0; j < ResourceManager.currentResourceManager._resources.length; j++) {
                    var resource = ResourceManager.currentResourceManager._resources[j];
                    (!resource.released) && (resource.releaseResource(force));
                }
            }
            ResourceManager.currentResourceManager = temp;
        };
        ResourceManager._uniqueIDCounter = 0;
        ResourceManager._isResourceManagersSorted = false;
        ResourceManager._resourceManagers = [];
        __static(ResourceManager, ['_systemResourceManager', function () { return this._systemResourceManager = new ResourceManager("System Resource Manager"); }, 'currentResourceManager', function () { return this.currentResourceManager = ResourceManager._systemResourceManager; }
        ]);
        return ResourceManager;
    })();
    var System = (function () {
        function System() { }
        __class(System, 'laya.system.System');
        System.changeDefinition = function (name, classObj) {
            Laya[name] = classObj;
            var str = name + "=classObj";
            eval(str);
        };
        System.__init__ = function () {
            if (Render.isConchApp) {
                conch.disableConchResManager();
                conch.disableConchAutoRestoreLostedDevice();
            }
        };
        return System;
    })();
    SoundManager;
    var Browser = (function () {
        function Browser() { }
        __class(Browser, 'laya.utils.Browser');
        __getset(1, Browser, 'pixelRatio', function () {
            Browser.__init__();
            if (Browser.userAgent.indexOf("Mozilla/6.0(Linux; Android 6.0; HUAWEI NXT-AL10 Build/HUAWEINXT-AL10)") > -1)
                return 2;
            return RunDriver.getPixelRatio();
        });
        __getset(1, Browser, 'height', function () {
            Browser.__init__();
            return ((Laya.stage && Laya.stage.canvasRotation) ? Browser.clientWidth : Browser.clientHeight) * Browser.pixelRatio;
        });
        __getset(1, Browser, 'clientWidth', function () {
            Browser.__init__();
            return Browser.window.innerWidth || Browser.document.body.clientWidth;
        });
        __getset(1, Browser, 'window', function () {
            Browser.__init__();
            return Browser._window;
        });
        __getset(1, Browser, 'clientHeight', function () {
            Browser.__init__();
            return Browser.window.innerHeight || Browser.document.body.clientHeight || Browser.document.documentElement.clientHeight;
        });
        __getset(1, Browser, 'width', function () {
            Browser.__init__();
            return ((Laya.stage && Laya.stage.canvasRotation) ? Browser.clientHeight : Browser.clientWidth) * Browser.pixelRatio;
        });
        __getset(1, Browser, 'container', function () {
            Browser.__init__();
            if (!Browser._container) {
                Browser._container = Browser.createElement("div");
                Browser._container.id = "the3Container";
                Browser.document.body.appendChild(Browser._container);
            }
            return Browser._container;
        }, function (value) {
            Browser._container = value;
        });
        __getset(1, Browser, 'document', function () {
            Browser.__init__();
            return Browser._document;
        });
        Browser.__init__ = function () {
            SoundManager;
            if (Browser._window)
                return;
            Browser._window = RunDriver.getWindow();
            Browser._document = Browser.window.document;
            window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (c) { return window.setTimeout(c, 1000 / 60); };
            Browser._window.addEventListener('message', function (e) {
                laya.utils.Browser._onMessage(e);
            }, false);
            Browser.document.__createElement = Browser.document.createElement;
            Browser.userAgent = Browser.window.navigator.userAgent;
            Browser.u = Browser.userAgent;
            Browser.onIOS = !!Browser.u.match(/\(i[^;]+;(U;)? CPU.+Mac OS X/);
            Browser.onMobile = Browser.u.indexOf("Mobile") > -1;
            Browser.onIPhone = Browser.u.indexOf("iPhone") > -1;
            Browser.onMac = Browser.u.indexOf("Mac OS X") > -1;
            Browser.onIPad = Browser.u.indexOf("iPad") > -1;
            Browser.onAndriod = Browser.u.indexOf('Android') > -1 || Browser.u.indexOf('Adr') > -1;
            Browser.onWP = Browser.u.indexOf("Windows Phone") > -1;
            Browser.onQQBrowser = Browser.u.indexOf("QQBrowser") > -1;
            Browser.onMQQBrowser = Browser.u.indexOf("MQQBrowser") > -1 || (Browser.u.indexOf("Mobile") > -1 && Browser.u.indexOf("QQ") > -1);
            Browser.onIE = !!Browser.window.ActiveXObject || "ActiveXObject" in Browser.window;
            Browser.onWeiXin = Browser.u.indexOf('MicroMessenger') > -1;
            Browser.onPC = !Browser.onMobile;
            Browser.onSafari = !!Browser.u.match(/Version\/\d+\.\d\x20Mobile\/\S+\x20Safari/);
            Browser.onFirefox = Browser.u.indexOf('Firefox') > -1;
            Browser.onEdge = Browser.u.indexOf('Edge') > -1;
            Browser.onMiniGame = Browser.u.indexOf('MiniGame') > -1;
            Browser.onLimixiu = Browser.u.indexOf('limixiu') > -1;
            Browser.httpProtocol = Browser.window.location.protocol == "http:";
            if (Browser.onMiniGame && Browser.window.focus == null) {
                console_error("请先初始化小游戏适配库，详细教程https://ldc.the3box.com/doc/?nav=zh-ts-5-0-0");
            }
            Browser.webAudioEnabled = Browser.window["AudioContext"] || Browser.window["webkitAudioContext"] || Browser.window["mozAudioContext"] ? true : false;
            Browser.soundType = Browser.webAudioEnabled ? "WEBAUDIOSOUND" : "AUDIOSOUND";
            Sound = Browser.webAudioEnabled ? WebAudioSound : AudioSound;
            ;
            if (Browser.webAudioEnabled)
                WebAudioSound.initWebAudio();
            ;
            AudioSound._initMusicAudio();
            Browser.enableTouch = (('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch);
            window.focus();
            SoundManager._soundClass = Sound;
            ;
            Render._mainCanvas = Render._mainCanvas || HTMLCanvas.create('2D');
            if (Browser.canvas)
                return;
            Browser.canvas = HTMLCanvas.create('2D');
            Browser.context = Browser.canvas.getContext('2d');
            Browser.document.body.style.overflow = "hidden";
        };
        Browser._onMessage = function (e) {
            if (!e.data)
                return;
            if (e.data.name == "size") {
                Browser.window.innerWidth = e.data.width;
                Browser.window.innerHeight = e.data.height;
                Browser.window.__innerHeight = e.data.clientHeight;
                if (!Browser.document.createEvent) {
                    console_warn("no document.createEvent");
                    return;
                }
                ;
                var evt = Browser.document.createEvent("HTMLEvents");
                evt.initEvent("resize", false, false);
                Browser.window.dispatchEvent(evt);
                return;
            }
        };
        Browser.createElement = function (type) {
            Browser.__init__();
            return Browser.document.__createElement(type);
        };
        Browser.getElementById = function (type) {
            Browser.__init__();
            return Browser.document.getElementById(type);
        };
        Browser.removeElement = function (ele) {
            if (ele && ele.parentNode)
                ele.parentNode.removeChild(ele);
        };
        Browser.now = function () {
            return RunDriver.now();
        };
        Browser._window = null;
        Browser._document = null;
        Browser._container = null;
        Browser.userAgent = null;
        Browser.u = null;
        Browser.onIOS = false;
        Browser.onMac = false;
        Browser.onMobile = false;
        Browser.onIPhone = false;
        Browser.onIPad = false;
        Browser.onAndriod = false;
        Browser.onAndroid = false;
        Browser.onWP = false;
        Browser.onQQBrowser = false;
        Browser.onMQQBrowser = false;
        Browser.onSafari = false;
        Browser.onFirefox = false;
        Browser.onEdge = false;
        Browser.onIE = false;
        Browser.onWeiXin = false;
        Browser.onMiniGame = false;
        Browser.onLimixiu = false;
        Browser.onPC = false;
        Browser.httpProtocol = false;
        Browser.webAudioEnabled = false;
        Browser.soundType = null;
        Browser.enableTouch = false;
        Browser.canvas = null;
        Browser.context = null;
        Browser.__init$ = function () {
            AudioSound;
            WebAudioSound;
        };
        return Browser;
    })();
    var Byte = (function () {
        function Byte(data) {
            this._xd_ = true;
            this._allocated_ = 8;
            this._pos_ = 0;
            this._length = 0;
            if (data) {
                this._u8d_ = new Uint8Array(data);
                this._d_ = new DataView(this._u8d_.buffer);
                this._length = this._d_.byteLength;
            }
            else {
                this.___resizeBuffer(this._allocated_);
            }
        }
        __class(Byte, 'laya.utils.Byte');
        var __proto = Byte.prototype;
        __proto.___resizeBuffer = function (len) {
            try {
                var newByteView = new Uint8Array(len);
                if (this._u8d_ != null) {
                    if (this._u8d_.length <= len)
                        newByteView.set(this._u8d_);
                    else
                        newByteView.set(this._u8d_.subarray(0, len));
                }
                this._u8d_ = newByteView;
                this._d_ = new DataView(newByteView.buffer);
            }
            catch (err) {
                throw "___resizeBuffer err:" + len;
            }
        };
        __proto.getString = function () {
            return this.rUTF(this.getUint16());
        };
        __proto.getFloat32Array = function (start, len) {
            var end = start + len;
            end = (end > this._length) ? this._length : end;
            var v = new Float32Array(this._d_.buffer.slice(start, end));
            this._pos_ = end;
            return v;
        };
        __proto.getUint8Array = function (start, len) {
            var end = start + len;
            end = (end > this._length) ? this._length : end;
            var v = new Uint8Array(this._d_.buffer.slice(start, end));
            this._pos_ = end;
            return v;
        };
        __proto.getInt16Array = function (start, len) {
            var end = start + len;
            end = (end > this._length) ? this._length : end;
            var v = new Int16Array(this._d_.buffer.slice(start, end));
            this._pos_ = end;
            return v;
        };
        __proto.getFloat32 = function () {
            if (this._pos_ + 4 > this._length)
                throw "getFloat32 error - Out of bounds";
            var v = this._d_.getFloat32(this._pos_, this._xd_);
            this._pos_ += 4;
            return v;
        };
        __proto.getFloat64 = function () {
            if (this._pos_ + 8 > this._length)
                throw "getFloat64 error - Out of bounds";
            var v = this._d_.getFloat64(this._pos_, this._xd_);
            this._pos_ += 8;
            return v;
        };
        __proto.writeFloat32 = function (value) {
            this.ensureWrite(this._pos_ + 4);
            this._d_.setFloat32(this._pos_, value, this._xd_);
            this._pos_ += 4;
        };
        __proto.writeFloat64 = function (value) {
            this.ensureWrite(this._pos_ + 8);
            this._d_.setFloat64(this._pos_, value, this._xd_);
            this._pos_ += 8;
        };
        __proto.getInt32 = function () {
            if (this._pos_ + 4 > this._length)
                throw "getInt32 error - Out of bounds";
            var float = this._d_.getInt32(this._pos_, this._xd_);
            this._pos_ += 4;
            return float;
        };
        __proto.getUint32 = function () {
            if (this._pos_ + 4 > this._length)
                throw "getUint32 error - Out of bounds";
            var v = this._d_.getUint32(this._pos_, this._xd_);
            this._pos_ += 4;
            return v;
        };
        __proto.writeInt32 = function (value) {
            this.ensureWrite(this._pos_ + 4);
            this._d_.setInt32(this._pos_, value, this._xd_);
            this._pos_ += 4;
        };
        __proto.writeUint32 = function (value) {
            this.ensureWrite(this._pos_ + 4);
            this._d_.setUint32(this._pos_, value, this._xd_);
            this._pos_ += 4;
        };
        __proto.getInt16 = function () {
            if (this._pos_ + 2 > this._length)
                throw "getInt16 error - Out of bounds";
            var us = this._d_.getInt16(this._pos_, this._xd_);
            this._pos_ += 2;
            return us;
        };
        __proto.getUint16 = function () {
            if (this._pos_ + 2 > this._length)
                throw "getUint16 error - Out of bounds";
            var us = this._d_.getUint16(this._pos_, this._xd_);
            this._pos_ += 2;
            return us;
        };
        __proto.writeUint16 = function (value) {
            this.ensureWrite(this._pos_ + 2);
            this._d_.setUint16(this._pos_, value, this._xd_);
            this._pos_ += 2;
        };
        __proto.writeInt16 = function (value) {
            this.ensureWrite(this._pos_ + 2);
            this._d_.setInt16(this._pos_, value, this._xd_);
            this._pos_ += 2;
        };
        __proto.getUint8 = function () {
            if (this._pos_ + 1 > this._length)
                throw "getUint8 error - Out of bounds";
            return this._d_.getUint8(this._pos_++);
        };
        __proto.writeUint8 = function (value) {
            this.ensureWrite(this._pos_ + 1);
            this._d_.setUint8(this._pos_, value);
            this._pos_++;
        };
        __proto._getUInt8 = function (pos) {
            return this._d_.getUint8(pos);
        };
        __proto._getUint16 = function (pos) {
            return this._d_.getUint16(pos, this._xd_);
        };
        __proto._getMatrix = function () {
            var rst = new Matrix(this.getFloat32(), this.getFloat32(), this.getFloat32(), this.getFloat32(), this.getFloat32(), this.getFloat32());
            return rst;
        };
        __proto.rUTF = function (len) {
            var v = "", max = this._pos_ + len, c = 0, c2 = 0, c3 = 0, f = String.fromCharCode;
            var u = this._u8d_, i = 0;
            while (this._pos_ < max) {
                c = u[this._pos_++];
                if (c < 0x80) {
                    if (c != 0) {
                        v += f(c);
                    }
                }
                else if (c < 0xE0) {
                    v += f(((c & 0x3F) << 6) | (u[this._pos_++] & 0x7F));
                }
                else if (c < 0xF0) {
                    c2 = u[this._pos_++];
                    v += f(((c & 0x1F) << 12) | ((c2 & 0x7F) << 6) | (u[this._pos_++] & 0x7F));
                }
                else {
                    c2 = u[this._pos_++];
                    c3 = u[this._pos_++];
                    v += f(((c & 0x0F) << 18) | ((c2 & 0x7F) << 12) | ((c3 << 6) & 0x7F) | (u[this._pos_++] & 0x7F));
                }
                i++;
            }
            return v;
        };
        __proto.getCustomString = function (len) {
            var v = "", ulen = 0, c = 0, c2 = 0, f = String.fromCharCode;
            var u = this._u8d_, i = 0;
            while (len > 0) {
                c = u[this._pos_];
                if (c < 0x80) {
                    v += f(c);
                    this._pos_++;
                    len--;
                }
                else {
                    ulen = c - 0x80;
                    this._pos_++;
                    len -= ulen;
                    while (ulen > 0) {
                        c = u[this._pos_++];
                        c2 = u[this._pos_++];
                        v += f((c2 << 8) | c);
                        ulen--;
                    }
                }
            }
            return v;
        };
        __proto.clear = function () {
            this._pos_ = 0;
            this.length = 0;
        };
        __proto.__getBuffer = function () {
            return this._d_.buffer;
        };
        __proto.writeUTFBytes = function (value) {
            value = value + "";
            for (var i = 0, sz = value.length; i < sz; i++) {
                var c = value.charCodeAt(i);
                if (c <= 0x7F) {
                    this.writeByte(c);
                }
                else if (c <= 0x7FF) {
                    this.ensureWrite(this._pos_ + 2);
                    this._u8d_.set([0xC0 | (c >> 6), 0x80 | (c & 0x3F)], this._pos_);
                    this._pos_ += 2;
                }
                else if (c <= 0xFFFF) {
                    this.ensureWrite(this._pos_ + 3);
                    this._u8d_.set([0xE0 | (c >> 12), 0x80 | ((c >> 6) & 0x3F), 0x80 | (c & 0x3F)], this._pos_);
                    this._pos_ += 3;
                }
                else {
                    this.ensureWrite(this._pos_ + 4);
                    this._u8d_.set([0xF0 | (c >> 18), 0x80 | ((c >> 12) & 0x3F), 0x80 | ((c >> 6) & 0x3F), 0x80 | (c & 0x3F)], this._pos_);
                    this._pos_ += 4;
                }
            }
        };
        __proto.writeUTFString = function (value) {
            var tPos = this.pos;
            this.writeUint16(1);
            this.writeUTFBytes(value);
            var dPos = this.pos - tPos - 2;
            if (dPos >= 65536) {
                throw "writeUTFString byte len more than 65536";
            }
            this._d_.setUint16(tPos, dPos, this._xd_);
        };
        __proto.readUTFString = function () {
            return this.readUTFBytes(this.getUint16());
        };
        __proto.getUTFString = function () {
            return this.readUTFString();
        };
        __proto.readUTFBytes = function (len) {
            (len === void 0) && (len = -1);
            if (len == 0)
                return "";
            var lastBytes = this.bytesAvailable;
            if (len > lastBytes)
                throw "readUTFBytes error - Out of bounds";
            len = len > 0 ? len : lastBytes;
            return this.rUTF(len);
        };
        __proto.getUTFBytes = function (len) {
            (len === void 0) && (len = -1);
            return this.readUTFBytes(len);
        };
        __proto.writeByte = function (value) {
            this.ensureWrite(this._pos_ + 1);
            this._d_.setInt8(this._pos_, value);
            this._pos_ += 1;
        };
        __proto.readByte = function () {
            if (this._pos_ + 1 > this._length)
                throw "readByte error - Out of bounds";
            return this._d_.getInt8(this._pos_++);
        };
        __proto.getByte = function () {
            return this.readByte();
        };
        __proto.ensureWrite = function (lengthToEnsure) {
            if (this._length < lengthToEnsure)
                this._length = lengthToEnsure;
            if (this._allocated_ < lengthToEnsure)
                this.length = lengthToEnsure;
        };
        __proto.writeArrayBuffer = function (arraybuffer, offset, length) {
            (offset === void 0) && (offset = 0);
            (length === void 0) && (length = 0);
            if (offset < 0 || length < 0)
                throw "writeArrayBuffer error - Out of bounds";
            if (length == 0)
                length = arraybuffer.byteLength - offset;
            this.ensureWrite(this._pos_ + length);
            var uint8array = new Uint8Array(arraybuffer);
            this._u8d_.set(uint8array.subarray(offset, offset + length), this._pos_);
            this._pos_ += length;
        };
        __getset(0, __proto, 'buffer', function () {
            var rstBuffer = this._d_.buffer;
            if (rstBuffer.byteLength == this.length)
                return rstBuffer;
            return rstBuffer.slice(0, this.length);
        });
        __getset(0, __proto, 'endian', function () {
            return this._xd_ ? "littleEndian" : "bigEndian";
        }, function (endianStr) {
            this._xd_ = (endianStr == "littleEndian");
        });
        __getset(0, __proto, 'length', function () {
            return this._length;
        }, function (value) {
            if (this._allocated_ < value)
                this.___resizeBuffer(this._allocated_ = Math.floor(Math.max(value, this._allocated_ * 2)));
            else if (this._allocated_ > value)
                this.___resizeBuffer(this._allocated_ = value);
            this._length = value;
        });
        __getset(0, __proto, 'pos', function () {
            return this._pos_;
        }, function (value) {
            this._pos_ = value;
        });
        __getset(0, __proto, 'bytesAvailable', function () {
            return this._length - this._pos_;
        });
        Byte.getSystemEndian = function () {
            if (!Byte._sysEndian) {
                var buffer = new ArrayBuffer(2);
                new DataView(buffer).setInt16(0, 256, true);
                Byte._sysEndian = (new Int16Array(buffer))[0] === 256 ? "littleEndian" : "bigEndian";
            }
            return Byte._sysEndian;
        };
        Byte.BIG_ENDIAN = "bigEndian";
        Byte.LITTLE_ENDIAN = "littleEndian";
        Byte._sysEndian = null;
        return Byte;
    })();
    var CacheManager = (function () {
        function CacheManager() { }
        __class(CacheManager, 'laya.utils.CacheManager');
        CacheManager.regCacheByFunction = function (disposeFunction, getCacheListFunction) {
            CacheManager.unRegCacheByFunction(disposeFunction, getCacheListFunction);
            var cache;
            cache = { tryDispose: disposeFunction, getCacheList: getCacheListFunction };
            CacheManager._cacheList.push(cache);
        };
        CacheManager.unRegCacheByFunction = function (disposeFunction, getCacheListFunction) {
            var i = 0, len = 0;
            len = CacheManager._cacheList.length;
            for (i = 0; i < len; i++) {
                if (CacheManager._cacheList[i].tryDispose == disposeFunction && CacheManager._cacheList[i].getCacheList == getCacheListFunction) {
                    CacheManager._cacheList.splice(i, 1);
                    return;
                }
            }
        };
        CacheManager.forceDispose = function () {
            var i = 0, len = CacheManager._cacheList.length;
            for (i = 0; i < len; i++) {
                CacheManager._cacheList[i].tryDispose(true);
            }
        };
        CacheManager.beginCheck = function (waitTime) {
            (waitTime === void 0) && (waitTime = 15000);
            Laya.timer.loop(waitTime, null, CacheManager._checkLoop);
        };
        CacheManager.stopCheck = function () {
            Laya.timer.clear(null, CacheManager._checkLoop);
        };
        CacheManager._checkLoop = function () {
            var cacheList = CacheManager._cacheList;
            if (cacheList.length < 1)
                return;
            var tTime = Browser.now();
            var count = 0;
            var len = 0;
            len = count = cacheList.length;
            while (count > 0) {
                CacheManager._index++;
                CacheManager._index = CacheManager._index % len;
                cacheList[CacheManager._index].tryDispose(false);
                if (Browser.now() - tTime > CacheManager.loopTimeLimit)
                    break;
                count--;
            }
        };
        CacheManager.loopTimeLimit = 2;
        CacheManager._cacheList = [];
        CacheManager._index = 0;
        return CacheManager;
    })();
    var ClassUtils = (function () {
        function ClassUtils() { }
        __class(ClassUtils, 'laya.utils.ClassUtils');
        ClassUtils.regClass = function (className, classDef) {
            ClassUtils._classMap[className] = classDef;
        };
        ClassUtils.getRegClass = function (className) {
            return ClassUtils._classMap[className];
        };
        ClassUtils.getInstance = function (className) {
            var compClass = ClassUtils.getClass(className);
            if (compClass)
                return new compClass();
            else
                console_warn("[error] Undefined class:", className);
            return null;
        };
        ClassUtils.createByJson = function (json, node, root, customHandler, instanceHandler) {
            if ((typeof json == 'string'))
                json = JSON.parse(json);
            var props = json.props;
            if (!node) {
                node = instanceHandler ? instanceHandler.runWith(json) : ClassUtils.getInstance(props.runtime || json.type);
                if (!node)
                    return null;
            }
            ;
            var child = json.child;
            if (child) {
                for (var i = 0, n = child.length; i < n; i++) {
                    var data = child[i];
                    if ((data.props.name === "render" || data.props.renderType === "render") && node["_$set_itemRender"])
                        node.itemRender = data;
                    else {
                        if (data.type == "Graphic") {
                            ClassUtils.addGraphicsToSprite(data, node);
                        }
                        else if (ClassUtils.isDrawType(data.type)) {
                            ClassUtils.addGraphicToSprite(data, node, true);
                        }
                        else {
                            var tChild = ClassUtils.createByJson(data, null, root, customHandler, instanceHandler);
                            if (data.type == "Script") {
                                if (tChild.hasOwnProperty("owner")) {
                                    tChild["owner"] = node;
                                }
                                else if (tChild.hasOwnProperty("target")) {
                                    tChild["target"] = node;
                                }
                            }
                            else if (data.props.renderType == "mask") {
                                node.mask = tChild;
                            }
                            else {
                                node.addChild(tChild);
                            }
                        }
                    }
                }
            }
            if (props) {
                for (var prop in props) {
                    var value = props[prop];
                    if (prop === "var" && root) {
                        root[value] = node;
                    }
                    else if ((value instanceof Array) && (typeof (node[prop]) == 'function')) {
                        node[prop].apply(node, value);
                    }
                    else {
                        node[prop] = value;
                    }
                }
            }
            if (customHandler && json.customProps) {
                customHandler.runWith([node, json]);
            }
            if (node["created"])
                node.created();
            return node;
        };
        ClassUtils.addGraphicsToSprite = function (graphicO, sprite) {
            var graphics;
            graphics = graphicO.child;
            if (!graphics || graphics.length < 1)
                return;
            var g;
            g = ClassUtils._getGraphicsFromSprite(graphicO, sprite);
            var ox = 0;
            var oy = 0;
            if (graphicO.props) {
                ox = ClassUtils._getObjVar(graphicO.props, "x", 0);
                oy = ClassUtils._getObjVar(graphicO.props, "y", 0);
            }
            if (ox != 0 && oy != 0) {
                g.translate(ox, oy);
            }
            ;
            var i = 0, len = 0;
            len = graphics.length;
            for (i = 0; i < len; i++) {
                ClassUtils._addGraphicToGraphics(graphics[i], g);
            }
            if (ox != 0 && oy != 0) {
                g.translate(-ox, -oy);
            }
        };
        ClassUtils.addGraphicToSprite = function (graphicO, sprite, isChild) {
            (isChild === void 0) && (isChild = false);
            var g;
            g = isChild ? ClassUtils._getGraphicsFromSprite(graphicO, sprite) : sprite.graphics;
            ClassUtils._addGraphicToGraphics(graphicO, g);
        };
        ClassUtils._getGraphicsFromSprite = function (dataO, sprite) {
            var g;
            if (!dataO || !dataO.props)
                return sprite.graphics;
            var propsName;
            propsName = dataO.props.renderType;
            switch (propsName) {
                case "hit":
                case "unHit":
                    ;
                    var hitArea;
                    if (!sprite.hitArea) {
                        sprite.hitArea = new HitArea();
                    }
                    hitArea = sprite.hitArea;
                    if (!hitArea[propsName]) {
                        hitArea[propsName] = new Graphics();
                    }
                    g = hitArea[propsName];
                    break;
                default:
            }
            if (!g)
                g = sprite.graphics;
            return g;
        };
        ClassUtils._getTransformData = function (propsO) {
            var m;
            if (propsO.hasOwnProperty("pivotX") || propsO.hasOwnProperty("pivotY")) {
                m = m || new Matrix();
                m.translate(-ClassUtils._getObjVar(propsO, "pivotX", 0), -ClassUtils._getObjVar(propsO, "pivotY", 0));
            }
            ;
            var sx = ClassUtils._getObjVar(propsO, "scaleX", 1), sy = ClassUtils._getObjVar(propsO, "scaleY", 1);
            var rotate = ClassUtils._getObjVar(propsO, "rotation", 0);
            var skewX = ClassUtils._getObjVar(propsO, "skewX", 0);
            var skewY = ClassUtils._getObjVar(propsO, "skewY", 0);
            if (sx != 1 || sy != 1 || rotate != 0) {
                m = m || new Matrix();
                m.scale(sx, sy);
                m.rotate(rotate * 0.0174532922222222);
            }
            return m;
        };
        ClassUtils._addGraphicToGraphics = function (graphicO, graphic) {
            var propsO;
            propsO = graphicO.props;
            if (!propsO)
                return;
            var drawConfig;
            drawConfig = ClassUtils.DrawTypeDic[graphicO.type];
            if (!drawConfig)
                return;
            var g;
            g = graphic;
            var m;
            var params = ClassUtils._getParams(propsO, drawConfig[1], drawConfig[2], drawConfig[3]);
            m = ClassUtils._tM;
            if (m || ClassUtils._alpha != 1) {
                g.save();
                if (m)
                    g.transform(m);
                if (ClassUtils._alpha != 1)
                    g.alpha(ClassUtils._alpha);
            }
            g[drawConfig[0]].apply(g, params);
            if (m || ClassUtils._alpha != 1) {
                g.restore();
            }
        };
        ClassUtils._adptLineData = function (params) {
            params[2] = parseFloat(params[0]) + parseFloat(params[2]);
            params[3] = parseFloat(params[1]) + parseFloat(params[3]);
            return params;
        };
        ClassUtils._adptTextureData = function (params) {
            params[0] = Loader.getRes(params[0]);
            return params;
        };
        ClassUtils._adptLinesData = function (params) {
            params[2] = ClassUtils._getPointListByStr(params[2]);
            return params;
        };
        ClassUtils.isDrawType = function (type) {
            if (type == "Image")
                return false;
            return ClassUtils.DrawTypeDic.hasOwnProperty(type);
        };
        ClassUtils._getParams = function (obj, params, xPos, adptFun) {
            (xPos === void 0) && (xPos = 0);
            var rst;
            rst = ClassUtils._temParam;
            rst.length = params.length;
            var i = 0, len = 0;
            len = params.length;
            for (i = 0; i < len; i++) {
                rst[i] = ClassUtils._getObjVar(obj, params[i][0], params[i][1]);
            }
            ClassUtils._alpha = ClassUtils._getObjVar(obj, "alpha", 1);
            var m;
            m = ClassUtils._getTransformData(obj);
            if (m) {
                if (!xPos)
                    xPos = 0;
                m.translate(rst[xPos], rst[xPos + 1]);
                rst[xPos] = rst[xPos + 1] = 0;
                ClassUtils._tM = m;
            }
            else {
                ClassUtils._tM = null;
            }
            if (adptFun && ClassUtils[adptFun]) {
                rst = ClassUtils[adptFun](rst);
            }
            return rst;
        };
        ClassUtils._getPointListByStr = function (str) {
            var pointArr;
            pointArr = str.split(",");
            var i = 0, len = 0;
            len = pointArr.length;
            for (i = 0; i < len; i++) {
                pointArr[i] = parseFloat(pointArr[i]);
            }
            return pointArr;
        };
        ClassUtils._getObjVar = function (obj, key, noValue) {
            if (obj.hasOwnProperty(key)) {
                return obj[key];
            }
            return noValue;
        };
        ClassUtils._temParam = [];
        ClassUtils._classMap = { 'Sprite': 'laya.display.Sprite', 'Text': 'laya.display.Text', 'Animation': 'laya.display.Animation', 'Skeleton': 'laya.ani.bone.Skeleton', 'Particle2D': 'laya.particle.Particle2D', 'div': 'laya.html.dom.HTMLDivElement', 'p': 'laya.html.dom.HTMLElement', 'img': 'laya.html.dom.HTMLImageElement', 'span': 'laya.html.dom.HTMLElement', 'br': 'laya.html.dom.HTMLBrElement', 'style': 'laya.html.dom.HTMLStyleElement', 'font': 'laya.html.dom.HTMLElement', 'a': 'laya.html.dom.HTMLElement', '#text': 'laya.html.dom.HTMLElement' };
        ClassUtils.getClass = function (className) {
            var classObject = ClassUtils._classMap[className] || className;
            if ((typeof classObject == 'string'))
                return Laya["__classmap"][classObject];
            return classObject;
        };
        ClassUtils._tM = null;
        ClassUtils._alpha = NaN;
        __static(ClassUtils, ['DrawTypeDic', function () { return this.DrawTypeDic = { "Rect": ["drawRect", [["x", 0], ["y", 0], ["width", 0], ["height", 0], ["fillColor", null], ["lineColor", null], ["lineWidth", 1]]], "Circle": ["drawCircle", [["x", 0], ["y", 0], ["radius", 0], ["fillColor", null], ["lineColor", null], ["lineWidth", 1]]], "Pie": ["drawPie", [["x", 0], ["y", 0], ["radius", 0], ["startAngle", 0], ["endAngle", 0], ["fillColor", null], ["lineColor", null], ["lineWidth", 1]]], "Image": ["drawTexture", [["x", 0], ["y", 0], ["width", 0], ["height", 0]]], "Texture": ["drawTexture", [["skin", null], ["x", 0], ["y", 0], ["width", 0], ["height", 0]], 1, "_adptTextureData"], "FillTexture": ["fillTexture", [["skin", null], ["x", 0], ["y", 0], ["width", 0], ["height", 0], ["repeat", null]], 1, "_adptTextureData"], "FillText": ["fillText", [["text", ""], ["x", 0], ["y", 0], ["font", null], ["color", null], ["textAlign", null]], 1], "Line": ["drawLine", [["x", 0], ["y", 0], ["toX", 0], ["toY", 0], ["lineColor", null], ["lineWidth", 0]], 0, "_adptLineData"], "Lines": ["drawLines", [["x", 0], ["y", 0], ["points", ""], ["lineColor", null], ["lineWidth", 0]], 0, "_adptLinesData"], "Curves": ["drawCurves", [["x", 0], ["y", 0], ["points", ""], ["lineColor", null], ["lineWidth", 0]], 0, "_adptLinesData"], "Poly": ["drawPoly", [["x", 0], ["y", 0], ["points", ""], ["fillColor", null], ["lineColor", null], ["lineWidth", 1]], 0, "_adptLinesData"] }; }
        ]);
        return ClassUtils;
    })();
    var Color = (function () {
        function Color(str) {
            this._color = [];
            if ((typeof str == 'string')) {
                this.strColor = str;
                if (str === null)
                    str = "#000000";
                str.charAt(0) == '#' && (str = str.substr(1));
                var len = str.length;
                if (len == 3 || len == 4) {
                    var temp = "";
                    for (var i = 0; i < len; i++) {
                        temp += (str[i] + str[i]);
                    }
                    str = temp;
                }
                ;
                var color = this.numColor = parseInt(str, 16);
                var flag = (str.length == 8);
                if (flag) {
                    this._color = [parseInt(str.substr(0, 2), 16) / 255, ((0x00FF0000 & color) >> 16) / 255, ((0x0000FF00 & color) >> 8) / 255, (0x000000FF & color) / 255];
                    return;
                }
            }
            else {
                color = this.numColor = str;
                this.strColor = Utils.toHexColor(color);
            }
            this._color = [((0xFF0000 & color) >> 16) / 255, ((0xFF00 & color) >> 8) / 255, (0xFF & color) / 255, 1];
            (this._color).__id = ++Color._COLODID;
        }
        __class(Color, 'laya.utils.Color');
        Color._initDefault = function () {
            Color._DEFAULT = {};
            for (var i in Color._COLOR_MAP)
                Color._SAVE[i] = Color._DEFAULT[i] = new Color(Color._COLOR_MAP[i]);
            return Color._DEFAULT;
        };
        Color._initSaveMap = function () {
            Color._SAVE_SIZE = 0;
            Color._SAVE = {};
            for (var i in Color._DEFAULT)
                Color._SAVE[i] = Color._DEFAULT[i];
        };
        Color.create = function (str) {
            var color = Color._SAVE[str + ""];
            if (color != null)
                return color;
            (Color._SAVE_SIZE < 1000) || Color._initSaveMap();
            return Color._SAVE[str + ""] = new Color(str);
        };
        Color._SAVE = {};
        Color._SAVE_SIZE = 0;
        Color._COLOR_MAP = { "white": '#FFFFFF', "red": '#FF0000', "green": '#00FF00', "blue": '#0000FF', "black": '#000000', "yellow": '#FFFF00', 'gray': '#AAAAAA' };
        Color._DEFAULT = Color._initDefault();
        Color._COLODID = 1;
        return Color;
    })();
    var Dictionary = (function () {
        function Dictionary() {
            this._values = [];
            this._keys = [];
        }
        __class(Dictionary, 'laya.utils.Dictionary');
        var __proto = Dictionary.prototype;
        __proto.set = function (key, value) {
            var index = this.indexOf(key);
            if (index >= 0) {
                this._values[index] = value;
                return;
            }
            this._keys.push(key);
            this._values.push(value);
        };
        __proto.indexOf = function (key) {
            var index = this._keys.indexOf(key);
            if (index >= 0)
                return index;
            key = ((typeof key == 'string')) ? Number(key) : (((typeof key == 'number')) ? key.toString() : key);
            return this._keys.indexOf(key);
        };
        __proto.get = function (key) {
            var index = this.indexOf(key);
            return index < 0 ? null : this._values[index];
        };
        __proto.remove = function (key) {
            var index = this.indexOf(key);
            if (index >= 0) {
                this._keys.splice(index, 1);
                this._values.splice(index, 1);
                return true;
            }
            return false;
        };
        __proto.clear = function () {
            this._values.length = 0;
            this._keys.length = 0;
        };
        __getset(0, __proto, 'values', function () {
            return this._values;
        });
        __getset(0, __proto, 'keys', function () {
            return this._keys;
        });
        return Dictionary;
    })();
    var Dragging = (function () {
        function Dragging() {
            this.ratio = 0.92;
            this.maxOffset = 60;
            this._dragging = false;
            this._clickOnly = true;
        }
        __class(Dragging, 'laya.utils.Dragging');
        var __proto = Dragging.prototype;
        __proto.start = function (target, area, hasInertia, elasticDistance, elasticBackTime, data, disableMouseEvent, ratio) {
            (ratio === void 0) && (ratio = 0.92);
            this.clearTimer();
            this.target = target;
            this.area = area;
            this.hasInertia = hasInertia;
            this.elasticDistance = area ? elasticDistance : 0;
            this.elasticBackTime = elasticBackTime;
            this.data = data;
            this._disableMouseEvent = disableMouseEvent;
            this.ratio = ratio;
            if (target.globalScaleX != 1 || target.globalScaleY != 1) {
                this._parent = target.parent;
            }
            else {
                this._parent = Laya.stage;
            }
            this._clickOnly = true;
            this._dragging = true;
            this._elasticRateX = this._elasticRateY = 1;
            this._lastX = this._parent.mouseX;
            this._lastY = this._parent.mouseY;
            Laya.stage.on("mouseup", this, this.onStageMouseUp);
            Laya.stage.on("mouseout", this, this.onStageMouseUp);
            Laya.timer.frameLoop(1, this, this.loop);
        };
        __proto.clearTimer = function () {
            Laya.timer.clear(this, this.loop);
            Laya.timer.clear(this, this.tweenMove);
            if (this._tween) {
                this._tween.recover();
                this._tween = null;
            }
        };
        __proto.stop = function () {
            if (this._dragging) {
                MouseManager.instance.disableMouseEvent = false;
                Laya.stage.off("mouseup", this, this.onStageMouseUp);
                Laya.stage.off("mouseout", this, this.onStageMouseUp);
                this._dragging = false;
                this.target && this.area && this.backToArea();
                this.clear();
            }
        };
        __proto.loop = function () {
            var point = this._parent.getMousePoint();
            var mouseX = point.x;
            var mouseY = point.y;
            var offsetX = mouseX - this._lastX;
            var offsetY = mouseY - this._lastY;
            if (this._clickOnly) {
                if (Math.abs(offsetX * Laya.stage._canvasTransform.getScaleX()) > 1 || Math.abs(offsetY * Laya.stage._canvasTransform.getScaleY()) > 1) {
                    this._clickOnly = false;
                    this._offsets || (this._offsets = []);
                    this._offsets.length = 0;
                    this.target.event("dragstart", this.data);
                    MouseManager.instance.disableMouseEvent = this._disableMouseEvent;
                    this.target._set$P("$_MOUSEDOWN", false);
                }
                else
                    return;
            }
            else {
                this._offsets.push(offsetX, offsetY);
            }
            if (offsetX === 0 && offsetY === 0)
                return;
            this._lastX = mouseX;
            this._lastY = mouseY;
            this.target.x += offsetX * this._elasticRateX;
            this.target.y += offsetY * this._elasticRateY;
            this.area && this.checkArea();
            this.target.event("dragmove", this.data);
        };
        __proto.checkArea = function () {
            if (this.elasticDistance <= 0) {
                this.backToArea();
            }
            else {
                if (this.target.x < this.area.x) {
                    var offsetX = this.area.x - this.target.x;
                }
                else if (this.target.x > this.area.x + this.area.width) {
                    offsetX = this.target.x - this.area.x - this.area.width;
                }
                else {
                    offsetX = 0;
                }
                this._elasticRateX = Math.max(0, 1 - (offsetX / this.elasticDistance));
                if (this.target.y < this.area.y) {
                    var offsetY = this.area.y - this.target.y;
                }
                else if (this.target.y > this.area.y + this.area.height) {
                    offsetY = this.target.y - this.area.y - this.area.height;
                }
                else {
                    offsetY = 0;
                }
                this._elasticRateY = Math.max(0, 1 - (offsetY / this.elasticDistance));
            }
        };
        __proto.backToArea = function () {
            this.target.x = Math.min(Math.max(this.target.x, this.area.x), this.area.x + this.area.width);
            this.target.y = Math.min(Math.max(this.target.y, this.area.y), this.area.y + this.area.height);
        };
        __proto.onStageMouseUp = function (e) {
            MouseManager.instance.disableMouseEvent = false;
            Laya.stage.off("mouseup", this, this.onStageMouseUp);
            Laya.stage.off("mouseout", this, this.onStageMouseUp);
            Laya.timer.clear(this, this.loop);
            if (this._clickOnly || !this.target)
                return;
            if (this.hasInertia) {
                if (this._offsets.length < 1) {
                    this._offsets.push(this._parent.mouseX - this._lastX, this._parent.mouseY - this._lastY);
                }
                this._offsetX = this._offsetY = 0;
                var len = this._offsets.length;
                var n = Math.min(len, 6);
                var m = this._offsets.length - n;
                for (var i = len - 1; i > m; i--) {
                    this._offsetY += this._offsets[i--];
                    this._offsetX += this._offsets[i];
                }
                this._offsetX = this._offsetX / n * 2;
                this._offsetY = this._offsetY / n * 2;
                if (Math.abs(this._offsetX) > this.maxOffset)
                    this._offsetX = this._offsetX > 0 ? this.maxOffset : -this.maxOffset;
                if (Math.abs(this._offsetY) > this.maxOffset)
                    this._offsetY = this._offsetY > 0 ? this.maxOffset : -this.maxOffset;
                Laya.timer.frameLoop(1, this, this.tweenMove);
            }
            else if (this.elasticDistance > 0) {
                this.checkElastic();
            }
            else {
                this.clear();
            }
        };
        __proto.checkElastic = function () {
            var tx = NaN;
            var ty = NaN;
            if (this.target.x < this.area.x)
                tx = this.area.x;
            else if (this.target.x > this.area.x + this.area.width)
                tx = this.area.x + this.area.width;
            if (this.target.y < this.area.y)
                ty = this.area.y;
            else if (this.target.y > this.area.y + this.area.height)
                ty = this.area.y + this.area.height;
            if (!isNaN(tx) || !isNaN(ty)) {
                var obj = {};
                if (!isNaN(tx))
                    obj.x = tx;
                if (!isNaN(ty))
                    obj.y = ty;
                this._tween = Tween.to(this.target, obj, this.elasticBackTime, Ease.sineOut, Handler.create(this, this.clear), 0, false);
            }
            else {
                this.clear();
            }
        };
        __proto.tweenMove = function () {
            this._offsetX *= this.ratio * this._elasticRateX;
            this._offsetY *= this.ratio * this._elasticRateY;
            this.target.x += this._offsetX;
            this.target.y += this._offsetY;
            this.area && this.checkArea();
            this.target.event("dragmove", this.data);
            if ((Math.abs(this._offsetX) < 1 && Math.abs(this._offsetY) < 1) || this._elasticRateX < 0.5 || this._elasticRateY < 0.5) {
                Laya.timer.clear(this, this.tweenMove);
                if (this.elasticDistance > 0)
                    this.checkElastic();
                else
                    this.clear();
            }
        };
        __proto.clear = function () {
            if (this.target) {
                this.clearTimer();
                var sp = this.target;
                this.target = null;
                this._parent = null;
                sp.event("dragend", this.data);
            }
        };
        return Dragging;
    })();
    var Ease = (function () {
        function Ease() { }
        __class(Ease, 'laya.utils.Ease');
        Ease.linearNone = function (t, b, c, d) {
            return c * t / d + b;
        };
        Ease.linearIn = function (t, b, c, d) {
            return c * t / d + b;
        };
        Ease.linearInOut = function (t, b, c, d) {
            return c * t / d + b;
        };
        Ease.linearOut = function (t, b, c, d) {
            return c * t / d + b;
        };
        Ease.bounceIn = function (t, b, c, d) {
            return c - Ease.bounceOut(d - t, 0, c, d) + b;
        };
        Ease.bounceInOut = function (t, b, c, d) {
            if (t < d * 0.5)
                return Ease.bounceIn(t * 2, 0, c, d) * .5 + b;
            else
                return Ease.bounceOut(t * 2 - d, 0, c, d) * .5 + c * .5 + b;
        };
        Ease.bounceOut = function (t, b, c, d) {
            if ((t /= d) < (1 / 2.75))
                return c * (7.5625 * t * t) + b;
            else if (t < (2 / 2.75))
                return c * (7.5625 * (t -= (1.5 / 2.75)) * t + .75) + b;
            else if (t < (2.5 / 2.75))
                return c * (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) + b;
            else
                return c * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375) + b;
        };
        Ease.backIn = function (t, b, c, d, s) {
            (s === void 0) && (s = 1.70158);
            return c * (t /= d) * t * ((s + 1) * t - s) + b;
        };
        Ease.backInOut = function (t, b, c, d, s) {
            (s === void 0) && (s = 1.70158);
            if ((t /= d * 0.5) < 1)
                return c * 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
            return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
        };
        Ease.backOut = function (t, b, c, d, s) {
            (s === void 0) && (s = 1.70158);
            return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
        };
        Ease.elasticIn = function (t, b, c, d, a, p) {
            (a === void 0) && (a = 0);
            (p === void 0) && (p = 0);
            var s;
            if (t == 0)
                return b;
            if ((t /= d) == 1)
                return b + c;
            if (!p)
                p = d * .3;
            if (!a || (c > 0 && a < c) || (c < 0 && a < -c)) {
                a = c;
                s = p / 4;
            }
            else
                s = p / Ease.PI2 * Math.asin(c / a);
            return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * Ease.PI2 / p)) + b;
        };
        Ease.elasticInOut = function (t, b, c, d, a, p) {
            (a === void 0) && (a = 0);
            (p === void 0) && (p = 0);
            var s;
            if (t == 0)
                return b;
            if ((t /= d * 0.5) == 2)
                return b + c;
            if (!p)
                p = d * (.3 * 1.5);
            if (!a || (c > 0 && a < c) || (c < 0 && a < -c)) {
                a = c;
                s = p / 4;
            }
            else
                s = p / Ease.PI2 * Math.asin(c / a);
            if (t < 1)
                return -.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * Ease.PI2 / p)) + b;
            return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * Ease.PI2 / p) * .5 + c + b;
        };
        Ease.elasticOut = function (t, b, c, d, a, p) {
            (a === void 0) && (a = 0);
            (p === void 0) && (p = 0);
            var s;
            if (t == 0)
                return b;
            if ((t /= d) == 1)
                return b + c;
            if (!p)
                p = d * .3;
            if (!a || (c > 0 && a < c) || (c < 0 && a < -c)) {
                a = c;
                s = p / 4;
            }
            else
                s = p / Ease.PI2 * Math.asin(c / a);
            return (a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * Ease.PI2 / p) + c + b);
        };
        Ease.strongIn = function (t, b, c, d) {
            return c * (t /= d) * t * t * t * t + b;
        };
        Ease.strongInOut = function (t, b, c, d) {
            if ((t /= d * 0.5) < 1)
                return c * 0.5 * t * t * t * t * t + b;
            return c * 0.5 * ((t -= 2) * t * t * t * t + 2) + b;
        };
        Ease.strongOut = function (t, b, c, d) {
            return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
        };
        Ease.sineInOut = function (t, b, c, d) {
            return -c * 0.5 * (Math.cos(Math.PI * t / d) - 1) + b;
        };
        Ease.sineIn = function (t, b, c, d) {
            return -c * Math.cos(t / d * Ease.HALF_PI) + c + b;
        };
        Ease.sineOut = function (t, b, c, d) {
            return c * Math.sin(t / d * Ease.HALF_PI) + b;
        };
        Ease.quintIn = function (t, b, c, d) {
            return c * (t /= d) * t * t * t * t + b;
        };
        Ease.quintInOut = function (t, b, c, d) {
            if ((t /= d * 0.5) < 1)
                return c * 0.5 * t * t * t * t * t + b;
            return c * 0.5 * ((t -= 2) * t * t * t * t + 2) + b;
        };
        Ease.quintOut = function (t, b, c, d) {
            return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
        };
        Ease.quartIn = function (t, b, c, d) {
            return c * (t /= d) * t * t * t + b;
        };
        Ease.quartInOut = function (t, b, c, d) {
            if ((t /= d * 0.5) < 1)
                return c * 0.5 * t * t * t * t + b;
            return -c * 0.5 * ((t -= 2) * t * t * t - 2) + b;
        };
        Ease.quartOut = function (t, b, c, d) {
            return -c * ((t = t / d - 1) * t * t * t - 1) + b;
        };
        Ease.cubicIn = function (t, b, c, d) {
            return c * (t /= d) * t * t + b;
        };
        Ease.cubicInOut = function (t, b, c, d) {
            if ((t /= d * 0.5) < 1)
                return c * 0.5 * t * t * t + b;
            return c * 0.5 * ((t -= 2) * t * t + 2) + b;
        };
        Ease.cubicOut = function (t, b, c, d) {
            return c * ((t = t / d - 1) * t * t + 1) + b;
        };
        Ease.quadIn = function (t, b, c, d) {
            return c * (t /= d) * t + b;
        };
        Ease.quadInOut = function (t, b, c, d) {
            if ((t /= d * 0.5) < 1)
                return c * 0.5 * t * t + b;
            return -c * 0.5 * ((--t) * (t - 2) - 1) + b;
        };
        Ease.quadOut = function (t, b, c, d) {
            return -c * (t /= d) * (t - 2) + b;
        };
        Ease.expoIn = function (t, b, c, d) {
            return (t == 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b - c * 0.001;
        };
        Ease.expoInOut = function (t, b, c, d) {
            if (t == 0)
                return b;
            if (t == d)
                return b + c;
            if ((t /= d * 0.5) < 1)
                return c * 0.5 * Math.pow(2, 10 * (t - 1)) + b;
            return c * 0.5 * (-Math.pow(2, -10 * --t) + 2) + b;
        };
        Ease.expoOut = function (t, b, c, d) {
            return (t == d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
        };
        Ease.circIn = function (t, b, c, d) {
            return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
        };
        Ease.circInOut = function (t, b, c, d) {
            if ((t /= d * 0.5) < 1)
                return -c * 0.5 * (Math.sqrt(1 - t * t) - 1) + b;
            return c * 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
        };
        Ease.circOut = function (t, b, c, d) {
            return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
        };
        Ease.HALF_PI = Math.PI * 0.5;
        Ease.PI2 = Math.PI * 2;
        return Ease;
    })();
    var HitArea = (function () {
        function HitArea() {
            this._hit = null;
            this._unHit = null;
        }
        __class(HitArea, 'laya.utils.HitArea');
        var __proto = HitArea.prototype;
        __proto.isHit = function (x, y) {
            if (!HitArea.isHitGraphic(x, y, this.hit))
                return false;
            return !HitArea.isHitGraphic(x, y, this.unHit);
        };
        __proto.contains = function (x, y) {
            return this.isHit(x, y);
        };
        __getset(0, __proto, 'hit', function () {
            if (!this._hit)
                this._hit = new Graphics();
            return this._hit;
        }, function (value) {
            this._hit = value;
        });
        __getset(0, __proto, 'unHit', function () {
            if (!this._unHit)
                this._unHit = new Graphics();
            return this._unHit;
        }, function (value) {
            this._unHit = value;
        });
        HitArea.isHitGraphic = function (x, y, graphic) {
            if (!graphic)
                return false;
            var cmds;
            cmds = graphic.cmds;
            if (!cmds && graphic._one) {
                cmds = HitArea._cmds;
                cmds.length = 1;
                cmds[0] = graphic._one;
            }
            if (!cmds)
                return false;
            var i = 0, len = 0;
            len = cmds.length;
            var cmd;
            for (i = 0; i < len; i++) {
                cmd = cmds[i];
                if (!cmd)
                    continue;
                var context = Render._context;
                switch (cmd.callee) {
                    case context._translate:
                    case 6:
                        x -= cmd[0];
                        y -= cmd[1];
                    default:
                }
                if (HitArea.isHitCmd(x, y, cmd))
                    return true;
            }
            return false;
        };
        HitArea.isHitCmd = function (x, y, cmd) {
            if (!cmd)
                return false;
            var context = Render._context;
            var rst = false;
            switch (cmd["callee"]) {
                case context._drawRect:
                case 13:
                    HitArea._rec.setTo(cmd[0], cmd[1], cmd[2], cmd[3]);
                    rst = HitArea._rec.contains(x, y);
                    break;
                case context._drawCircle:
                case context._fillCircle:
                case 14:
                    ;
                    var d = NaN;
                    x -= cmd[0];
                    y -= cmd[1];
                    d = x * x + y * y;
                    rst = d < cmd[2] * cmd[2];
                    break;
                case context._drawPoly:
                case 18:
                    x -= cmd[0];
                    y -= cmd[1];
                    rst = HitArea.ptInPolygon(x, y, cmd[2]);
                    break;
                default:
                    break;
            }
            return rst;
        };
        HitArea.ptInPolygon = function (x, y, areaPoints) {
            var p;
            p = HitArea._ptPoint;
            p.setTo(x, y);
            var nCross = 0;
            var p1x = NaN, p1y = NaN, p2x = NaN, p2y = NaN;
            var len = 0;
            len = areaPoints.length;
            for (var i = 0; i < len; i += 2) {
                p1x = areaPoints[i];
                p1y = areaPoints[i + 1];
                p2x = areaPoints[(i + 2) % len];
                p2y = areaPoints[(i + 3) % len];
                if (p1y == p2y)
                    continue;
                if (p.y < Math.min(p1y, p2y))
                    continue;
                if (p.y >= Math.max(p1y, p2y))
                    continue;
                var tx = (p.y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x;
                if (tx > p.x) {
                    nCross++;
                }
            }
            return (nCross % 2 == 1);
        };
        HitArea._cmds = [];
        __static(HitArea, ['_rec', function () { return this._rec = new Rectangle(); }, '_ptPoint', function () { return this._ptPoint = new Point(); }
        ]);
        return HitArea;
    })();
    var HTMLChar = (function () {
        function HTMLChar(char, w, h, style) {
            this.char = char;
            this.charNum = char.charCodeAt(0);
            this._x = this._y = 0;
            this.width = w;
            this.height = h;
            this.style = style;
            this.isWord = !HTMLChar._isWordRegExp.test(char);
        }
        __class(HTMLChar, 'laya.utils.HTMLChar');
        var __proto = HTMLChar.prototype;
        Laya.imps(__proto, { "laya.display.ILayout": true });
        __proto.setSprite = function (sprite) {
            this._sprite = sprite;
        };
        __proto.getSprite = function () {
            return this._sprite;
        };
        __proto._isChar = function () {
            return true;
        };
        __proto._getCSSStyle = function () {
            return this.style;
        };
        __getset(0, __proto, 'width', function () {
            return this._w;
        }, function (value) {
            this._w = value;
        });
        __getset(0, __proto, 'x', function () {
            return this._x;
        }, function (value) {
            if (this._sprite) {
                this._sprite.x = value;
            }
            this._x = value;
        });
        __getset(0, __proto, 'y', function () {
            return this._y;
        }, function (value) {
            if (this._sprite) {
                this._sprite.y = value;
            }
            this._y = value;
        });
        __getset(0, __proto, 'height', function () {
            return this._h;
        }, function (value) {
            this._h = value;
        });
        HTMLChar._isWordRegExp = new RegExp("[\\w\.]", "");
        return HTMLChar;
    })();
    var Log = (function () {
        function Log() { }
        __class(Log, 'laya.utils.Log');
        Log.enable = function () {
            if (!Log._logdiv) {
                Log._logdiv = Browser.window.document.createElement('div');
                Browser.window.document.body.appendChild(Log._logdiv);
                Log._logdiv.style.cssText = "pointer-events:none;border:white;overflow:hidden;z-index:1000000;background:rgba(100,100,100,0.6);color:white;position: absolute;left:0px;top:0px;width:50%;height:50%;";
            }
        };
        Log.toggle = function () {
            var style = Log._logdiv.style;
            if (style.width == "1px") {
                style.width = style.height = "50%";
            }
            else {
                style.width = style.height = "1px";
            }
        };
        Log.print = function (value) {
            if (Log._logdiv) {
                if (Log._count >= Log.maxCount)
                    Log.clear();
                Log._count++;
                Log._logdiv.innerText += value + "\n";
                Log._logdiv.scrollTop = Log._logdiv.scrollHeight;
            }
        };
        Log.clear = function () {
            Log._logdiv.innerText = "";
            Log._count = 0;
        };
        Log._logdiv = null;
        Log._count = 0;
        Log.maxCount = 20;
        return Log;
    })();
    var Mouse = (function () {
        function Mouse() { }
        __class(Mouse, 'laya.utils.Mouse');
        __getset(1, Mouse, 'cursor', function () {
            return Mouse._style.cursor;
        }, function (cursorStr) {
            Mouse._style.cursor = cursorStr;
        });
        Mouse.hide = function () {
            if (Mouse.cursor != "none") {
                Mouse._preCursor = Mouse.cursor;
                Mouse.cursor = "none";
            }
        };
        Mouse.show = function () {
            if (Mouse.cursor == "none") {
                if (Mouse._preCursor) {
                    Mouse.cursor = Mouse._preCursor;
                }
                else {
                    Mouse.cursor = "auto";
                }
            }
        };
        Mouse._preCursor = null;
        __static(Mouse, ['_style', function () { return this._style = Browser.document.body.style; }
        ]);
        return Mouse;
    })();
    var Pool = (function () {
        function Pool() { }
        __class(Pool, 'laya.utils.Pool');
        Pool.getPoolBySign = function (sign) {
            return Pool._poolDic[sign] || (Pool._poolDic[sign] = []);
        };
        Pool.clearBySign = function (sign) {
            if (Pool._poolDic[sign])
                Pool._poolDic[sign].length = 0;
        };
        Pool.recover = function (sign, item) {
            if (item["__InPool"])
                return;
            item["__InPool"] = true;
            Pool.getPoolBySign(sign).push(item);
        };
        Pool.getItemByClass = function (sign, cls) {
            var pool = Pool.getPoolBySign(sign);
            var rst = pool.length ? pool.pop() : new cls();
            rst["__InPool"] = false;
            return rst;
        };
        Pool.getItemByCreateFun = function (sign, createFun) {
            var pool = Pool.getPoolBySign(sign);
            var rst = pool.length ? pool.pop() : createFun();
            rst["__InPool"] = false;
            return rst;
        };
        Pool.getItem = function (sign) {
            var pool = Pool.getPoolBySign(sign);
            var rst = pool.length ? pool.pop() : null;
            if (rst) {
                rst["__InPool"] = false;
            }
            return rst;
        };
        Pool._poolDic = {};
        Pool.InPoolSign = "__InPool";
        return Pool;
    })();
    var PoolCache = (function () {
        function PoolCache() {
            this.sign = null;
            this.maxCount = 1000;
        }
        __class(PoolCache, 'laya.utils.PoolCache');
        var __proto = PoolCache.prototype;
        __proto.getCacheList = function () {
            return Pool.getPoolBySign(this.sign);
        };
        __proto.tryDispose = function (force) {
            var list;
            list = Pool.getPoolBySign(this.sign);
            if (list.length > this.maxCount) {
                list.splice(this.maxCount, list.length - this.maxCount);
            }
        };
        PoolCache.addPoolCacheManager = function (sign, maxCount) {
            (maxCount === void 0) && (maxCount = 100);
            var cache;
            cache = new PoolCache();
            cache.sign = sign;
            cache.maxCount = maxCount;
            CacheManager.regCacheByFunction(Utils.bind(cache.tryDispose, cache), Utils.bind(cache.getCacheList, cache));
        };
        return PoolCache;
    })();
    var Stat = (function () {
        function Stat() { }
        __class(Stat, 'laya.utils.Stat');
        __getset(1, Stat, 'onclick', null, function (fn) {
            if (Stat._sp) {
                Stat._sp.on("click", Stat._sp, fn);
            }
            if (Stat._canvas) {
                Stat._canvas.source.onclick = fn;
                Stat._canvas.source.style.pointerEvents = '';
            }
        });
        Stat.show = function (x, y) {
            (x === void 0) && (x = 0);
            (y === void 0) && (y = 0);
            if (Render.isConchApp) {
                Browser.window.conch.showFPS && Browser.window.conch.showFPS(x, y);
                return;
            }
            if (!Browser.onMiniGame && !Browser.onLimixiu)
                Stat._useCanvas = true;
            Stat._show = true;
            Stat._fpsData.length = 60;
            Stat._view[0] = { title: "FPS(Canvas)", value: "_fpsStr", color: "yellow", units: "int" };
            Stat._view[1] = { title: "Sprite", value: "_spriteStr", color: "white", units: "int" };
            Stat._view[2] = { title: "DrawCall", value: "drawCall", color: "white", units: "int" };
            Stat._view[3] = { title: "CurMem", value: "currentMemorySize", color: "yellow", units: "M" };
            if (Render.isWebGL) {
                Stat._view[4] = { title: "Shader", value: "shaderCall", color: "white", units: "int" };
                if (!Render.is3DMode) {
                    Stat._view[0].title = "FPS";
                    Stat._view[5] = { title: "Canvas", value: "_canvasStr", color: "white", units: "int" };
                }
                else {
                    Stat._view[0].title = "FPS(3D)";
                    Stat._view[5] = { title: "TriFaces", value: "trianglesFaces", color: "white", units: "int" };
                    Stat._view[6] = { title: "treeNodeColl", value: "treeNodeCollision", color: "white", units: "int" };
                    Stat._view[7] = { title: "treeSpriteColl", value: "treeSpriteCollision", color: "white", units: "int" };
                }
            }
            else {
                Stat._view[4] = { title: "Canvas", value: "_canvasStr", color: "white", units: "int" };
            }
            if (Stat._useCanvas) {
                Stat.createUIPre(x, y);
            }
            else
                Stat.createUI(x, y);
            Stat.enable();
        };
        Stat.createUIPre = function (x, y) {
            var pixel = Browser.pixelRatio;
            Stat._width = pixel * 130;
            Stat._vx = pixel * 75;
            Stat._height = pixel * (Stat._view.length * 12 + 3 * pixel) + 4;
            Stat._fontSize = 12 * pixel;
            var d = 0;
            for (var i = 0; i < Stat._view.length; i++) {
                if (i == 3 || i == 5) {
                    continue;
                }

                Stat._view[i].x = 4;
                Stat._view[i].y = d * Stat._fontSize + 2 * pixel + d * 5 + 6;
                d++;
            }
            if (!Stat._canvas) {
                Stat._canvas = new HTMLCanvas('2D');
                Stat._canvas.size(Stat._width, Stat._height);
                Stat._ctx = Stat._canvas.getContext('2d');
                Stat._ctx.textBaseline = "top";
                Stat._ctx.font = Stat._fontSize + "px Sans-serif";
                Stat._canvas.source.style.cssText = "pointer-events:none;background:rgba(0,0,0,0.8);z-index:100000;position: absolute;direction:ltr;left:" + x + "px;top:" + y + "px;width:" + (Stat._width / pixel) + "px;height:" + (Stat._height / pixel) + "px;";
            }
            Stat._first = true;
            Stat.loop();
            Stat._first = false;
            Browser.container.appendChild(Stat._canvas.source);
        };
        Stat.createUI = function (x, y) {
            var stat = Stat._sp;
            var pixel = Browser.pixelRatio;
            if (!stat) {
                stat = new Sprite();
                Stat._leftText = new Text();
                Stat._leftText.pos(5, 5);
                Stat._leftText.color = "#ffffff";
                stat.addChild(Stat._leftText);
                Stat._txt = new Text();
                Stat._txt.pos(80 * pixel, 5);
                Stat._txt.color = "#ffffff";
                stat.addChild(Stat._txt);
                Stat._sp = stat;
            }
            stat.pos(x, y);
            var text = "";
            for (var i = 0; i < Stat._view.length; i++) {
                var one = Stat._view[i];
                text += one.title + "\n";
            }
            Stat._leftText.text = text;
            var width = pixel * 138;
            var height = pixel * (Stat._view.length * 12 + 3 * pixel) + 4;
            Stat._txt.fontSize = Stat._fontSize * pixel;
            Stat._leftText.fontSize = Stat._fontSize * pixel;
            stat.size(width, height);
            stat.graphics.clear();
            stat.graphics.setAlpha(0.5);
            stat.graphics.drawRect(0, 0, width, height, "#999999");
            stat.graphics.setAlpha(1);
            Stat.loop();
        };
        Stat.enable = function () {
            Laya.timer.frameLoop(1, Stat, Stat.loop);
        };
        Stat.hide = function () {
            Stat._show = false;
            Laya.timer.clear(Stat, Stat.loop);
            if (Stat._canvas) {
                Browser.removeElement(Stat._canvas.source);
            }
        };
        Stat.clear = function () {
            Stat.trianglesFaces = Stat.drawCall = Stat.shaderCall = Stat.spriteCount = Stat.spriteRenderUseCacheCount = Stat.treeNodeCollision = Stat.treeSpriteCollision = Stat.canvasNormal = Stat.canvasBitmap = Stat.canvasReCache = 0;
        };
        Stat.loop = function () {
            Stat._count++;
            var timer = Browser.now();
            if (timer - Stat._timer < 1000)
                return;
            var count = Stat._count;
            Stat.FPS = Math.round((count * 1000) / (timer - Stat._timer));
            if (Stat._show) {
                Stat.trianglesFaces = Math.round(Stat.trianglesFaces / count);
                if (!Stat._useCanvas) {
                    Stat.drawCall = Math.round(Stat.drawCall / count) - 2;
                    Stat.shaderCall = Math.round(Stat.shaderCall / count) - 4;
                    Stat.spriteCount = Math.round(Stat.spriteCount / count) - 4;
                }
                else {
                    Stat.drawCall = Math.round(Stat.drawCall / count) - 2;
                    Stat.shaderCall = Math.round(Stat.shaderCall / count);
                    Stat.spriteCount = Math.round(Stat.spriteCount / count) - 1;
                }
                Stat.spriteRenderUseCacheCount = Math.round(Stat.spriteRenderUseCacheCount / count);
                Stat.canvasNormal = Math.round(Stat.canvasNormal / count);
                Stat.canvasBitmap = Math.round(Stat.canvasBitmap / count);
                Stat.canvasReCache = Math.ceil(Stat.canvasReCache / count);
                Stat.treeNodeCollision = Math.round(Stat.treeNodeCollision / count);
                Stat.treeSpriteCollision = Math.round(Stat.treeSpriteCollision / count);
                var delay = Stat.FPS > 0 ? Math.floor(1000 / Stat.FPS).toString() : " ";
                Stat._fpsStr = Stat.FPS + (Stat.renderSlow ? " slow" : "") + " " + delay;
                Stat._spriteStr = Stat.spriteCount + (Stat.spriteRenderUseCacheCount ? ("/" + Stat.spriteRenderUseCacheCount) : '');
                Stat._canvasStr = Stat.canvasReCache + "/" + Stat.canvasNormal + "/" + Stat.canvasBitmap;
                Stat.currentMemorySize = ResourceManager.systemResourceManager.memorySize;
                if (Stat._useCanvas) {
                    Stat.renderInfoPre();
                }
                else
                    Stat.renderInfo();
                Stat.clear();
            }
            Stat._count = 0;
            Stat._timer = timer;
        };
        Stat.renderInfoPre = function () {
            if (Stat._canvas) {
                var ctx = Stat._ctx;
                ctx.clearRect(Stat._first ? 0 : Stat._vx, 0, Stat._width, Stat._height);
                for (var i = 0; i < Stat._view.length; i++) {
                    var one = Stat._view[i];
                    if (Stat._first) {
                        ctx.fillStyle = "white";
                        ctx.fillText(one.title, one.x, one.y, null, null, null);
                    }
                    ctx.fillStyle = one.color;
                    var value = Stat[one.value];
                    (one.units == "M") && (value = Math.floor(value / (1024 * 1024) * 100) / 100 + " M");
                    ctx.fillText(value + "", one.x + Stat._vx, one.y, null, null, null);
                }
            }
        };
        Stat.renderInfo = function () {
            var text = "";
            for (var i = 0; i < Stat._view.length; i++) {
                var one = Stat._view[i];
                var value = Stat[one.value];
                (one.units == "M") && (value = Math.floor(value / (1024 * 1024) * 100) / 100 + " M");
                (one.units == "K") && (value = Math.floor(value / (1024) * 100) / 100 + " K");
                text += value + "\n";
            }
            Stat._txt.text = text;
        };
        Stat.FPS = 0;
        Stat.loopCount = 0;
        Stat.shaderCall = 0;
        Stat.drawCall = 0;
        Stat.trianglesFaces = 0;
        Stat.spriteCount = 0;
        Stat.spriteRenderUseCacheCount = 0;
        Stat.treeNodeCollision = 0;
        Stat.treeSpriteCollision = 0;
        Stat.canvasNormal = 0;
        Stat.canvasBitmap = 0;
        Stat.canvasReCache = 0;
        Stat.renderSlow = false;
        Stat.currentMemorySize = 0;
        Stat._fpsStr = null;
        Stat._canvasStr = null;
        Stat._spriteStr = null;
        Stat._fpsData = [];
        Stat._timer = 0;
        Stat._count = 0;
        Stat._view = [];
        Stat._fontSize = 12;
        Stat._txt = null;
        Stat._leftText = null;
        Stat._sp = null;
        Stat._show = false;
        Stat._useCanvas = false;
        Stat._canvas = null;
        Stat._ctx = null;
        Stat._first = false;
        Stat._vx = NaN;
        Stat._width = 0;
        Stat._height = 100;
        return Stat;
    })();
    var StringKey = (function () {
        function StringKey() {
            this._strsToID = {};
            this._idToStrs = [];
            this._length = 0;
        }
        __class(StringKey, 'laya.utils.StringKey');
        var __proto = StringKey.prototype;
        __proto.add = function (str) {
            var index = this._strsToID[str];
            if (index != null)
                return index;
            this._idToStrs[this._length] = str;
            return this._strsToID[str] = this._length++;
        };
        __proto.getID = function (str) {
            var index = this._strsToID[str];
            return index == null ? -1 : index;
        };
        __proto.getName = function (id) {
            var str = this._idToStrs[id];
            return str == null ? undefined : str;
        };
        return StringKey;
    })();
    var Timer = (function () {
        var TimerHandler;
        function Timer() {
            this._delta = 0;
            this.scale = 1;
            this.currFrame = 0;
            this._mid = 1;
            this._map = [];
            this._laters = [];
            this._handlers = [];
            this._temp = [];
            this._count = 0;
            this.currTimer = this._now();
            this._lastTimer = this._now();
            this._init();
        }
        __class(Timer, 'laya.utils.Timer');
        var __proto = Timer.prototype;
        __proto._init = function () {
            Laya.timer && Laya.timer.frameLoop(1, this, this._update);
        };
        __proto._now = function () {
            return Date.now();
        };
        __proto._update = function () {
            if (this.scale <= 0) {
                this._lastTimer = this._now();
                return;
            }
            ;
            var frame = this.currFrame = this.currFrame + this.scale;
            var now = this._now();
            this._delta = (now - this._lastTimer) * this.scale;
            var timer = this.currTimer = this.currTimer + this._delta;
            this._lastTimer = now;
            var handlers = this._handlers;
            this._count = 0;
            for (i = 0, n = handlers.length; i < n; i++) {
                handler = handlers[i];
                if (handler == null) continue;
                if (handler.method !== null) {
                    var t = handler.userFrame ? frame : timer;
                    if (t >= handler.exeTime) {
                        if (handler.repeat) {
                            if (!handler.jumpFrame) {
                                handler.exeTime += handler.delay;
                                handler.run(false);
                                if (t > handler.exeTime) {
                                    handler.exeTime += Math.ceil((t - handler.exeTime) / handler.delay) * handler.delay;
                                }
                            }
                            else {
                                while (t >= handler.exeTime) {
                                    handler.exeTime += handler.delay;
                                    handler.run(false);
                                }
                            }
                        }
                        else {
                            handler.run(true);
                        }
                    }
                }
                else {
                    this._count++;
                }
            }
            if (this._count > 30 || frame % 200 === 0)
                this._clearHandlers();
            var laters = this._laters;
            for (var i = 0, n = laters.length - 1; i <= n; i++) {
                var handler = laters[i];
                if (handler.method !== null) {
                    this._map[handler.key] = null;
                    handler.run(false);
                }
                this._recoverHandler(handler);
                i === n && (n = laters.length - 1);
            }
            laters.length = 0;
        };
        __proto._clearHandlers = function () {
            var handlers = this._handlers;
            for (var i = 0, n = handlers.length; i < n; i++) {
                var handler = handlers[i];
                if (handler.method !== null)
                    this._temp.push(handler);
                else
                    this._recoverHandler(handler);
            }
            this._handlers = this._temp;
            this._temp = handlers;
            this._temp.length = 0;
        };
        __proto._recoverHandler = function (handler) {
            if (this._map[handler.key] == handler)
                this._map[handler.key] = null;
            handler.clear();
            Timer._pool.push(handler);
        };
        __proto._create = function (useFrame, repeat, delay, caller, method, args, coverBefore) {
            if (!delay) {
                method.apply(caller, args);
                return null;
            }
            if (coverBefore) {
                var handler = this._getHandler(caller, method);
                if (handler) {
                    handler.repeat = repeat;
                    handler.userFrame = useFrame;
                    handler.delay = delay;
                    handler.caller = caller;
                    handler.method = method;
                    handler.args = args;
                    handler.exeTime = delay + (useFrame ? this.currFrame : this.currTimer + this._now() - this._lastTimer);
                    return handler;
                }
            }
            handler = Timer._pool.length > 0 ? Timer._pool.pop() : new TimerHandler();
            handler.repeat = repeat;
            handler.userFrame = useFrame;
            handler.delay = delay;
            handler.caller = caller;
            handler.method = method;
            handler.args = args;
            handler.exeTime = delay + (useFrame ? this.currFrame : this.currTimer + this._now() - this._lastTimer) + 1;
            this._indexHandler(handler);
            this._handlers.push(handler);
            return handler;
        };
        __proto._indexHandler = function (handler) {
            var caller = handler.caller;
            var method = handler.method;
            var cid = caller ? caller.$_GID || (caller.$_GID = Utils.getGID()) : 0;
            var mid = method.$_TID || (method.$_TID = (this._mid++) * 100000);
            handler.key = cid + mid;
            this._map[handler.key] = handler;
        };
        __proto.once = function (delay, caller, method, args, coverBefore) {
            (coverBefore === void 0) && (coverBefore = true);
            this._create(false, false, delay, caller, method, args, coverBefore);
        };
        __proto.loop = function (delay, caller, method, args, coverBefore, jumpFrame) {
            (coverBefore === void 0) && (coverBefore = true);
            (jumpFrame === void 0) && (jumpFrame = false);
            var handler = this._create(false, true, delay, caller, method, args, coverBefore);
            if (handler)
                handler.jumpFrame = jumpFrame;
        };
        __proto.frameOnce = function (delay, caller, method, args, coverBefore) {
            (coverBefore === void 0) && (coverBefore = true);
            this._create(true, false, delay, caller, method, args, coverBefore);
        };
        __proto.frameLoop = function (delay, caller, method, args, coverBefore) {
            (coverBefore === void 0) && (coverBefore = true);
            this._create(true, true, delay, caller, method, args, coverBefore);
        };
        __proto.toString = function () {
            return "callLater:" + this._laters.length + " handlers:" + this._handlers.length + " pool:" + Timer._pool.length;
        };
        __proto.clear = function (caller, method) {
            var handler = this._getHandler(caller, method);
            if (handler) {
                this._map[handler.key] = null;
                handler.key = 0;
                handler.clear();
            }
        };
        __proto.clearAll = function (caller) {
            if (!caller)
                return;
            for (var i = 0, n = this._handlers.length; i < n; i++) {
                var handler = this._handlers[i];
                if (handler.caller === caller) {
                    this._map[handler.key] = null;
                    handler.key = 0;
                    handler.clear();
                }
            }
        };
        __proto._getHandler = function (caller, method) {
            var cid = caller ? caller.$_GID || (caller.$_GID = Utils.getGID()) : 0;
            var mid = method.$_TID || (method.$_TID = (this._mid++) * 100000);
            return this._map[cid + mid];
        };
        __proto.callLater = function (caller, method, args) {
            if (this._getHandler(caller, method) == null) {
                if (Timer._pool.length)
                    var handler = Timer._pool.pop();
                else
                    handler = new TimerHandler();
                handler.caller = caller;
                handler.method = method;
                handler.args = args;
                this._indexHandler(handler);
                this._laters.push(handler);
            }
        };
        __proto.runCallLater = function (caller, method) {
            var handler = this._getHandler(caller, method);
            if (handler && handler.method != null) {
                this._map[handler.key] = null;
                handler.run(true);
            }
        };
        __proto.runTimer = function (caller, method) {
            this.runCallLater(caller, method);
        };
        __getset(0, __proto, 'delta', function () {
            return this._delta;
        });
        Timer._pool = [];
        Timer.__init$ = function () {
            TimerHandler = (function () {
                function TimerHandler() {
                    this.key = 0;
                    this.repeat = false;
                    this.delay = 0;
                    this.userFrame = false;
                    this.exeTime = 0;
                    this.caller = null;
                    this.method = null;
                    this.args = null;
                    this.jumpFrame = false;
                }
                __class(TimerHandler, '');
                var __proto = TimerHandler.prototype;
                __proto.clear = function () {
                    this.caller = null;
                    this.method = null;
                    this.args = null;
                };
                __proto.run = function (withClear) {
                    var caller = this.caller;
                    if (caller && caller.destroyed)
                        return this.clear();
                    var method = this.method;
                    var args = this.args;
                    withClear && this.clear();
                    if (method == null)
                        return;
                    args ? method.apply(caller, args) : method.call(caller);
                };
                return TimerHandler;
            })();
        };
        return Timer;
    })();
    var Tween = (function () {
        function Tween() {
            this.gid = 0;
        }
        __class(Tween, 'laya.utils.Tween');
        var __proto = Tween.prototype;
        __proto.to = function (target, props, duration, ease, complete, delay, coverBefore) {
            (delay === void 0) && (delay = 0);
            (coverBefore === void 0) && (coverBefore = false);
            return this._create(target, props, duration, ease, complete, delay, coverBefore, true, false, true);
        };
        __proto.from = function (target, props, duration, ease, complete, delay, coverBefore) {
            (delay === void 0) && (delay = 0);
            (coverBefore === void 0) && (coverBefore = false);
            return this._create(target, props, duration, ease, complete, delay, coverBefore, false, false, true);
        };
        __proto._create = function (target, props, duration, ease, complete, delay, coverBefore, isTo, usePool, runNow) {
            if (!target)
                throw new Error("Tween:target is null");
            this._target = target;
            this._duration = duration;
            this._ease = ease || props.ease || Tween.easeNone;
            this._complete = complete || props.complete;
            this._delay = delay;
            this._props = [];
            this._usedTimer = 0;
            this._startTimer = Browser.now();
            this._usedPool = usePool;
            this._delayParam = null;
            this.update = props.update;
            var gid = (target.$_GID || (target.$_GID = Utils.getGID()));
            if (!Tween.tweenMap[gid]) {
                Tween.tweenMap[gid] = [this];
            }
            else {
                if (coverBefore)
                    Tween.clearTween(target);
                Tween.tweenMap[gid].push(this);
            }
            if (runNow) {
                if (delay <= 0)
                    this.firstStart(target, props, isTo);
                else {
                    this._delayParam = [target, props, isTo];
                    Laya.scaleTimer.once(delay, this, this.firstStart, this._delayParam);
                }
            }
            else {
                this._initProps(target, props, isTo);
            }
            return this;
        };
        __proto.firstStart = function (target, props, isTo) {
            this._delayParam = null;
            if (target.destroyed) {
                this.clear();
                return;
            }
            this._initProps(target, props, isTo);
            this._beginLoop();
        };
        __proto._initProps = function (target, props, isTo) {
            for (var p in props) {
                if ((typeof (target[p]) == 'number')) {
                    var start = isTo ? target[p] : props[p];
                    var end = isTo ? props[p] : target[p];
                    this._props.push([p, start, end - start]);
                    if (!isTo)
                        target[p] = start;
                }
            }
        };
        __proto._beginLoop = function () {
            Laya.scaleTimer.frameLoop(1, this, this._doEase);
        };
        __proto._doEase = function () {
            this._updateEase(Browser.now());
        };
        __proto._updateEase = function (time) {
            var target = this._target;
            if (!target)
                return;
            if (target.destroyed)
                return Tween.clearTween(target);
            var usedTimer = this._usedTimer = time - this._startTimer - this._delay;
            if (usedTimer < 0)
                return;
            if (usedTimer >= this._duration)
                return this.complete();
            var ratio = usedTimer > 0 ? this._ease(usedTimer, 0, 1, this._duration) : 0;
            var props = this._props;
            for (var i = 0, n = props.length; i < n; i++) {
                var prop = props[i];
                target[prop[0]] = prop[1] + (ratio * prop[2]);
            }
            if (this.update)
                this.update.run();
        };
        __proto.complete = function () {
            if (!this._target)
                return;
            Laya.scaleTimer.runTimer(this, this.firstStart);
            var target = this._target;
            var props = this._props;
            var handler = this._complete;
            for (var i = 0, n = props.length; i < n; i++) {
                var prop = props[i];
                target[prop[0]] = prop[1] + prop[2];
            }
            if (this.update)
                this.update.run();
            this.clear();
            handler && handler.run();
        };
        __proto.pause = function () {
            Laya.scaleTimer.clear(this, this._beginLoop);
            Laya.scaleTimer.clear(this, this._doEase);
            Laya.scaleTimer.clear(this, this.firstStart);
            var time = Browser.now();
            var dTime = NaN;
            dTime = time - this._startTimer - this._delay;
            if (dTime < 0) {
                this._usedTimer = dTime;
            }
        };
        __proto.setStartTime = function (startTime) {
            this._startTimer = startTime;
        };
        __proto.clear = function () {
            if (this._target) {
                this._remove();
                this._clear();
            }
        };
        __proto._clear = function () {
            this.pause();
            Laya.scaleTimer.clear(this, this.firstStart);
            this._complete = null;
            this._target = null;
            this._ease = null;
            this._props = null;
            this._delayParam = null;
            // if (this._usedPool) {
            //     this.update = null;
            //     Pool.recover("tween", this);
            // }
        };
        __proto.recover = function () {
            // this._usedPool = true;
            this._clear();
        };
        __proto._remove = function () {
            var tweens = Tween.tweenMap[this._target.$_GID];
            if (tweens) {
                for (var i = 0, n = tweens.length; i < n; i++) {
                    if (tweens[i] === this) {
                        tweens.splice(i, 1);
                        break;
                    }
                }
            }
        };
        __proto.restart = function () {
            this.pause();
            this._usedTimer = 0;
            this._startTimer = Browser.now();
            if (this._delayParam) {
                Laya.scaleTimer.once(this._delay, this, this.firstStart, this._delayParam);
                return;
            }
            ;
            var props = this._props;
            for (var i = 0, n = props.length; i < n; i++) {
                var prop = props[i];
                this._target[prop[0]] = prop[1];
            }
            Laya.scaleTimer.once(this._delay, this, this._beginLoop);
        };
        __proto.resume = function () {
            if (this._usedTimer >= this._duration)
                return;
            this._startTimer = Browser.now() - this._usedTimer - this._delay;
            if (this._delayParam) {
                if (this._usedTimer < 0) {
                    Laya.scaleTimer.once(-this._usedTimer, this, this.firstStart, this._delayParam);
                }
                else {
                    this.firstStart.apply(this, this._delayParam);
                }
            }
            else {
                this._beginLoop();
            }
        };
        __getset(0, __proto, 'progress', function () {
            return Math.min(Math.max((Browser.now() - this._startTimer) / this._duration, 0), 1);
        }, function (v) {
            var uTime = v * this._duration;
            this._startTimer = Browser.now() - this._delay - uTime;
        });
        Tween.to = function (target, props, duration, ease, complete, delay, coverBefore) {
            (delay === void 0) && (delay = 0);
            (coverBefore === void 0) && (coverBefore = false);
            return new Tween()._create(target, props, duration, ease, complete, delay, coverBefore, true, false, true);
        };
        Tween.from = function (target, props, duration, ease, complete, delay, coverBefore) {
            (delay === void 0) && (delay = 0);
            (coverBefore === void 0) && (coverBefore = false);
            return new Tween()._create(target, props, duration, ease, complete, delay, coverBefore, false, false, true);
        };
        Tween.clearAll = function (target) {
            if (!target || !target.$_GID)
                return;
            var tweens = Tween.tweenMap[target.$_GID];
            if (tweens) {
                for (var i = 0, n = tweens.length; i < n; i++) {
                    tweens[i]._clear();
                }
                tweens.length = 0;
            }
        };
        Tween.clear = function (tween) {
            tween.clear();
        };
        Tween.clearTween = function (target) {
            Tween.clearAll(target);
        };
        Tween.easeNone = function (t, b, c, d) {
            return c * t / d + b;
        };
        Tween.tweenMap = {};
        return Tween;
    })();
    var Utils = (function () {
        function Utils() { }
        __class(Utils, 'laya.utils.Utils');
        Utils.toRadian = function (angle) {
            return angle * Utils._pi2;
        };
        Utils.toAngle = function (radian) {
            return radian * Utils._pi;
        };
        Utils.toHexColor = function (color) {
            if (color < 0 || isNaN(color))
                return null;
            var str = color.toString(16);
            while (str.length < 6)
                str = "0" + str;
            return "#" + str;
        };
        Utils.getGID = function () {
            return Utils._gid++;
        };
        Utils.concatArray = function (source, array) {
            if (!array)
                return source;
            if (!source)
                return array;
            var i = 0, len = array.length;
            for (i = 0; i < len; i++) {
                source.push(array[i]);
            }
            return source;
        };
        Utils.clearArray = function (array) {
            if (!array)
                return array;
            array.length = 0;
            return array;
        };
        Utils.copyArray = function (source, array) {
            source || (source = []);
            if (!array)
                return source;
            source.length = array.length;
            var i = 0, len = array.length;
            for (i = 0; i < len; i++) {
                source[i] = array[i];
            }
            return source;
        };
        Utils.getGlobalRecByPoints = function (sprite, x0, y0, x1, y1) {
            var newLTPoint;
            newLTPoint = new Point(x0, y0);
            newLTPoint = sprite.localToGlobal(newLTPoint);
            var newRBPoint;
            newRBPoint = new Point(x1, y1);
            newRBPoint = sprite.localToGlobal(newRBPoint);
            return Rectangle._getWrapRec([newLTPoint.x, newLTPoint.y, newRBPoint.x, newRBPoint.y]);
        };
        Utils.getGlobalPosAndScale = function (sprite) {
            return Utils.getGlobalRecByPoints(sprite, 0, 0, 1, 1);
        };
        Utils.bind = function (fun, scope) {
            var rst = fun;
            rst = fun.bind(scope);
            ;
            return rst;
        };
        Utils.measureText = function (txt, font) {
            return RunDriver.measureText(txt, font);
        };
        Utils.updateOrder = function (array) {
            if (!array || array.length < 2)
                return false;
            var i = 1, j = 0, len = array.length, key = NaN, c;
            while (i < len) {
                j = i;
                c = array[j];
                key = array[j]._zOrder;
                while (--j > -1) {
                    if (array[j]._zOrder > key)
                        array[j + 1] = array[j];
                    else
                        break;
                }
                array[j + 1] = c;
                i++;
            }
            ;
            var model = c.parent.conchModel;
            if (model) {
                if (model.updateZOrder != null) {
                    model.updateZOrder();
                }
                else {
                    for (i = 0; i < len; i++) {
                        model.removeChild(array[i].conchModel);
                    }
                    for (i = 0; i < len; i++) {
                        model.addChildAt(array[i].conchModel, i);
                    }
                }
            }
            return true;
        };
        Utils.transPointList = function (points, x, y) {
            var i = 0, len = points.length;
            for (i = 0; i < len; i += 2) {
                points[i] += x;
                points[i + 1] += y;
            }
        };
        Utils.parseInt = function (str, radix) {
            (radix === void 0) && (radix = 0);
            var result = Browser.window.parseInt(str, radix);
            if (isNaN(result))
                return 0;
            return result;
        };
        Utils.getFileExtension = function (path) {
            Utils._extReg.lastIndex = path.lastIndexOf(".");
            var result = Utils._extReg.exec(path);
            if (result && result.length > 1) {
                return result[1].toLowerCase();
            }
            return null;
        };
        Utils.getTransformRelativeToWindow = function (coordinateSpace, x, y) {
            var stage = Laya.stage;
            var globalTransform = laya.utils.Utils.getGlobalPosAndScale(coordinateSpace);
            var canvasMatrix = stage._canvasTransform.clone();
            var canvasLeft = canvasMatrix.tx;
            var canvasTop = canvasMatrix.ty;
            canvasMatrix.rotate(-Math.PI / 180 * Laya.stage.canvasDegree);
            canvasMatrix.scale(Laya.stage.clientScaleX, Laya.stage.clientScaleY);
            var perpendicular = (Laya.stage.canvasDegree % 180 != 0);
            var tx = NaN, ty = NaN;
            if (perpendicular) {
                tx = y + globalTransform.y;
                ty = x + globalTransform.x;
                tx *= canvasMatrix.d;
                ty *= canvasMatrix.a;
                if (Laya.stage.canvasDegree == 90) {
                    tx = canvasLeft - tx;
                    ty += canvasTop;
                }
                else {
                    tx += canvasLeft;
                    ty = canvasTop - ty;
                }
            }
            else {
                tx = x + globalTransform.x;
                ty = y + globalTransform.y;
                tx *= canvasMatrix.a;
                ty *= canvasMatrix.d;
                tx += canvasLeft;
                ty += canvasTop;
            }
            ;
            var domScaleX = NaN, domScaleY = NaN;
            if (perpendicular) {
                domScaleX = canvasMatrix.d * globalTransform.height;
                domScaleY = canvasMatrix.a * globalTransform.width;
            }
            else {
                domScaleX = canvasMatrix.a * globalTransform.width;
                domScaleY = canvasMatrix.d * globalTransform.height;
            }
            return { x: tx, y: ty, scaleX: domScaleX, scaleY: domScaleY };
        };
        Utils.fitDOMElementInArea = function (dom, coordinateSpace, x, y, width, height) {
            if (!dom._fitThe3AirInitialized) {
                dom._fitThe3AirInitialized = true;
                dom.style.transformOrigin = dom.style.webKittransformOrigin = "left top";
                dom.style.position = "absolute";
            }
            ;
            var transform = Utils.getTransformRelativeToWindow(coordinateSpace, x, y);
            dom.style.transform = dom.style.webkitTransform = "scale(" + transform.scaleX + "," + transform.scaleY + ") rotate(" + (Laya.stage.canvasDegree) + "deg)";
            dom.style.width = width + 'px';
            dom.style.height = height + 'px';
            dom.style.left = transform.x + 'px';
            dom.style.top = transform.y + 'px';
        };
        Utils.isOkTextureList = function (textureList) {
            if (!textureList)
                return false;
            var i = 0, len = textureList.length;
            var tTexture;
            for (i = 0; i < len; i++) {
                tTexture = textureList[i];
                if (!tTexture || !tTexture.source)
                    return false;
            }
            return true;
        };
        Utils.isOKCmdList = function (cmds) {
            if (!cmds)
                return false;
            var i = 0, len = cmds.length;
            var context = Render._context;
            var cmd;
            var tex;
            for (i = 0; i < len; i++) {
                cmd = cmds[i];
                switch (cmd.callee) {
                    case context._drawTexture:
                    case context._fillTexture:
                    case context._drawTextureWithTransform:
                        tex = cmd[0];
                        if (!tex || !tex.source)
                            return false;
                }
            }
            return true;
        };
        Utils._gid = 1;
        Utils._pi = 180 / Math.PI;
        Utils._pi2 = Math.PI / 180;
        Utils._extReg = /\.(\w+)\??/g;
        Utils.parseXMLFromString = function (value) {
            var rst;
            value = value.replace(/>\s+</g, '><');
            rst = (new DOMParser()).parseFromString(value, 'text/xml');
            if (rst.firstChild.textContent.indexOf("This page contains the following errors") > -1) {
                throw new Error(rst.firstChild.firstChild.textContent);
            }
            return rst;
        };
        return Utils;
    })();
    var VectorGraphManager = (function () {
        function VectorGraphManager() {
            this.useDic = {};
            this.shapeDic = {};
            this.shapeLineDic = {};
            this._id = 0;
            this._checkKey = false;
            this._freeIdArray = [];
            if (Render.isWebGL) {
                CacheManager.regCacheByFunction(Utils.bind(this.startDispose, this), Utils.bind(this.getCacheList, this));
            }
        }
        __class(VectorGraphManager, 'laya.utils.VectorGraphManager');
        var __proto = VectorGraphManager.prototype;
        __proto.getId = function () {
            return this._id++;
        };
        __proto.addShape = function (id, shape) {
            this.shapeDic[id] = shape;
            if (!this.useDic[id]) {
                this.useDic[id] = true;
            }
        };
        __proto.addLine = function (id, Line) {
            this.shapeLineDic[id] = Line;
            if (!this.shapeLineDic[id]) {
                this.shapeLineDic[id] = true;
            }
        };
        __proto.getShape = function (id) {
            if (this._checkKey) {
                if (this.useDic[id] != null) {
                    this.useDic[id] = true;
                }
            }
        };
        __proto.deleteShape = function (id) {
            if (this.shapeDic[id]) {
                this.shapeDic[id] = null;
                delete this.shapeDic[id];
            }
            if (this.shapeLineDic[id]) {
                this.shapeLineDic[id] = null;
                delete this.shapeLineDic[id];
            }
            if (this.useDic[id] != null) {
                delete this.useDic[id];
            }
        };
        __proto.getCacheList = function () {
            var str;
            var list = [];
            for (str in this.shapeDic) {
                list.push(this.shapeDic[str]);
            }
            for (str in this.shapeLineDic) {
                list.push(this.shapeLineDic[str]);
            }
            return list;
        };
        __proto.startDispose = function (key) {
            var str;
            for (str in this.useDic) {
                this.useDic[str] = false;
            }
            this._checkKey = true;
        };
        __proto.endDispose = function () {
            if (this._checkKey) {
                var str;
                for (str in this.useDic) {
                    if (!this.useDic[str]) {
                        this.deleteShape(str);
                    }
                }
                this._checkKey = false;
            }
        };
        VectorGraphManager.getInstance = function () {
            return VectorGraphManager.instance = VectorGraphManager.instance || new VectorGraphManager();
        };
        VectorGraphManager.instance = null;
        return VectorGraphManager;
    })();
    var WeakObject = (function () {
        function WeakObject() {
            this._obj = null;
            this._obj = WeakObject.supportWeakMap ? new Browser.window.WeakMap() : {};
            if (!WeakObject.supportWeakMap)
                WeakObject._maps.push(this);
        }
        __class(WeakObject, 'laya.utils.WeakObject');
        var __proto = WeakObject.prototype;
        __proto.set = function (key, value) {
            if (key == null)
                return;
            if (WeakObject.supportWeakMap) {
                var objKey = key;
                if ((typeof key == 'string') || (typeof key == 'number')) {
                    objKey = WeakObject._keys[key];
                    if (!objKey)
                        objKey = WeakObject._keys[key] = { k: key };
                }
                this._obj.set(objKey, value);
            }
            else {
                if ((typeof key == 'string') || (typeof key == 'number')) {
                    this._obj[key] = value;
                }
                else {
                    key.$_GID || (key.$_GID = Utils.getGID());
                    this._obj[key.$_GID] = value;
                }
            }
        };
        __proto.get = function (key) {
            if (key == null)
                return null;
            if (WeakObject.supportWeakMap) {
                var objKey = ((typeof key == 'string') || (typeof key == 'number')) ? WeakObject._keys[key] : key;
                if (!objKey)
                    return null;
                return this._obj.get(objKey);
            }
            else {
                if ((typeof key == 'string') || (typeof key == 'number'))
                    return this._obj[key];
                return this._obj[key.$_GID];
            }
        };
        __proto.del = function (key) {
            if (key == null)
                return;
            if (WeakObject.supportWeakMap) {
                var objKey = ((typeof key == 'string') || (typeof key == 'number')) ? WeakObject._keys[key] : key;
                if (!objKey)
                    return;
                this._obj.delete(objKey);
            }
            else {
                if ((typeof key == 'string') || (typeof key == 'number'))
                    delete this._obj[key];
                else
                    delete this._obj[this._obj.$_GID];
            }
        };
        __proto.has = function (key) {
            if (key == null)
                return false;
            if (WeakObject.supportWeakMap) {
                var objKey = ((typeof key == 'string') || (typeof key == 'number')) ? WeakObject._keys[key] : key;
                return this._obj.has(objKey);
            }
            else {
                if ((typeof key == 'string') || (typeof key == 'number'))
                    return this._obj[key] != null;
                return this._obj[this._obj.$_GID] != null;
            }
        };
        WeakObject.__init__ = function () {
            WeakObject.supportWeakMap = Browser.window.WeakMap != null;
            if (!WeakObject.supportWeakMap)
                Laya.timer.loop(WeakObject.delInterval, null, WeakObject.clearCache);
        };
        WeakObject.clearCache = function () {
            for (var i = 0, n = WeakObject._maps.length; i < n; i++) {
                var obj = WeakObject._maps[i];
                obj._obj = {};
            }
        };
        WeakObject.supportWeakMap = false;
        WeakObject.delInterval = 5 * 60 * 1000;
        WeakObject._keys = {};
        WeakObject._maps = [];
        __static(WeakObject, ['I', function () { return this.I = new WeakObject(); }
        ]);
        return WeakObject;
    })();
    var WordText = (function () {
        function WordText() {
            this.id = NaN;
            this.save = [];
            this.toUpperCase = null;
            this.changed = false;
            this._text = null;
        }
        __class(WordText, 'laya.utils.WordText');
        var __proto = WordText.prototype;
        __proto.setText = function (txt, letterSpacing, stroke) {
            this.changed = true;
            this._text = txt;
            this._letterSpacing = letterSpacing ? letterSpacing * (stroke ? 2 : 1) : 0;

        };
        __proto.toString = function () {
            return this._text;
        };
        __proto.charCodeAt = function (i) {
            return this._text ? this._text.charCodeAt(i) : NaN;
        };
        __proto.charAt = function (i) {
            return this._text ? this._text.charAt(i) : null;
        };
        __getset(0, __proto, 'length', function () {
            return this._text ? this._text.length : 0;
        });
        return WordText;
    })();
    var Node = (function (_super) {
        function Node() {
            this._bits = 0;
            this._displayedInStage = false;
            this._parent = null;
            this.conchModel = null;
            this.name = "";
            this._destroyed = false;
            Node.__super.call(this);
            this._childs = Node.ARRAY_EMPTY;
            this._$P = Node.PROP_EMPTY;
            this.timer = Laya.scaleTimer;
            this.conchModel = Render.isConchNode ? this.createConchModel() : null;
        }
        __class(Node, 'laya.display.Node', _super);
        var __proto = Node.prototype;
        __proto._setBit = function (type, value) {
            if (type == 0x1) {
                var preValue = this._getBit(type);
                if (preValue != value) {
                    this._updateDisplayedInstage();
                }
            }
            if (value) {
                this._bits |= type;
            }
            else {
                this._bits &= ~type;
            }
        };
        __proto._getBit = function (type) {
            return (this._bits & type) != 0;
        };
        __proto._setUpNoticeChain = function () {
            if (this._getBit(0x1)) {
                this._setUpNoticeType(0x1);
            }
        };
        __proto._setUpNoticeType = function (type) {
            var ele = this;
            ele._setBit(type, true);
            ele = ele.parent;
            while (ele) {
                if (ele._getBit(type))
                    return;
                ele._setBit(type, true);
                ele = ele.parent;
            }
        };
        __proto.on = function (type, caller, listener, args) {
            if (type === "display" || type === "undisplay") {
                if (!this._getBit(0x1)) {
                    this._setUpNoticeType(0x1);
                }
            }
            return this._createListener(type, caller, listener, args, false);
        };
        __proto.once = function (type, caller, listener, args) {
            if (type === "display" || type === "undisplay") {
                if (!this._getBit(0x1)) {
                    this._setUpNoticeType(0x1);
                }
            }
            return this._createListener(type, caller, listener, args, true);
        };
        __proto.createConchModel = function () {
            return null;
        };
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            this._destroyed = true;
            this._parent && this._parent.removeChild(this);
            if (this._childs) {
                if (destroyChild)
                    this.destroyChildren();
                else
                    this.removeChildren();
            }
            this._childs = null;
            this._$P = null;
            this.offAll();
            this.timer.clearAll(this);
        };
        __proto.destroyChildren = function () {
            if (this._childs) {
                for (var i = this._childs.length - 1; i > -1; i--) {
                    this._childs[i].destroy(true);
                }
            }
        };
        __proto.addChild = function (node) {
            if (!node || this.destroyed || node === this)
                return node;
            if ((node).zOrder)
                this._set$P("hasZorder", true);
            if (node._parent === this) {
                var index = this.getChildIndex(node);
                if (index !== this._childs.length - 1) {
                    this._childs.splice(index, 1);
                    this._childs.push(node);
                    if (this.conchModel) {
                        this.conchModel.removeChild(node.conchModel);
                        this.conchModel.addChildAt(node.conchModel, this._childs.length - 1);
                    }
                    this._childChanged();
                }
            }
            else {
                node.parent && node.parent.removeChild(node);
                this._childs === Node.ARRAY_EMPTY && (this._childs = []);
                this._childs.push(node);
                this.conchModel && this.conchModel.addChildAt(node.conchModel, this._childs.length - 1);
                node.parent = this;
                this._childChanged();
            }
            return node;
        };
        __proto.addChildren = function (__args) {
            var args = arguments;
            var i = 0, n = args.length;
            while (i < n) {
                this.addChild(args[i++]);
            }
        };
        __proto.addChildAt = function (node, index) {
            if (!node || this.destroyed || node === this)
                return node;
            if ((node).zOrder)
                this._set$P("hasZorder", true);
            if (index >= 0 && index <= this._childs.length) {
                if (node._parent === this) {
                    var oldIndex = this.getChildIndex(node);
                    this._childs.splice(oldIndex, 1);
                    this._childs.splice(index, 0, node);
                    if (this.conchModel) {
                        this.conchModel.removeChild(node.conchModel);
                        this.conchModel.addChildAt(node.conchModel, index);
                    }
                    this._childChanged();
                }
                else {
                    node.parent && node.parent.removeChild(node);
                    this._childs === Node.ARRAY_EMPTY && (this._childs = []);
                    this._childs.splice(index, 0, node);
                    this.conchModel && this.conchModel.addChildAt(node.conchModel, index);
                    node.parent = this;
                }
                return node;
            }
            else {
                throw new Error("appendChildAt:The index is out of bounds");
            }
        };
        __proto.getChildIndex = function (node) {
            return this._childs.indexOf(node);
        };
        __proto.getChildByName = function (name) {
            var nodes = this._childs;
            if (nodes) {
                for (var i = 0, n = nodes.length; i < n; i++) {
                    var node = nodes[i];
                    if (node.name === name)
                        return node;
                }
            }
            return null;
        };
        __proto._get$P = function (key) {
            return this._$P[key];
        };
        __proto._set$P = function (key, value) {
            if (!this.destroyed) {
                this._$P === Node.PROP_EMPTY && (this._$P = {});
                this._$P[key] = value;
            }
            return value;
        };
        __proto.getChildAt = function (index) {
            return this._childs[index];
        };
        __proto.setChildIndex = function (node, index) {
            var childs = this._childs;
            if (index < 0 || index >= childs.length) {
                throw new Error("setChildIndex:The index is out of bounds.");
            }
            ;
            var oldIndex = this.getChildIndex(node);
            if (oldIndex < 0)
                throw new Error("setChildIndex:node is must child of this object.");
            childs.splice(oldIndex, 1);
            childs.splice(index, 0, node);
            if (this.conchModel) {
                this.conchModel.removeChild(node.conchModel);
                this.conchModel.addChildAt(node.conchModel, index);
            }
            this._childChanged();
            return node;
        };
        __proto._childChanged = function (child) { };
        __proto.removeChild = function (node) {
            if (!this._childs)
                return node;
            var index = this._childs.indexOf(node);
            return this.removeChildAt(index);
        };
        __proto.removeSelf = function () {
            this._parent && this._parent.removeChild(this);
            return this;
        };
        __proto.removeChildByName = function (name) {
            var node = this.getChildByName(name);
            node && this.removeChild(node);
            return node;
        };
        __proto.removeChildAt = function (index) {
            var node = this.getChildAt(index);
            if (node) {
                this._childs.splice(index, 1);
                this.conchModel && this.conchModel.removeChild(node.conchModel);
                node.parent = null;
            }
            return node;
        };
        __proto.removeChildren = function (beginIndex, endIndex) {
            (beginIndex === void 0) && (beginIndex = 0);
            (endIndex === void 0) && (endIndex = 0x7fffffff);
            if (this._childs && this._childs.length > 0) {
                var childs = this._childs;
                if (beginIndex === 0 && endIndex >= n) {
                    var arr = childs;
                    this._childs = Node.ARRAY_EMPTY;
                }
                else {
                    arr = childs.splice(beginIndex, endIndex - beginIndex);
                }
                for (var i = 0, n = arr.length; i < n; i++) {
                    arr[i].parent = null;
                    this.conchModel && this.conchModel.removeChild(arr[i].conchModel);
                }
            }
            return this;
        };
        __proto.replaceChild = function (newNode, oldNode) {
            var index = this._childs.indexOf(oldNode);
            if (index > -1) {
                this._childs.splice(index, 1, newNode);
                if (this.conchModel) {
                    this.conchModel.removeChild(oldNode.conchModel);
                    this.conchModel.addChildAt(newNode.conchModel, index);
                }
                oldNode.parent = null;
                newNode.parent = this;
                return newNode;
            }
            return null;
        };
        __proto._updateDisplayedInstage = function () {
            var ele;
            ele = this;
            var stage = Laya.stage;
            this._displayedInStage = false;
            while (ele) {
                if (ele._getBit(0x1)) {
                    this._displayedInStage = ele._displayedInStage;
                    break;
                }
                if (ele == stage || ele._displayedInStage) {
                    this._displayedInStage = true;
                    break;
                }
                ele = ele.parent;
            }
        };
        __proto._setDisplay = function (value) {
            if (this._displayedInStage !== value) {
                this._displayedInStage = value;
                if (value)
                    this.event("display");
                else
                    this.event("undisplay");
            }
        };
        __proto._displayChild = function (node, display) {
            var childs = node._childs;
            if (childs) {
                for (var i = 0, n = childs.length; i < n; i++) {
                    var child = childs[i];
                    if (!child._getBit(0x1))
                        continue;
                    if (child._childs.length > 0) {
                        this._displayChild(child, display);
                    }
                    else {
                        child._setDisplay(display);
                    }
                }
            }
            node._setDisplay(display);
        };
        __proto.contains = function (node) {
            if (node === this)
                return true;
            while (node) {
                if (node.parent === this)
                    return true;
                node = node.parent;
            }
            return false;
        };
        __proto.timerLoop = function (delay, caller, method, args, coverBefore, jumpFrame) {
            (coverBefore === void 0) && (coverBefore = true);
            (jumpFrame === void 0) && (jumpFrame = false);
            this.timer.loop(delay, caller, method, args, coverBefore, jumpFrame);
        };
        __proto.timerOnce = function (delay, caller, method, args, coverBefore) {
            (coverBefore === void 0) && (coverBefore = true);
            this.timer._create(false, false, delay, caller, method, args, coverBefore);
        };
        __proto.frameLoop = function (delay, caller, method, args, coverBefore) {
            (coverBefore === void 0) && (coverBefore = true);
            this.timer._create(true, true, delay, caller, method, args, coverBefore);
        };
        __proto.frameOnce = function (delay, caller, method, args, coverBefore) {
            (coverBefore === void 0) && (coverBefore = true);
            this.timer._create(true, false, delay, caller, method, args, coverBefore);
        };
        __proto.clearTimer = function (caller, method) {
            this.timer.clear(caller, method);
        };
        __getset(0, __proto, 'numChildren', function () {
            return this._childs.length;
        });
        __getset(0, __proto, 'destroyed', function () {
            return this._destroyed;
        });
        __getset(0, __proto, 'parent', function () {
            return this._parent;
        }, function (value) {
            if (this._parent !== value) {
                if (value) {
                    this._parent = value;
                    this.event("added");
                    if (this._getBit(0x1)) {
                        this._setUpNoticeChain();
                        value.displayedInStage && this._displayChild(this, true);
                    }
                    value._childChanged(this);
                }
                else {
                    this.event("removed");
                    this._parent._childChanged();
                    if (this._getBit(0x1))
                        this._displayChild(this, false);
                    this._parent = value;
                }
            }
        });
        __getset(0, __proto, 'displayedInStage', function () {
            if (this._getBit(0x1))
                return this._displayedInStage;
            this._setUpNoticeType(0x1);
            return this._displayedInStage;
        });
        Node.ARRAY_EMPTY = [];
        Node.PROP_EMPTY = {};
        Node.NOTICE_DISPLAY = 0x1;
        Node.MOUSEENABLE = 0x2;
        return Node;
    })(EventDispatcher);
    var CSSStyle = (function (_super) {
        function CSSStyle(ower) {
            this._bgground = null;
            this._border = null;
            this._rect = null;
            this.underLine = 0;
            this.lineHeight = 0;
            CSSStyle.__super.call(this);
            this._padding = CSSStyle._PADDING;
            this._spacing = CSSStyle._SPACING;
            this._aligns = CSSStyle._ALIGNS;
            this._font = Font.EMPTY;
            this._ower = ower;
        }
        __class(CSSStyle, 'laya.display.css.CSSStyle', _super);
        var __proto = CSSStyle.prototype;
        __proto.destroy = function () {
            this._ower = null;
            this._font = null;
            this._rect = null;
        };
        __proto.inherit = function (src) {
            this._font = src._font;
            this._spacing = src._spacing === CSSStyle._SPACING ? CSSStyle._SPACING : src._spacing.slice();
            this.lineHeight = src.lineHeight;
        };
        __proto._widthAuto = function () {
            return (this._type & 0x40000) !== 0;
        };
        __proto.widthed = function (sprite) {
            return (this._type & 0x8) != 0;
        };
        __proto._calculation = function (type, value) {
            if (value.indexOf('%') < 0)
                return false;
            var ower = this._ower;
            var parent = ower.parent;
            var rect = this._rect;
            function getValue(pw, w, nums) {
                return (pw * nums[0] + w * nums[1] + nums[2]);
            }
            function onParentResize(type) {
                var pw = parent.width, w = ower.width;
                rect.width && (ower.width = getValue(pw, w, rect.width));
                rect.height && (ower.height = getValue(pw, w, rect.height));
                rect.left && (ower.x = getValue(pw, w, rect.left));
                rect.top && (ower.y = getValue(pw, w, rect.top));
            }
            if (rect === null) {
                parent._getCSSStyle()._type |= 0x80000;
                parent.on("resize", this, onParentResize);
                this._rect = rect = { input: {} };
            }
            ;
            var nums = value.split(' ');
            nums[0] = parseFloat(nums[0]) / 100;
            if (nums.length == 1)
                nums[1] = nums[2] = 0;
            else {
                nums[1] = parseFloat(nums[1]) / 100;
                nums[2] = parseFloat(nums[2]);
            }
            rect[type] = nums;
            rect.input[type] = value;
            onParentResize(type);
            return true;
        };
        __proto.heighted = function (sprite) {
            return (this._type & 0x2000) != 0;
        };
        __proto.size = function (w, h) {
            var ower = this._ower;
            var resize = false;
            if (w !== -1 && w != this._ower.width) {
                this._type |= 0x8;
                this._ower.width = w;
                resize = true;
            }
            if (h !== -1 && h != this._ower.height) {
                this._type |= 0x2000;
                this._ower.height = h;
                resize = true;
            }
            if (resize) {
                ower._layoutLater();
                (this._type & 0x80000) && ower.event("resize", this);
            }
        };
        __proto._getAlign = function () {
            return this._aligns[0];
        };
        __proto._getValign = function () {
            return this._aligns[1];
        };
        __proto._getCssFloat = function () {
            return (this._type & 0x8000) != 0 ? 0x8000 : 0;
        };
        __proto._createFont = function () {
            return (this._type & 0x1000) ? this._font : (this._type |= 0x1000, this._font = new Font(this._font));
        };
        __proto.render = function (sprite, context, x, y) {
            var w = sprite.width;
            var h = sprite.height;
            x -= sprite.pivotX;
            y -= sprite.pivotY;
            this._bgground && this._bgground.color != null && context.ctx.fillRect(x, y, w, h, this._bgground.color);
            this._border && this._border.color && context.drawRect(x, y, w, h, this._border.color.strColor, this._border.size);
        };
        __proto.getCSSStyle = function () {
            return this;
        };
        __proto.cssText = function (text) {
            this.attrs(CSSStyle.parseOneCSS(text, ';'));
        };
        __proto.attrs = function (attrs) {
            if (attrs) {
                for (var i = 0, n = attrs.length; i < n; i++) {
                    var attr = attrs[i];
                    this[attr[0]] = attr[1];
                }
            }
        };
        __proto.setTransform = function (value) {
            (value === 'none') ? (this._tf = Style._TF_EMPTY) : this.attrs(CSSStyle.parseOneCSS(value, ','));
        };
        __proto.translate = function (x, y) {
            this._tf === Style._TF_EMPTY && (this._tf = new TransformInfo());
            this._tf.translateX = x;
            this._tf.translateY = y;
        };
        __proto.scale = function (x, y) {
            this._tf === Style._TF_EMPTY && (this._tf = new TransformInfo());
            this._tf.scaleX = x;
            this._tf.scaleY = y;
        };
        __proto._enableLayout = function () {
            return (this._type & 0x2) === 0 && (this._type & 0x4) === 0;
        };
        __getset(0, __proto, 'block', _super.prototype._$get_block, function (value) {
            value ? (this._type |= 0x1) : (this._type &= (~0x1));
        });
        __getset(0, __proto, 'valign', function () {
            return CSSStyle._valigndef[this._aligns[1]];
        }, function (value) {
            this._aligns === CSSStyle._ALIGNS && (this._aligns = [0, 0, 0]);
            this._aligns[1] = CSSStyle._valigndef[value];
        });
        __getset(0, __proto, 'height', null, function (h) {
            this._type |= 0x2000;
            if ((typeof h == 'string')) {
                if (this._calculation("height", h))
                    return;
                h = parseInt(h);
            }
            this.size(-1, h);
        });
        __getset(0, __proto, 'width', null, function (w) {
            this._type |= 0x8;
            if ((typeof w == 'string')) {
                var offset = w.indexOf('auto');
                if (offset >= 0) {
                    this._type |= 0x40000;
                    w = w.substr(0, offset);
                }
                if (this._calculation("width", w))
                    return;
                w = parseInt(w);
            }
            this.size(w, -1);
        });
        __getset(0, __proto, 'fontWeight', function () {
            return this._font.weight;
        }, function (value) {
            this._createFont().weight = value;
        });
        __getset(0, __proto, 'left', null, function (value) {
            var ower = this._ower;
            if (((typeof value == 'string'))) {
                if (value === "center")
                    value = "50% -50% 0";
                else if (value === "right")
                    value = "100% -100% 0";
                if (this._calculation("left", value))
                    return;
                value = parseInt(value);
            }
            ower.x = value;
        });
        __getset(0, __proto, '_translate', null, function (value) {
            this.translate(value[0], value[1]);
        });
        __getset(0, __proto, 'absolute', function () {
            return (this._type & 0x4) !== 0;
        });
        __getset(0, __proto, 'top', null, function (value) {
            var ower = this._ower;
            if (((typeof value == 'string'))) {
                if (value === "middle")
                    value = "50% -50% 0";
                else if (value === "bottom")
                    value = "100% -100% 0";
                if (this._calculation("top", value))
                    return;
                value = parseInt(value);
            }
            ower.y = value;
        });
        __getset(0, __proto, 'align', function () {
            return CSSStyle._aligndef[this._aligns[0]];
        }, function (value) {
            this._aligns === CSSStyle._ALIGNS && (this._aligns = [0, 0, 0]);
            this._aligns[0] = CSSStyle._aligndef[value];
        });
        __getset(0, __proto, 'bold', function () {
            return this._font.bold;
        }, function (value) {
            this._createFont().bold = value;
        });
        __getset(0, __proto, 'padding', function () {
            return this._padding;
        }, function (value) {
            this._padding = value;
        });
        __getset(0, __proto, 'leading', function () {
            return this._spacing[1];
        }, function (d) {
            ((typeof d == 'string')) && (d = parseInt(d + ""));
            this._spacing === CSSStyle._SPACING && (this._spacing = [0, 0]);
            this._spacing[1] = d;
        });
        __getset(0, __proto, 'lineElement', function () {
            return (this._type & 0x10000) != 0;
        }, function (value) {
            value ? (this._type |= 0x10000) : (this._type &= (~0x10000));
        });
        __getset(0, __proto, 'cssFloat', function () {
            return (this._type & 0x8000) != 0 ? "right" : "left";
        }, function (value) {
            this.lineElement = false;
            value === "right" ? (this._type |= 0x8000) : (this._type &= (~0x8000));
        });
        __getset(0, __proto, 'textDecoration', function () {
            return this._font.decoration;
        }, function (value) {
            this._createFont().decoration = value;
        });
        __getset(0, __proto, 'whiteSpace', function () {
            return (this._type & 0x20000) ? "nowrap" : "";
        }, function (type) {
            type === "nowrap" && (this._type |= 0x20000);
            type === "none" && (this._type &= ~0x20000);
        });
        __getset(0, __proto, 'background', null, function (value) {
            if (!value) {
                this._bgground = null;
                return;
            }
            this._bgground || (this._bgground = {});
            this._bgground.color = value;
            this._ower.conchModel && this._ower.conchModel.bgColor(value);
            this._type |= 0x4000;
            this._ower._renderType |= 0x100;
        });
        __getset(0, __proto, 'wordWrap', function () {
            return (this._type & 0x20000) === 0;
        }, function (value) {
            value ? (this._type &= ~0x20000) : (this._type |= 0x20000);
        });
        __getset(0, __proto, 'color', function () {
            return this._font.color;
        }, function (value) {
            this._createFont().color = value;
        });
        __getset(0, __proto, 'password', function () {
            return this._font.password;
        }, function (value) {
            this._createFont().password = value;
        });
        __getset(0, __proto, 'backgroundColor', function () {
            return this._bgground ? this._bgground.color : null;
        }, function (value) {
            if (value === 'none')
                this._bgground = null;
            else
                (this._bgground || (this._bgground = {}), this._bgground.color = value);
            this._ower.conchModel && this._ower.conchModel.bgColor(value);
            this._ower._renderType |= 0x100;
        });
        __getset(0, __proto, 'font', function () {
            return this._font.toString();
        }, function (value) {
            this._createFont().set(value);
        });
        __getset(0, __proto, 'weight', null, function (value) {
            this._createFont().weight = value;
        });
        __getset(0, __proto, 'letterSpacing', function () {
            return this._spacing[0];
        }, function (d) {
            ((typeof d == 'string')) && (d = parseInt(d + ""));
            this._spacing === CSSStyle._SPACING && (this._spacing = [0, 0]);
            this._spacing[0] = d;
        });
        __getset(0, __proto, 'fontSize', function () {
            return this._font.size;
        }, function (value) {
            this._createFont().size = value;
        });
        __getset(0, __proto, 'italic', function () {
            return this._font.italic;
        }, function (value) {
            this._createFont().italic = value;
        });
        __getset(0, __proto, 'fontFamily', function () {
            return this._font.family;
        }, function (value) {
            this._createFont().family = value;
        });
        __getset(0, __proto, 'stroke', function () {
            return this._font.stroke[0];
        }, function (value) {
            if (this._createFont().stroke === Font._STROKE)
                this._font.stroke = [0, "#000000"];
            this._font.stroke[0] = value;
        });
        __getset(0, __proto, 'strokeColor', function () {
            return this._font.stroke[1];
        }, function (value) {
            if (this._createFont().stroke === Font._STROKE)
                this._font.stroke = [0, "#000000"];
            this._font.stroke[1] = value;
        });
        __getset(0, __proto, 'border', function () {
            return this._border ? this._border.value : "";
        }, function (value) {
            if (value == 'none') {
                this._border = null;
                return;
            }
            this._border || (this._border = {});
            this._border.value = value;
            var values = value.split(' ');
            this._border.color = Color.create(values[values.length - 1]);
            if (values.length == 1) {
                this._border.size = 1;
                this._border.type = 'solid';
                return;
            }
            ;
            var i = 0;
            if (values[0].indexOf('px') > 0) {
                this._border.size = parseInt(values[0]);
                i++;
            }
            else
                this._border.size = 1;
            this._border.type = values[i];
            this._ower._renderType |= 0x100;
        });
        __getset(0, __proto, 'borderColor', function () {
            return (this._border && this._border.color) ? this._border.color.strColor : null;
        }, function (value) {
            if (!value) {
                this._border = null;
                return;
            }
            this._border || (this._border = { size: 1, type: 'solid' });
            this._border.color = (value == null) ? null : Color.create(value);
            this._ower.conchModel && this._ower.conchModel.border(this._border.color.strColor);
            this._ower._renderType |= 0x100;
        });
        __getset(0, __proto, 'position', function () {
            return (this._type & 0x4) ? "absolute" : "";
        }, function (value) {
            value == "absolute" ? (this._type |= 0x4) : (this._type &= ~0x4);
        });
        __getset(0, __proto, 'display', null, function (value) {
            switch (value) {
                case '':
                    this._type &= ~0x2;
                    this.visible = true;
                    break;
                case 'none':
                    this._type |= 0x2;
                    this.visible = false;
                    this._ower._layoutLater();
                    break;
            }
        });
        __getset(0, __proto, 'paddingLeft', function () {
            return this.padding[3];
        });
        __getset(0, __proto, 'paddingTop', function () {
            return this.padding[0];
        });
        __getset(0, __proto, '_scale', null, function (value) {
            this._ower.scale(value[0], value[1]);
        });
        __getset(0, __proto, '_rotate', null, function (value) {
            this._ower.rotation = value;
        });
        CSSStyle.parseOneCSS = function (text, clipWord) {
            var out = [];
            var attrs = text.split(clipWord);
            var valueArray;
            for (var i = 0, n = attrs.length; i < n; i++) {
                var attr = attrs[i];
                var ofs = attr.indexOf(':');
                var name = attr.substr(0, ofs).replace(/^\s+|\s+$/g, '');
                if (name.length == 0)
                    continue;
                var value = attr.substr(ofs + 1).replace(/^\s+|\s+$/g, '');
                var one = [name, value];
                switch (name) {
                    case 'italic':
                    case 'bold':
                        one[1] = value == "true";
                        break;
                    case 'line-height':
                        one[0] = 'lineHeight';
                        one[1] = parseInt(value);
                        break;
                    case 'font-size':
                        one[0] = 'fontSize';
                        one[1] = parseInt(value);
                        break;
                    case 'padding':
                        valueArray = value.split(' ');
                        valueArray.length > 1 || (valueArray[1] = valueArray[2] = valueArray[3] = valueArray[0]);
                        one[1] = [parseInt(valueArray[0]), parseInt(valueArray[1]), parseInt(valueArray[2]), parseInt(valueArray[3])];
                        break;
                    case 'rotate':
                        one[0] = "_rotate";
                        one[1] = parseFloat(value);
                        break;
                    case 'scale':
                        valueArray = value.split(' ');
                        one[0] = "_scale";
                        one[1] = [parseFloat(valueArray[0]), parseFloat(valueArray[1])];
                        break;
                    case 'translate':
                        valueArray = value.split(' ');
                        one[0] = "_translate";
                        one[1] = [parseInt(valueArray[0]), parseInt(valueArray[1])];
                        break;
                    default:
                        (one[0] = CSSStyle._CSSTOVALUE[name]) || (one[0] = name);
                }
                out.push(one);
            }
            return out;
        };
        CSSStyle.parseCSS = function (text, uri) {
            var one;
            while ((one = CSSStyle._parseCSSRegExp.exec(text)) != null) {
                CSSStyle.styleSheets[one[1]] = CSSStyle.parseOneCSS(one[2], ';');
            }
        };
        CSSStyle.EMPTY = new CSSStyle(null);
        CSSStyle._CSSTOVALUE = { 'letter-spacing': 'letterSpacing', 'line-spacing': 'lineSpacing', 'white-space': 'whiteSpace', 'line-height': 'lineHeight', 'scale-x': 'scaleX', 'scale-y': 'scaleY', 'translate-x': 'translateX', 'translate-y': 'translateY', 'font-family': 'fontFamily', 'font-weight': 'fontWeight', 'vertical-align': 'valign', 'text-decoration': 'textDecoration', 'background-color': 'backgroundColor', 'border-color': 'borderColor', 'float': 'cssFloat' };
        CSSStyle._parseCSSRegExp = new RegExp("([\.\#]\\w+)\\s*{([\\s\\S]*?)}", "g");
        CSSStyle._aligndef = { 'left': 0, 'center': 1, 'right': 2, 0: 'left', 1: 'center', 2: 'right' };
        CSSStyle._valigndef = { 'top': 0, 'middle': 1, 'bottom': 2, 0: 'top', 1: 'middle', 2: 'bottom' };
        CSSStyle.styleSheets = {};
        CSSStyle.ALIGN_CENTER = 1;
        CSSStyle.ALIGN_RIGHT = 2;
        CSSStyle.VALIGN_MIDDLE = 1;
        CSSStyle.VALIGN_BOTTOM = 2;
        CSSStyle._CSS_BLOCK = 0x1;
        CSSStyle._DISPLAY_NONE = 0x2;
        CSSStyle._ABSOLUTE = 0x4;
        CSSStyle._WIDTH_SET = 0x8;
        CSSStyle._PADDING = [0, 0, 0, 0];
        CSSStyle._RECT = [-1, -1, -1, -1];
        CSSStyle._SPACING = [0, 0];
        CSSStyle._ALIGNS = [0, 0, 0];
        CSSStyle.ADDLAYOUTED = 0x200;
        CSSStyle._NEWFONT = 0x1000;
        CSSStyle._HEIGHT_SET = 0x2000;
        CSSStyle._BACKGROUND_SET = 0x4000;
        CSSStyle._FLOAT_RIGHT = 0x8000;
        CSSStyle._LINE_ELEMENT = 0x10000;
        CSSStyle._NOWARP = 0x20000;
        CSSStyle._WIDTHAUTO = 0x40000;
        CSSStyle._LISTERRESZIE = 0x80000;
        return CSSStyle;
    })(Style);
    var AudioSound = (function (_super) {
        function AudioSound() {
            this.url = null;
            this.audio = null;
            this.loaded = false;
            AudioSound.__super.call(this);
        }
        __class(AudioSound, 'laya.media.h5audio.AudioSound', _super);
        var __proto = AudioSound.prototype;
        __proto.dispose = function () {
            var ad = AudioSound._audioCache[this.url];
            if (ad) {
                ad.src = "";
                delete AudioSound._audioCache[this.url];
            }
        };
        __proto.load = function (url) {
            url = URL.formatURL(url);
            this.url = url;
            var ad;
            if (url == SoundManager._tMusic) {
                AudioSound._initMusicAudio();
                ad = AudioSound._musicAudio;
                if (ad.src != url) {
                    AudioSound._audioCache[ad.src] = null;
                    ad = null;
                }
            }
            else {
                ad = AudioSound._audioCache[url];
            }
            if (ad && ad.readyState >= 2) {
                this.event("complete");
                return;
            }
            if (!ad) {
                if (url == SoundManager._tMusic) {
                    AudioSound._initMusicAudio();
                    ad = AudioSound._musicAudio;
                }
                else {
                    ad = Browser.createElement("audio");
                }
                AudioSound._audioCache[url] = ad;
                ad.src = url;
            }
            ad.addEventListener("canplaythrough", onLoaded);
            ad.addEventListener("error", onErr);
            var me = this;
            function onLoaded() {
                offs();
                me.loaded = true;
                me.event("complete");
            }
            function onErr() {
                ad.load = null;
                offs();
                me.event("error");
            }
            function offs() {
                ad.removeEventListener("canplaythrough", onLoaded);
                ad.removeEventListener("error", onErr);
            }
            this.audio = ad;
            if (ad.load) {
                ad.load();
            }
            else {
                onErr();
            }
        };
        __proto.play = function (startTime, loops, playbackRate) {
            (startTime === void 0) && (startTime = 0);
            (loops === void 0) && (loops = 0);
            (playbackRate === void 0) && (playbackRate = 1);
            if (!this.url)
                return null;
            var ad;
            if (this.url == SoundManager._tMusic) {
                ad = AudioSound._musicAudio;
            }
            else {
                ad = AudioSound._audioCache[this.url];
            }
            if (!ad)
                return null;
            var tAd;
            tAd = Pool.getItem("audio:" + this.url);
            if (Render.isConchApp) {
                if (!tAd) {
                    tAd = Browser.createElement("audio");
                    tAd.src = this.url;
                }
            }
            else {
                if (this.url == SoundManager._tMusic) {
                    AudioSound._initMusicAudio();
                    tAd = AudioSound._musicAudio;
                    tAd.src = this.url;
                }
                else {
                    tAd = tAd ? tAd : ad.cloneNode(true);
                }
            }
            ;
            var channel = new AudioSoundChannel(tAd);
            channel.url = this.url;
            channel.loops = loops;
            channel.startTime = startTime;
            channel.playbackRate = playbackRate;
            channel.play();
            SoundManager.addChannel(channel);
            return channel;
        };
        __getset(0, __proto, 'duration', function () {
            var ad;
            ad = AudioSound._audioCache[this.url];
            if (!ad)
                return 0;
            return ad.duration;
        });
        AudioSound._initMusicAudio = function () {
            if (AudioSound._musicAudio)
                return;
            if (!AudioSound._musicAudio)
                AudioSound._musicAudio = Browser.createElement("audio");
            if (!Render.isConchApp) {
                Browser.document.addEventListener("mousedown", AudioSound._makeMusicOK);
            }
        };
        AudioSound._makeMusicOK = function () {
            Browser.document.removeEventListener("mousedown", AudioSound._makeMusicOK);
            if (!AudioSound._musicAudio.src) {
                AudioSound._musicAudio.src = "";
                AudioSound._musicAudio.load();
            }
            else {
                AudioSound._musicAudio.play();
            }
        };
        AudioSound._audioCache = {};
        AudioSound._musicAudio = null;
        return AudioSound;
    })(EventDispatcher);
    var SoundChannel = (function (_super) {
        function SoundChannel() {
            this.url = null;
            this.loops = 0;
            this.startTime = NaN;
            this.isStopped = false;
            this.completeHandler = null;
            SoundChannel.__super.call(this);
        }
        __class(SoundChannel, 'laya.media.SoundChannel', _super);
        var __proto = SoundChannel.prototype;
        __proto.play = function () { };
        __proto.stop = function () { };
        __proto.pause = function () { };
        __proto.resume = function () { };
        __proto.__runComplete = function (handler) {
            if (handler) {
                handler.run();
            }
        };
        __getset(0, __proto, 'volume', function () {
            return 1;
        }, function (v) {
        });
        __getset(0, __proto, 'position', function () {
            return 0;
        });
        __getset(0, __proto, 'duration', function () {
            return 0;
        });
        return SoundChannel;
    })(EventDispatcher);
    var Sound = (function (_super) {
        function Sound() {
            Sound.__super.call(this);
            ;
        }
        __class(Sound, 'laya.media.Sound', _super);
        var __proto = Sound.prototype;
        __proto.load = function (url) { };
        __proto.play = function (startTime, loops) {
            (startTime === void 0) && (startTime = 0);
            (loops === void 0) && (loops = 0);
            return null;
        };
        __proto.dispose = function () { };
        __getset(0, __proto, 'duration', function () {
            return 0;
        });
        return Sound;
    })(EventDispatcher);
    var WebAudioSound = (function (_super) {
        function WebAudioSound() {
            this.url = null;
            this.loaded = false;
            this.data = null;
            this.audioBuffer = null;
            this.__toPlays = null;
            WebAudioSound.__super.call(this);
        }
        __class(WebAudioSound, 'laya.media.webaudio.WebAudioSound', _super);
        var __proto = WebAudioSound.prototype;
        __proto.load = function (url) {
            var me = this;
            url = URL.formatURL(url);
            this.url = url;
            this.audioBuffer = WebAudioSound._dataCache[url];
            if (this.audioBuffer) {
                this._loaded(this.audioBuffer);
                return;
            }
            WebAudioSound.e.on("loaded:" + url, this, this._loaded);
            WebAudioSound.e.on("err:" + url, this, this._err);
            if (WebAudioSound.__loadingSound[url]) {
                return;
            }
            WebAudioSound.__loadingSound[url] = true;
            var request = new Browser.window.XMLHttpRequest();
            request.open("GET", url, true);
            request.responseType = "arraybuffer";
            request.onload = function () {
                me.data = request.response;
                WebAudioSound.buffs.push({ "buffer": me.data, "url": me.url });
                WebAudioSound.decode();
            };
            request.onerror = function (e) {
                me._err();
            };
            request.send();
        };
        __proto._err = function () {
            this._removeLoadEvents();
            WebAudioSound.__loadingSound[this.url] = false;
            this.event("error");
        };
        __proto._loaded = function (audioBuffer) {
            this._removeLoadEvents();
            this.audioBuffer = audioBuffer;
            WebAudioSound._dataCache[this.url] = this.audioBuffer;
            this.loaded = true;
            this.event("complete");
        };
        __proto._removeLoadEvents = function () {
            WebAudioSound.e.off("loaded:" + this.url, this, this._loaded);
            WebAudioSound.e.off("err:" + this.url, this, this._err);
        };
        __proto.__playAfterLoaded = function () {
            if (!this.__toPlays)
                return;
            var i = 0, len = 0;
            var toPlays;
            toPlays = this.__toPlays;
            len = toPlays.length;
            var tParams;
            for (i = 0; i < len; i++) {
                tParams = toPlays[i];
                if (tParams[3] && !(tParams[3]).isStopped) {
                    this.play(tParams[0], tParams[1], tParams[2], tParams[3]);
                }
            }
            this.__toPlays.length = 0;
        };
        __proto.play = function (startTime, loops, playbackRate, channel) {
            (startTime === void 0) && (startTime = 0);
            (loops === void 0) && (loops = 0);
            (playbackRate === void 0) && (playbackRate = 1);
            channel = channel ? channel : new WebAudioSoundChannel();
            if (!this.audioBuffer) {
                if (this.url) {
                    if (!this.__toPlays)
                        this.__toPlays = [];
                    this.__toPlays.push([startTime, loops, playbackRate, channel]);
                    this.once("complete", this, this.__playAfterLoaded);
                    this.load(this.url);
                }
            }
            channel.url = this.url;
            channel.loops = loops;
            channel["audioBuffer"] = this.audioBuffer;
            channel.playbackRate = playbackRate;
            channel.startTime = startTime;
            channel.play();
            SoundManager.addChannel(channel);
            return channel;
        };
        __proto.dispose = function () {
            delete WebAudioSound._dataCache[this.url];
            delete WebAudioSound.__loadingSound[this.url];
            this.audioBuffer = null;
            this.data = null;
            this.__toPlays = [];
        };
        __getset(0, __proto, 'duration', function () {
            if (this.audioBuffer) {
                return this.audioBuffer.duration;
            }
            return 0;
        });
        WebAudioSound.decode = function () {
            if (WebAudioSound.buffs.length <= 0 || WebAudioSound.isDecoding) {
                return;
            }
            WebAudioSound.isDecoding = true;
            WebAudioSound.tInfo = WebAudioSound.buffs.shift();
            WebAudioSound.ctx.decodeAudioData(WebAudioSound.tInfo["buffer"], WebAudioSound._done, WebAudioSound._fail);
        };
        WebAudioSound._done = function (audioBuffer) {
            WebAudioSound.e.event("loaded:" + WebAudioSound.tInfo.url, audioBuffer);
            WebAudioSound.isDecoding = false;
            WebAudioSound.decode();
        };
        WebAudioSound._fail = function () {
            WebAudioSound.e.event("err:" + WebAudioSound.tInfo.url, null);
            WebAudioSound.isDecoding = false;
            WebAudioSound.decode();
        };
        WebAudioSound._playEmptySound = function () {
            if (WebAudioSound.ctx == null) {
                return;
            }
            ;
            var source = WebAudioSound.ctx.createBufferSource();
            source.buffer = WebAudioSound._miniBuffer;
            source.connect(WebAudioSound.ctx.destination);
            source.start(0, 0, 0);
        };
        WebAudioSound._unlock = function () {
            if (WebAudioSound._unlocked) {
                return;
            }
            WebAudioSound._playEmptySound();
            if (WebAudioSound.ctx.state == "running") {
                Browser.document.removeEventListener("mousedown", WebAudioSound._unlock, true);
                Browser.document.removeEventListener("touchend", WebAudioSound._unlock, true);
                WebAudioSound._unlocked = true;
            }
        };
        WebAudioSound.initWebAudio = function () {
            if (WebAudioSound.ctx.state != "running") {
                WebAudioSound._unlock();
                Browser.document.addEventListener("mousedown", WebAudioSound._unlock, true);
                Browser.document.addEventListener("touchend", WebAudioSound._unlock, true);
            }
        };
        WebAudioSound._dataCache = {};
        WebAudioSound.buffs = [];
        WebAudioSound.isDecoding = false;
        WebAudioSound._unlocked = false;
        WebAudioSound.tInfo = null;
        WebAudioSound.__loadingSound = {};
        __static(WebAudioSound, ['window', function () { return this.window = Browser.window; }, 'webAudioEnabled', function () { return this.webAudioEnabled = WebAudioSound.window["AudioContext"] || WebAudioSound.window["webkitAudioContext"] || WebAudioSound.window["mozAudioContext"]; }, 'ctx', function () { return this.ctx = (os.platform != 0 && gcTop["audioCtx"]) ? gcTop["audioCtx"] : WebAudioSound.webAudioEnabled ? new (WebAudioSound.window["AudioContext"] || WebAudioSound.window["webkitAudioContext"] || WebAudioSound.window["mozAudioContext"])() : undefined; }, '_miniBuffer', function () { return this._miniBuffer = WebAudioSound.ctx.createBuffer(1, 1, 22050); }, 'e', function () { return this.e = new EventDispatcher(); }
        ]);
        return WebAudioSound;
    })(EventDispatcher);
    var HttpRequest = (function (_super) {
        function HttpRequest() {
            this._responseType = null;
            this._data = null;
            HttpRequest.__super.call(this);
            this._http = new Browser.window.XMLHttpRequest();
        }
        __class(HttpRequest, 'laya.net.HttpRequest', _super);
        var __proto = HttpRequest.prototype;
        __proto.send = function (url, data, method, responseType, headers) {
            (method === void 0) && (method = "get");
            (responseType === void 0) && (responseType = "text");
            this._responseType = responseType;
            this._data = null;
            var _this = this;
            var http = this._http;
            http.open(method, url, true);
            if (headers) {
                for (var i = 0; i < headers.length; i++) {
                    http.setRequestHeader(headers[i++], headers[i]);
                }
            }
            else if (!Render.isConchApp) {
                if (!data || (typeof data == 'string'))
                    http.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
                else
                    http.setRequestHeader("Content-Type", "application/json");
            }
            http.responseType = responseType !== "arraybuffer" ? "text" : "arraybuffer";
            http.onerror = function (e) {
                _this._onError(e);
            };
            http.onabort = function (e) {
                _this._onAbort(e);
            };
            http.onprogress = function (e) {
                _this._onProgress(e);
            };
            http.onload = function (e) {
                _this._onLoad(e);
            };
            http.send(data);
        };
        __proto._onProgress = function (e) {
            if (e && e.lengthComputable)
                this.event("progress", e.loaded / e.total);
        };
        __proto._onAbort = function (e) {
            this.error("Request was aborted by user");
        };
        __proto._onError = function (e) {
            this.error("Request failed Status:" + this._http.status + " text:" + this._http.statusText);
        };
        __proto._onLoad = function (e) {
            var http = this._http;
            var status = http.status !== undefined ? http.status : 200;
            if (status === 200 || status === 204 || status === 0) {
                this.complete();
            }
            else {
                this.error("[" + http.status + "]" + http.statusText + ":" + http.responseURL);
            }
        };
        __proto.error = function (message) {
            this.clear();
            this.event("error", message);
        };
        __proto.complete = function () {
            this.clear();
            var flag = true;
            try {
                if (this._responseType === "json") {
                    this._data = JSON.parse(this._http.responseText);
                }
                else if (this._responseType === "xml") {
                    this._data = Utils.parseXMLFromString(this._http.responseText);
                }
                else {
                    this._data = this._http.response || this._http.responseText;
                }
            }
            catch (e) {
                flag = false;
                this.error(e.message);
            }
            flag && this.event("complete", (this._data instanceof Array) ? [this._data] : this._data);
        };
        __proto.clear = function () {
            var http = this._http;
            http.onerror = http.onabort = http.onprogress = http.onload = null;
        };
        __getset(0, __proto, 'url', function () {
            return this._http.responseURL;
        });
        __getset(0, __proto, 'http', function () {
            return this._http;
        });
        __getset(0, __proto, 'data', function () {
            return this._data;
        });
        return HttpRequest;
    })(EventDispatcher);
    var Loader = (function (_super) {
        function Loader() {
            this._data = null;
            this._class = null;
            this._url = null;
            this._type = null;
            this._cache = false;
            this._http = null;
            this._customParse = false;
            Loader.__super.call(this);
        }
        __class(Loader, 'laya.net.Loader', _super);
        var __proto = Loader.prototype;
        __proto.load = function (url, type, cache, group, ignoreCache) {
            (cache === void 0) && (cache = true);
            (ignoreCache === void 0) && (ignoreCache = false);
            this._url = url;
            if (url.indexOf("data:image") === 0)
                this._type = type = "image";
            else {
                this._type = type || (type = this.getTypeFromUrl(url));
                url = URL.formatURL(url);
            }
            this._cache = cache;
            this._data = null;
            if (!ignoreCache && Loader.loadedMap[url]) {
                this._data = Loader.loadedMap[url];
                this.event("progress", 1);
                this.event("complete", this._data);
                return;
            }
            if (group)
                Loader.setGroup(url, group);
            if (Loader.parserMap[type] != null) {
                this._customParse = true;
                if (((Loader.parserMap[type]) instanceof laya.utils.Handler))
                    Loader.parserMap[type].runWith(this);
                else
                    Loader.parserMap[type].call(null, this);
                return;
            }
            if (type === "image" || type === "htmlimage" || type === "nativeimage")
                return this._loadImage(url);
            if (type === "sound")
                return this._loadSound(url);
            if (type === "ttf")
                return this._loadTTF(url);
            if (type == "atlas") {
                if (Loader.preLoadedAtlasConfigMap[url]) {
                    this.onLoaded(Loader.preLoadedAtlasConfigMap[url]);
                    delete Loader.preLoadedAtlasConfigMap[url];
                    return;
                }
            }
            if (!this._http) {
                this._http = new HttpRequest();
                this._http.on("progress", this, this.onProgress);
                this._http.on("error", this, this.onError);
                this._http.on("complete", this, this.onLoaded);
            }
            ;
            var contentType;
            switch (type) {
                case "atlas":
                    contentType = "json";
                    break;
                case "font":
                    contentType = "xml";
                    break;
                case "pkm":
                    contentType = "arraybuffer";
                    break;
                default:
                    contentType = type;
            }
            this._http.send(url, null, "get", contentType);
        };
        __proto.getTypeFromUrl = function (url) {
            var type = Utils.getFileExtension(url);
            if (type)
                return Loader.typeMap[type];
            console_warn("Not recognize the resources suffix", url);
            return "text";
        };
        __proto._loadTTF = function (url) {
            url = URL.formatURL(url);
            var ttfLoader = new TTFLoader();
            ttfLoader.complete = Handler.create(this, this.onLoaded);
            ttfLoader.load(url);
        };
        __proto._loadImage = function (url) {
            url = URL.formatURL(url);
            var _this = this;
            var image;
            function clear() {
                image.onload = null;
                image.onerror = null;
                delete Loader.imgCache[url];
            }
            ;
            var onload = function () {
                clear();
                _this.onLoaded(image);
            };
            var onerror = function () {
                clear();
                _this.event("error", "Load image failed");
            };
            if (this._type === "nativeimage") {
                image = new Browser.window.Image();
                image.crossOrigin = "";
                image.onload = onload;
                image.onerror = onerror;
                image.src = url;
                Loader.imgCache[url] = image;
            }
            else {
                new HTMLImage.create(url, {
                    onload: onload, onerror: onerror, onCreate: function (img) {
                        image = img;
                        Loader.imgCache[url] = img;
                    }
                });
            }
        };
        __proto._loadSound = function (url) {
            var sound = (new SoundManager._soundClass());
            var _this = this;
            sound.on("complete", this, soundOnload);
            sound.on("error", this, soundOnErr);
            sound.load(url);
            function soundOnload() {
                clear();
                _this.onLoaded(sound);
            }
            function soundOnErr() {
                clear();
                sound.dispose();
                _this.event("error", "Load sound failed");
            }
            function clear() {
                sound.offAll();
            }
        };
        __proto.onProgress = function (value) {
            if (this._type === "atlas")
                this.event("progress", value * 0.3);
            else
                this.event("progress", value);
        };
        __proto.onError = function (message) {
            this.event("error", message);
        };
        __proto.onLoaded = function (data) {
            var type = this._type;
            if (type === "image") {
                var tex = new Texture(data);
                tex.url = this._url;
                this.complete(tex);
            }
            else if (type === "sound" || type === "htmlimage" || type === "nativeimage") {
                this.complete(data);
            }
            else if (type === "atlas") {
                if (!data.src && !data._setContext) {
                    if (!this._data) {
                        this._data = data;
                        if (data.meta && data.meta.image) {
                            var toloadPics = data.meta.image.split(",");
                            var split = this._url.indexOf("/") >= 0 ? "/" : "\\";
                            var idx = this._url.lastIndexOf(split);
                            var folderPath = idx >= 0 ? this._url.substr(0, idx + 1) : "";
                            for (var i = 0, len = toloadPics.length; i < len; i++) {
                                toloadPics[i] = folderPath + toloadPics[i];
                            }
                        }
                        else {
                            toloadPics = [this._url.replace(".json", ".png")];
                        }
                        toloadPics.reverse();
                        data.toLoads = toloadPics;
                        data.pics = [];
                    }
                    this.event("progress", 0.3 + 1 / toloadPics.length * 0.6);
                    return this._loadImage(toloadPics.pop());
                }
                else {
                    this._data.pics.push(data);
                    if (this._data.toLoads.length > 0) {
                        this.event("progress", 0.3 + 1 / this._data.toLoads.length * 0.6);
                        return this._loadImage(this._data.toLoads.pop());
                    }
                    ;
                    var frames = this._data.frames;
                    var cleanUrl = this._url.split("?")[0];
                    var directory = (this._data.meta && this._data.meta.prefix) ? this._data.meta.prefix : cleanUrl.substring(0, cleanUrl.lastIndexOf(".")) + "/";
                    var pics = this._data.pics;
                    var atlasURL = URL.formatURL(this._url);
                    var map = Loader.atlasMap[atlasURL] || (Loader.atlasMap[atlasURL] = []);
                    map.dir = directory;
                    var scaleRate = 1;
                    if (this._data.meta && this._data.meta.scale && this._data.meta.scale != 1) {
                        scaleRate = parseFloat(this._data.meta.scale);
                        for (var name in frames) {
                            var obj = frames[name];
                            var tPic = pics[obj.frame.idx ? obj.frame.idx : 0];
                            var url = URL.formatURL(directory + name);
                            tPic.scaleRate = scaleRate;
                            Loader.cacheRes(url, Texture.create(tPic, obj.frame.x, obj.frame.y, obj.frame.w, obj.frame.h, obj.spriteSourceSize.x, obj.spriteSourceSize.y, obj.sourceSize.w, obj.sourceSize.h));
                            Loader.loadedMap[url].url = url;
                            map.push(url);
                        }
                    }
                    else {
                        for (name in frames) {
                            obj = frames[name];
                            tPic = pics[obj.frame.idx ? obj.frame.idx : 0];
                            url = URL.formatURL(directory + name);
                            Loader.cacheRes(url, Texture.create(tPic, obj.frame.x, obj.frame.y, obj.frame.w, obj.frame.h, obj.spriteSourceSize.x, obj.spriteSourceSize.y, obj.sourceSize.w, obj.sourceSize.h));
                            Loader.loadedMap[url].url = url;
                            map.push(url);
                        }
                    }
                    delete this._data.pics;
                    this.complete(this._data);
                }
            }
            else if (type == "font") {
                if (!data.src) {
                    this._data = data;
                    this.event("progress", 0.5);
                    return this._loadImage(this._url.replace(".fnt", ".png"));
                }
                else {
                    var bFont = new BitmapFont();
                    bFont.parseFont(this._data, data);
                    var tArr = this._url.split(".fnt")[0].split("/");
                    var fontName = tArr[tArr.length - 1];
                    Text.registerBitmapFont(fontName, bFont);
                    this._data = bFont;
                    this.complete(this._data);
                }
            }
            else if (type == "pkm") {
                var image = HTMLImage.create(data, this._url);
                var tex1 = new Texture(image);
                tex1.url = this._url;
                this.complete(tex1);
            }
            else {
                this.complete(data);
            }
        };
        __proto.complete = function (data) {
            this._data = data;
            if (this._customParse) {
                this.event("loaded", (data instanceof Array) ? [data] : data);
            }
            else {
                Loader._loaders.push(this);
                if (!Loader._isWorking)
                    Loader.checkNext();
            }
        };
        __proto.endLoad = function (content) {
            content && (this._data = content);
            if (this._cache)
                Loader.cacheRes(this._url, this._data);
            this._customParse = false;
            this.event("progress", 1);
            this.event("complete", (this.data instanceof Array) ? [this.data] : this.data);
        };
        __getset(0, __proto, 'url', function () {
            return this._url;
        });
        __getset(0, __proto, 'data', function () {
            return this._data;
        });
        __getset(0, __proto, 'cache', function () {
            return this._cache;
        });
        __getset(0, __proto, 'type', function () {
            return this._type;
        });
        Loader.checkNext = function () {
            Loader._isWorking = true;
            var startTimer = Browser.now();
            var thisTimer = startTimer;
            while (Loader._startIndex < Loader._loaders.length) {
                thisTimer = Browser.now();
                Loader._loaders[Loader._startIndex].endLoad();
                Loader._startIndex++;
                if (Browser.now() - startTimer > Loader.maxTimeOut) {
                    console_warn("loader callback cost a long time:" + (Browser.now() - startTimer) + " url=" + Loader._loaders[Loader._startIndex - 1].url);
                    Laya.timer && Laya.timer.frameOnce(1, null, Loader.checkNext);
                    return;
                }
            }
            Loader._loaders.length = 0;
            Loader._startIndex = 0;
            Loader._isWorking = false;
        };
        Loader.clearRes = function (url, forceDispose) {
            (forceDispose === void 0) && (forceDispose = false);
            url = URL.formatURL(url);
            var arr = Loader.getAtlas(url);
            if (arr) {
                for (var i = 0, n = arr.length; i < n; i++) {
                    var resUrl = arr[i];
                    var tex = Loader.getRes(resUrl);
                    delete Loader.loadedMap[resUrl];
                    if (tex)
                        tex.destroy(forceDispose);
                }
                arr.length = 0;
                delete Loader.atlasMap[url];
                delete Loader.loadedMap[url];
            }
            else {
                var res = Loader.loadedMap[url];
                if (res) {
                    delete Loader.loadedMap[url];
                    if ((res instanceof laya.resource.Texture) && res.bitmap)
                        (res).destroy(forceDispose);
                }
            }
        };
        Loader.clearTextureRes = function (url) {
            url = URL.formatURL(url);
            var arr = laya.net.Loader.getAtlas(url);
            var res = (arr && arr.length > 0) ? laya.net.Loader.getRes(arr[0]) : laya.net.Loader.getRes(url);
            if (res && res.bitmap) {
                if (Render.isConchApp) {
                    if (res.bitmap.source.releaseTexture) {
                        res.bitmap.source.releaseTexture();
                    }
                }
                else if (res.bitmap._atlaser == null) {
                    res.bitmap.releaseResource(true);
                }
            }
        };
        Loader.setAtlasConfigs = function (url, config) {
            Loader.preLoadedAtlasConfigMap[URL.formatURL(url)] = config;
        };
        Loader.getRes = function (url) {
            return Loader.loadedMap[URL.formatURL(url)];
        };
        Loader.getAtlas = function (url) {
            return Loader.atlasMap[URL.formatURL(url)];
        };
        Loader.cacheRes = function (url, data) {
            url = URL.formatURL(url);
            if (Loader.loadedMap[url] != null) {
                console_warn("Resources already exist,is repeated loading:", url);
            }
            else {
                Loader.loadedMap[url] = data;
            }
        };
        Loader.setGroup = function (url, group) {
            if (!Loader.groupMap[group])
                Loader.groupMap[group] = [];
            Loader.groupMap[group].push(url);
        };
        Loader.clearResByGroup = function (group) {
            if (!Loader.groupMap[group])
                return;
            var arr = Loader.groupMap[group], i = 0, len = arr.length;
            for (i = 0; i < len; i++) {
                Loader.clearRes(arr[i]);
            }
            arr.length = 0;
        };
        Loader.TEXT = "text";
        Loader.JSON = "json";
        Loader.XML = "xml";
        Loader.BUFFER = "arraybuffer";
        Loader.IMAGE = "image";
        Loader.SOUND = "sound";
        Loader.ATLAS = "atlas";
        Loader.FONT = "font";
        Loader.TTF = "ttf";
        Loader.PKM = "pkm";
        Loader.typeMap = { "png": "image", "jpg": "image", "jpeg": "image", "txt": "text", "json": "json", "xml": "xml", "als": "atlas", "atlas": "atlas", "mp3": "sound", "ogg": "sound", "wav": "sound", "part": "json", "fnt": "font", "pkm": "pkm", "ttf": "ttf" };
        Loader.parserMap = {};
        Loader.groupMap = {};
        Loader.maxTimeOut = 100;
        Loader.loadedMap = {};
        Loader.preLoadedAtlasConfigMap = {};
        Loader.atlasMap = {};
        Loader._loaders = [];
        Loader._isWorking = false;
        Loader._startIndex = 0;
        Loader.imgCache = {};
        return Loader;
    })(EventDispatcher);
    var LoaderManager = (function (_super) {
        var ResInfo;
        function LoaderManager() {
            this.retryNum = 1;
            this.retryDelay = 0;
            this.maxLoader = 5;
            this._loaders = [];
            this._loaderCount = 0;
            this._resInfos = [];
            this._infoPool = [];
            this._maxPriority = 5;
            this._failRes = {};
            LoaderManager.__super.call(this);
            for (var i = 0; i < this._maxPriority; i++)
                this._resInfos[i] = [];
        }
        __class(LoaderManager, 'laya.net.LoaderManager', _super);
        var __proto = LoaderManager.prototype;
        __proto.create = function (url, complete, progress, clas, params, priority, cache, group) {
            (priority === void 0) && (priority = 1);
            (cache === void 0) && (cache = true);
            if ((url instanceof Array)) {
                var items = url;
                var itemCount = items.length;
                var loadedCount = 0;
                if (progress) {
                    var progress2 = Handler.create(progress.caller, progress.method, progress.args, false);
                }
                for (var i = 0; i < itemCount; i++) {
                    var item = items[i];
                    if ((typeof item == 'string'))
                        item = items[i] = { url: item };
                    item.progress = 0;
                    var progressHandler = progress ? Handler.create(null, onProgress, [item], false) : null;
                    var completeHandler = (progress || complete) ? Handler.create(null, onComplete, [item]) : null;
                    this._create(item.url, completeHandler, progressHandler, item.clas || clas, item.params || params, item.priority || priority, cache, item.group || group);
                }
                function onComplete(item, content) {
                    loadedCount++;
                    item.progress = 1;
                    if (loadedCount === itemCount && complete) {
                        complete.run();
                    }
                }
                function onProgress(item, value) {
                    item.progress = value;
                    var num = 0;
                    for (var j = 0; j < itemCount; j++) {
                        var item1 = items[j];
                        num += item1.progress;
                    }
                    ;
                    var v = num / itemCount;
                    progress2.runWith(v);
                }
                return true;
            }
            else
                return this._create(url, complete, progress, clas, params, priority, cache, group);
        };
        __proto._create = function (url, complete, progress, clas, params, priority, cache, group) {
            (priority === void 0) && (priority = 1);
            (cache === void 0) && (cache = true);
            var formarUrl = URL.formatURL(url);
            var item = this.getRes(formarUrl);
            if (!item) {
                var extension = Utils.getFileExtension(url);
                var creatItem = LoaderManager.createMap[extension];
                if (!creatItem)
                    throw new Error("LoaderManager:unknown file(" + url + ") extension with: " + extension + ".");
                if (!clas)
                    clas = creatItem[0];
                var type = creatItem[1];
                if (extension == "atlas") {
                    this.load(url, complete, progress, type, priority, cache);
                }
                else {
                    if (clas === Texture)
                        type = "htmlimage";
                    item = clas ? new clas() : null;
                    if (item.hasOwnProperty("_loaded"))
                        item._loaded = false;
                    item._setUrl(url);
                    (group) && (item._setGroup(group));
                    this._createLoad(item, url, Handler.create(null, onLoaded), progress, type, priority, false, group, true);
                    function onLoaded(data) {
                        (item && !item.destroyed && data) && (item.onAsynLoaded.call(item, url, data, params));
                        if (complete)
                            complete.run();
                        Laya.loader.event(url);
                    }
                    (cache) && (this.cacheRes(formarUrl, item));
                }
            }
            else {
                if (!item.hasOwnProperty("loaded") || item.loaded) {
                    progress && progress.runWith(1);
                    complete && complete.run();
                }
                else if (complete) {
                    Laya.loader._createListener(url, complete.caller, complete.method, complete.args, true, false);
                }
            }
            return item;
        };
        __proto.load = function (url, complete, progress, type, priority, cache, group, ignoreCache) {
            var _$this = this;
            (priority === void 0) && (priority = 1);
            (cache === void 0) && (cache = true);
            (ignoreCache === void 0) && (ignoreCache = false);
            if ((url instanceof Array))
                return this._loadAssets(url, complete, progress, type, priority, cache, group);
            var content = Loader.getRes(url);
            if (content != null) {
                Laya.timer && Laya.timer.frameOnce(1, null, function () {
                    progress && progress.runWith(1);
                    complete && complete.runWith(content);
                    _$this._loaderCount || _$this.event("complete");
                });
            }
            else {
                var info = LoaderManager._resMap[url];
                if (!info) {
                    info = this._infoPool.length ? this._infoPool.pop() : new ResInfo();
                    info.url = url;
                    info.type = type;
                    info.cache = cache;
                    info.group = group;
                    info.ignoreCache = ignoreCache;
                    complete && info.on("complete", complete.caller, complete.method, complete.args);
                    progress && info.on("progress", progress.caller, progress.method, progress.args);
                    LoaderManager._resMap[url] = info;
                    priority = priority < this._maxPriority ? priority : this._maxPriority - 1;
                    this._resInfos[priority].push(info);
                    this._next();
                }
                else {
                    complete && info._createListener("complete", complete.caller, complete.method, complete.args, false, false);
                    progress && info._createListener("progress", progress.caller, progress.method, progress.args, false, false);
                }
            }
            return this;
        };
        __proto._createLoad = function (item, url, complete, progress, type, priority, cache, group, ignoreCache) {
            var _$this = this;
            (priority === void 0) && (priority = 1);
            (cache === void 0) && (cache = true);
            (ignoreCache === void 0) && (ignoreCache = false);
            if ((url instanceof Array))
                return this._loadAssets(url, complete, progress, type, priority, cache, group);
            var content = Loader.getRes(url);
            if (content != null) {
                Laya.timer.frameOnce(1, null, function () {
                    progress && progress.runWith(1);
                    complete && complete.runWith(content);
                    _$this._loaderCount || _$this.event("complete");
                });
            }
            else {
                var info = LoaderManager._resMap[url];
                if (!info) {
                    info = this._infoPool.length ? this._infoPool.pop() : new ResInfo();
                    info.url = url;
                    info.clas = item;
                    info.type = type;
                    info.cache = cache;
                    info.group = group;
                    info.ignoreCache = ignoreCache;
                    complete && info.on("complete", complete.caller, complete.method, complete.args);
                    progress && info.on("progress", progress.caller, progress.method, progress.args);
                    LoaderManager._resMap[url] = info;
                    priority = priority < this._maxPriority ? priority : this._maxPriority - 1;
                    this._resInfos[priority].push(info);
                    this._next();
                }
                else {
                    complete && info._createListener("complete", complete.caller, complete.method, complete.args, false, false);
                    progress && info._createListener("progress", progress.caller, progress.method, progress.args, false, false);
                }
            }
            return this;
        };
        __proto._next = function () {
            if (this._loaderCount >= this.maxLoader)
                return;
            for (var i = 0; i < this._maxPriority; i++) {
                var infos = this._resInfos[i];
                while (infos.length > 0) {
                    var info = infos.shift();
                    if (info)
                        return this._doLoad(info);
                }
            }
            this._loaderCount || this.event("complete");
        };
        __proto._doLoad = function (resInfo) {
            this._loaderCount++;
            var loader = this._loaders.length ? this._loaders.pop() : new Loader();
            loader.on("complete", null, onLoaded);
            loader.on("progress", null, function (num) {
                resInfo.event("progress", num);
            });
            loader.on("error", null, function (msg) {
                onLoaded(null);
            });
            var _this = this;
            function onLoaded(data) {
                loader.offAll();
                loader._data = null;
                _this._loaders.push(loader);
                _this._endLoad(resInfo, (data instanceof Array) ? [data] : data);
                _this._loaderCount--;
                _this._next();
            }
            loader._class = resInfo.clas;
            loader.load(resInfo.url, resInfo.type, resInfo.cache, resInfo.group, resInfo.ignoreCache);
        };
        __proto._endLoad = function (resInfo, content) {
            var url = resInfo.url;
            if (content == null) {
                var errorCount = this._failRes[url] || 0;
                if (errorCount < this.retryNum) {
                    console_warn("[warn]Retry to load:", url);
                    this._failRes[url] = errorCount + 1;
                    Laya.timer.once(this.retryDelay, this, this._addReTry, [resInfo], false);
                    return;
                }
                else {
                    console_warn("[error]Failed to load:", url);
                    this.event("error", url);
                }
            }
            if (this._failRes[url])
                this._failRes[url] = 0;
            delete LoaderManager._resMap[url];
            resInfo.event("complete", content);
            resInfo.offAll();
            this._infoPool.push(resInfo);
        };
        __proto._addReTry = function (resInfo) {
            this._resInfos[this._maxPriority - 1].push(resInfo);
            this._next();
        };
        __proto.clearRes = function (url, forceDispose) {
            (forceDispose === void 0) && (forceDispose = false);
            Loader.clearRes(url, forceDispose);
        };
        __proto.getRes = function (url) {
            return Loader.getRes(url);
        };
        __proto.cacheRes = function (url, data) {
            Loader.cacheRes(url, data);
        };
        __proto.clearTextureRes = function (url) {
            Loader.clearTextureRes(url);
        };
        __proto.setGroup = function (url, group) {
            Loader.setGroup(url, group);
        };
        __proto.clearResByGroup = function (group) {
            Loader.clearResByGroup(group);
        };
        __proto.clearUnLoaded = function () {
            for (var i = 0; i < this._maxPriority; i++) {
                var infos = this._resInfos[i];
                for (var j = infos.length - 1; j > -1; j--) {
                    var info = infos[j];
                    if (info) {
                        info.offAll();
                        this._infoPool.push(info);
                    }
                }
                infos.length = 0;
            }
            this._loaderCount = 0;
            LoaderManager._resMap = {};
        };
        __proto.cancelLoadByUrls = function (urls) {
            if (!urls)
                return;
            for (var i = 0, n = urls.length; i < n; i++) {
                this.cancelLoadByUrl(urls[i]);
            }
        };
        __proto.cancelLoadByUrl = function (url) {
            for (var i = 0; i < this._maxPriority; i++) {
                var infos = this._resInfos[i];
                for (var j = infos.length - 1; j > -1; j--) {
                    var info = infos[j];
                    if (info && info.url === url) {
                        infos[j] = null;
                        info.offAll();
                        this._infoPool.push(info);
                    }
                }
            }
            if (LoaderManager._resMap[url])
                delete LoaderManager._resMap[url];
        };
        __proto._loadAssets = function (arr, complete, progress, type, priority, cache, group) {
            (priority === void 0) && (priority = 1);
            (cache === void 0) && (cache = true);
            var itemCount = arr.length;
            var loadedCount = 0;
            var totalSize = 0;
            var items = [];
            var success = true;
            for (var i = 0; i < itemCount; i++) {
                var item = arr[i];
                if ((typeof item == 'string'))
                    item = { url: item, type: type, size: 1, priority: priority };
                if (!item.size)
                    item.size = 1;
                item.progress = 0;
                totalSize += item.size;
                items.push(item);
                var progressHandler = progress ? Handler.create(null, loadProgress, [item], false) : null;
                var completeHandler = (complete || progress) ? Handler.create(null, loadComplete, [item]) : null;
                this.load(item.url, completeHandler, progressHandler, item.type, item.priority || 1, cache, item.group || group);
            }
            function loadComplete(item, content) {
                loadedCount++;
                item.progress = 1;
                if (!content)
                    success = false;
                if (loadedCount === itemCount && complete) {
                    complete.runWith(success);
                }
            }
            function loadProgress(item, value) {
                if (progress != null) {
                    item.progress = value;
                    var num = 0;
                    for (var j = 0; j < items.length; j++) {
                        var item1 = items[j];
                        num += item1.size * item1.progress;
                    }
                    ;
                    var v = num / totalSize;
                    progress.runWith(v);
                }
            }
            return this;
        };
        LoaderManager.cacheRes = function (url, data) {
            Loader.cacheRes(url, data);
        };
        LoaderManager._resMap = {};
        __static(LoaderManager, ['createMap', function () { return this.createMap = { atlas: [null, "atlas"] }; }
        ]);
        LoaderManager.__init$ = function () {
            ResInfo = (function (_super) {
                function ResInfo() {
                    this.url = null;
                    this.type = null;
                    this.cache = false;
                    this.group = null;
                    this.ignoreCache = false;
                    this.clas = null;
                    ResInfo.__super.call(this);
                }
                __class(ResInfo, '', _super);
                return ResInfo;
            })(EventDispatcher);
        };
        return LoaderManager;
    })(EventDispatcher);
    var ColorFilter = (function (_super) {
        function ColorFilter(mat) {
            ColorFilter.__super.call(this);
            if (!mat) {
                mat = [0.3, 0.59, 0.11, 0, 0, 0.3, 0.59, 0.11, 0, 0, 0.3, 0.59, 0.11, 0, 0, 0, 0, 0, 1, 0];
            }
            this._mat = new Float32Array(16);
            this._alpha = new Float32Array(4);
            var j = 0;
            var z = 0;
            for (var i = 0; i < 20; i++) {
                if (i % 5 != 4) {
                    this._mat[j++] = mat[i];
                }
                else {
                    this._alpha[z++] = mat[i];
                }
            }
            this._action = RunDriver.createFilterAction(0x20);
            this._action.data = this;
        }
        __class(ColorFilter, 'laya.filters.ColorFilter', _super);
        var __proto = ColorFilter.prototype;
        Laya.imps(__proto, { "laya.filters.IFilter": true });
        __proto.callNative = function (sp) {
            var t = sp._$P.cf = this;
            sp.conchModel && sp.conchModel.setFilterMatrix && sp.conchModel.setFilterMatrix(this._mat, this._alpha);
        };
        __getset(0, __proto, 'type', function () {
            return 0x20;
        });
        __getset(0, __proto, 'action', function () {
            return this._action;
        });
        return ColorFilter;
    })(Filter);
    var Socket = (function (_super) {
        function Socket(host, port, byteClass) {
            this._endian = null;
            this._stamp = NaN;
            this._socket = null;
            this._connected = false;
            this._addInputPosition = 0;
            this._input = null;
            this._output = null;
            this.timeout = 0;
            this.objectEncoding = 0;
            this.disableInput = false;
            this._byteClass = null;
            this.protocols = [];
            (port === void 0) && (port = 0);
            Socket.__super.call(this);
            this._byteClass = byteClass ? byteClass : Byte;
            this.endian = "bigEndian";
            this.timeout = 20000;
            this._addInputPosition = 0;
            if (host && port > 0 && port < 65535)
                this.connect(host, port);
        }
        __class(Socket, 'laya.net.Socket', _super);
        var __proto = Socket.prototype;
        __proto.connect = function (host, port) {
            var url = "ws://" + host + ":" + port;
            if (Browser.window.location.protocol == "https:") {
                url = "wss://" + host + ":" + port;
            }
            else {
                url = "ws://" + host + ":" + port;
            }
            this.connectByUrl(url);
        };
        __proto.connectByUrl = function (url) {
            var _$this = this;
            if (this._socket != null)
                this.close();
            this._socket && this.cleanSocket();
            if (!this.protocols || this.protocols.length == 0) {
                this._socket = new Browser.window.WebSocket(url);
            }
            else {
                this._socket = new Browser.window.WebSocket(url, this.protocols);
            }
            this._socket.binaryType = "arraybuffer";
            this._output = new this._byteClass();
            this._output.endian = this.endian;
            this._input = new this._byteClass();
            this._input.endian = this.endian;
            this._addInputPosition = 0;
            this._socket.onopen = function (e) {
                _$this._onOpen(e);
            };
            this._socket.onmessage = function (msg) {
                _$this._onMessage(msg);
            };
            this._socket.onclose = function (e) {
                _$this._onClose(e);
            };
            this._socket.onerror = function (e) {
                _$this._onError(e);
            };
        };
        __proto.cleanSocket = function () {
            try {
                this._socket.close();
            }
            catch (e) { }
            this._connected = false;
            this._socket.onopen = null;
            this._socket.onmessage = null;
            this._socket.onclose = null;
            this._socket.onerror = null;
            this._socket = null;
        };
        __proto.close = function () {
            if (this._socket != null) {
                try {
                    this._socket.close();
                }
                catch (e) { }
            }
        };
        __proto._onOpen = function (e) {
            this._connected = true;
            this.event("open", e);
        };
        __proto._onMessage = function (msg) {
            if (!msg || !msg.data)
                return;
            var data = msg.data;
            if (this.disableInput && data) {
                this.event("message", data);
                return;
            }
            if (this._input.length > 0 && this._input.bytesAvailable < 1) {
                this._input.clear();
                this._addInputPosition = 0;
            }
            ;
            var pre = this._input.pos;
            !this._addInputPosition && (this._addInputPosition = 0);
            this._input.pos = this._addInputPosition;
            if (data) {
                if ((typeof data == 'string')) {
                    this._input.writeUTFBytes(data);
                }
                else {
                    this._input.writeArrayBuffer(data);
                }
                this._addInputPosition = this._input.pos;
                this._input.pos = pre;
            }
            this.event("message", data);
        };
        __proto._onClose = function (e) {
            this._connected = false;
            this.event("close", e);
        };
        __proto._onError = function (e) {
            this.event("error", e);
        };
        __proto.send = function (data) {
            this._socket.send(data);
        };
        __proto.flush = function () {
            if (this._output && this._output.length > 0) {
                var evt;
                try {
                    this._socket && this._socket.send(this._output.__getBuffer().slice(0, this._output.length));
                }
                catch (e) {
                    evt = e;
                }
                this._output.endian = this.endian;
                this._output.clear();
                if (evt)
                    this.event("error", evt);
            }
        };
        __getset(0, __proto, 'input', function () {
            return this._input;
        });
        __getset(0, __proto, 'output', function () {
            return this._output;
        });
        __getset(0, __proto, 'connected', function () {
            return this._connected;
        });
        __getset(0, __proto, 'endian', function () {
            return this._endian;
        }, function (value) {
            this._endian = value;
            if (this._input != null)
                this._input.endian = value;
            if (this._output != null)
                this._output.endian = value;
        });
        Socket.LITTLE_ENDIAN = "littleEndian";
        Socket.BIG_ENDIAN = "bigEndian";
        return Socket;
    })(EventDispatcher);
    var WorkerLoader = (function (_super) {
        function WorkerLoader() {
            this.worker = null;
            WorkerLoader.__super.call(this);
            var _$this = this;
            this.worker = new Browser.window.Worker(WorkerLoader.workerPath);
            this.worker.onmessage = function (evt) {
                _$this.workerMessage(evt.data);
            };
        }
        __class(WorkerLoader, 'laya.net.WorkerLoader', _super);
        var __proto = WorkerLoader.prototype;
        __proto.workerMessage = function (data) {
            if (data) {
                switch (data.type) {
                    case "Image":
                        this.imageLoaded(data);
                        break;
                    case "Msg":
                        this.event("image_msg", data.msg);
                        break;
                }
            }
        };
        __proto.imageLoaded = function (data) {
            if (data && data.buffer && data.buffer.length < 10) {
                WorkerLoader._enable = false;
                this._myTrace("buffer lost when postmessage ,disable workerloader");
                this.event(data.url, null);
                this.event("image_err", data.url + "\n" + data.msg);
                return;
            }
            if (!data.dataType) {
                this.event(data.url, null);
                this.event("image_err", data.url + "\n" + data.msg);
                return;
            }
            ;
            var canvas, ctx;
            var imageData;
            switch (data.dataType) {
                case "buffer":
                    canvas = new HTMLCanvas("2D");
                    ctx = canvas.source.getContext("2d");
                    imageData = ctx.createImageData(data.width, data.height);
                    imageData.data.set(data.buffer);
                    canvas.size(imageData.width, imageData.height);
                    ctx.putImageData(imageData, 0, 0);
                    canvas.memorySize = 0;
                    break;
                case "imagedata":
                    canvas = new HTMLCanvas("2D");
                    ctx = canvas.source.getContext("2d");
                    imageData = data.imagedata;
                    canvas.size(imageData.width, imageData.height);
                    ctx.putImageData(imageData, 0, 0);
                    imageData = data.imagedata;
                    canvas.memorySize = 0;
                    break;
                case "imageBitmap":
                    imageData = data.imageBitmap;
                    if (!Render.isWebGL) {
                        canvas = new HTMLCanvas("2D");
                        ctx = canvas.source.getContext("2d");
                        canvas.size(imageData.width, imageData.height);
                        ctx.drawImage(imageData, 0, 0);
                        canvas.src = data.url;
                    }
                    else
                        canvas = imageData;
                    break;
            }
            if (Render.isWebGL)
                canvas = new laya.webgl.resource.WebGLImage(canvas, data.url);
            ;
            this.event(data.url, canvas);
        };
        __proto._myTrace = function (__arg) {
            var arg = arguments;
            var rst = [];
            var i = 0, len = arg.length;
            for (i = 0; i < len; i++) {
                rst.push(arg[i]);
            }
            this.event("image_msg", rst.join(" "));
        };
        __proto.loadImage = function (url) {
            var data;
            data = {};
            data.type = "load";
            data.url = url;
            this.worker.postMessage(data);
        };
        __proto._loadImage = function (url) {
            var _this = this;
            if (!WorkerLoader._enable || url.toLowerCase().indexOf(".png") < 0) {
                WorkerLoader._preLoadFun.call(_this, url);
                return;
            }
            url = URL.formatURL(url);
            function clear() {
                laya.net.WorkerLoader.I.off(url, _this, onload);
            }
            ;
            var onload = function (image) {
                clear();
                if (image) {
                    _this["onLoaded"](image);
                }
                else {
                    WorkerLoader._preLoadFun.call(_this, url);
                }
            };
            laya.net.WorkerLoader.I.on(url, _this, onload);
            laya.net.WorkerLoader.I.loadImage(url);
        };
        __getset(1, WorkerLoader, 'enable', function () {
            return WorkerLoader._enable;
        }, function (v) {
            if (WorkerLoader.disableJSDecode && (!Browser.window.createImageBitmap))
                return;
            WorkerLoader._enable = v;
            if (WorkerLoader._enable && WorkerLoader._preLoadFun == null)
                WorkerLoader._enable = WorkerLoader.__init__();
        });
        WorkerLoader.__init__ = function () {
            if (WorkerLoader._preLoadFun != null)
                return false;
            if (!Browser.window.Worker)
                return false;
            WorkerLoader._preLoadFun = Loader["prototype"]["_loadImage"];
            Loader["prototype"]["_loadImage"] = WorkerLoader["prototype"]["_loadImage"];
            if (!WorkerLoader.I)
                WorkerLoader.I = new WorkerLoader();
            return true;
        };
        WorkerLoader.workerSupported = function () {
            return Browser.window.Worker ? true : false;
        };
        WorkerLoader.IMAGE_LOADED = "image_loaded";
        WorkerLoader.IMAGE_ERR = "image_err";
        WorkerLoader.IMAGE_MSG = "image_msg";
        WorkerLoader.I = null;
        WorkerLoader._preLoadFun = null;
        WorkerLoader._enable = false;
        WorkerLoader.workerPath = "libs/worker.js";
        WorkerLoader.disableJSDecode = true;
        return WorkerLoader;
    })(EventDispatcher);
    var Resource = (function (_super) {
        function Resource() {
            Resource.__super.call(this);
            this._$1__id = ++Resource._uniqueIDCounter;
            this.__loaded = true;
            this._destroyed = false;
            this._referenceCount = 0;
            Resource._idResourcesMap[this.id] = this;
            this._released = true;
            this.lock = false;
            this._memorySize = 0;
            this._lastUseFrameCount = -1;
            (ResourceManager.currentResourceManager) && (ResourceManager.currentResourceManager.addResource(this));
        }
        __class(Resource, 'laya.resource.Resource', _super);
        var __proto = Resource.prototype;
        Laya.imps(__proto, { "laya.resource.ICreateResource": true, "laya.resource.IDispose": true });
        __proto._setUrl = function (url) {
            if (this._url !== url) {
                var resList;
                if (this._url) {
                    resList = Resource._urlResourcesMap[this._url];
                    resList.splice(resList.indexOf(this), 1);
                    (resList.length === 0) && (delete Resource._urlResourcesMap[this._url]);
                }
                if (url) {
                    resList = Resource._urlResourcesMap[url];
                    (resList) || (Resource._urlResourcesMap[url] = resList = []);
                    resList.push(this);
                }
                this._url = url;
            }
        };
        __proto._getGroup = function () {
            return this._group;
        };
        __proto._setGroup = function (value) {
            if (this._group !== value) {
                var groupList;
                if (this._group) {
                    groupList = Resource._groupResourcesMap[this._group];
                    groupList.splice(groupList.indexOf(this), 1);
                    (groupList.length === 0) && (delete Resource._groupResourcesMap[this._group]);
                }
                if (value) {
                    groupList = Resource._groupResourcesMap[value];
                    (groupList) || (Resource._groupResourcesMap[value] = groupList = []);
                    groupList.push(this);
                }
                this._group = value;
            }
        };
        __proto._addReference = function () {
            this._referenceCount++;
        };
        __proto._removeReference = function () {
            this._referenceCount--;
        };
        __proto._clearReference = function () {
            this._referenceCount = 0;
        };
        __proto._endLoaded = function () {
            this.__loaded = true;
            this.event("loaded", this);
        };
        __proto.recreateResource = function () {
            this.completeCreate();
        };
        __proto.disposeResource = function () { };
        __proto.activeResource = function (force) {
            (force === void 0) && (force = false);
            this._lastUseFrameCount = Stat.loopCount;
            if (!this._destroyed && this.__loaded && (this._released || force))
                this.recreateResource();
        };
        __proto.releaseResource = function (force) {
            (force === void 0) && (force = false);
            if (!force && this.lock)
                return false;
            if (!this._released || force) {
                this.disposeResource();
                this._released = true;
                this._lastUseFrameCount = -1;
                this.event("released", this);
                return true;
            }
            else {
                return false;
            }
        };
        __proto.onAsynLoaded = function (url, data, params) {
            throw new Error("Resource: must override this function!");
        };
        __proto.destroy = function () {
            if (this._destroyed)
                return;
            if (this._resourceManager !== null)
                this._resourceManager.removeResource(this);
            this._destroyed = true;
            this.lock = false;
            this.releaseResource();
            delete Resource._idResourcesMap[this.id];
            var resList;
            if (this._url) {
                resList = Resource._urlResourcesMap[this._url];
                if (resList) {
                    resList.splice(resList.indexOf(this), 1);
                    (resList.length === 0) && (delete Resource._urlResourcesMap[this.url]);
                }
                Loader.clearRes(this._url);
                (this.__loaded) || (RunDriver.cancelLoadByUrl(this._url));
            }
            if (this._group) {
                resList = Resource._groupResourcesMap[this._group];
                resList.splice(resList.indexOf(this), 1);
                (resList.length === 0) && (delete Resource._groupResourcesMap[this.url]);
            }
        };
        __proto.completeCreate = function () {
            this._released = false;
            this.event("recovered", this);
        };
        __proto.dispose = function () {
            this.destroy();
        };
        __getset(0, __proto, 'memorySize', function () {
            return this._memorySize;
        }, function (value) {
            var offsetValue = value - this._memorySize;
            this._memorySize = value;
            this.resourceManager && this.resourceManager.addSize(offsetValue);
        });
        __getset(0, __proto, '_loaded', null, function (value) {
            this.__loaded = value;
        });
        __getset(0, __proto, 'loaded', function () {
            return this.__loaded;
        });
        __getset(0, __proto, 'id', function () {
            return this._$1__id;
        });
        __getset(0, __proto, 'destroyed', function () {
            return this._destroyed;
        });
        __getset(0, __proto, 'group', function () {
            return this._getGroup();
        }, function (value) {
            this._setGroup(value);
        });
        __getset(0, __proto, 'resourceManager', function () {
            return this._resourceManager;
        });
        __getset(0, __proto, 'url', function () {
            return this._url;
        });
        __getset(0, __proto, 'released', function () {
            return this._released;
        });
        __getset(0, __proto, 'referenceCount', function () {
            return this._referenceCount;
        });
        Resource.getResourceByID = function (id) {
            return Resource._idResourcesMap[id];
        };
        Resource.getResourceByURL = function (url, index) {
            (index === void 0) && (index = 0);
            return Resource._urlResourcesMap[url][index];
        };
        Resource.getResourceCountByURL = function (url) {
            return Resource._urlResourcesMap[url].length;
        };
        Resource.destroyUnusedResources = function (group) {
            var res;
            if (group) {
                var resouList = Resource._groupResourcesMap[group];
                if (resouList) {
                    var tempResouList = resouList.slice();
                    for (var i = 0, n = tempResouList.length; i < n; i++) {
                        res = tempResouList[i];
                        if (!res.lock && res._referenceCount === 0)
                            res.destroy();
                    }
                }
            }
            else {
                for (var k in Resource._idResourcesMap) {
                    res = Resource._idResourcesMap[k];
                    if (!res.lock && res._referenceCount === 0)
                        res.destroy();
                }
            }
        };
        Resource._uniqueIDCounter = 0;
        Resource._idResourcesMap = {};
        Resource._urlResourcesMap = {};
        Resource._groupResourcesMap = {};
        return Resource;
    })(EventDispatcher);
    var Texture = (function (_super) {
        function Texture(bitmap, uv) {
            this.offsetX = 0;
            this.offsetY = 0;
            this.sourceWidth = 0;
            this.sourceHeight = 0;
            this._w = 0;
            this._h = 0;
            this._uvID = 0;
            this._atlasID = -1;
            this.scaleRate = 1;
            Texture.__super.call(this);
            if (bitmap && bitmap._addReference) {
                bitmap._addReference();
            }
            this.setTo(bitmap, uv);
        }
        __class(Texture, 'laya.resource.Texture', _super);
        var __proto = Texture.prototype;
        __proto._setUrl = function (url) {
            this.url = url;
        };
        __proto.setTo = function (bitmap, uv) {
            if (bitmap instanceof window.HTMLElement) {
                var canvas = HTMLCanvas.create("2D", bitmap);
                this.bitmap = canvas;
            }
            else {
                this.bitmap = bitmap;
            }
            this.uv = uv || Texture.DEF_UV;
            if (bitmap) {
                this._w = bitmap.width;
                this._h = bitmap.height;
                this.sourceWidth = this.sourceWidth || this._w;
                this.sourceHeight = this.sourceHeight || this._h;
                this._loaded = this._w > 0;
                var _this = this;
                if (this._loaded) {
                    RunDriver.addToAtlas && RunDriver.addToAtlas(_this);
                }
                else {
                    var bm = bitmap;
                    if ((bm instanceof laya.resource.HTMLImage) && bm.image)
                        bm.image.addEventListener('load', function (e) {
                            RunDriver.addToAtlas && RunDriver.addToAtlas(_this);
                        }, false);
                }
            }
        };
        __proto.active = function () {
            if (this.bitmap)
                this.bitmap.activeResource();
        };
        __proto.destroy = function (forceDispose) {
            (forceDispose === void 0) && (forceDispose = false);
            if (this.bitmap && (this.bitmap).referenceCount > 0) {
                var temp = this.bitmap;
                if (forceDispose) {
                    if (Render.isConchApp && temp.source && temp.source.conchDestroy) {
                        this.bitmap.source.conchDestroy();
                    }
                    this.bitmap = null;
                    temp.dispose();
                    (temp)._clearReference();
                }
                else {
                    (temp)._removeReference();
                    if ((temp).referenceCount == 0) {
                        if (Render.isConchApp && temp.source && temp.source.conchDestroy) {
                            this.bitmap.source.conchDestroy();
                        }
                        this.bitmap = null;
                        temp.dispose();
                    }
                }
                if (this.url && this === Laya.loader.getRes(this.url))
                    Laya.loader.clearRes(this.url, forceDispose);
                this._loaded = false;
            }
        };
        __proto.dispose = function () {
            this.destroy(true);
        };
        __proto.load = function (url) {
            var _$this = this;
            this._loaded = false;
            url = URL.customFormat(url);
            var fileBitmap = (this.bitmap || (this.bitmap = HTMLImage.create(url)));
            if (fileBitmap)
                fileBitmap._addReference();
            var _this = this;
            fileBitmap.onload = function () {
                fileBitmap.onload = null;
                _this._loaded = true;
                _$this.sourceWidth = _$this._w = fileBitmap.width;
                _$this.sourceHeight = _$this._h = fileBitmap.height;
                _this.event("loaded", this);
                (RunDriver.addToAtlas) && (RunDriver.addToAtlas(_this));
            };
        };
        __proto.addTextureToAtlas = function (e) {
            RunDriver.addTextureToAtlas(this);
        };
        __proto.getPixels = function (x, y, width, height) {
            if (Render.isConchApp) {
                var temp = this.bitmap;
                if (temp.source && temp.source.getImageData) {
                    var arraybuffer = temp.source.getImageData(x, y, width, height);
                    var tUint8Array = new Uint8Array(arraybuffer);
                    return Array.from(tUint8Array);
                }
                return null;
            }
            else if (Render.isWebGL) {
                return RunDriver.getTexturePixels(this, x, y, width, height);
            }
            else {
                Browser.canvas.size(width, height);
                Browser.canvas.clear();
                Browser.context.drawTexture(this, -x, -y, this.width, this.height, 0, 0);
                var info = Browser.context.getImageData(0, 0, width, height);
            }
            return info.data;
        };
        __proto.onAsynLoaded = function (url, bitmap) {
            if (bitmap)
                bitmap._addReference();
            this.setTo(bitmap, this.uv);
        };
        __getset(0, __proto, 'source', function () {
            if (!this.bitmap)
                return null;
            this.bitmap.activeResource();
            return this.bitmap.source;
        });
        __getset(0, __proto, 'loaded', function () {
            return this._loaded;
        });
        __getset(0, __proto, 'released', function () {
            if (!this.bitmap)
                return true;
            return this.bitmap.released;
        });
        __getset(0, __proto, 'disposed', function () {
            if (!this.bitmap)
                return true;
            return this.bitmap.released;
        });
        __getset(0, __proto, 'width', function () {
            if (this._w)
                return this._w;
            return (this.uv && this.uv !== Texture.DEF_UV) ? (this.uv[2] - this.uv[0]) * this.bitmap.width : this.bitmap.width;
        }, function (value) {
            this._w = value;
            this.sourceWidth || (this.sourceWidth = value);
        });
        __getset(0, __proto, 'repeat', function () {
            if (Render.isWebGL && this.bitmap) {
                return this.bitmap.repeat;
            }
            return true;
        }, function (value) {
            if (value) {
                if (Render.isWebGL && this.bitmap) {
                    this.bitmap.repeat = value;
                    if (value) {
                        this.bitmap.enableMerageInAtlas = false;
                    }
                }
            }
        });
        __getset(0, __proto, 'height', function () {
            if (this._h)
                return this._h;
            return (this.uv && this.uv !== Texture.DEF_UV) ? (this.uv[5] - this.uv[1]) * this.bitmap.height : this.bitmap.height;
        }, function (value) {
            this._h = value;
            this.sourceHeight || (this.sourceHeight = value);
        });
        __getset(0, __proto, 'isLinearSampling', function () {
            return Render.isWebGL ? (this.bitmap.minFifter != 0x2600) : true;
        }, function (value) {
            if (!value && Render.isWebGL) {
                if (!value && (this.bitmap.minFifter == -1) && (this.bitmap.magFifter == -1)) {
                    this.bitmap.minFifter = 0x2600;
                    this.bitmap.magFifter = 0x2600;
                    this.bitmap.enableMerageInAtlas = false;
                }
            }
        });
        Texture.moveUV = function (offsetX, offsetY, uv) {
            for (var i = 0; i < 8; i += 2) {
                uv[i] += offsetX;
                uv[i + 1] += offsetY;
            }
            return uv;
        };
        Texture.create = function (source, x, y, width, height, offsetX, offsetY, sourceWidth, sourceHeight) {
            (offsetX === void 0) && (offsetX = 0);
            (offsetY === void 0) && (offsetY = 0);
            (sourceWidth === void 0) && (sourceWidth = 0);
            (sourceHeight === void 0) && (sourceHeight = 0);
            var btex = (source instanceof laya.resource.Texture);
            var uv = btex ? source.uv : Texture.DEF_UV;
            var bitmap = btex ? source.bitmap : source;
            var bIsAtlas = RunDriver.isAtlas(bitmap);
            if (bIsAtlas) {
                var atlaser = bitmap._atlaser;
                var nAtlasID = (source)._atlasID;
                if (nAtlasID == -1) {
                    throw new Error("create texture error");
                }
                bitmap = atlaser._inAtlasTextureBitmapValue[nAtlasID];
                uv = atlaser._inAtlasTextureOriUVValue[nAtlasID];
            }
            if (!bitmap) return;
            var tex = new Texture(bitmap, null);
            if (bitmap.width && (x + width) > bitmap.width)
                width = bitmap.width - x;
            if (bitmap.height && (y + height) > bitmap.height)
                height = bitmap.height - y;
            tex.width = width;
            tex.height = height;
            tex.offsetX = offsetX;
            tex.offsetY = offsetY;
            tex.sourceWidth = sourceWidth || width;
            tex.sourceHeight = sourceHeight || height;
            var dwidth = 1 / bitmap.width;
            var dheight = 1 / bitmap.height;
            x *= dwidth;
            y *= dheight;
            width *= dwidth;
            height *= dheight;
            var u1 = tex.uv[0], v1 = tex.uv[1], u2 = tex.uv[4], v2 = tex.uv[5];
            var inAltasUVWidth = (u2 - u1), inAltasUVHeight = (v2 - v1);
            var oriUV = Texture.moveUV(uv[0], uv[1], [x, y, x + width, y, x + width, y + height, x, y + height]);
            tex.uv = [u1 + oriUV[0] * inAltasUVWidth, v1 + oriUV[1] * inAltasUVHeight, u2 - (1 - oriUV[2]) * inAltasUVWidth, v1 + oriUV[3] * inAltasUVHeight, u2 - (1 - oriUV[4]) * inAltasUVWidth, v2 - (1 - oriUV[5]) * inAltasUVHeight, u1 + oriUV[6] * inAltasUVWidth, v2 - (1 - oriUV[7]) * inAltasUVHeight];
            if (bIsAtlas) {
                tex.addTextureToAtlas();
            }
            ;
            var bitmapScale = bitmap.scaleRate;
            if (bitmapScale && bitmapScale != 1) {
                tex.sourceWidth /= bitmapScale;
                tex.sourceHeight /= bitmapScale;
                tex.width /= bitmapScale;
                tex.height /= bitmapScale;
                tex.scaleRate = bitmapScale;
                tex.offsetX /= bitmapScale;
                tex.offsetY /= bitmapScale;
            }
            else {
                tex.scaleRate = 1;
            }
            return tex;
        };
        Texture.createFromTexture = function (texture, x, y, width, height) {
            var texScaleRate = texture.scaleRate;
            if (texScaleRate != 1) {
                x *= texScaleRate;
                y *= texScaleRate;
                width *= texScaleRate;
                height *= texScaleRate;
            }
            var rect = Rectangle.TEMP.setTo(x - texture.offsetX, y - texture.offsetY, width, height);
            var result = rect.intersection(Texture._rect1.setTo(0, 0, texture.width, texture.height), Texture._rect2);
            if (result)
                var tex = Texture.create(texture, result.x, result.y, result.width, result.height, result.x - rect.x, result.y - rect.y, width, height);
            else
                return null;
            if (!tex || !tex.bitmap) return null;
            tex.bitmap._removeReference();
            return tex;
        };
        Texture.DEF_UV = [0, 0, 1.0, 0, 1.0, 1.0, 0, 1.0];
        Texture.INV_UV = [0, 1, 1.0, 1, 1.0, 0.0, 0, 0.0];
        Texture._rect1 = new Rectangle();
        Texture._rect2 = new Rectangle();
        return Texture;
    })(EventDispatcher);
    var TimeLine = (function (_super) {
        var tweenData;
        function TimeLine() {
            this._labelDic = null;
            this._tweenDic = {};
            this._tweenDataList = [];
            this._endTweenDataList = null;
            this._currTime = 0;
            this._lastTime = 0;
            this._startTime = 0;
            this._index = 0;
            this._gidIndex = 0;
            this._firstTweenDic = {};
            this._startTimeSort = false;
            this._endTimeSort = false;
            this._loopKey = false;
            this.scale = 1;
            this._frameRate = 60;
            this._frameIndex = 0;
            this._total = 0;
            TimeLine.__super.call(this);
        }
        __class(TimeLine, 'laya.utils.TimeLine', _super);
        var __proto = TimeLine.prototype;
        __proto.to = function (target, props, duration, ease, offset) {
            (offset === void 0) && (offset = 0);
            return this._create(target, props, duration, ease, offset, true);
        };
        __proto.from = function (target, props, duration, ease, offset) {
            (offset === void 0) && (offset = 0);
            return this._create(target, props, duration, ease, offset, false);
        };
        __proto._create = function (target, props, duration, ease, offset, isTo) {
            var tTweenData = Pool.getItemByClass("tweenData", tweenData);
            tTweenData.isTo = isTo;
            tTweenData.type = 0;
            tTweenData.target = target;
            tTweenData.duration = duration;
            tTweenData.data = props;
            tTweenData.startTime = this._startTime + offset;
            tTweenData.endTime = tTweenData.startTime + tTweenData.duration;
            tTweenData.ease = ease;
            this._startTime = Math.max(tTweenData.endTime, this._startTime);
            this._tweenDataList.push(tTweenData);
            this._startTimeSort = true;
            this._endTimeSort = true;
            return this;
        };
        __proto.addLabel = function (label, offset) {
            var tTweenData = Pool.getItemByClass("tweenData", tweenData);
            tTweenData.type = 1;
            tTweenData.data = label;
            tTweenData.endTime = tTweenData.startTime = this._startTime + offset;
            this._labelDic || (this._labelDic = {});
            this._labelDic[label] = tTweenData;
            this._tweenDataList.push(tTweenData);
            return this;
        };
        __proto.removeLabel = function (label) {
            if (this._labelDic && this._labelDic[label]) {
                var tTweenData = this._labelDic[label];
                if (tTweenData) {
                    var tIndex = this._tweenDataList.indexOf(tTweenData);
                    if (tIndex > -1) {
                        this._tweenDataList.splice(tIndex, 1);
                    }
                }
                delete this._labelDic[label];
            }
        };
        __proto.gotoTime = function (time) {
            if (this._tweenDataList == null || this._tweenDataList.length == 0)
                return;
            var tTween;
            var tObject;
            for (var p in this._firstTweenDic) {
                tObject = this._firstTweenDic[p];
                if (tObject) {
                    for (var tDataP in tObject) {
                        if (tObject.diyTarget.hasOwnProperty(tDataP)) {
                            tObject.diyTarget[tDataP] = tObject[tDataP];
                        }
                    }
                }
            }
            for (p in this._tweenDic) {
                tTween = this._tweenDic[p];
                tTween.clear();
                delete this._tweenDic[p];
            }
            this._index = 0;
            this._gidIndex = 0;
            this._currTime = time;
            this._lastTime = Browser.now();
            var tTweenDataCopyList;
            if (this._endTweenDataList == null || this._endTimeSort) {
                this._endTimeSort = false;
                this._endTweenDataList = tTweenDataCopyList = this._tweenDataList.concat();
                function Compare(paraA, paraB) {
                    if (paraA.endTime > paraB.endTime) {
                        return 1;
                    }
                    else if (paraA.endTime < paraB.endTime) {
                        return -1;
                    }
                    else {
                        return 0;
                    }
                }
                tTweenDataCopyList.sort(Compare);
            }
            else {
                tTweenDataCopyList = this._endTweenDataList;
            }
            ;
            var tTweenData;
            for (var i = 0, n = tTweenDataCopyList.length; i < n; i++) {
                tTweenData = tTweenDataCopyList[i];
                if (tTweenData.type == 0) {
                    if (time >= tTweenData.endTime) {
                        this._index = Math.max(this._index, i + 1);
                        var props = tTweenData.data;
                        if (tTweenData.isTo) {
                            for (var tP in props) {
                                tTweenData.target[tP] = props[tP];
                            }
                        }
                    }
                    else {
                        break;
                    }
                }
            }
            for (i = 0, n = this._tweenDataList.length; i < n; i++) {
                tTweenData = this._tweenDataList[i];
                if (tTweenData.type == 0) {
                    if (time >= tTweenData.startTime && time < tTweenData.endTime) {
                        this._index = Math.max(this._index, i + 1);
                        this._gidIndex++;
                        tTween = Pool.getItemByClass("tween", Tween);
                        tTween._create(tTweenData.target, tTweenData.data, tTweenData.duration, tTweenData.ease, Handler.create(this, this._animComplete, [this._gidIndex]), 0, false, tTweenData.isTo, true, false);
                        tTween.setStartTime(this._currTime - (time - tTweenData.startTime));
                        tTween._updateEase(this._currTime);
                        tTween.gid = this._gidIndex;
                        this._tweenDic[this._gidIndex] = tTween;
                    }
                }
            }
        };
        __proto.gotoLabel = function (Label) {
            if (this._labelDic == null)
                return;
            var tLabelData = this._labelDic[Label];
            if (tLabelData)
                this.gotoTime(tLabelData.startTime);
        };
        __proto.pause = function () {
            Laya.timer.clear(this, this._update);
        };
        __proto.resume = function () {
            this.play(this._currTime, this._loopKey);
        };
        __proto.play = function (timeOrLabel, loop) {
            (timeOrLabel === void 0) && (timeOrLabel = 0);
            (loop === void 0) && (loop = false);
            if (!this._tweenDataList)
                return;
            if (this._startTimeSort) {
                this._startTimeSort = false;
                function Compare(paraA, paraB) {
                    if (paraA.startTime > paraB.startTime) {
                        return 1;
                    }
                    else if (paraA.startTime < paraB.startTime) {
                        return -1;
                    }
                    else {
                        return 0;
                    }
                }
                this._tweenDataList.sort(Compare);
                for (var i = 0, n = this._tweenDataList.length; i < n; i++) {
                    var tTweenData = this._tweenDataList[i];
                    if (tTweenData != null && tTweenData.type == 0) {
                        var tTarget = tTweenData.target;
                        var gid = (tTarget.$_GID || (tTarget.$_GID = Utils.getGID()));
                        var tSrcData = null;
                        if (this._firstTweenDic[gid] == null) {
                            tSrcData = {};
                            tSrcData.diyTarget = tTarget;
                            this._firstTweenDic[gid] = tSrcData;
                        }
                        else {
                            tSrcData = this._firstTweenDic[gid];
                        }
                        for (var p in tTweenData.data) {
                            if (tSrcData[p] == null) {
                                tSrcData[p] = tTarget[p];
                            }
                        }
                    }
                }
            }
            if ((typeof timeOrLabel == 'string')) {
                this.gotoLabel(timeOrLabel);
            }
            else {
                this.gotoTime(timeOrLabel);
            }
            this._loopKey = loop;
            this._lastTime = Browser.now();
            Laya.timer.frameLoop(1, this, this._update);
        };
        __proto._update = function () {
            if (this._currTime >= this._startTime) {
                if (this._loopKey) {
                    this._complete();
                    if (!this._tweenDataList)
                        return;
                    this.gotoTime(0);
                }
                else {
                    for (var p in this._tweenDic) {
                        tTween = this._tweenDic[p];
                        tTween.complete();
                    }
                    this._complete();
                    this.pause();
                    return;
                }
            }
            ;
            var tNow = Browser.now();
            var tFrameTime = tNow - this._lastTime;
            var tCurrTime = this._currTime += tFrameTime * this.scale;
            this._lastTime = tNow;
            for (p in this._tweenDic) {
                tTween = this._tweenDic[p];
                tTween._updateEase(tCurrTime);
            }
            ;
            var tTween;
            if (this._tweenDataList.length != 0 && this._index < this._tweenDataList.length) {
                var tTweenData = this._tweenDataList[this._index];
                if (tCurrTime >= tTweenData.startTime) {
                    this._index++;
                    if (tTweenData.type == 0) {
                        this._gidIndex++;
                        tTween = Pool.getItemByClass("tween", Tween);
                        tTween._create(tTweenData.target, tTweenData.data, tTweenData.duration, tTweenData.ease, Handler.create(this, this._animComplete, [this._gidIndex]), 0, false, tTweenData.isTo, true, false);
                        tTween.setStartTime(tCurrTime);
                        tTween.gid = this._gidIndex;
                        this._tweenDic[this._gidIndex] = tTween;
                        tTween._updateEase(tCurrTime);
                    }
                    else {
                        this.event("label", tTweenData.data);
                    }
                }
            }
        };
        __proto._animComplete = function (index) {
            var tTween = this._tweenDic[index];
            if (tTween)
                delete this._tweenDic[index];
        };
        __proto._complete = function () {
            this.event("complete");
        };
        __proto.reset = function () {
            var p;
            if (this._labelDic) {
                for (p in this._labelDic) {
                    delete this._labelDic[p];
                }
            }
            ;
            var tTween;
            for (p in this._tweenDic) {
                tTween = this._tweenDic[p];
                tTween.clear();
                delete this._tweenDic[p];
            }
            for (p in this._firstTweenDic) {
                delete this._firstTweenDic[p];
            }
            this._endTweenDataList = null;
            if (this._tweenDataList && this._tweenDataList.length) {
                var i = 0, len = 0;
                len = this._tweenDataList.length;
                for (i = 0; i < len; i++) {
                    if (this._tweenDataList[i])
                        this._tweenDataList[i].destroy();
                }
            }
            this._tweenDataList.length = 0;
            this._currTime = 0;
            this._lastTime = 0;
            this._startTime = 0;
            this._index = 0;
            this._gidIndex = 0;
            this.scale = 1;
            Laya.timer.clear(this, this._update);
        };
        __proto.destroy = function () {
            this.reset();
            this._labelDic = null;
            this._tweenDic = null;
            this._tweenDataList = null;
            this._firstTweenDic = null;
        };
        __getset(0, __proto, 'index', function () {
            return this._frameIndex;
        }, function (value) {
            this._frameIndex = value;
            this.gotoTime(this._frameIndex / this._frameRate * 1000);
        });
        __getset(0, __proto, 'total', function () {
            this._total = Math.floor(this._startTime / 1000 * this._frameRate);
            return this._total;
        });
        TimeLine.to = function (target, props, duration, ease, offset) {
            (offset === void 0) && (offset = 0);
            return (new TimeLine()).to(target, props, duration, ease, offset);
        };
        TimeLine.from = function (target, props, duration, ease, offset) {
            (offset === void 0) && (offset = 0);
            return (new TimeLine()).from(target, props, duration, ease, offset);
        };
        TimeLine.__init$ = function () {
            tweenData = (function () {
                function tweenData() {
                    this.type = 0;
                    this.isTo = true;
                    this.startTime = NaN;
                    this.endTime = NaN;
                    this.target = null;
                    this.duration = NaN;
                    this.ease = null;
                    this.data = null;
                }
                __class(tweenData, '');
                var __proto = tweenData.prototype;
                __proto.destroy = function () {
                    this.target = null;
                    this.ease = null;
                    this.data = null;
                    this.isTo = true;
                    this.type = 0;
                    Pool.recover("tweenData", this);
                };
                return tweenData;
            })();
        };
        return TimeLine;
    })(EventDispatcher);
    var Sprite = (function (_super) {
        function Sprite() {
            this._transform = null;
            this._tfChanged = false;
            this._x = 0;
            this._y = 0;
            this._width = 0;
            this._height = 0;
            this._repaint = 1;
            this._mouseEnableState = 0;
            this._zOrder = 0;
            this._graphics = null;
            this._renderType = 0;
            this._optimizeScrollRect = false;
            this._texture = null;
            this.mouseThrough = false;
            this.autoSize = false;
            this.hitTestPrior = false;
            this.viewport = null;
            Sprite.__super.call(this);
            this._style = Style.EMPTY;
        }
        __class(Sprite, 'laya.display.Sprite', _super);
        var __proto = Sprite.prototype;
        Laya.imps(__proto, { "laya.display.ILayout": true });
        __proto.createConchModel = function () {
            return new ConchNode();
        };
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            this._releaseMem();
            _super.prototype.destroy.call(this, destroyChild);
            this._style && this._style.destroy();
            this._transform && this._transform.destroy();
            this._transform = null;
            this._style = null;
            this._graphics = null;
        };
        __proto.updateZOrder = function () {
            Utils.updateOrder(this._childs) && this.repaint();
        };
        __proto.reCache = function () {
            if (this._$P.cacheCanvas)
                this._$P.cacheCanvas.reCache = true;
            this._repaint = 1;
        };
        __proto.setBounds = function (bound) {
            this._set$P("uBounds", bound);
        };
        __proto.getBounds = function () {
            if (!this._$P.mBounds)
                this._set$P("mBounds", new Rectangle());
            return Rectangle._getWrapRec(this._boundPointsToParent(), this._$P.mBounds);
        };
        __proto.getSelfBounds = function () {
            if (this._$P.uBounds)
                return this._$P.uBounds;
            if (!this._$P.mBounds)
                this._set$P("mBounds", new Rectangle());
            return Rectangle._getWrapRec(this._getBoundPointsM(false), this._$P.mBounds);
        };
        __proto._boundPointsToParent = function (ifRotate) {
            (ifRotate === void 0) && (ifRotate = false);
            var pX = 0, pY = 0;
            if (this._style) {
                pX = this._style._tf.translateX;
                pY = this._style._tf.translateY;
                ifRotate = ifRotate || (this._style._tf.rotate !== 0);
                if (this._style.scrollRect) {
                    pX += this._style.scrollRect.x;
                    pY += this._style.scrollRect.y;
                }
            }
            ;
            var pList = this._getBoundPointsM(ifRotate);
            if (!pList || pList.length < 1)
                return pList;
            if (pList.length != 8) {
                pList = ifRotate ? GrahamScan.scanPList(pList) : Rectangle._getWrapRec(pList, Rectangle.TEMP)._getBoundPoints();
            }
            if (!this.transform) {
                Utils.transPointList(pList, this._x - pX, this._y - pY);
                return pList;
            }
            ;
            var tPoint = Point.TEMP;
            var i = 0, len = pList.length;
            for (i = 0; i < len; i += 2) {
                tPoint.x = pList[i];
                tPoint.y = pList[i + 1];
                this.toParentPoint(tPoint);
                pList[i] = tPoint.x;
                pList[i + 1] = tPoint.y;
            }
            return pList;
        };
        __proto.getGraphicBounds = function (realSize) {
            (realSize === void 0) && (realSize = false);
            if (!this._graphics)
                return Rectangle.TEMP.setTo(0, 0, 0, 0);
            return this._graphics.getBounds(realSize);
        };
        __proto._getBoundPointsM = function (ifRotate) {
            (ifRotate === void 0) && (ifRotate = false);
            if (this._$P.uBounds)
                return this._$P.uBounds._getBoundPoints();
            if (!this._$P.temBM)
                this._set$P("temBM", []);
            if (this.scrollRect) {
                var rst = Utils.clearArray(this._$P.temBM);
                var rec = Rectangle.TEMP;
                rec.copyFrom(this.scrollRect);
                Utils.concatArray(rst, rec._getBoundPoints());
                return rst;
            }
            ;
            var pList = this._graphics ? this._graphics.getBoundPoints() : Utils.clearArray(this._$P.temBM);
            var child;
            var cList;
            var __childs;
            __childs = this._childs;
            for (var i = 0, n = __childs.length; i < n; i++) {
                child = __childs[i];
                if ((child instanceof laya.display.Sprite) && child.visible == true) {
                    cList = child._boundPointsToParent(ifRotate);
                    if (cList)
                        pList = pList ? Utils.concatArray(pList, cList) : cList;
                }
            }
            return pList;
        };
        __proto.getStyle = function () {
            this._style === Style.EMPTY && (this._style = new Style());
            return this._style;
        };
        __proto.setStyle = function (value) {
            this._style = value;
        };
        __proto._adjustTransform = function () {
            'use strict';
            this._tfChanged = false;
            var style = this._style;
            var tf = style._tf;
            var sx = tf.scaleX, sy = tf.scaleY;
            var m;
            if (tf.rotate || sx !== 1 || sy !== 1 || tf.skewX || tf.skewY) {
                m = this._transform || (this._transform = Matrix.create());
                m.bTransform = true;
                var skx = (tf.rotate - tf.skewX) * 0.0174532922222222;
                var sky = (tf.rotate + tf.skewY) * 0.0174532922222222;
                var cx = Math.cos(sky);
                var ssx = Math.sin(sky);
                var cy = Math.sin(skx);
                var ssy = Math.cos(skx);
                m.a = sx * cx;
                m.b = sx * ssx;
                m.c = -sy * cy;
                m.d = sy * ssy;
                m.tx = m.ty = 0;
                return m;
            }
            else {
                this._transform && this._transform.destroy();
                this._transform = null;
                this._renderType &= ~0x04;
            }
            return m;
        };
        __proto.pos = function (x, y, speedMode) {
            (speedMode === void 0) && (speedMode = false);
            if (this._x !== x || this._y !== y) {
                if (this.destroyed)
                    return this;
                if (speedMode) {
                    this._x = x;
                    this._y = y;
                    this.conchModel && this.conchModel.pos(this._x, this._y);
                    var p = this._parent;
                    if (p && p._repaint === 0) {
                        p._repaint = 1;
                        p.parentRepaint();
                    }
                    if (this._$P.maskParent && this._$P.maskParent._repaint === 0) {
                        this._$P.maskParent._repaint = 1;
                        this._$P.maskParent.parentRepaint();
                    }
                }
                else {
                    this.x = x;
                    this.y = y;
                }
            }
            return this;
        };
        __proto.pivot = function (x, y) {
            this.pivotX = x;
            this.pivotY = y;
            return this;
        };
        __proto.size = function (width, height) {
            this.width = width;
            this.height = height;
            return this;
        };
        __proto.scale = function (scaleX, scaleY, speedMode) {
            (speedMode === void 0) && (speedMode = false);
            var style = this.getStyle();
            var _tf = style._tf;
            if (_tf.scaleX != scaleX || _tf.scaleY != scaleY) {
                if (this.destroyed)
                    return this;
                if (speedMode) {
                    style.setScale(scaleX, scaleY);
                    this._tfChanged = true;
                    this.conchModel && this.conchModel.scale(scaleX, scaleY);
                    this._renderType |= 0x04;
                    var p = this._parent;
                    if (p && p._repaint === 0) {
                        p._repaint = 1;
                        p.parentRepaint();
                    }
                }
                else {
                    this.scaleX = scaleX;
                    this.scaleY = scaleY;
                }
            }
            return this;
        };
        __proto.skew = function (skewX, skewY) {
            this.skewX = skewX;
            this.skewY = skewY;
            return this;
        };
        __proto.render = function (context, x, y) {
            Stat.spriteCount++;
            RenderSprite.renders[this._renderType]._fun(this, context, x + this._x, y + this._y);
            this._repaint = 0;
        };
        __proto.drawToCanvas = function (canvasWidth, canvasHeight, offsetX, offsetY) {
            if (Render.isConchNode) {
                var canvas = HTMLCanvas.create("2D");
                var context = new RenderContext(canvasWidth, canvasHeight, canvas);
                context.ctx.setCanvasType(1);
                this.conchModel.drawToCanvas(canvas.source, offsetX, offsetY);
                return canvas;
            }
            else {
                return RunDriver.drawToCanvas(this, this._renderType, canvasWidth, canvasHeight, offsetX, offsetY);
            }
        };
        __proto.customRender = function (context, x, y) {
            this._renderType |= 0x400;
        };
        __proto._applyFilters = function () {
            if (Render.isWebGL)
                return;
            var _filters;
            _filters = this._$P.filters;
            if (!_filters || _filters.length < 1)
                return;
            for (var i = 0, n = _filters.length; i < n; i++) {
                _filters[i].action.apply(this._$P.cacheCanvas);
            }
        };
        __proto._isHaveGlowFilter = function () {
            var i = 0, len = 0;
            if (this.filters) {
                for (i = 0; i < this.filters.length; i++) {
                    if (this.filters[i].type == 0x08) {
                        return true;
                    }
                }
            }
            for (i = 0, len = this._childs.length; i < len; i++) {
                if (this._childs[i]._isHaveGlowFilter()) {
                    return true;
                }
            }
            return false;
        };
        __proto.localToGlobal = function (point, createNewPoint) {
            (createNewPoint === void 0) && (createNewPoint = true);
            if (createNewPoint === true) {
                point = new Point(point.x, point.y);
            }
            ;
            var ele = this;
            while (ele) {
                if (ele == Laya.stage)
                    break;
                point = ele.toParentPoint(point);
                ele = ele.parent;
            }
            return point;
        };
        __proto.globalToLocal = function (point, createNewPoint) {
            (createNewPoint === void 0) && (createNewPoint = false);
            if (createNewPoint) {
                point = new Point(point.x, point.y);
            }
            ;
            var ele = this;
            var list = [];
            while (ele) {
                if (ele == Laya.stage)
                    break;
                list.push(ele);
                ele = ele.parent;
            }
            ;
            var i = list.length - 1;
            while (i >= 0) {
                ele = list[i];
                point = ele.fromParentPoint(point);
                i--;
            }
            return point;
        };
        __proto.toParentPoint = function (point) {
            if (!point)
                return point;
            point.x -= this.pivotX;
            point.y -= this.pivotY;
            if (this.transform) {
                this._transform.transformPoint(point);
            }
            point.x += this._x;
            point.y += this._y;
            var scroll = this._style.scrollRect;
            if (scroll) {
                point.x -= scroll.x;
                point.y -= scroll.y;
            }
            return point;
        };
        __proto.fromParentPoint = function (point) {
            if (!point)
                return point;
            point.x -= this._x;
            point.y -= this._y;
            var scroll = this._style.scrollRect;
            if (scroll) {
                point.x += scroll.x;
                point.y += scroll.y;
            }
            if (this.transform) {
                this._transform.invertTransformPoint(point);
            }
            point.x += this.pivotX;
            point.y += this.pivotY;
            return point;
        };
        __proto.on = function (type, caller, listener, args) {
            if (this._mouseEnableState !== 1 && this.isMouseEvent(type)) {
                this.mouseEnabled = true;
                this._setBit(0x2, true);
                if (this._parent) {
                    this._$2__onDisplay();
                }
                return this._createListener(type, caller, listener, args, false);
            }
            return _super.prototype.on.call(this, type, caller, listener, args);
        };
        __proto.once = function (type, caller, listener, args) {
            if (this._mouseEnableState !== 1 && this.isMouseEvent(type)) {
                this.mouseEnabled = true;
                this._setBit(0x2, true);
                if (this._parent) {
                    this._$2__onDisplay();
                }
                return this._createListener(type, caller, listener, args, true);
            }
            return _super.prototype.once.call(this, type, caller, listener, args);
        };
        __proto._$2__onDisplay = function () {
            if (this._mouseEnableState !== 1) {
                var ele = this;
                ele = ele.parent;
                while (ele && ele._mouseEnableState !== 1) {
                    if (ele._getBit(0x2))
                        break;
                    ele.mouseEnabled = true;
                    ele._setBit(0x2, true);
                    ele = ele.parent;
                }
            }
        };
        __proto.loadImage = function (url, x, y, width, height, complete) {
            var _$this = this;
            (x === void 0) && (x = 0);
            (y === void 0) && (y = 0);
            (width === void 0) && (width = 0);
            (height === void 0) && (height = 0);
            function loaded(tex) {
                if (!_$this.destroyed) {
                    _$this.size(x + (width || tex.width), y + (height || tex.height));
                    _$this.repaint();
                    complete && complete.runWith(tex);
                }
            }
            this.graphics.loadImage(url, x, y, width, height, loaded);
            return this;
        };
        __proto.repaint = function () {
            this.conchModel && this.conchModel.repaint && this.conchModel.repaint();
            if (this._repaint === 0) {
                this._repaint = 1;
                this.parentRepaint();
            }
            if (this._$P && this._$P.maskParent) {
                this._$P.maskParent.repaint();
            }
        };
        __proto._needRepaint = function () {
            return (this._repaint !== 0) && this._$P.cacheCanvas && this._$P.cacheCanvas.reCache;
        };
        __proto._childChanged = function (child) {
            if (this._childs.length)
                this._renderType |= 0x800;
            else
                this._renderType &= ~0x800;
            if (child && this._get$P("hasZorder"))
                Laya.timer.callLater(this, this.updateZOrder);
            this.repaint();
        };
        __proto.parentRepaint = function () {
            var p = this._parent;
            if (p && p._repaint === 0) {
                p._repaint = 1;
                p.parentRepaint();
            }
        };
        __proto.startDrag = function (area, hasInertia, elasticDistance, elasticBackTime, data, disableMouseEvent, ratio) {
            (hasInertia === void 0) && (hasInertia = false);
            (elasticDistance === void 0) && (elasticDistance = 0);
            (elasticBackTime === void 0) && (elasticBackTime = 300);
            (disableMouseEvent === void 0) && (disableMouseEvent = false);
            (ratio === void 0) && (ratio = 0.92);
            this._$P.dragging || (this._set$P("dragging", new Dragging()));
            this._$P.dragging.start(this, area, hasInertia, elasticDistance, elasticBackTime, data, disableMouseEvent, ratio);
        };
        __proto.stopDrag = function () {
            this._$P.dragging && this._$P.dragging.stop();
        };
        __proto._releaseMem = function () {
            if (!this._$P)
                return;
            var cc = this._$P.cacheCanvas;
            if (cc && cc.ctx) {
                Pool.recover("RenderContext", cc.ctx);
                cc.ctx.canvas.size(0, 0);
                cc.ctx = null;
            }
            ;
            var fc = this._$P._filterCache;
            if (fc) {
                fc.destroy();
                fc.recycle();
                this._set$P('_filterCache', null);
            }
            this._$P._isHaveGlowFilter && this._set$P('_isHaveGlowFilter', false);
            this._$P._isHaveGlowFilter = null;
        };
        __proto._setDisplay = function (value) {
            if (!value)
                this._releaseMem();
            _super.prototype._setDisplay.call(this, value);
        };
        __proto.hitTestPoint = function (x, y) {
            var point = this.globalToLocal(Point.TEMP.setTo(x, y));
            x = point.x;
            y = point.y;
            var rect = this._$P.hitArea ? this._$P.hitArea : (this._width > 0 && this._height > 0) ? Rectangle.TEMP.setTo(0, 0, this._width, this._height) : this.getSelfBounds();
            return rect.contains(x, y);
        };
        __proto.getMousePoint = function () {
            return this.globalToLocal(Point.TEMP.setTo(Laya.stage.mouseX, Laya.stage.mouseY));
        };
        __proto._getWords = function () {
            return null;
        };
        __proto._addChildsToLayout = function (out) {
            var words = this._getWords();
            if (words == null && this._childs.length == 0)
                return false;
            if (words) {
                for (var i = 0, n = words.length; i < n; i++) {
                    out.push(words[i]);
                }
            }
            this._childs.forEach(function (o, index, array) {
                o._style._enableLayout() && o._addToLayout(out);
            });
            return true;
        };
        __proto._addToLayout = function (out) {
            if (this._style.absolute)
                return;
            this._style.block ? out.push(this) : (this._addChildsToLayout(out) && (this.x = this.y = 0));
        };
        __proto._isChar = function () {
            return false;
        };
        __proto._getCSSStyle = function () {
            return this._style.getCSSStyle();
        };
        __proto._setAttributes = function (name, value) {
            switch (name) {
                case 'x':
                    this.x = parseFloat(value);
                    break;
                case 'y':
                    this.y = parseFloat(value);
                    break;
                case 'width':
                    this.width = parseFloat(value);
                    break;
                case 'height':
                    this.height = parseFloat(value);
                    break;
                default:
                    this[name] = value;
            }
        };
        __proto._layoutLater = function () {
            this.parent && (this.parent)._layoutLater();
        };
        __getset(0, __proto, 'optimizeScrollRect', function () {
            return this._optimizeScrollRect;
        }, function (b) {
            if (this._optimizeScrollRect != b) {
                this._optimizeScrollRect = b;
                this.conchModel && this.conchModel.optimizeScrollRect(b);
            }
        });
        __getset(0, __proto, 'customRenderEnable', null, function (b) {
            if (b) {
                this._renderType |= 0x400;
                if (Render.isConchNode) {
                    Sprite.CustomList.push(this);
                    var canvas = new HTMLCanvas("2d");
                    canvas._setContext(new CanvasRenderingContext2D());
                    this.customContext = new RenderContext(0, 0, canvas);
                    canvas.context.setCanvasType && canvas.context.setCanvasType(2);
                    this.conchModel.custom(canvas.context);
                }
            }
        });
        __getset(0, __proto, 'cacheAsBitmap', function () {
            return this.cacheAs !== "none";
        }, function (value) {
            this.cacheAs = value ? (this._$P["hasFilter"] ? "none" : "normal") : "none";
        });
        __getset(0, __proto, 'cacheAs', function () {
            return this._$P.cacheCanvas == null ? "none" : this._$P.cacheCanvas.type;
        }, function (value) {
            var cacheCanvas = this._$P.cacheCanvas;
            if (value === (cacheCanvas ? cacheCanvas.type : "none"))
                return;
            if (value !== "none") {
                if (!this._getBit(0x1))
                    this._setUpNoticeType(0x1);
                cacheCanvas || (cacheCanvas = this._set$P("cacheCanvas", Pool.getItemByClass("cacheCanvas", Object)));
                cacheCanvas.type = value;
                cacheCanvas.reCache = true;
                this._renderType |= 0x10;
                if (value == "bitmap")
                    this.conchModel && this.conchModel.cacheAs(1);
                this._set$P("cacheForFilters", false);
            }
            else {
                if (this._$P["hasFilter"]) {
                    this._set$P("cacheForFilters", true);
                }
                else {
                    if (cacheCanvas) {
                        var cc = cacheCanvas;
                        if (cc && cc.ctx) {
                            Pool.recover("RenderContext", cc.ctx);
                            cc.ctx.canvas.size(0, 0);
                            cc.ctx = null;
                        }
                        Pool.recover("cacheCanvas", cacheCanvas);
                    }
                    this._$P.cacheCanvas = null;
                    this._renderType &= ~0x10;
                    this.conchModel && this.conchModel.cacheAs(0);
                }
            }
            this.repaint();
        });
        __getset(0, __proto, 'zOrder', function () {
            return this._zOrder;
        }, function (value) {
            if (this._zOrder != value) {
                this._zOrder = value;
                this.conchModel && this.conchModel.setZOrder && this.conchModel.setZOrder(value);
                if (this._parent) {
                    value && this._parent._set$P("hasZorder", true);
                    Laya.timer.callLater(this._parent, this.updateZOrder);
                }
            }
        });
        __getset(0, __proto, 'rotation', function () {
            return this._style._tf.rotate;
        }, function (value) {
            var style = this.getStyle();
            if (style && style._tf.rotate !== value) {
                style.setRotate(value);
                this._tfChanged = true;
                this.conchModel && this.conchModel.rotate(value);
                this._renderType |= 0x04;
                var p = this._parent;
                if (p && p._repaint === 0) {
                    p._repaint = 1;
                    p.parentRepaint();
                }
            }
        });
        __getset(0, __proto, 'width', function () {
            if (!this.autoSize)
                return this._width;
            return this.getSelfBounds().width;
        }, function (value) {
            if (this._width !== value) {
                this._width = value;
                this.conchModel && this.conchModel.size(value, this._height);
                this.repaint();
            }
        });
        __getset(0, __proto, 'x', function () {
            return this._x;
        }, function (value) {
            if (this._x !== value) {
                if (this.destroyed)
                    return;
                this._x = value;
                this.conchModel && this.conchModel.pos(value, this._y);
                var p = this._parent;
                if (p && p._repaint === 0) {
                    p._repaint = 1;
                    p.parentRepaint();
                }
                if (this._$P.maskParent && this._$P.maskParent._repaint === 0) {
                    this._$P.maskParent._repaint = 1;
                    this._$P.maskParent.parentRepaint();
                }
            }
        });
        __getset(0, __proto, 'globalScaleY', function () {
            var scale = 1;
            var ele = this;
            while (ele) {
                if (ele === Laya.stage)
                    break;
                scale *= ele.scaleY;
                ele = ele.parent;
            }
            return scale;
        });
        __getset(0, __proto, 'hitArea', function () {
            return this._$P.hitArea;
        }, function (value) {
            this._set$P("hitArea", value);
        });
        __getset(0, __proto, 'staticCache', function () {
            return this._$P.staticCache;
        }, function (value) {
            this._set$P("staticCache", value);
            if (!value)
                this.reCache();
        });
        __getset(0, __proto, 'texture', function () {
            return this._texture;
        }, function (value) {
            if (this._texture != value) {
                this._texture = value;
                this.graphics.cleanByTexture(value, 0, 0);
            }
        });
        __getset(0, __proto, 'y', function () {
            return this._y;
        }, function (value) {
            if (this._y !== value) {
                if (this.destroyed)
                    return;
                this._y = value;
                this.conchModel && this.conchModel.pos(this._x, value);
                var p = this._parent;
                if (p && p._repaint === 0) {
                    p._repaint = 1;
                    p.parentRepaint();
                }
                if (this._$P.maskParent && this._$P.maskParent._repaint === 0) {
                    this._$P.maskParent._repaint = 1;
                    this._$P.maskParent.parentRepaint();
                }
            }
        });
        __getset(0, __proto, 'height', function () {
            if (!this.autoSize)
                return this._height;
            return this.getSelfBounds().height;
        }, function (value) {
            if (this._height !== value) {
                this._height = value;
                this.conchModel && this.conchModel.size(this._width, value);
                this.repaint();
            }
        });
        __getset(0, __proto, 'blendMode', function () {
            return this._style.blendMode;
        }, function (value) {
            this.getStyle().blendMode = value;
            this.conchModel && this.conchModel.blendMode(value);
            if (value && value != "source-over")
                this._renderType |= 0x08;
            else
                this._renderType &= ~0x08;
            this.parentRepaint();
        });
        __getset(0, __proto, 'scaleX', function () {
            return this._style._tf.scaleX;
        }, function (value) {
            var style = this.getStyle();
            if (style && style._tf.scaleX !== value) {
                style.setScaleX(value);
                this._tfChanged = true;
                this.conchModel && this.conchModel.scale(value, style._tf.scaleY);
                this._renderType |= 0x04;
                var p = this._parent;
                if (p && p._repaint === 0) {
                    p._repaint = 1;
                    p.parentRepaint();
                }
            }
        });
        __getset(0, __proto, 'scaleY', function () {
            return this._style._tf.scaleY;
        }, function (value) {
            var style = this.getStyle();
            if (style && style._tf.scaleY !== value) {
                style.setScaleY(value);
                this._tfChanged = true;
                this.conchModel && this.conchModel.scale(style._tf.scaleX, value);
                this._renderType |= 0x04;
                var p = this._parent;
                if (p && p._repaint === 0) {
                    p._repaint = 1;
                    p.parentRepaint();
                }
            }
        });
        __getset(0, __proto, 'stage', function () {
            return this.displayedInStage ? Laya.stage : null;
        });
        __getset(0, __proto, 'skewX', function () {
            return this._style._tf.skewX;
        }, function (value) {
            var style = this.getStyle();
            if (style._tf.skewX !== value) {
                style.setSkewX(value);
                this._tfChanged = true;
                this.conchModel && this.conchModel.skew(value, style._tf.skewY);
                this._renderType |= 0x04;
                var p = this._parent;
                if (p && p._repaint === 0) {
                    p._repaint = 1;
                    p.parentRepaint();
                }
            }
        });
        __getset(0, __proto, 'scrollRect', function () {
            return this._style.scrollRect;
        }, function (value) {
            this.getStyle().scrollRect = value;
            this.repaint();
            if (value) {
                this._renderType |= 0x80;
                this.conchModel && this.conchModel.scrollRect(value.x, value.y, value.width, value.height);
            }
            else {
                this._renderType &= ~0x80;
                if (this.conchModel) {
                    if (Sprite.RUNTIMEVERION < "0.9.1")
                        this.conchModel.removeType(0x40);
                    else
                        this.conchModel.removeType(0x80);
                }
            }
        });
        __getset(0, __proto, 'skewY', function () {
            return this._style._tf.skewY;
        }, function (value) {
            var style = this.getStyle();
            if (style._tf.skewY !== value) {
                style.setSkewY(value);
                this._tfChanged = true;
                this.conchModel && this.conchModel.skew(style._tf.skewX, value);
                this._renderType |= 0x04;
                var p = this._parent;
                if (p && p._repaint === 0) {
                    p._repaint = 1;
                    p.parentRepaint();
                }
            }
        });
        __getset(0, __proto, 'transform', function () {
            return this._tfChanged ? this._adjustTransform() : this._transform;
        }, function (value) {
            this._tfChanged = false;
            this._transform = value;
            if (value) {
                this._x = value.tx;
                this._y = value.ty;
                value.tx = value.ty = 0;
                this.conchModel && this.conchModel.transform(value.a, value.b, value.c, value.d, this._x, this._y);
            }
            if (value)
                this._renderType |= 0x04;
            else {
                this._renderType &= ~0x04;
                this.conchModel && this.conchModel.removeType(0x04);
            }
            this.parentRepaint();
        });
        __getset(0, __proto, 'pivotX', function () {
            return this._style._tf.translateX;
        }, function (value) {
            this.getStyle().setTranslateX(value);
            this.conchModel && this.conchModel.pivot(value, this._style._tf.translateY);
            this.repaint();
        });
        __getset(0, __proto, 'pivotY', function () {
            return this._style._tf.translateY;
        }, function (value) {
            this.getStyle().setTranslateY(value);
            this.conchModel && this.conchModel.pivot(this._style._tf.translateX, value);
            this.repaint();
        });
        __getset(0, __proto, 'alpha', function () {
            return this._style.alpha;
        }, function (value) {
            if (this._style && this._style.alpha !== value) {
                value = value < 0 ? 0 : (value > 1 ? 1 : value);
                this.getStyle().alpha = value;
                this.conchModel && this.conchModel.alpha(value);
                if (value !== 1)
                    this._renderType |= 0x02;
                else
                    this._renderType &= ~0x02;
                this.parentRepaint();
            }
        });
        __getset(0, __proto, 'visible', function () {
            return this._style.visible;
        }, function (value) {
            if (this._style && this._style.visible !== value) {
                this.getStyle().visible = value;
                this.conchModel && this.conchModel.visible(value);
                this.parentRepaint();
            }
        });
        __getset(0, __proto, 'graphics', function () {
            return this._graphics || (this.graphics = RunDriver.createGraphics());
        }, function (value) {
            if (this._graphics)
                this._graphics._sp = null;
            this._graphics = value;
            if (value) {
                this._renderType &= ~0x01;
                this._renderType |= 0x200;
                value._sp = this;
                this.conchModel && this.conchModel.graphics(this._graphics);
            }
            else {
                this._renderType &= ~0x200;
                this._renderType &= ~0x01;
                if (this.conchModel) {
                    if (Sprite.RUNTIMEVERION < "0.9.1")
                        this.conchModel.removeType(0x100);
                    else
                        this.conchModel.removeType(0x200);
                }
            }
            this.repaint();
        });
        __getset(0, __proto, 'filters', function () {
            return this._$P.filters;
        }, function (value) {
            value && value.length === 0 && (value = null);
            if (this._$P.filters == value)
                return;
            this._set$P("filters", value ? value.slice() : null);
            if (Render.isConchApp) {
                if (this.conchModel) {
                    if (Sprite.RUNTIMEVERION < "0.9.1")
                        this.conchModel.removeType(0x10);
                    else
                        this.conchModel.removeType(0x20);
                }
                if (this._$P.filters && this._$P.filters.length == 1) {
                    this._$P.filters[0].callNative(this);
                }
            }
            if (Render.isWebGL) {
                if (value && value.length) {
                    this._renderType |= 0x20;
                }
                else {
                    this._renderType &= ~0x20;
                }
            }
            if (value && value.length > 0) {
                if (!this._getBit(0x1))
                    this._setUpNoticeType(0x1);
                if (!(Render.isWebGL && value.length == 1 && (((value[0]) instanceof laya.filters.ColorFilter)))) {
                    // 只有未放大的情况下缓存为图片，否则如果缓存的话会造成小图缓存图片后再放大就马赛克的现象
                    if ((this.scaleX <= 1 && this.scaleY <= 1) && this.cacheAs != "bitmap") {
                        if (!Render.isConchNode)
                            this.cacheAs = "bitmap";
                        this._set$P("cacheForFilters", true);
                    }
                    this._set$P("hasFilter", true);
                }
            }
            else {
                this._set$P("hasFilter", false);
                if (this._$P["cacheForFilters"] && this.cacheAs == "bitmap") {
                    this.cacheAs = "none";
                }
            }
            this.repaint();
        });
        __getset(0, __proto, 'parent', _super.prototype._$get_parent, function (value) {
            Laya.superSet(Node, this, 'parent', value);
            if (value && this._getBit(0x2)) {
                this._$2__onDisplay();
            }
        });
        __getset(0, __proto, 'mask', function () {
            return this._$P._mask;
        }, function (value) {
            if (value && this.mask && this.mask._$P.maskParent)
                return;
            if (value) {
                this.cacheAs = "bitmap";
                this._set$P("_mask", value);
                value._set$P("maskParent", this);
            }
            else {
                this.cacheAs = "none";
                this.mask && this.mask._set$P("maskParent", null);
                this._set$P("_mask", value);
            }
            this.conchModel && this.conchModel.mask(value ? value.conchModel : null);
            this._renderType |= 0x40;
            this.parentRepaint();
        });
        __getset(0, __proto, 'mouseEnabled', function () {
            return this._mouseEnableState > 1;
        }, function (value) {
            this._mouseEnableState = value ? 2 : 1;
        });
        __getset(0, __proto, 'globalScaleX', function () {
            var scale = 1;
            var ele = this;
            while (ele) {
                if (ele === Laya.stage)
                    break;
                scale *= ele.scaleX;
                ele = ele.parent;
            }
            return scale;
        });
        __getset(0, __proto, 'mouseX', function () {
            return this.getMousePoint().x;
        });
        __getset(0, __proto, 'mouseY', function () {
            return this.getMousePoint().y;
        });
        Sprite.fromImage = function (url) {
            return new Sprite().loadImage(url);
        };
        Sprite.CustomList = [];
        __static(Sprite, ['RUNTIMEVERION', function () { return this.RUNTIMEVERION = window.conch ? conchConfig.getRuntimeVersion().substr(conchConfig.getRuntimeVersion().lastIndexOf('-') + 1) : ''; }
        ]);
        return Sprite;
    })(Node);
    var AudioSoundChannel = (function (_super) {
        function AudioSoundChannel(audio) {
            this._audio = null;
            this._onEnd = null;
            this._resumePlay = null;
            AudioSoundChannel.__super.call(this);
            this._onEnd = Utils.bind(this.__onEnd, this);
            this._resumePlay = Utils.bind(this.__resumePlay, this);
            audio.addEventListener("ended", this._onEnd);
            this._audio = audio;
        }
        __class(AudioSoundChannel, 'laya.media.h5audio.AudioSoundChannel', _super);
        var __proto = AudioSoundChannel.prototype;
        __proto.__onEnd = function () {
            if (this.loops == 1) {
                if (this.completeHandler) {
                    Laya.timer.once(10, this, this.__runComplete, [this.completeHandler], false);
                    this.completeHandler = null;
                }
                this.stop();
                this.event("complete");
                return;
            }
            if (this.loops > 0) {
                this.loops--;
            }
            this.startTime = 0;
            this.play();
        };
        __proto.__resumePlay = function () {
            if (this._audio)
                this._audio.removeEventListener("canplay", this._resumePlay);
            try {
                this._audio.currentTime = this.startTime;
                Browser.container.appendChild(this._audio);
                this._audio.play();
            }
            catch (e) {
                this.event("error");
            }
        };
        __proto.play = function () {
            this.isStopped = false;
            if (!this._audio)
                return;
            try {
                this._audio.currentTime = this.startTime;
            }
            catch (e) {
                this._audio.addEventListener("canplay", this._resumePlay);
                return;
            }
            SoundManager.addChannel(this);
            Browser.container.appendChild(this._audio);
            if ("play" in this._audio)
                this._audio.play();
        };
        __proto.stop = function () {
            this.isStopped = true;
            SoundManager.removeChannel(this);
            this.completeHandler = null;
            if (!this._audio)
                return;
            if ("pause" in this._audio)
                if (Render.isConchApp) {
                    this._audio.stop();
                }
            this._audio.pause();
            this._audio.removeEventListener("ended", this._onEnd);
            this._audio.removeEventListener("canplay", this._resumePlay);
            if (!Browser.onIE) {
                if (this._audio != AudioSound._musicAudio) {
                    Pool.recover("audio:" + this.url, this._audio);
                }
            }
            Browser.removeElement(this._audio);
            this._audio = null;
        };
        __proto.pause = function () {
            this.isStopped = true;
            SoundManager.removeChannel(this);
            if ("pause" in this._audio)
                this._audio.pause();
        };
        __proto.resume = function () {
            if (!this._audio)
                return;
            this.isStopped = false;
            SoundManager.addChannel(this);
            if ("play" in this._audio)
                this._audio.play();
        };
        __getset(0, __proto, 'position', function () {
            if (!this._audio)
                return 0;
            return this._audio.currentTime;
        });
        __getset(0, __proto, 'duration', function () {
            if (!this._audio)
                return 0;
            return this._audio.duration;
        });
        __getset(0, __proto, 'volume', function () {
            if (!this._audio)
                return 1;
            return this._audio.volume;
        }, function (v) {
            if (!this._audio)
                return;
            this._audio.volume = v;
        });
        __getset(0, __proto, 'playbackRate', function () {
            if (!this._audio)
                return 1;
            return this._audio.playbackRate;
        }, function (v) {
            if (!this._audio)
                return;
            this._audio.playbackRate = v;
        });
        return AudioSoundChannel;
    })(SoundChannel);
    var WebAudioSoundChannel = (function (_super) {
        function WebAudioSoundChannel() {
            this.audioBuffer = null;
            this.gain = null;
            this.bufferSource = null;
            this._currentTime = 0;
            this._volume = 1;
            this._startTime = 0;
            this._pauseTime = 0;
            this._onPlayEnd = null;
            this.context = WebAudioSound.ctx;
            WebAudioSoundChannel.__super.call(this);
            this._onPlayEnd = Utils.bind(this.__onPlayEnd, this);
            if (this.context["createGain"] && typeof this.context["createGain"] == "function") {
                this.gain = this.context["createGain"]();
            }
            else if (this.context["createGainNode"] && typeof this.context["createGainNode"] == "function") {
                this.gain = this.context["createGainNode"]();
            }
            else {
                return function () { return 0; };
            }
        }
        __class(WebAudioSoundChannel, 'laya.media.webaudio.WebAudioSoundChannel', _super);
        var __proto = WebAudioSoundChannel.prototype;
        __proto.play = function () {
            SoundManager.addChannel(this);
            this.isStopped = false;
            this._clearBufferSource();
            if (!this.audioBuffer)
                return;
            var context = this.context;
            var gain = this.gain;
            var bufferSource = context.createBufferSource();
            this.bufferSource = bufferSource;
            bufferSource.buffer = this.audioBuffer;
            bufferSource.connect(gain);
            if (gain)
                gain.disconnect();
            gain.connect(context.destination);
            bufferSource.onended = this._onPlayEnd;
            if (this.startTime >= this.duration)
                this.startTime = 0;
            this._startTime = Browser.now();
            this.gain.gain.value = this._volume;
            if (this.loops == 0) {
                bufferSource.loop = true;
            }
            bufferSource.playbackRate.value = this._playbackRate;
            bufferSource.start(0, this.startTime);
            this._currentTime = 0;
        };
        __proto.__onPlayEnd = function () {
            if (this.loops == 1) {
                if (this.completeHandler) {
                    Laya.timer.once(10, this, this.__runComplete, [this.completeHandler], false);
                    this.completeHandler = null;
                }
                this.stop();
                this.event("complete");
                return;
            }
            if (this.loops > 0) {
                this.loops--;
            }
            this.startTime = 0;
            this.play();
        };
        __proto._clearBufferSource = function () {
            if (this.bufferSource) {
                var sourceNode = this.bufferSource;
                if (sourceNode.stop) {
                    sourceNode.stop(0);
                }
                else {
                    sourceNode.noteOff(0);
                }
                sourceNode.disconnect(0);
                sourceNode.onended = null;
                if (!WebAudioSoundChannel._tryCleanFailed)
                    this._tryClearBuffer(sourceNode);
                this.bufferSource = null;
            }
        };
        __proto._tryClearBuffer = function (sourceNode) {
            if (!Browser.onMac) {
                try {
                    sourceNode.buffer = null;
                }
                catch (e) {
                    WebAudioSoundChannel._tryCleanFailed = true;
                }
                return;
            }
            try {
                sourceNode.buffer = WebAudioSound._miniBuffer;
            }
            catch (e) {
                WebAudioSoundChannel._tryCleanFailed = true;
            }
        };
        __proto.stop = function () {
            this._clearBufferSource();
            this.audioBuffer = null;
            if (this.gain)
                this.gain.disconnect();
            this.isStopped = true;
            SoundManager.removeChannel(this);
            this.completeHandler = null;
            if (SoundManager.autoReleaseSound)
                Laya.timer.once(5000, null, SoundManager.disposeSoundIfNotUsed, [this.url], false);
        };
        __proto.pause = function () {
            if (!this.isStopped) {
                this._pauseTime = this.position;
            }
            this._clearBufferSource();
            if (this.gain)
                this.gain.disconnect();
            this.isStopped = true;
            SoundManager.removeChannel(this);
            if (SoundManager.autoReleaseSound)
                Laya.timer.once(5000, null, SoundManager.disposeSoundIfNotUsed, [this.url], false);
        };
        __proto.resume = function () {
            this.startTime = this._pauseTime;
            this.play();
        };
        __getset(0, __proto, 'position', function () {
            if (this.bufferSource) {
                return (Browser.now() - this._startTime) / 1000 + this.startTime;
            }
            return 0;
        });
        __getset(0, __proto, 'duration', function () {
            if (this.audioBuffer) {
                return this.audioBuffer.duration;
            }
            return 0;
        });
        __getset(0, __proto, 'volume', function () {
            return this._volume;
        }, function (v) {
            if (this.isStopped) {
                return;
            }
            this._volume = v;
            this.gain.gain.value = v;
        });
        __getset(0, __proto, 'playbackRate', function () {
            return this._playbackRate;
        }, function (v) {
            if (this.isStopped) {
                return;
            }
            this._playbackRate = v;
        });
        WebAudioSoundChannel._tryCleanFailed = false;
        return WebAudioSoundChannel;
    })(SoundChannel);
    var Bitmap = (function (_super) {
        function Bitmap() {
            Bitmap.__super.call(this);
            this._w = 0;
            this._h = 0;
        }
        __class(Bitmap, 'laya.resource.Bitmap', _super);
        var __proto = Bitmap.prototype;
        __getset(0, __proto, 'width', function () {
            return this._w;
        });
        __getset(0, __proto, 'height', function () {
            return this._h;
        });
        __getset(0, __proto, 'source', function () {
            return this._source;
        });
        return Bitmap;
    })(Resource);
    var AnimationPlayerBase = (function (_super) {
        function AnimationPlayerBase() {
            this.loop = false;
            this.wrapMode = 0;
            this._index = 0;
            this._count = 0;
            this._isPlaying = false;
            this._labels = null;
            this._isReverse = false;
            this._frameRateChanged = false;
            this._controlNode = null;
            this._actionName = null;
            AnimationPlayerBase.__super.call(this);
            this._interval = Config.animationInterval;
            this._setUpNoticeType(0x1);
        }
        __class(AnimationPlayerBase, 'laya.display.AnimationPlayerBase', _super);
        var __proto = AnimationPlayerBase.prototype;
        __proto.play = function (start, loop, name, showWarn) {
            (start === void 0) && (start = 0);
            (loop === void 0) && (loop = true);
            (name === void 0) && (name = "");
            (showWarn === void 0) && (showWarn = true);
            this._isPlaying = true;
            this.index = ((typeof start == 'string')) ? this._getFrameByLabel(start) : start;
            this.loop = loop;
            this._actionName = name;
            this._isReverse = this.wrapMode == 1;
            if (this.interval > 0) {
                this.timerLoop(this.interval, this, this._frameLoop, null, true, true);
            }
        };
        __proto._getFrameByLabel = function (label) {
            var i = 0;
            for (i = 0; i < this._count; i++) {
                if (this._labels[i] && (this._labels[i]).indexOf(label) >= 0)
                    return i;
            }
            return 0;
        };
        __proto._frameLoop = function () {
            if (this._isReverse) {
                this._index--;
                if (this._index < 0) {
                    if (this.loop) {
                        if (this.wrapMode == 2) {
                            this._index = this._count > 0 ? 1 : 0;
                            this._isReverse = false;
                        }
                        else {
                            this._index = this._count - 1;
                        }
                        this.event("complete");
                    }
                    else {
                        this._index = 0;
                        this.stop();
                        this.event("complete");
                        return;
                    }
                }
            }
            else {
                this._index++;
                if (this._index >= this._count) {
                    if (this.loop) {
                        if (this.wrapMode == 2) {
                            this._index = this._count - 2 >= 0 ? this._count - 2 : 0;
                            this._isReverse = true;
                        }
                        else {
                            this._index = 0;
                        }
                        this.event("complete");
                    }
                    else {
                        this._index--;
                        this.stop();
                        this.event("complete");
                        return;
                    }
                }
            }
            this.index = this._index;
        };
        __proto._setControlNode = function (node) {
            if (this._controlNode) {
                this._controlNode.off("display", this, this._checkResumePlaying);
                this._controlNode.off("undisplay", this, this._checkResumePlaying);
            }
            this._controlNode = node;
            if (node && node != this) {
                node.on("display", this, this._checkResumePlaying);
                node.on("undisplay", this, this._checkResumePlaying);
            }
        };
        __proto._setDisplay = function (value) {
            _super.prototype._setDisplay.call(this, value);
            this._checkResumePlaying();
        };
        __proto._checkResumePlaying = function () {
            if (this._isPlaying) {
                if (this._controlNode.displayedInStage)
                    this.play(this._index, this.loop, this._actionName);
                else
                    this.clearTimer(this, this._frameLoop);
            }
        };
        __proto.stop = function () {
            this._isPlaying = false;
            this.clearTimer(this, this._frameLoop);
        };
        __proto.addLabel = function (label, index) {
            if (!this._labels)
                this._labels = {};
            if (!this._labels[index])
                this._labels[index] = [];
            this._labels[index].push(label);
        };
        __proto.removeLabel = function (label) {
            if (!label)
                this._labels = null;
            else if (this._labels) {
                for (var name in this._labels) {
                    this._removeLabelFromLabelList(this._labels[name], label);
                }
            }
        };
        __proto._removeLabelFromLabelList = function (list, label) {
            if (!list)
                return;
            for (var i = list.length - 1; i >= 0; i--) {
                if (list[i] == label) {
                    list.splice(i, 1);
                }
            }
        };
        __proto.gotoAndStop = function (position) {
            this.index = ((typeof position == 'string')) ? this._getFrameByLabel(position) : position;
            this.stop();
        };
        __proto._displayToIndex = function (value) { };
        __proto.clear = function () {
            this.stop();
            this._labels = null;
        };
        __getset(0, __proto, 'interval', function () {
            return this._interval;
        }, function (value) {
            if (this._interval != value) {
                this._frameRateChanged = true;
                this._interval = value;
                if (this._isPlaying && value > 0) {
                    this.timerLoop(value, this, this._frameLoop, null, true, true);
                }
            }
        });
        __getset(0, __proto, 'isPlaying', function () {
            return this._isPlaying;
        });
        __getset(0, __proto, 'index', function () {
            return this._index;
        }, function (value) {
            this._index = value;
            this._displayToIndex(value);
            if (this._labels && this._labels[value]) {
                var tArr = this._labels[value];
                for (var i = 0, len = tArr.length; i < len; i++) {
                    this.event("label", tArr[i]);
                }
            }
        });
        __getset(0, __proto, 'count', function () {
            return this._count;
        });
        AnimationPlayerBase.WRAP_POSITIVE = 0;
        AnimationPlayerBase.WRAP_REVERSE = 1;
        AnimationPlayerBase.WRAP_PINGPONG = 2;
        return AnimationPlayerBase;
    })(Sprite);
    var Text = (function (_super) {
        function Text() {
            this._clipPoint = null;
            this._currBitmapFont = null;
            this._text = null;
            this._isChanged = false;
            this._textWidth = 0;
            this._textHeight = 0;
            this._lines = [];
            this._lineWidths = [];
            this._startX = NaN;
            this._startY = NaN;
            this._lastVisibleLineIndex = -1;
            this._words = null;
            this._charSize = {};
            this.underline = false;
            this._underlineColor = null;
            Text.__super.call(this);
            this.overflow = Text.VISIBLE;
            this._style = new CSSStyle(this);
            (this._style).wordWrap = false;
        }
        __class(Text, 'laya.display.Text', _super);
        var __proto = Text.prototype;
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            _super.prototype.destroy.call(this, destroyChild);
            this._lines = null;
            if (this._words) {
                this._words.length = 0;
                this._words = null;
            }
        };
        __proto._getBoundPointsM = function (ifRotate) {
            (ifRotate === void 0) && (ifRotate = false);
            var rec = Rectangle.TEMP;
            rec.setTo(0, 0, this.width, this.height);
            return rec._getBoundPoints();
        };
        __proto.getGraphicBounds = function (realSize) {
            (realSize === void 0) && (realSize = false);
            var rec = Rectangle.TEMP;
            rec.setTo(0, 0, this.width, this.height);
            return rec;
        };
        __proto._getCSSStyle = function () {
            return this._style;
        };
        __proto.lang = function (text, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10) {
            text = Text.langPacks && Text.langPacks[text] ? Text.langPacks[text] : text;
            if (arguments.length < 2) {
                this._text = text;
            }
            else {
                for (var i = 0, n = arguments.length; i < n; i++) {
                    text = text.replace("{" + i + "}", arguments[i + 1]);
                }
                this._text = text;
            }
        };
        __proto._isPassWordMode = function () {
            var style = this._style;
            var password = style.password;
            if (("prompt" in this) && this['prompt'] == this._text)
                password = false;
            return password;
        };
        __proto._getPassWordTxt = function (txt) {
            var len = txt.length;
            var word;
            word = "";
            for (var j = len; j > 0; j--) {
                word += "●";
            }
            return word;
        };
        __proto.renderText = function (begin, visibleLineCount) {
            var graphics = this.graphics;
            graphics.clear(true);
            if (this.font == "[#GAME_FONT]") this.font = mainDomain_gcide.CodeIDE_FontLoadManager.defaultFont;
            var ctxFont = (this.italic ? "italic " : "") + (this.bold ? "bold " : "") + this.fontSize + "px " + (Browser.onIPhone ? (laya.display.Text._fontFamilyMap[this.font] || this.font) : this.font);
            Browser.context.font = ctxFont;
            var padding = this.padding;
            var startX = padding[3];
            var textAlgin = "left";
            var lines = this._lines;
            var __leading = this.leading;
            if (this.stroke > 0) __leading *= 2;
            var lineHeight = __leading + this._charSize.height;
            var tCurrBitmapFont = this._currBitmapFont;
            if (tCurrBitmapFont) {
                lineHeight = __leading + tCurrBitmapFont.getMaxHeight();
            }
            var startY = padding[0];
            var strokeW = this._width;
            if (this.stroke > 0) strokeW *= 2;
            var strokeH = this._height;
            if (this.stroke > 0) strokeH *= 2;
            if ((!tCurrBitmapFont) && strokeW > 0 && this._textWidth <= strokeW) {
                if (this.align == "right") {
                    textAlgin = "right";
                    startX = strokeW - padding[1];
                }
                else if (this.align == "center") {
                    textAlgin = "center";
                    startX = strokeW * 0.5 + padding[3] - padding[1];
                }
            }
            if (strokeH > 0) {
                var tempVAlign = (this._textHeight > strokeH) ? "top" : this.valign;
                if (tempVAlign === "middle")
                    startY = (strokeH - visibleLineCount * lineHeight) * 0.5 + padding[0] - padding[2];
                else if (tempVAlign === "bottom")
                    startY = strokeH - visibleLineCount * lineHeight - padding[2];
            }
            //
            var style = this._style;
            if (tCurrBitmapFont && tCurrBitmapFont.autoScaleSize) {
                var bitmapScale = tCurrBitmapFont.fontSize / this.fontSize;
            }
            if (this._clipPoint) {
                graphics.save();
                var tClipWidth = 0;
                var tClipHeight = 0;
                this._width ? tClipWidth = (this._width - padding[3] - padding[1]) : tClipWidth = this._textWidth;
                this._height ? tClipHeight = (this._height - padding[0] - padding[2]) : tClipHeight = this._textHeight;
                if (tCurrBitmapFont && tCurrBitmapFont.autoScaleSize) {
                    tClipWidth *= bitmapScale;
                    tClipHeight *= bitmapScale;
                }
                if (this.stroke > 0) {
                    tClipWidth *= 2;
                    tClipHeight *= 2;
                }
                graphics.clipRect(padding[3], padding[0], tClipWidth, tClipHeight);
            }
            var password = style.password;
            if (("prompt" in this) && this['prompt'] == this._text)
                password = false;
            var x = 0, y = 0;
            var end = Math.min(this._lines.length, visibleLineCount + begin) || 1;
            for (var i = begin; i < end; i++) {
                var word = lines[i];
                var _word;
                if (password) {
                    var len = word.length;
                    word = "";
                    for (var j = len; j > 0; j--) {
                        word += "●";
                    }
                }
                //计算字间距
                var letterSpacingW = 0;
                if (textAlgin == "right") {
                    letterSpacingW = (this.letterSpacing * (word.length - 1)) * (this.stroke ? 2 : 1);
                } else if (textAlgin == "center") {
                    letterSpacingW = (this.letterSpacing * (word.length - 1)) * (this.stroke ? 2 : 1) * 0.5;
                }
                x = startX - (this._clipPoint ? this._clipPoint.x : 0) - letterSpacingW;
                y = startY + lineHeight * i - (this._clipPoint ? this._clipPoint.y : 0);
                this.underline && this.drawUnderline(textAlgin, x, y, i);
                if (tCurrBitmapFont) {
                    var tWidth = this.width;
                    if (tCurrBitmapFont.autoScaleSize) {
                        tWidth = this.width * bitmapScale;
                    }
                    tCurrBitmapFont.drawText(word, this, x, y, this.align, tWidth);
                }
                else {
                    if (Render.isWebGL) {
                        this._words || (this._words = []);
                        _word = this._words.length > (i - begin) ? this._words[i - begin] : new WordText();
                        _word.setText(word, this.letterSpacing, this.stroke);
                    }
                    else {
                        _word = word;
                    }
                    style.stroke ? graphics.fillBorderText(_word, x, y, ctxFont, this.color, style.strokeColor, style.stroke, textAlgin) : graphics.fillText(_word, x, y, ctxFont, this.color, textAlgin);
                }
            }
            if (tCurrBitmapFont && tCurrBitmapFont.autoScaleSize) {
                var tScale = 1 / bitmapScale;
                this.scale(tScale, tScale);
            }
            if (this._clipPoint)
                graphics.restore();
            this._startX = startX;
            this._startY = startY;
        };
        __proto.drawUnderline = function (align, x, y, lineIndex) {
            var lineWidth = this._lineWidths[lineIndex];
            switch (align) {
                case 'center':
                    x -= lineWidth / 2;
                    break;
                case 'right':
                    x -= lineWidth;
                    break;
                case 'left':
                default:
                    break;
            }
            y += this._charSize.height;
            this._graphics.drawLine(x, y, x + lineWidth, y, this.underlineColor || this.color, 1);
        };
        __proto.typeset = function () {
            this._isChanged = false;
            if (!this._text) {
                this._clipPoint = null;
                this._textWidth = this._textHeight = 0;
                this.graphics.clear(true);
                return;
            }
            Browser.context.font = this._getCSSStyle().font;
            this._lines.length = 0;
            this._lineWidths.length = 0;
            if (this._isPassWordMode()) {
                this.parseLines(this._getPassWordTxt(this._text));
            }
            else
                this.parseLines(this._text);
            this.evalTextSize();
            if (this.checkEnabledViewportOrNot())
                this._clipPoint || (this._clipPoint = new Point(0, 0));
            else
                this._clipPoint = null;
            var lineCount = this._lines.length;
            var __leading = this.leading;
            if (this.stroke > 0) __leading *= 2;
            if (this.overflow != Text.VISIBLE) {
                var func = this.overflow == Text.HIDDEN ? Math.floor : Math.ceil;
                lineCount = Math.min(lineCount, func((this.height - this.padding[0] - this.padding[2]) / (__leading + this._charSize.height)));
            }
            var startLine = this.scrollY / (this._charSize.height + __leading) | 0;
            this.renderText(startLine, lineCount);
            this.repaint();
        };
        __proto.evalTextSize = function () {
            var nw = NaN, nh = NaN;
            nw = this.___maxValue;//Math.max.apply(this, this._lineWidths) ;
            nw += this.___wordWidthPlus;
            var __leading = this.leading;
            if (this.stroke > 0) __leading *= 2;
            if (this._currBitmapFont)
                nh = this._lines.length * (this._currBitmapFont.getMaxHeight() + __leading) + this.padding[0] + this.padding[2];
            else
                nh = this._lines.length * (this._charSize.height + __leading) + this.padding[0] + this.padding[2];
            if (nw != this._textWidth || nh != this._textHeight) {
                this._textWidth = nw;
                this._textHeight = nh;
                if (!this._width || !this._height)
                    this.conchModel && this.conchModel.size(this._width || this._textWidth, this._height || this._textHeight);
            }
        };
        __proto.checkEnabledViewportOrNot = function () {
            return this.overflow == Text.SCROLL && ((this._width > 0 && this._textWidth > this._width) || (this._height > 0 && this._textHeight > this._height));
        };
        __proto.changeText = function (text) {
            if (this._text !== text) {
                this.lang(text + "");
                if (this._graphics && this._graphics.replaceText(this._text)) {
                }
                else {
                    this.typeset();
                }
            }
        };
        __proto.parseLines = function (text) {
            var needWordWrapOrTruncate = this.wordWrap || this.overflow == Text.HIDDEN;
            if (needWordWrapOrTruncate) {
                var wordWrapWidth = this.getWordWrapWidth();
            }
            if (this._currBitmapFont) {
                this._charSize.width = this._currBitmapFont.getMaxWidth();
                this._charSize.height = this._currBitmapFont.getMaxHeight();
            }
            else {
                var measureResult = Browser.context.measureText(Text._testWord);
                this._charSize.width = measureResult.width;
                this._charSize.height = (measureResult.height || this.fontSize);
            }
            var maxValue = 0; // 行最大宽度
            this.___maxValue = 0;
            // this.___wordWidthPlus 自动换行需要追加的值
            var lines = text.replace(/\r\n/g, "\n").split("\n");
            for (var i = 0, n = lines.length; i < n; i++) {
                var line = lines[i];
                if (needWordWrapOrTruncate) {
                    // KDS 追加计算 wordWrapWidth ，根据描边和字间距决定
                    var wordWrapWidthReal = wordWrapWidth;
                    if (this.stroke > 0) {
                        wordWrapWidthReal *= 2;
                    }
                    this.parseLine(line, wordWrapWidthReal);
                }
                else {
                    var w = this.getTextWidth(line);
                    if (w > maxValue) {
                        maxValue = w;
                        // maxIndex = i;
                        this.___maxValue = maxValue;
                        this.___wordWidthPlus = this.letterSpacing * (line.length - 1) * (this.stroke ? 2 : 1);
                    }
                    this._lineWidths.push(w);
                    this._lines.push(line);
                }
            }
            if (needWordWrapOrTruncate) {
                // var _lineCalc = this._lineWidths.concat();
                for (var i = 0; i < this._lineWidths.length; i++) {
                    var w = this._lineWidths[i];
                    if (w > maxValue) {
                        maxValue = w;
                        // maxIndex = i;
                        this.___maxValue = maxValue;
                        this.___wordWidthPlus = 0;
                    }
                }
            }
        };
        __proto.parseLine = function (line, wordWrapWidth) {
            var lines = this._lines;
            var maybeIndex = 0;
            var execResult;
            var charsWidth = NaN;
            var wordWidth = NaN;
            var startIndex = 0;
            var ___lineWidth = this.getTextWidth(line);
            var letterSpacingW = (this.letterSpacing * (line.length - 1)) * (this.stroke ? 2 : 1);
            wordWrapWidth = Math.max(wordWrapWidth, this._charSize.width);
            charsWidth = ___lineWidth + letterSpacingW;
            // 一行内解决的情况，直接添加到一行
            if (charsWidth <= wordWrapWidth) {
                lines.push(line);
                this._lineWidths.push(charsWidth);
                return;
            }
            charsWidth = this._charSize.width + letterSpacingW;
            maybeIndex = Math.floor((wordWrapWidth - this._charSize.width) / charsWidth);
            (maybeIndex <= 0 || maybeIndex == Infinity) && (maybeIndex = 1);
            charsWidth = this.getTextWidth(line.substring(0, maybeIndex));
            wordWidth = charsWidth;
            var ___letterSpacing = this.letterSpacing * (this.stroke ? 2 : 1);
            var needPlusLetterSpacing = true;
            for (var j = maybeIndex, m = line.length; j < m; j++) {
                charsWidth = this.getTextWidth(line.charAt(j)) + (needPlusLetterSpacing ? ___letterSpacing : 0);
                needPlusLetterSpacing = true;
                wordWidth += charsWidth;
                if (wordWidth > wordWrapWidth) {
                    needPlusLetterSpacing = false;
                    if (this.wordWrap) {
                        var newLine = line.substring(startIndex, j);
                        if (newLine.charCodeAt(newLine.length - 1) < 255) {
                            execResult = /(?:\w|-)+$/.exec(newLine);
                            if (execResult) {
                                j = execResult.index + startIndex;
                                if (execResult.index == 0)
                                    j += newLine.length;
                                else
                                    newLine = line.substring(startIndex, j);
                            }
                        }
                        else if (Text.RightToLeft) {
                            execResult = /([\u0600-\u06FF])+$/.exec(newLine);
                            if (execResult) {
                                j = execResult.index + startIndex;
                                if (execResult.index == 0)
                                    j += newLine.length;
                                else
                                    newLine = line.substring(startIndex, j);
                            }
                        }
                        lines.push(newLine);
                        this._lineWidths.push(wordWidth - charsWidth);
                        startIndex = j;
                        if (j + maybeIndex < m) {
                            j += maybeIndex;
                            charsWidth = this.getTextWidth(line.substring(startIndex, j)) + ___letterSpacing;
                            wordWidth = charsWidth;
                            j--;
                        }
                        else {
                            lines.push(line.substring(startIndex, m));
                            this._lineWidths.push(this.getTextWidth(lines[lines.length - 1]) + ___letterSpacing);
                            startIndex = -1;
                            break;
                        }
                    }
                    else if (this.overflow == Text.HIDDEN) {
                        lines.push(line.substring(0, j));
                        this._lineWidths.push(this.getTextWidth(lines[lines.length - 1]) + ___letterSpacing);
                        return;
                    }
                }
            }
            if (this.wordWrap && startIndex != -1) {
                lines.push(line.substring(startIndex, m));
                this._lineWidths.push(this.getTextWidth(lines[lines.length - 1]) + ___letterSpacing);
            }
        };
        __proto.getTextWidth = function (text) {
            if (this._currBitmapFont)
                return this._currBitmapFont.getTextWidth(text);
            else
                return Browser.context.measureText(text).width;
        };
        __proto.getWordWrapWidth = function () {
            var p = this.padding;
            var w = NaN;
            if (this._currBitmapFont && this._currBitmapFont.autoScaleSize)
                w = this._width * (this._currBitmapFont.fontSize / this.fontSize);
            else
                w = this._width;
            if (w <= 0) {
                w = this.wordWrap ? 100 : Browser.width;
            }
            w <= 0 && (w = 100);
            return w - p[3] - p[1];
        };
        __proto.getCharPoint = function (charIndex, out) {
            this._isChanged && Laya.timer.runCallLater(this, this.typeset);
            var len = 0, lines = this._lines, startIndex = 0;
            for (var i = 0, n = lines.length; i < n; i++) {
                len += lines[i].length;
                if (charIndex < len) {
                    var line = i;
                    break;
                }
                startIndex = len;
            }
            ;
            var ctxFont = (this.italic ? "italic " : "") + (this.bold ? "bold " : "") + this.fontSize + "px " + this.font;
            Browser.context.font = ctxFont;
            var width = this.getTextWidth(this._text.substring(startIndex, charIndex));
            var point = out || new Point();
            var __leading = this.leading;
            if (this.stroke > 0) __leading *= 2;
            return point.setTo(this._startX + width - (this._clipPoint ? this._clipPoint.x : 0), this._startY + line * (this._charSize.height + __leading) - (this._clipPoint ? this._clipPoint.y : 0));
        };
        __getset(0, __proto, 'width', function () {
            var __width = this._width ? this._width : (this.textWidth + this.padding[1] + this.padding[3]);
            if (this.stroke > 0) {
                return __width * 2;
            } else {
                return __width;
            }
            // if (this._width)
            //     return this._width;
            // return this.textWidth + this.padding[1] + this.padding[3];
        }, function (value) {
            if (value != this._width) {
                Laya.superSet(Sprite, this, 'width', value);
                this.isChanged = true;
            }
        });
        __getset(0, __proto, 'textWidth', function () {
            this._isChanged && Laya.timer.runCallLater(this, this.typeset);
            if (this.stroke > 0) {
                return this._textWidth * 0.5;
            } else {
                return this._textWidth;
            }
            // return this._textWidth;
        });
        __getset(0, __proto, 'height', function () {
            var __height = this._height ? this._height : (this.textHeight + this.padding[0] + this.padding[2]);
            if (this.stroke > 0) {
                return __height * 2;
            } else {
                return __height;
            }
            // if (this._height)
            //     return this._height;
            // return this.textHeight + this.padding[0] + this.padding[2];
        }, function (value) {
            if (value != this._height) {
                Laya.superSet(Sprite, this, 'height', value);
                this.isChanged = true;
            }
        });
        __getset(0, __proto, 'textHeight', function () {
            this._isChanged && Laya.timer.runCallLater(this, this.typeset);
            if (this.stroke > 0) {
                return this._textHeight * 0.5;
            } else {
                return this._textHeight;
            }
            // return this._textHeight;
        });
        __getset(0, __proto, 'padding', function () {
            return this._getCSSStyle().padding;
        }, function (value) {
            this._getCSSStyle().padding = value;
            this.isChanged = true;
        });
        __getset(0, __proto, 'bold', function () {
            return this._getCSSStyle().bold;
        }, function (value) {
            this._getCSSStyle().bold = value;
            this.isChanged = true;
        });
        __getset(0, __proto, 'text', function () {
            return this._text || "";
        }, function (value) {
            if (this._text !== value) {
                this.lang(value + "");
                this.isChanged = true;
                this.event("change");
            }
        });
        __getset(0, __proto, 'color', function () {
            return this._getCSSStyle().color;
        }, function (value) {
            if (this._getCSSStyle().color != value) {
                this._getCSSStyle().color = value;
                if (!this._isChanged && this._graphics) {
                    this._graphics.replaceTextColor(this.color);
                }
                else {
                    this.isChanged = true;
                }
            }
        });
        __getset(0, __proto, 'font', function () {
            var font = this._getCSSStyle().fontFamily;
            return font == "Arial" ? Font.defaultFont : font;
        }, function (value) {
            if (this._currBitmapFont) {
                this._currBitmapFont = null;
                this.scale(1, 1);
            }
            if (Text._bitmapFonts && Text._bitmapFonts[value]) {
                this._currBitmapFont = Text._bitmapFonts[value];
            }
            this._getCSSStyle().fontFamily = value;
            this.isChanged = true;
        });
        __getset(0, __proto, 'fontSize', function () {
            return this._getCSSStyle().fontSize;
        }, function (value) {
            this._getCSSStyle().fontSize = value;
            this.isChanged = true;
        });
        __getset(0, __proto, 'italic', function () {
            return this._getCSSStyle().italic;
        }, function (value) {
            this._getCSSStyle().italic = value;
            this.isChanged = true;
        });
        __getset(0, __proto, 'align', function () {
            return this._getCSSStyle().align;
        }, function (value) {
            this._getCSSStyle().align = value;
            this.isChanged = true;
        });
        __getset(0, __proto, 'valign', function () {
            return this._getCSSStyle().valign;
        }, function (value) {
            this._getCSSStyle().valign = value;
            this.isChanged = true;
        });
        __getset(0, __proto, 'wordWrap', function () {
            return this._getCSSStyle().wordWrap;
        }, function (value) {
            this._getCSSStyle().wordWrap = value;
            this.isChanged = true;
        });
        __getset(0, __proto, 'leading', function () {
            return this._getCSSStyle().leading;
        }, function (value) {
            this._getCSSStyle().leading = value;
            this.isChanged = true;
        });
        __getset(0, __proto, 'letterSpacing', function () {
            return this._getCSSStyle().letterSpacing;
        }, function (value) {
            this._getCSSStyle().letterSpacing = value;
            this.isChanged = true;
        });
        __getset(0, __proto, 'bgColor', function () {
            return this._getCSSStyle().backgroundColor;
        }, function (value) {
            this._getCSSStyle().backgroundColor = value;
            this.isChanged = true;
        });
        __getset(0, __proto, 'borderColor', function () {
            return this._getCSSStyle().borderColor;
        }, function (value) {
            this._getCSSStyle().borderColor = value;
            this.isChanged = true;
        });
        __getset(0, __proto, 'stroke', function () {
            return this._getCSSStyle().stroke;
        }, function (value) {
            this._getCSSStyle().stroke = value;
            this.isChanged = true;
        });
        __getset(0, __proto, 'strokeColor', function () {
            return this._getCSSStyle().strokeColor;
        }, function (value) {
            this._getCSSStyle().strokeColor = value;
            this.isChanged = true;
        });
        __getset(0, __proto, 'isChanged', null, function (value) {
            if (this._isChanged !== value) {
                this._isChanged = value;
                value && Laya.timer.callLater(this, this.typeset);
            }
        });
        __getset(0, __proto, 'scrollX', function () {
            if (!this._clipPoint)
                return 0;
            return this._clipPoint.x;
        }, function (value) {
            if (this.overflow != Text.SCROLL || (this._textWidth < this._width || !this._clipPoint))
                return;
            value = value < this.padding[3] ? this.padding[3] : value;
            var maxScrollX = this._textWidth - this._width;
            value = value > maxScrollX ? maxScrollX : value;
            var __leading = this.leading;
            if (this.stroke > 0) __leading *= 2;
            var visibleLineCount = this._height / (this._charSize.height + __leading) | 0 + 1;
            this._clipPoint.x = value;
            this.renderText(this._lastVisibleLineIndex, visibleLineCount);
        });
        __getset(0, __proto, 'scrollY', function () {
            if (!this._clipPoint)
                return 0;
            return this._clipPoint.y;
        }, function (value) {
            if (this.overflow != Text.SCROLL || (this._textHeight < this._height || !this._clipPoint))
                return;
            value = value < this.padding[0] ? this.padding[0] : value;
            var maxScrollY = this._textHeight - this._height;
            value = value > maxScrollY ? maxScrollY : value;
            var __leading = this.leading;
            if (this.stroke > 0) __leading *= 2;
            var startLine = value / (this._charSize.height + __leading) | 0;
            this._lastVisibleLineIndex = startLine;
            var visibleLineCount = (this._height / (this._charSize.height + __leading) | 0) + 1;
            this._clipPoint.y = value;
            this.renderText(startLine, visibleLineCount);
        });
        __getset(0, __proto, 'maxScrollX', function () {
            return (this._textWidth < this._width) ? 0 : this._textWidth - this._width;
        });
        __getset(0, __proto, 'maxScrollY', function () {
            return (this._textHeight < this._height) ? 0 : this._textHeight - this._height;
        });
        __getset(0, __proto, 'lines', function () {
            if (this._isChanged)
                this.typeset();
            return this._lines;
        });
        __getset(0, __proto, 'underlineColor', function () {
            return this._underlineColor;
        }, function (value) {
            this._underlineColor = value;
            this._isChanged = true;
            this.typeset();
        });
        Text.registerBitmapFont = function (name, bitmapFont) {
            Text._bitmapFonts || (Text._bitmapFonts = {});
            Text._bitmapFonts[name] = bitmapFont;
        };
        Text.unregisterBitmapFont = function (name, destroy) {
            (destroy === void 0) && (destroy = true);
            if (Text._bitmapFonts && Text._bitmapFonts[name]) {
                var tBitmapFont = Text._bitmapFonts[name];
                if (destroy) {
                    tBitmapFont.destroy();
                }
                delete Text._bitmapFonts[name];
            }
        };
        Text.setTextRightToLeft = function () {
            var style;
            style = Browser.canvas.source.style;
            style.display = "none";
            style.position = "absolute";
            style.direction = "rtl";
            Render._mainCanvas.source.style.direction = "rtl";
            laya.display.Text.RightToLeft = true;
            Browser.document.body.appendChild(Browser.canvas.source);
        };
        Text.supportFont = function (font) {
            Browser.context.font = "10px sans-serif";
            var defaultFontWidth = Browser.context.measureText("abcji").width;
            Browser.context.font = "10px " + font;
            var customFontWidth = Browser.context.measureText("abcji").width;
            console_log(defaultFontWidth, customFontWidth);
            if (defaultFontWidth === customFontWidth)
                return false;
            else
                return true;
        };
        Text._testWord = "游";
        Text.langPacks = null;
        Text.VISIBLE = "visible";
        Text.SCROLL = "scroll";
        Text.HIDDEN = "hidden";
        Text.CharacterCache = true;
        Text.RightToLeft = false;
        Text._bitmapFonts = null;
        __static(Text, ['_fontFamilyMap', function () { return this._fontFamilyMap = { "报隶": "报隶-简", "黑体": "黑体-简", "楷体": "楷体-简", "兰亭黑": "兰亭黑-简", "隶变": "隶变-简", "凌慧体": "凌慧体-简", "翩翩体": "翩翩体-简", "苹方": "苹方-简", "手札体": "手札体-简", "宋体": "宋体-简", "娃娃体": "娃娃体-简", "魏碑": "魏碑-简", "行楷": "行楷-简", "雅痞": "雅痞-简", "圆体": "圆体-简" }; }
        ]);
        return Text;
    })(Sprite);
    var Stage = (function (_super) {
        function Stage() {
            this.focus = null;
            this.designWidth = 0;
            this.designHeight = 0;
            this.canvasRotation = false;
            this.canvasDegree = 0;
            this.renderingEnabled = true;
            this.screenAdaptationEnabled = true;
            this._screenMode = "none";
            this._scaleMode = "noscale";
            this._alignV = "top";
            this._alignH = "left";
            this._bgColor = "black";
            this._mouseMoveTime = 0;
            this._renderCount = 0;
            this._frameStartTime = NaN;
            this._isFocused = false;
            this._isVisibility = false;
            this._scenes = null;
            this._frameRate = "fast";
            Stage.__super.call(this);
            this.offset = new Point();
            this._canvasTransform = new Matrix();
            this._previousOrientation = Browser.window.orientation;
            var _$this = this;
            this.transform = Matrix.create();
            this._scenes = [];
            this.mouseEnabled = true;
            this.hitTestPrior = true;
            this.autoSize = false;
            this._displayedInStage = true;
            this._isFocused = true;
            this._isVisibility = true;
            var window = Browser.window;
            var _this = this;
            window.addEventListener("focus", function () {
                _$this._isFocused = true;
                _this.event("focus");
                _this.event("focuschange");
            });
            window.addEventListener("blur", function () {
                _$this._isFocused = false;
                _this.event("blur");
                _this.event("focuschange");
                if (_this._isInputting())
                    Input["inputElement"].target.focus = false;
            });
            var hidden = "hidden", state = "visibilityState", visibilityChange = "visibilitychange";
            var document = window.document;
            if (typeof document.hidden !== "undefined") {
                visibilityChange = "visibilitychange";
                state = "visibilityState";
            }
            else if (typeof document.mozHidden !== "undefined") {
                visibilityChange = "mozvisibilitychange";
                state = "mozVisibilityState";
            }
            else if (typeof document.msHidden !== "undefined") {
                visibilityChange = "msvisibilitychange";
                state = "msVisibilityState";
            }
            else if (typeof document.webkitHidden !== "undefined") {
                visibilityChange = "webkitvisibilitychange";
                state = "webkitVisibilityState";
            }
            window.document.addEventListener(visibilityChange, visibleChangeFun);
            function visibleChangeFun() {
                if (Browser.document[state] == "hidden") {
                    _this._setStageVisible(false);
                }
                else {
                    _this._setStageVisible(true);
                }
            }
            window.document.addEventListener("qbrowserVisibilityChange", qbroserVisibleChangeFun);
            function qbroserVisibleChangeFun(e) {
                _this._setStageVisible(!e.hidden);
            }
            window.addEventListener("resize", function () {
                var orientation = Browser.window.orientation;
                if (orientation != null && orientation != _$this._previousOrientation && _this._isInputting()) {
                    Input["inputElement"].target.focus = false;
                }
                _$this._previousOrientation = orientation;
                if (_this._isInputting())
                    return;
                _this._resetCanvas();
            });
            window.addEventListener("orientationchange", function (e) {
                _this._resetCanvas();
            });
            this.on("mousemove", this, this._onmouseMove);
            if (Browser.onMobile)
                this.on("mousedown", this, this._onmouseMove);
        }
        __class(Stage, 'laya.display.Stage', _super);
        var __proto = Stage.prototype;
        __proto._setStageVisible = function (value) {
            if (this._isVisibility == value)
                return;
            this._isVisibility = value;
            if (!this._isVisibility)
                if (this._isInputting())
                    Input["inputElement"].target.focus = false;
            this.event("visibilitychange");
        };
        __proto._isInputting = function () {
            return (Browser.onMobile && Input.isInputting);
        };
        __proto._changeCanvasSize = function () {
            this.setScreenSize(Browser.clientWidth * Browser.pixelRatio, Browser.clientHeight * Browser.pixelRatio);
        };
        __proto._resetCanvas = function () {
            if (!this.screenAdaptationEnabled)
                return;
            var canvas = Render._mainCanvas;
            var canvasStyle = canvas.source.style;
            canvas.size(1, 1);
            Laya.timer.once(100, this, this._changeCanvasSize);
        };
        __proto.setScreenSize = function (screenWidth, screenHeight) {
            var rotation = false;
            if (this._screenMode !== "none") {
                var screenType = screenWidth / screenHeight < 1 ? "vertical" : "horizontal";
                rotation = screenType !== this._screenMode;
                if (rotation) {
                    var temp = screenHeight;
                    screenHeight = screenWidth;
                    screenWidth = temp;
                }
            }
            this.canvasRotation = rotation;
            var canvas = Render._mainCanvas;
            var canvasStyle = canvas.source.style;
            var mat = this._canvasTransform.identity();
            var scaleMode = this._scaleMode;
            var scaleX = screenWidth / this.designWidth;
            var scaleY = screenHeight / this.designHeight;
            var canvasWidth = this.designWidth;
            var canvasHeight = this.designHeight;
            var realWidth = screenWidth;
            var realHeight = screenHeight;
            var pixelRatio = Browser.pixelRatio;
            this._width = this.designWidth;
            this._height = this.designHeight;
            switch (scaleMode) {
                case "noscale":
                    scaleX = scaleY = 1;
                    realWidth = this.designWidth;
                    realHeight = this.designHeight;
                    break;
                case "showall":
                    scaleX = scaleY = Math.min(scaleX, scaleY);
                    canvasWidth = realWidth = Math.round(this.designWidth * scaleX);
                    canvasHeight = realHeight = Math.round(this.designHeight * scaleY);
                    break;
                case "noborder":
                    scaleX = scaleY = Math.max(scaleX, scaleY);
                    realWidth = Math.round(this.designWidth * scaleX);
                    realHeight = Math.round(this.designHeight * scaleY);
                    break;
                case "full":
                    scaleX = scaleY = 1;
                    this._width = canvasWidth = screenWidth;
                    this._height = canvasHeight = screenHeight;
                    break;
                case "fixedwidth":
                    scaleY = scaleX;
                    this._height = canvasHeight = Math.round(screenHeight / scaleX);
                    break;
                case "fixedheight":
                    scaleX = scaleY;
                    this._width = canvasWidth = Math.round(screenWidth / scaleY);
                    break;
                case "fixedauto":
                    if ((screenWidth / screenHeight) < (this.designWidth / this.designHeight)) {
                        scaleY = scaleX;
                        this._height = canvasHeight = Math.round(screenHeight / scaleX);
                    }
                    else {
                        scaleX = scaleY;
                        this._width = canvasWidth = Math.round(screenWidth / scaleY);
                    }
                    break;
            }
            if (this.conchModel)
                this.conchModel.size(this._width, this._height);
            scaleX *= this.scaleX;
            scaleY *= this.scaleY;
            if (scaleX === 1 && scaleY === 1) {
                this.transform.identity();
            }
            else {
                this.transform.a = this._formatData(scaleX / (realWidth / canvasWidth));
                this.transform.d = this._formatData(scaleY / (realHeight / canvasHeight));
                this.conchModel && this.conchModel.scale(this.transform.a, this.transform.d);
            }
            canvas.size(canvasWidth, canvasHeight);
            RunDriver.changeWebGLSize(canvasWidth, canvasHeight);
            mat.scale(realWidth / canvasWidth / pixelRatio, realHeight / canvasHeight / pixelRatio);
            if (this._alignH === "left")
                this.offset.x = 0;
            else if (this._alignH === "right")
                this.offset.x = screenWidth - realWidth;
            else
                this.offset.x = (screenWidth - realWidth) * 0.5 / pixelRatio;
            if (this._alignV === "top")
                this.offset.y = 0;
            else if (this._alignV === "bottom")
                this.offset.y = screenHeight - realHeight;
            else
                this.offset.y = (screenHeight - realHeight) * 0.5 / pixelRatio;
            this.offset.x = Math.round(this.offset.x);
            this.offset.y = Math.round(this.offset.y);
            mat.translate(this.offset.x, this.offset.y);
            this.canvasDegree = 0;
            if (rotation) {
                if (this._screenMode === "horizontal") {
                    mat.rotate(Math.PI / 2);
                    mat.translate(screenHeight / pixelRatio, 0);
                    this.canvasDegree = 90;
                }
                else {
                    mat.rotate(-Math.PI / 2);
                    mat.translate(0, screenWidth / pixelRatio);
                    this.canvasDegree = -90;
                }
            }
            mat.a = this._formatData(mat.a);
            mat.d = this._formatData(mat.d);
            mat.tx = this._formatData(mat.tx);
            mat.ty = this._formatData(mat.ty);
            canvasStyle.transformOrigin = canvasStyle.webkitTransformOrigin = canvasStyle.msTransformOrigin = canvasStyle.mozTransformOrigin = canvasStyle.oTransformOrigin = "0px 0px 0px";
            canvasStyle.transform = canvasStyle.webkitTransform = canvasStyle.msTransform = canvasStyle.mozTransform = canvasStyle.oTransform = "matrix(" + mat.toString() + ")";
            mat.translate(parseInt(canvasStyle.left) || 0, parseInt(canvasStyle.top) || 0);
            this.visible = true;
            this._repaint = 1;
            this.event("resize");
        };
        __proto._formatData = function (value) {
            if (Math.abs(value) < 0.000001)
                return 0;
            if (Math.abs(1 - value) < 0.001)
                return value > 0 ? 1 : -1;
            return value;
        };
        __proto.getMousePoint = function () {
            return Point.TEMP.setTo(this.mouseX, this.mouseY);
        };
        __proto.repaint = function () {
            this._repaint = 1;
        };
        __proto.parentRepaint = function () { };
        __proto._loop = function () {
            this.render(Render.context, 0, 0);
            return true;
        };
        __proto._onmouseMove = function (e) {
            this._mouseMoveTime = Browser.now();
        };
        __proto.getTimeFromFrameStart = function () {
            return Browser.now() - this._frameStartTime;
        };
        __proto.render = function (context, x, y, banSendEvent) {
            if (this._frameRate === "sleep" && !Render.isConchApp) {
                var now = Browser.now();
                if (now - this._frameStartTime >= 1000)
                    this._frameStartTime = now;
                else
                    return;
            }
            this._renderCount++;
            Render.isFlash && this.repaint();
            if (!this._style.visible) {
                if (this._renderCount % 5 === 0) {
                    Stat.loopCount++;
                    MouseManager.instance.runEvent();
                    Laya.timer._update();
                }
                return;
            }
            this._frameStartTime = Browser.now();
            var frameMode = this._frameRate === "mouse" ? (((this._frameStartTime - this._mouseMoveTime) < 2000) ? "fast" : "slow") : this._frameRate;
            var isFastMode = (frameMode !== "slow");
            var isDoubleLoop = (this._renderCount % 2 === 0);
            Stat.renderSlow = !isFastMode;
            if (isFastMode || isDoubleLoop || Render.isConchApp) {
                Stat.loopCount++;
                MouseManager.instance.runEvent();

                window.___callbackBeforeRenderFunc();
                if (!banSendEvent) Laya.stage.event(EventObject.RENDER);

                Laya.timer._update();
                RunDriver.update3DLoop();
                var scene;
                var i = 0, n = 0;
                if (Render.isConchNode) {
                    for (i = 0, n = this._scenes.length; i < n; i++) {
                        scene = this._scenes[i];
                        (scene) && (scene._updateSceneConch());
                    }
                }
                else {
                    for (i = 0, n = this._scenes.length; i < n; i++) {
                        scene = this._scenes[i];
                        (scene) && (scene._updateScene());
                    }
                }
                if (Render.isConchNode) {
                    var customList = Sprite["CustomList"];
                    for (i = 0, n = customList.length; i < n; i++) {
                        var customItem = customList[i];
                        customItem.customRender(customItem.customContext, 0, 0);
                    }
                    return;
                }
            }
            if (Render.isConchNode)
                return;
            if (this.renderingEnabled && (isFastMode || !isDoubleLoop)) {

                if (Render.isWebGL) {
                    context.clear();
                    _super.prototype.render.call(this, context, x, y);
                    Stat._show && Stat._sp && Stat._sp.render(context, x, y);
                    RunDriver.clear(this._bgColor);
                    RunDriver.beginFlush();
                    context.flush();
                    RunDriver.endFinish();
                    VectorGraphManager.instance && VectorGraphManager.getInstance().endDispose();
                }
                else {
                    RunDriver.clear(this._bgColor);
                    _super.prototype.render.call(this, context, x, y);
                    Stat._show && Stat._sp && Stat._sp.render(context, x, y);
                }
            }
        };
        __proto._requestFullscreen = function () {
            var element = Browser.document.documentElement;
            if (element.requestFullscreen) {
                element.requestFullscreen();
            }
            else if (element.mozRequestFullScreen) {
                element.mozRequestFullScreen();
            }
            else if (element.webkitRequestFullscreen) {
                element.webkitRequestFullscreen();
            }
            else if (element.msRequestFullscreen) {
                element.msRequestFullscreen();
            }
        };
        __proto._fullScreenChanged = function () {
            Laya.stage.event("fullscreenchange");
        };
        __proto.exitFullscreen = function () {
            var document = Browser.document;
            if (document.exitFullscreen) {
                document.exitFullscreen();
            }
            else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
            }
            else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            }
        };
        __getset(0, __proto, 'clientScaleX', function () {
            return this._transform ? this._transform.getScaleX() : 1;
        });
        __getset(0, __proto, 'desginHeight', function () {
            console_debug("desginHeight已经弃用，请使用designHeight代替");
            return this.designHeight;
        });
        __getset(0, __proto, 'frameRate', function () {
            return this._frameRate;
        }, function (value) {
            this._frameRate = value;
            if (Render.isConchApp) {
                switch (this._frameRate) {
                    case "slow":
                        Browser.window.conch && Browser.window.conchConfig.setSlowFrame && Browser.window.conchConfig.setSlowFrame(true);
                        break;
                    case "fast":
                        Browser.window.conch && Browser.window.conchConfig.setSlowFrame && Browser.window.conchConfig.setSlowFrame(false);
                        break;
                    case "mouse":
                        Browser.window.conch && Browser.window.conchConfig.setMouseFrame && Browser.window.conchConfig.setMouseFrame(2000);
                        break;
                    case "sleep":
                        Browser.window.conch && Browser.window.conchConfig.setLimitFPS && Browser.window.conchConfig.setLimitFPS(1);
                        break;
                    default:
                        throw new Error("Stage:frameRate invalid.");
                        break;
                }
            }
        });
        __getset(0, __proto, 'clientScaleY', function () {
            return this._transform ? this._transform.getScaleY() : 1;
        });
        __getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
            this.designWidth = value;
            Laya.superSet(Sprite, this, 'width', value);
            Laya.timer.callLater(this, this._changeCanvasSize);
        });
        __getset(0, __proto, 'alignH', function () {
            return this._alignH;
        }, function (value) {
            this._alignH = value;
            Laya.timer.callLater(this, this._changeCanvasSize);
        });
        __getset(0, __proto, 'isFocused', function () {
            return this._isFocused;
        });
        __getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
            this.designHeight = value;
            Laya.superSet(Sprite, this, 'height', value);
            Laya.timer.callLater(this, this._changeCanvasSize);
        });
        __getset(0, __proto, 'transform', function () {
            if (this._tfChanged)
                this._adjustTransform();
            return this._transform = this._transform || Matrix.create();
        }, _super.prototype._$set_transform);
        __getset(0, __proto, 'isVisibility', function () {
            return this._isVisibility;
        });
        __getset(0, __proto, 'desginWidth', function () {
            console_debug("desginWidth已经弃用，请使用designWidth代替");
            return this.designWidth;
        });
        __getset(0, __proto, 'scaleMode', function () {
            return this._scaleMode;
        }, function (value) {
            this._scaleMode = value;
            Laya.timer.callLater(this, this._changeCanvasSize);
        });
        __getset(0, __proto, 'alignV', function () {
            return this._alignV;
        }, function (value) {
            this._alignV = value;
            Laya.timer.callLater(this, this._changeCanvasSize);
        });
        __getset(0, __proto, 'bgColor', function () {
            return this._bgColor;
        }, function (value) {
            this._bgColor = value;
            this.conchModel && this.conchModel.bgColor(value);
            if (Render.isWebGL) {
                if (value && value !== "black" && value !== "#000000") {
                    Stage._wgColor = Color.create(value)._color;
                }
                else {
                    if (!Browser.onMiniGame)
                        Stage._wgColor = null;
                }
            }
            if (Browser.onLimixiu) {
                Stage._wgColor = Color.create(value)._color;
            }
            else if (value) {
                Render.canvas.style.background = value;
            }
            else {
                Render.canvas.style.background = "none";
            }
        });
        __getset(0, __proto, 'mouseX', function () {
            return Math.round(MouseManager.instance.mouseX / this.clientScaleX);
        });
        __getset(0, __proto, 'mouseY', function () {
            return Math.round(MouseManager.instance.mouseY / this.clientScaleY);
        });
        __getset(0, __proto, 'screenMode', function () {
            return this._screenMode;
        }, function (value) {
            this._screenMode = value;
        });
        __getset(0, __proto, 'visible', _super.prototype._$get_visible, function (value) {
            if (this.visible !== value) {
                Laya.superSet(Sprite, this, 'visible', value);
                var style = Render._mainCanvas.source.style;
                style.visibility = value ? "visible" : "hidden";
            }
        });
        __getset(0, __proto, 'fullScreenEnabled', null, function (value) {
            var document = Browser.document;
            var canvas = Render.canvas;
            if (value) {
                canvas.addEventListener('mousedown', this._requestFullscreen);
                canvas.addEventListener('touchstart', this._requestFullscreen);
                document.addEventListener("fullscreenchange", this._fullScreenChanged);
                document.addEventListener("mozfullscreenchange", this._fullScreenChanged);
                document.addEventListener("webkitfullscreenchange", this._fullScreenChanged);
                document.addEventListener("msfullscreenchange", this._fullScreenChanged);
            }
            else {
                canvas.removeEventListener('mousedown', this._requestFullscreen);
                canvas.removeEventListener('touchstart', this._requestFullscreen);
                document.removeEventListener("fullscreenchange", this._fullScreenChanged);
                document.removeEventListener("mozfullscreenchange", this._fullScreenChanged);
                document.removeEventListener("webkitfullscreenchange", this._fullScreenChanged);
                document.removeEventListener("msfullscreenchange", this._fullScreenChanged);
            }
        });
        Stage.SCALE_NOSCALE = "noscale";
        Stage.SCALE_EXACTFIT = "exactfit";
        Stage.SCALE_SHOWALL = "showall";
        Stage.SCALE_NOBORDER = "noborder";
        Stage.SCALE_FULL = "full";
        Stage.SCALE_FIXED_WIDTH = "fixedwidth";
        Stage.SCALE_FIXED_HEIGHT = "fixedheight";
        Stage.SCALE_FIXED_AUTO = "fixedauto";
        Stage.ALIGN_LEFT = "left";
        Stage.ALIGN_RIGHT = "right";
        Stage.ALIGN_CENTER = "center";
        Stage.ALIGN_TOP = "top";
        Stage.ALIGN_MIDDLE = "middle";
        Stage.ALIGN_BOTTOM = "bottom";
        Stage.SCREEN_NONE = "none";
        Stage.SCREEN_HORIZONTAL = "horizontal";
        Stage.SCREEN_VERTICAL = "vertical";
        Stage.FRAME_FAST = "fast";
        Stage.FRAME_SLOW = "slow";
        Stage.FRAME_MOUSE = "mouse";
        Stage.FRAME_SLEEP = "sleep";
        Stage._wgColor = null;
        Stage.FRAME_MOUSE_THREDHOLD = 2000;
        return Stage;
    })(Sprite);
    var SoundNode = (function (_super) {
        function SoundNode() {
            this.url = null;
            this._channel = null;
            this._tar = null;
            this._playEvents = null;
            this._stopEvents = null;
            SoundNode.__super.call(this);
            this.visible = false;
            this.on("added", this, this._onParentChange);
            this.on("removed", this, this._onParentChange);
        }
        __class(SoundNode, 'laya.media.SoundNode', _super);
        var __proto = SoundNode.prototype;
        __proto._onParentChange = function () {
            this.target = this.parent;
        };
        __proto.play = function (loops, complete) {
            (loops === void 0) && (loops = 1);
            if (isNaN(loops)) {
                loops = 1;
            }
            if (!this.url)
                return;
            this.stop();
            this._channel = SoundManager.playSound(this.url, loops, complete);
        };
        __proto.stop = function () {
            if (this._channel && !this._channel.isStopped) {
                this._channel.stop();
            }
            this._channel = null;
        };
        __proto._setPlayAction = function (tar, event, action, add) {
            (add === void 0) && (add = true);
            if (!this[action])
                return;
            if (!tar)
                return;
            if (add) {
                tar.on(event, this, this[action]);
            }
            else {
                tar.off(event, this, this[action]);
            }
        };
        __proto._setPlayActions = function (tar, events, action, add) {
            (add === void 0) && (add = true);
            if (!tar)
                return;
            if (!events)
                return;
            var eventArr = events.split(",");
            var i = 0, len = 0;
            len = eventArr.length;
            for (i = 0; i < len; i++) {
                this._setPlayAction(tar, eventArr[i], action, add);
            }
        };
        __getset(0, __proto, 'playEvent', null, function (events) {
            this._playEvents = events;
            if (!events)
                return;
            if (this._tar) {
                this._setPlayActions(this._tar, events, "play");
            }
        });
        __getset(0, __proto, 'target', null, function (tar) {
            if (this._tar) {
                this._setPlayActions(this._tar, this._playEvents, "play", false);
                this._setPlayActions(this._tar, this._stopEvents, "stop", false);
            }
            this._tar = tar;
            if (this._tar) {
                this._setPlayActions(this._tar, this._playEvents, "play", true);
                this._setPlayActions(this._tar, this._stopEvents, "stop", true);
            }
        });
        __getset(0, __proto, 'stopEvent', null, function (events) {
            this._stopEvents = events;
            if (!events)
                return;
            if (this._tar) {
                this._setPlayActions(this._tar, events, "stop");
            }
        });
        return SoundNode;
    })(Sprite);
    var FileBitmap = (function (_super) {
        function FileBitmap() {
            this._src = null;
            this._onload = null;
            this._onerror = null;
            FileBitmap.__super.call(this);
        }
        __class(FileBitmap, 'laya.resource.FileBitmap', _super);
        var __proto = FileBitmap.prototype;
        __getset(0, __proto, 'src', function () {
            return this._src;
        }, function (value) {
            this._src = value;
        });
        __getset(0, __proto, 'onload', null, function (value) {
        });
        __getset(0, __proto, 'onerror', null, function (value) {
        });
        return FileBitmap;
    })(Bitmap);
    var HTMLCanvas = (function (_super) {
        function HTMLCanvas(type, canvas) {
            this._is2D = false;
            HTMLCanvas.__super.call(this);
            var _$this = this;
            this._source = this;
            if (type === "2D" || (type === "AUTO" && !Render.isWebGL)) {
                this._is2D = true;
                this._source = canvas || Browser.createElement("canvas");
                this._w = this._source.width;
                this._h = this._source.height;
                var o = this;
                o.getContext = function (contextID, other) {
                    if (_$this._ctx)
                        return _$this._ctx;
                    var ctx = _$this._ctx = _$this._source.getContext(contextID, other);
                    if (ctx) {
                        ctx._canvas = o;
                        if (!Render.isFlash && !Browser.onLimixiu)
                            ctx.size = function (w, h) {
                            };
                    }
                    return ctx;
                };
            }
            this.lock = true;
        }
        __class(HTMLCanvas, 'laya.resource.HTMLCanvas', _super);
        var __proto = HTMLCanvas.prototype;
        __proto.clear = function () {
            this._ctx && this._ctx.clear();
        };
        __proto.destroy = function () {
            this._ctx && this._ctx.destroy();
            this._ctx = null;
            laya.resource.Resource.prototype.destroy.call(this);
        };
        __proto.release = function () { };
        __proto._setContext = function (context) {
            this._ctx = context;
        };
        __proto.getContext = function (contextID, other) {
            return this._ctx ? this._ctx : (this._ctx = HTMLCanvas._createContext(this));
        };
        __proto.getMemSize = function () {
            return 0;
        };
        __proto.size = function (w, h) {
            if (this._w != w || this._h != h || (this._source && (this._source.width != w || this._source.height != h))) {
                this._w = w;
                this._h = h;
                this.memorySize = this._w * this._h * 4;
                this._ctx && this._ctx.size(w, h);
                this._source && (this._source.height = h, this._source.width = w);
            }
        };
        __proto.getCanvas = function () {
            return this._source;
        };
        __proto.toBase64 = function (type, encoderOptions, callBack) {
            if (this._source) {
                if (Render.isConchApp && this._source.toBase64) {
                    this._source.toBase64(type, encoderOptions, callBack);
                }
                else {
                    var base64Data = this._source.toDataURL(type, encoderOptions);
                    callBack.call(this, base64Data);
                }
            }
        };
        __getset(0, __proto, 'context', function () {
            return this._ctx;
        });
        __getset(0, __proto, 'asBitmap', null, function (value) {
        });
        HTMLCanvas.create = function (type, canvas) {
            return new HTMLCanvas(type, canvas);
        };
        HTMLCanvas.TYPE2D = "2D";
        HTMLCanvas.TYPE3D = "3D";
        HTMLCanvas.TYPEAUTO = "AUTO";
        HTMLCanvas._createContext = null;
        return HTMLCanvas;
    })(Bitmap);
    var HTMLSubImage = (function (_super) {
        function HTMLSubImage(canvas, offsetX, offsetY, width, height, atlasImage, src, allowMerageInAtlas) {
            HTMLSubImage.__super.call(this);
            throw new Error("不允许new！");
        }
        __class(HTMLSubImage, 'laya.resource.HTMLSubImage', _super);
        HTMLSubImage.create = function (canvas, offsetX, offsetY, width, height, atlasImage, src, allowMerageInAtlas) {
            (allowMerageInAtlas === void 0) && (allowMerageInAtlas = false);
            return new HTMLSubImage(canvas, offsetX, offsetY, width, height, atlasImage, src, allowMerageInAtlas);
        };
        return HTMLSubImage;
    })(Bitmap);
    var Animation = (function (_super) {
        function Animation() {
            this._frames = null;
            this._url = null;
            Animation.__super.call(this);
            this._setControlNode(this);
        }
        __class(Animation, 'laya.display.Animation', _super);
        var __proto = Animation.prototype;
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            this.stop();
            laya.display.Sprite.prototype.destroy.call(this, destroyChild);
            this._frames = null;
            this._labels = null;
        };
        __proto.play = function (start, loop, name, showWarn) {
            (start === void 0) && (start = 0);
            (loop === void 0) && (loop = true);
            (name === void 0) && (name = "");
            (showWarn === void 0) && (showWarn = true);
            if (name)
                this._setFramesFromCache(name, showWarn);
            this._isPlaying = true;
            this.index = ((typeof start == 'string')) ? this._getFrameByLabel(start) : start;
            this.loop = loop;
            this._actionName = name;
            this._isReverse = this.wrapMode == 1;
            if (this._frames && this.interval > 0) {
                this.timerLoop(this.interval, this, this._frameLoop, null, true, true);
            }
        };
        __proto._setFramesFromCache = function (name, showWarn) {
            (showWarn === void 0) && (showWarn = false);
            if (this._url)
                name = this._url + "#" + name;
            if (name && Animation.framesMap[name]) {
                var tAniO;
                tAniO = Animation.framesMap[name];
                if ((tAniO instanceof Array)) {
                    this._frames = Animation.framesMap[name];
                    this._count = this._frames.length;
                }
                else {
                    if (tAniO.nodeRoot) {
                        Animation.framesMap[name] = this._parseGraphicAnimationByData(tAniO);
                        tAniO = Animation.framesMap[name];
                    }
                    this._frames = tAniO.frames;
                    this._count = this._frames.length;
                    if (!this._frameRateChanged)
                        this._interval = tAniO.interval;
                    this._labels = this._copyLabels(tAniO.labels);
                }
                return true;
            }
            else {
                if (showWarn)
                    console_log("ani not found:", name);
            }
            return false;
        };
        __proto._copyLabels = function (labels) {
            if (!labels)
                return null;
            var rst;
            rst = {};
            var key;
            for (key in labels) {
                rst[key] = Utils.copyArray([], labels[key]);
            }
            return rst;
        };
        __proto._frameLoop = function () {
            if (this._style.visible && this._style.alpha > 0.01) {
                _super.prototype._frameLoop.call(this);
            }
        };
        __proto._displayToIndex = function (value) {
            if (this._frames)
                this.graphics = this._frames[value];
        };
        __proto.clear = function () {
            this.stop();
            this.graphics = null;
            this._frames = null;
            this._labels = null;
        };
        __proto.loadImages = function (urls, cacheName) {
            (cacheName === void 0) && (cacheName = "");
            this._url = "";
            if (!this._setFramesFromCache(cacheName)) {
                this.frames = Animation.framesMap[cacheName] ? Animation.framesMap[cacheName] : Animation.createFrames(urls, cacheName);
            }
            return this;
        };
        __proto.loadAtlas = function (url, loaded, cacheName) {
            (cacheName === void 0) && (cacheName = "");
            this._url = "";
            var _this_ = this;
            function onLoaded(loadUrl) {
                if (url === loadUrl) {
                    _this_.frames = Animation.framesMap[cacheName] ? Animation.framesMap[cacheName] : Animation.createFrames(url, cacheName);
                    if (loaded)
                        loaded.run();
                }
            }
            if (!_this_._setFramesFromCache(cacheName)) {
                if (Loader.getAtlas(url))
                    onLoaded(url);
                else
                    Laya.loader.load(url, Handler.create(null, onLoaded, [url]), null, "atlas");
            }
            return this;
        };
        __proto.loadAnimation = function (url, loaded, atlas) {
            this._url = url;
            var _this_ = this;
            if (!this._actionName)
                this._actionName = "";
            if (!_this_._setFramesFromCache("")) {
                if (!atlas || Loader.getAtlas(atlas)) {
                    this._loadAnimationData(url, loaded, atlas);
                }
                else {
                    Laya.loader.load(atlas, Handler.create(this, this._loadAnimationData, [url, loaded, atlas]), null, "atlas");
                }
            }
            else {
                _this_._setFramesFromCache(this._actionName, true);
                this.index = 0;
                if (loaded)
                    loaded.run();
            }
            return this;
        };
        __proto._loadAnimationData = function (url, loaded, atlas) {
            var _$this = this;
            if (atlas && !Loader.getAtlas(atlas)) {
                console_warn("atlas load fail:" + atlas);
                return;
            }
            ;
            var _this_ = this;
            function onLoaded(loadUrl) {
                if (!Loader.getRes(loadUrl))
                    return;
                if (url === loadUrl) {
                    var tAniO;
                    if (!Animation.framesMap[url + "#"]) {
                        var aniData = _this_._parseGraphicAnimation(Loader.getRes(url));
                        if (!aniData)
                            return;
                        var aniList = aniData.animationList;
                        var i = 0, len = aniList.length;
                        var defaultO;
                        for (i = 0; i < len; i++) {
                            tAniO = aniList[i];
                            Animation.framesMap[url + "#" + tAniO.name] = tAniO;
                            if (!defaultO)
                                defaultO = tAniO;
                        }
                        if (defaultO) {
                            Animation.framesMap[url + "#"] = defaultO;
                            _this_._setFramesFromCache(_$this._actionName, true);
                            _$this.index = 0;
                        }
                        _$this._checkResumePlaying();
                    }
                    else {
                        _this_._setFramesFromCache(_$this._actionName, true);
                        _$this.index = 0;
                        _$this._checkResumePlaying();
                    }
                    if (loaded)
                        loaded.run();
                }
            }
            if (Loader.getRes(url))
                onLoaded(url);
            else
                Laya.loader.load(url, Handler.create(null, onLoaded, [url]), null, "json");
            Loader.clearRes(url);
        };
        __proto._parseGraphicAnimation = function (animationData) {
            return GraphicAnimation.parseAnimationData(animationData);
        };
        __proto._parseGraphicAnimationByData = function (animationObject) {
            return GraphicAnimation.parseAnimationByData(animationObject);
        };
        __getset(0, __proto, 'frames', function () {
            return this._frames;
        }, function (value) {
            this._frames = value;
            if (value) {
                this._count = value.length;
                if (this._isPlaying)
                    this.play(this._index, this.loop, this._actionName);
                else
                    this.index = this._index;
            }
        });
        __getset(0, __proto, 'autoPlay', null, function (value) {
            if (value)
                this.play();
            else
                this.stop();
        });
        __getset(0, __proto, 'source', null, function (value) {
            if (value.indexOf(".ani") > -1)
                this.loadAnimation(value);
            else if (value.indexOf(".json") > -1 || value.indexOf("als") > -1 || value.indexOf("atlas") > -1)
                this.loadAtlas(value);
            else
                this.loadImages(value.split(","));
        });
        __getset(0, __proto, 'autoAnimation', null, function (value) {
            this.play(0, true, value, false);
        });
        Animation.createFrames = function (url, name) {
            var arr, i = 0, n = 0, g;
            if ((typeof url == 'string')) {
                var atlas = Loader.getAtlas(url);
                if (atlas && atlas.length) {
                    arr = [];
                    for (i = 0, n = atlas.length; i < n; i++) {
                        g = new RunDriver.createGraphics();
                        g.drawTexture(Loader.getRes(atlas[i]), 0, 0);
                        arr.push(g);
                    }
                }
            }
            else if ((url instanceof Array)) {
                arr = [];
                for (i = 0, n = url.length; i < n; i++) {
                    g = new RunDriver.createGraphics();
                    g.loadImage(url[i], 0, 0);
                    arr.push(g);
                }
            }
            if (name)
                Animation.framesMap[name] = arr;
            return arr;
        };
        Animation.clearCache = function (key) {
            var cache = Animation.framesMap;
            var val;
            var key2 = key + "#";
            for (val in cache) {
                if (val === key || val.indexOf(key2) == 0) {
                    delete Animation.framesMap[val];
                }
            }
        };
        Animation.framesMap = {};
        return Animation;
    })(AnimationPlayerBase);
    var FrameAnimation = (function (_super) {
        function FrameAnimation() {
            this._targetDic = null;
            this._animationData = null;
            this._animationNewFrames = null;
            FrameAnimation.__super.call(this);
            if (FrameAnimation._sortIndexFun == null) {
                FrameAnimation._sortIndexFun = MathUtil.sortByKey("index", false, true);
            }
        }
        __class(FrameAnimation, 'laya.display.FrameAnimation', _super);
        var __proto = FrameAnimation.prototype;
        __proto._setUp = function (targetDic, animationData) {
            this._labels = null;
            this._animationNewFrames = null;
            this._targetDic = targetDic;
            this._animationData = animationData;
            this.interval = 1000 / animationData.frameRate;
            if (animationData.parsed) {
                this._count = animationData.count;
                this._labels = animationData.labels;
                this._animationNewFrames = animationData.animationNewFrames;
            }
            else {
                this._animationNewFrames = [];
                this._calculateDatas();
            }
            animationData.parsed = true;
            animationData.labels = this._labels;
            animationData.count = this._count;
            animationData.animationNewFrames = this._animationNewFrames;
        };
        __proto.clear = function () {
            _super.prototype.clear.call(this);
            this._targetDic = null;
            this._animationData = null;
        };
        __proto._displayToIndex = function (value) {
            if (!this._animationData)
                return;
            if (value < 0)
                value = 0;
            if (value > this._count)
                value = this._count;
            var nodes = this._animationData.nodes, i = 0, len = nodes.length;
            for (i = 0; i < len; i++) {
                this._displayNodeToFrame(nodes[i], value);
            }
        };
        __proto._displayNodeToFrame = function (node, frame, targetDic) {
            if (!targetDic)
                targetDic = this._targetDic;
            var target = targetDic[node.target];
            if (!target) {
                return;
            }
            ;
            var frames = node.frames, key, propFrames, value;
            var keys = node.keys, i = 0, len = keys.length;
            for (i = 0; i < len; i++) {
                key = keys[i];
                propFrames = frames[key];
                if (propFrames.length > frame) {
                    value = propFrames[frame];
                }
                else {
                    value = propFrames[propFrames.length - 1];
                }
                target[key] = value;
            }
        };
        __proto._calculateDatas = function () {
            if (!this._animationData)
                return;
            var nodes = this._animationData.nodes, i = 0, len = nodes.length, tNode;
            this._count = 0;
            for (i = 0; i < len; i++) {
                tNode = nodes[i];
                this._calculateNodeKeyFrames(tNode);
            }
            this._count += 1;
        };
        __proto._calculateNodeKeyFrames = function (node) {
            var keyFrames = node.keyframes, key, tKeyFrames, target = node.target;
            if (!node.frames) {
                node.frames = {};
            }
            if (!node.keys) {
                node.keys = [];
            }
            else {
                node.keys.length = 0;
            }
            if (!node.initValues) {
                node.initValues = {};
            }
            for (key in keyFrames) {
                tKeyFrames = keyFrames[key];
                if (!node.frames[key]) {
                    node.frames[key] = [];
                }
                if (this._targetDic && this._targetDic[target]) {
                    node.initValues[key] = this._targetDic[target][key];
                }
                tKeyFrames.sort(FrameAnimation._sortIndexFun);
                node.keys.push(key);
                this._calculateNodePropFrames(tKeyFrames, node.frames[key], key, target);
            }
        };
        __proto.resetToInitState = function () {
            if (!this._targetDic)
                return;
            if (!this._animationData)
                return;
            var nodes = this._animationData.nodes, i = 0, len = nodes.length;
            var tNode;
            var initValues;
            for (i = 0; i < len; i++) {
                tNode = nodes[i];
                initValues = tNode.initValues;
                if (!initValues)
                    continue;
                var target = this._targetDic[tNode.target];
                if (!target)
                    continue;
                var key;
                for (key in initValues) {
                    target[key] = initValues[key];
                }
            }
        };
        __proto._calculateNodePropFrames = function (keyframes, frames, key, target) {
            var i = 0, len = keyframes.length - 1;
            frames.length = keyframes[len].index + 1;
            for (i = 0; i < len; i++) {
                this._dealKeyFrame(keyframes[i]);
                this._calculateFrameValues(keyframes[i], keyframes[i + 1], frames);
            }
            if (len == 0) {
                frames[0] = keyframes[0].value;
                if (this._animationNewFrames)
                    this._animationNewFrames[keyframes[0].index] = true;
            }
            this._dealKeyFrame(keyframes[i]);
        };
        __proto._dealKeyFrame = function (keyFrame) {
            if (keyFrame.label && keyFrame.label != "")
                this.addLabel(keyFrame.label, keyFrame.index);
        };
        __proto._calculateFrameValues = function (startFrame, endFrame, result) {
            var i = 0, easeFun;
            var start = startFrame.index, end = endFrame.index;
            var startValue = startFrame.value;
            var dValue = endFrame.value - startFrame.value;
            var dLen = end - start;
            if (end > this._count)
                this._count = end;
            if (startFrame.tween) {
                easeFun = Ease[startFrame.tweenMethod];
                if (easeFun == null) {
                    easeFun = Ease.linearNone;
                }
                for (i = start; i < end; i++) {
                    result[i] = easeFun(i - start, startValue, dValue, dLen);
                    if (this._animationNewFrames) {
                        this._animationNewFrames[i] = true;
                    }
                }
            }
            else {
                for (i = start; i < end; i++) {
                    result[i] = startValue;
                }
            }
            if (this._animationNewFrames) {
                this._animationNewFrames[startFrame.index] = true;
                this._animationNewFrames[endFrame.index] = true;
            }
            result[endFrame.index] = endFrame.value;
        };
        FrameAnimation._sortIndexFun = null;
        return FrameAnimation;
    })(AnimationPlayerBase);
    var Input = (function (_super) {
        function Input() {
            this._focus = false;
            this._multiline = false;
            this._editable = true;
            this._restrictPattern = null;
            this._type = "text";
            this._prompt = '';
            this._promptColor = "#A9A9A9";
            this._originColor = "#000000";
            this._content = '';
            Input.__super.call(this);
            this._maxChars = 1E5;
            this._width = 100;
            this._height = 20;
            this.multiline = false;
            this.overflow = Text.SCROLL;
            this.on("mousedown", this, this._onMouseDown);
            this.on("undisplay", this, this._onUnDisplay);
        }
        __class(Input, 'laya.display.Input', _super);
        var __proto = Input.prototype;
        __proto.setSelection = function (startIndex, endIndex) {
            this.focus = true;
            laya.display.Input.inputElement.selectionStart = startIndex;
            laya.display.Input.inputElement.selectionEnd = endIndex;
        };
        __proto._onUnDisplay = function (e) {
            this.focus = false;
        };
        __proto._onMouseDown = function (e) {
            this.focus = true;
        };
        __proto._syncInputTransform = function () {
            var inputElement = this.nativeInput;
            var transform = Utils.getTransformRelativeToWindow(this, this.padding[3], this.padding[0]);
            var inputWid = (this.stroke > 0 ? this._width * 2 : this._width) - this.padding[1] - this.padding[3] - 15;
            var inputHei = (this.stroke > 0 ? this._height * 2 : this._height) - this.padding[0] - this.padding[2];
            if (Render.isConchApp) {
                inputElement.setScale(transform.scaleX, transform.scaleY);
                inputElement.setSize(inputWid, inputHei);
                inputElement.setPos(transform.x, transform.y);
            }
            else {
                Input.inputContainer.style.transform = Input.inputContainer.style.webkitTransform = "scale(" + transform.scaleX + "," + transform.scaleY + ") rotate(" + (Laya.stage.canvasDegree) + "deg)";
                inputElement.style.width = inputWid + 'px';
                inputElement.style.height = inputHei + 'px';
                Input.inputContainer.style.left = transform.x + 'px';
                Input.inputContainer.style.top = transform.y + 'px';
            }
        };
        __proto.select = function () {
            this.nativeInput.select();
        };
        __proto._setInputMethod = function () {
            this.input.parentElement && (Input.inputContainer.removeChild(this.input));
            this.area.parentElement && (Input.inputContainer.removeChild(this.area));
            Input.inputElement = (this._multiline ? this.area : this.input);
            Input.inputContainer.appendChild(Input.inputElement);
            if (Text.RightToLeft) {
                Input.inputElement.style.direction = "rtl";
            }
        };
        __proto._focusIn = function () {
            laya.display.Input.isInputting = true;
            var input = this.nativeInput;
            this._focus = true;
            var cssStyle = input.style;
            cssStyle.whiteSpace = (this.wordWrap ? "pre-wrap" : "nowrap");
            this._setPromptColor();
            input.readOnly = !this._editable;
            if (Render.isConchApp) {
                input.setType(this._type);
                input.setForbidEdit(!this._editable);
            }
            input.maxLength = this._maxChars;
            input.type = this._type;
            input.value = this._content;
            input.placeholder = this._prompt;
            Laya.stage.off("keydown", this, this._onKeyDown);
            Laya.stage.on("keydown", this, this._onKeyDown);
            Laya.stage.focus = this;
            this.event("focus");
            if (Browser.onPC)
                input.focus();
            if (!Browser.onMiniGame) {
                var temp = this._text;
                this._text = null;
            }
            this.typeset();
            input.setColor(this._originColor);
            input.setFontSize(this.fontSize);
            input.setFontFace(Browser.onIPhone ? (Text._fontFamilyMap[this.font] || this.font) : this.font);
            if (Render.isConchApp) {
                input.setMultiAble && input.setMultiAble(this._multiline);
            }
            cssStyle.lineHeight = (this.leading + this.fontSize) + "px";
            cssStyle.fontStyle = (this.italic ? "italic" : "normal");
            cssStyle.fontWeight = (this.bold ? "bold" : "normal");
            cssStyle.textAlign = this.align;
            cssStyle.padding = "0 0";
            this._syncInputTransform();
            Laya.timer.frameLoop(1, this, this._syncInputTransform);
        };
        __proto._setPromptColor = function () {
            Input.promptStyleDOM = Browser.getElementById("promptStyle");
            if (!Input.promptStyleDOM) {
                Input.promptStyleDOM = Browser.createElement("style");
                Input.promptStyleDOM.setAttribute("id", "promptStyle");
                Browser.document.head.appendChild(Input.promptStyleDOM);
            }
            Input.promptStyleDOM.innerText = "input::-webkit-input-placeholder, textarea::-webkit-input-placeholder {" + "color:" + this._promptColor + "}" + "input:-moz-placeholder, textarea:-moz-placeholder {" + "color:" + this._promptColor + "}" + "input::-moz-placeholder, textarea::-moz-placeholder {" + "color:" + this._promptColor + "}" + "input:-ms-input-placeholder, textarea:-ms-input-placeholder {" + "color:" + this._promptColor + "}" + "input::-webkit-outer-spin-button,input::-webkit-inner-spin-button{ -webkit-appearance:none;}" +
                "input[type='number']{ -moz-appearance:textfield;}";
        };
        __proto._focusOut = function () {
            laya.display.Input.isInputting = false;
            this._focus = false;
            this._text = null;
            this._content = this.nativeInput.value;
            if (!this._content) {
                Laya.superSet(Text, this, 'text', this._prompt);
                Laya.superSet(Text, this, 'color', this._promptColor);
            }
            else {
                Laya.superSet(Text, this, 'text', this._content);
                Laya.superSet(Text, this, 'color', this._originColor);
            }
            Laya.stage.off("keydown", this, this._onKeyDown);
            Laya.stage.focus = null;
            this.event("blur");
            if (Render.isConchApp)
                this.nativeInput.blur();
            Laya.timer.clear(this, this._syncInputTransform);
        };
        __proto._onKeyDown = function (e) {
            if (e.keyCode === 13) {
                if (Browser.onMobile && !this._multiline)
                    this.focus = false;
                this.event("enter");
            }
        };
        __proto.changeText = function (text) {
            this._content = text;
            if (this._focus) {
                this.nativeInput.value = text || '';
                this.event("change");
            }
            else {
                _super.prototype.changeText.call(this, text);
            }
        };
        __getset(0, __proto, 'color', _super.prototype._$get_color, function (value) {
            if (this._focus)
                this.nativeInput.setColor(value);
            Laya.superSet(Text, this, 'color', this._content ? value : this._promptColor);
            this._originColor = value;
        });
        __getset(0, __proto, 'inputElementYAdjuster', function () {
            console_warn("deprecated: 由于即使设置了该值，在各平台和浏览器之间也不一定一致，inputElementYAdjuster已弃用。");
            return 0;
        }, function (value) {
            console_warn("deprecated: 由于即使设置了该值，在各平台和浏览器之间也不一定一致，inputElementYAdjuster已弃用。");
        });
        __getset(0, __proto, 'multiline', function () {
            return this._multiline;
        }, function (value) {
            this._multiline = value;
            this.valign = value ? "top" : "middle";
        });
        __getset(0, __proto, 'maxChars', function () {
            return this._maxChars;
        }, function (value) {
            if (value <= 0)
                value = 1E5;
            this._maxChars = value;
        });
        __getset(0, __proto, 'text', function () {
            if (this._focus)
                return this.nativeInput.value;
            else
                return this._content || "";
        }, function (value) {
            Laya.superSet(Text, this, 'color', this._originColor);
            value += '';
            if (this._focus) {
                this.nativeInput.value = value || '';
                this.event("change");
            }
            else {
                if (!this._multiline)
                    value = value.replace(/\r?\n/g, '');
                this._content = value;
                if (value)
                    Laya.superSet(Text, this, 'text', value);
                else {
                    Laya.superSet(Text, this, 'text', this._prompt);
                    Laya.superSet(Text, this, 'color', this.promptColor);
                }
            }
        });
        __getset(0, __proto, 'nativeInput', function () {
            return this._multiline ? this.area : this.input;
        });
        __getset(0, __proto, 'input', function () {
            return this._type == "password" ? Input.inputPassword : Input.inputText;
        });
        __getset(0, __proto, 'area', function () {
            return this._type == "password" ? Input.areaPassword : Input.areaText;
        });
        __getset(0, __proto, 'prompt', function () {
            return this._prompt;
        }, function (value) {
            this.promptColor = this._promptColor;
            this._prompt = Text.langPacks && Text.langPacks[value] ? Text.langPacks[value] : value;
            //
            if (!laya.display.Input.isInputting) {
                if (!this._text && value)
                    Laya.superSet(Text, this, 'color', this._promptColor);
                if (this._text)
                    Laya.superSet(Text, this, 'text', (this._text == this._prompt) ? value : this._text);
                else
                    Laya.superSet(Text, this, 'text', value);
            } else {
                var input = this.nativeInput;
                this._setPromptColor();
                input.placeholder = this._prompt;
            }
        });
        __getset(0, __proto, 'focus', function () {
            return this._focus;
        }, function (value) {
            var input = this.nativeInput;
            if (this._focus !== value) {
                if (value) {
                    if (Input.lastFocuInput) {
                        if (Input.lastFocuInput != input) {
                            if (Input.lastFocuInput.target)
                                Input.lastFocuInput.target._focusOut();
                            Browser.document.body.scrollTop = 0;
                            Input.lastFocuInput.blur();
                            if (Render.isConchApp) {
                                Input.lastFocuInput.setPos(-10000, -10000);
                            }
                            else if (Input.inputContainer.contains(Input.lastFocuInput))
                                Input.inputContainer.removeChild(Input.lastFocuInput);
                        }
                    }
                    this._setInputMethod();
                    Input.lastFocuInput = input;
                    if (input.target != this) {
                        if (input.target)
                            input.target._focusOut();
                        input.target = this;
                    }
                    this._focusIn();
                }
                else {
                    input.target = null;
                    this._focusOut();
                    Browser.document.body.scrollTop = 0;
                    input.blur();
                    if (Render.isConchApp) {
                        input.setPos(-10000, -10000);
                    }
                    else if (Input.inputContainer.contains(input))
                        Input.inputContainer.removeChild(input);
                }
            }
        });
        __getset(0, __proto, 'restrict', function () {
            if (this._restrictPattern) {
                return this._restrictPattern.source;
            }
            return "";
        }, function (pattern) {
            if (pattern) {
                pattern = "[^" + pattern + "]";
                if (pattern.indexOf("^^") > -1)
                    pattern = pattern.replace("^^", "");
                this._restrictPattern = new RegExp(pattern, "g");
            }
            else
                this._restrictPattern = null;
        });
        __getset(0, __proto, 'editable', function () {
            return this._editable;
        }, function (value) {
            this._editable = value;
            if (Render.isConchApp) {
                this.input.setForbidEdit(!value);
            }
        });
        __getset(0, __proto, 'promptColor', function () {
            return this._promptColor;
        }, function (value) {
            this._promptColor = value;
            if (!this._content)
                Laya.superSet(Text, this, 'color', value);
        });
        __getset(0, __proto, 'type', function () {
            return this._type;
        }, function (value) {
            if (value == "password") {
                this._getCSSStyle().password = true;
            }
            else {
                this._getCSSStyle().password = false;
            }
            this._type = value;
            if (Render.isConchApp) {
                this.nativeInput.setType(value);
            }
        });
        __getset(0, __proto, 'inputElementXAdjuster', function () {
            console_warn("deprecated: 由于即使设置了该值，在各平台和浏览器之间也不一定一致，inputElementXAdjuster已弃用。");
            return 0;
        }, function (value) {
            console_warn("deprecated: 由于即使设置了该值，在各平台和浏览器之间也不一定一致，inputElementXAdjuster已弃用。");
        });
        __getset(0, __proto, 'asPassword', function () {
            return this._getCSSStyle().password;
        }, function (value) {
            this._getCSSStyle().password = value;
            this._type = "password";
            console_warn("deprecated: 使用type=\"password\"替代设置asPassword, asPassword将在下次重大更新时删去");
            this.isChanged = true;
        });
        Input.__init__ = function () {
            Input._createInputElement();
            if (Browser.onMobile)
                Render.canvas.addEventListener(Input.IOS_IFRAME ? (Browser.onMiniGame ? "touchend" : "click") : "touchend", Input._popupInputMethod);
        };
        Input._popupInputMethod = function (e) {
            if (!laya.display.Input.isInputting)
                return;
            var input = laya.display.Input.inputElement;
            input.focus();
        };
        Input._createInputElement = function () {
            Input._initInput(Input.areaText = Browser.createElement("textarea"));
            Input._initInput(Input.areaPassword = Browser.createElement("textarea"), true);
            Input._initInput(Input.inputText = Browser.createElement("input"));
            Input._initInput(Input.inputPassword = Browser.createElement("input"), true);
            Input.inputContainer = Browser.createElement("div");
            Input.inputContainer.style.position = "absolute";
            Input.inputContainer.style.zIndex = 1E5;
            Browser.container.appendChild(Input.inputContainer);
            Input.inputContainer.setPos = function (x, y) { Input.inputContainer.style.left = x + 'px'; Input.inputContainer.style.top = y + 'px'; };
        };
        Input._initInput = function (input, password) {
            var style = input.style;
            style.cssText = "position:absolute;overflow:hidden;resize:none;transform-origin:0 0;-webkit-transform-origin:0 0;-moz-transform-origin:0 0;-o-transform-origin:0 0;";
            style.resize = 'none';
            style.backgroundColor = 'transparent';
            style.border = 'none';
            style.outline = 'none';
            style.zIndex = 1;
            if (password) input.type = "password";
            input.addEventListener('input', Input._processInputting);
            input.addEventListener('mousemove', Input._stopEvent);
            input.addEventListener('mousedown', Input._stopEvent);
            input.addEventListener('touchmove', Input._stopEvent);
            input.setFontFace = function (fontFace) { input.style.fontFamily = fontFace; };
            if (!Render.isConchApp) {
                input.setColor = function (color) { input.style.color = color; };
                input.setFontSize = function (fontSize) { input.style.fontSize = fontSize + 'px'; };
            }
        };
        Input._processInputting = function (e) {
            var input = laya.display.Input.inputElement.target;
            if (!input)
                return;
            var value = laya.display.Input.inputElement.value;
            if (input._restrictPattern) {
                value = value.replace(/\u2006|\x27/g, "");
                if (input._restrictPattern.test(value)) {
                    value = value.replace(input._restrictPattern, "");
                    laya.display.Input.inputElement.value = value;
                }
            }
            //number类型限制最大字符串
            if (laya.display.Input.inputElement.type == "number") {
                var max = laya.display.Input.inputElement.maxLength;
                if (value.length > max) {
                    value = value.slice(0, max);
                    laya.display.Input.inputElement.value = value;
                }
            }
            input._text = value;
            input.event("input");
        };
        Input._stopEvent = function (e) {
            if (e.type == 'touchmove')
                e.preventDefault();
            e.stopPropagation && e.stopPropagation();
        };
        Input.TYPE_TEXT = "text";
        Input.TYPE_PASSWORD = "password";
        Input.TYPE_EMAIL = "email";
        Input.TYPE_URL = "url";
        Input.TYPE_NUMBER = "number";
        Input.TYPE_RANGE = "range";
        Input.TYPE_DATE = "date";
        Input.TYPE_MONTH = "month";
        Input.TYPE_WEEK = "week";
        Input.TYPE_TIME = "time";
        Input.TYPE_DATE_TIME = "datetime";
        Input.TYPE_DATE_TIME_LOCAL = "datetime-local";
        Input.TYPE_SEARCH = "search";
        Input.inputText = null;
        Input.inputPassword = null;
        Input.areaText = null;
        Input.areaPassword = null;
        Input.inputElement = null;
        Input.lastFocuInput = null;
        Input.inputContainer = null;
        Input.confirmButton = null;
        Input.promptStyleDOM = null;
        Input.inputHeight = 45;
        Input.isInputting = false;
        Input.stageMatrix = null;
        __static(Input, ['IOS_IFRAME', function () { return this.IOS_IFRAME = (Browser.onIOS && Browser.window.top != Browser.window.self); }
        ]);
        return Input;
    })(Text);
    var HTMLImage = (function (_super) {
        function HTMLImage(src, def) {
            this._recreateLock = false;
            this._needReleaseAgain = false;
            this._enableMerageInAtlas = true;
            HTMLImage.__super.call(this);
            this._init_(src, def);
        }
        __class(HTMLImage, 'laya.resource.HTMLImage', _super);
        var __proto = HTMLImage.prototype;
        __proto._init_ = function (src, def) {
            this._src = src;
            this._source = new Browser.window.Image();
            if (def) {
                def.onload && (this.onload = def.onload);
                def.onerror && (this.onerror = def.onerror);
                def.onCreate && def.onCreate(this);
            }
            if (src.indexOf("data:image") != 0)
                this._source.crossOrigin = "";
            (src) && (this._source.src = src);
        };
        __proto.recreateResource = function () {
            var _$this = this;
            if (this._src === "")
                throw new Error("src no null！");
            this._needReleaseAgain = false;
            if (!this._source) {
                this._recreateLock = true;
                var _this = this;
                this._source = new Browser.window.Image();
                this._source.crossOrigin = "";
                this._source.onload = function () {
                    if (_this._needReleaseAgain) {
                        _this._needReleaseAgain = false;
                        _this._source.onload = null;
                        _this._source = null;
                        return;
                    }
                    _this._source.onload = null;
                    _this.memorySize = _$this._w * _$this._h * 4;
                    _this._recreateLock = false;
                    _this.completeCreate();
                };
                this._source.src = this._src;
            }
            else {
                if (this._recreateLock)
                    return;
                this.memorySize = this._w * this._h * 4;
                this._recreateLock = false;
                this.completeCreate();
            }
        };
        __proto.disposeResource = function () {
            if (this._recreateLock)
                this._needReleaseAgain = true;
            (this._source) && (this._source = null, this.memorySize = 0);
        };
        __proto.onresize = function () {
            this._w = this._source.width;
            this._h = this._source.height;
        };
        __getset(0, __proto, 'onload', null, function (value) {
            var _$this = this;
            this._onload = value;
            this._source && (this._source.onload = this._onload != null ? (function () {
                _$this.onresize();
                _$this._onload();
            }) : null);
        });
        __getset(0, __proto, 'onerror', null, function (value) {
            var _$this = this;
            this._onerror = value;
            this._source && (this._source.onerror = this._onerror != null ? (function () {
                _$this._onerror();
            }) : null);
        });
        __getset(0, __proto, 'enableMerageInAtlas', function () {
            return this._enableMerageInAtlas;
        }, function (value) {
            this._enableMerageInAtlas = value;
            if (Render.isConchApp) {
                if (this._source)
                    this._source.enableMerageInAtlas = value;
            }
        });
        HTMLImage.create = function (src, def) {
            return new HTMLImage(src, def);
        };
        return HTMLImage;
    })(FileBitmap);
    var EffectAnimation = (function (_super) {
        function EffectAnimation() {
            this._target = null;
            this._playEvents = null;
            this._initData = {};
            this._aniKeys = null;
            this._effectClass = null;
            EffectAnimation.__super.call(this);
        }
        __class(EffectAnimation, 'laya.display.EffectAnimation', _super);
        var __proto = EffectAnimation.prototype;
        __proto._onOtherBegin = function (effect) {
            if (effect == this)
                return;
            this.stop();
        };
        __proto.addEvent = function () {
            if (!this._target || !this._playEvents)
                return;
            this._setControlNode(this._target);
            this._target.on(this._playEvents, this, this._onPlayAction);
        };
        __proto._onPlayAction = function () {
            this.play(0, false);
        };
        __proto.play = function (start, loop, name, showWarn) {
            (start === void 0) && (start = 0);
            (loop === void 0) && (loop = true);
            (name === void 0) && (name = "");
            (showWarn === void 0) && (showWarn = true);
            if (!this._target)
                return;
            this._target.event("effectanimationbegin", [this]);
            this._recordInitData();
            laya.display.AnimationPlayerBase.prototype.play.call(this, start, loop, name, showWarn);
        };
        __proto._recordInitData = function () {
            if (!this._aniKeys)
                return;
            var i = 0, len = 0;
            len = this._aniKeys.length;
            var key;
            for (i = 0; i < len; i++) {
                key = this._aniKeys[i];
                this._initData[key] = this._target[key];
            }
        };
        __proto._displayToIndex = function (value) {
            if (!this._animationData)
                return;
            if (value < 0)
                value = 0;
            if (value > this._count)
                value = this._count;
            var nodes = this._animationData.nodes, i = 0, len = nodes.length;
            len = len > 1 ? 1 : len;
            for (i = 0; i < len; i++) {
                this._displayNodeToFrame(nodes[i], value);
            }
        };
        __proto._displayNodeToFrame = function (node, frame, targetDic) {
            if (!this._target)
                return;
            var target;
            target = this._target;
            var frames = node.frames, key, propFrames, value;
            var keys = node.keys, i = 0, len = keys.length;
            var secondFrames;
            secondFrames = node.secondFrames;
            var tSecondFrame = 0;
            var easeFun;
            var tKeyFrames;
            var startFrame;
            var endFrame;
            for (i = 0; i < len; i++) {
                key = keys[i];
                propFrames = frames[key];
                tSecondFrame = secondFrames[key];
                if (tSecondFrame == -1) {
                    value = this._initData[key];
                }
                else {
                    if (frame < tSecondFrame) {
                        tKeyFrames = node.keyframes[key];
                        startFrame = tKeyFrames[0];
                        if (startFrame.tween) {
                            easeFun = Ease[startFrame.tweenMethod];
                            if (easeFun == null) {
                                easeFun = Ease.linearNone;
                            }
                            endFrame = tKeyFrames[1];
                            value = easeFun(frame, this._initData[key], endFrame.value - this._initData[key], endFrame.index);
                        }
                        else {
                            value = this._initData[key];
                        }
                    }
                    else {
                        if (propFrames.length > frame) {
                            value = propFrames[frame];
                        }
                        else {
                            value = propFrames[propFrames.length - 1];
                        }
                    }
                }
                target[key] = value;
            }
        };
        __proto._calculateNodeKeyFrames = function (node) {
            _super.prototype._calculateNodeKeyFrames.call(this, node);
            var keyFrames = node.keyframes, key, tKeyFrames, target = node.target;
            var secondFrames;
            secondFrames = {};
            node.secondFrames = secondFrames;
            for (key in keyFrames) {
                tKeyFrames = keyFrames[key];
                if (tKeyFrames.length <= 1) {
                    secondFrames[key] = -1;
                }
                else {
                    secondFrames[key] = tKeyFrames[1].index;
                }
            }
        };
        __getset(0, __proto, 'target', function () {
            return this._target;
        }, function (v) {
            if (this._target) {
                this._target.off("effectanimationbegin", this, this._onOtherBegin);
            }
            this._target = v;
            if (this._target) {
                this._target.on("effectanimationbegin", this, this._onOtherBegin);
            }
            this.addEvent();
        });
        __getset(0, __proto, 'playEvent', null, function (event) {
            this._playEvents = event;
            if (!event)
                return;
            this.addEvent();
        });
        __getset(0, __proto, 'effectData', null, function (uiData) {
            if (uiData) {
                var aniData;
                aniData = uiData["animations"];
                if (aniData && aniData[0]) {
                    this._setUp({}, aniData[0]);
                    if (aniData[0].nodes && aniData[0].nodes[0]) {
                        this._aniKeys = aniData[0].nodes[0].keys;
                    }
                }
            }
        });
        __getset(0, __proto, 'effectClass', null, function (classStr) {
            this._effectClass = ClassUtils.getClass(classStr);
            if (this._effectClass) {
                var uiData;
                uiData = this._effectClass["uiView"];
                if (uiData) {
                    var aniData;
                    aniData = uiData["animations"];
                    if (aniData && aniData[0]) {
                        this._setUp({}, aniData[0]);
                        if (aniData[0].nodes && aniData[0].nodes[0]) {
                            this._aniKeys = aniData[0].nodes[0].keys;
                        }
                    }
                }
            }
        });
        EffectAnimation.EffectAnimationBegin = "effectanimationbegin";
        return EffectAnimation;
    })(FrameAnimation);
    var GraphicAnimation = (function (_super) {
        var GraphicNode;
        function GraphicAnimation() {
            this.animationList = null;
            this.animationDic = null;
            this._nodeList = null;
            this._nodeDefaultProps = null;
            this._gList = null;
            this._nodeIDAniDic = {};
            this._rootNode = null;
            this._nodeGDic = null;
            GraphicAnimation.__super.call(this);
        }
        __class(GraphicAnimation, 'laya.utils.GraphicAnimation', _super);
        var __proto = GraphicAnimation.prototype;
        __proto._parseNodeList = function (uiView) {
            if (!this._nodeList) {
                this._nodeList = [];
            }
            this._nodeDefaultProps[uiView.compId] = uiView.props;
            if (uiView.compId)
                this._nodeList.push(uiView.compId);
            var childs = uiView.child;
            if (childs) {
                var i = 0, len = childs.length;
                for (i = 0; i < len; i++) {
                    this._parseNodeList(childs[i]);
                }
            }
        };
        __proto._calGraphicData = function (aniData) {
            this._setUp(null, aniData);
            this._createGraphicData();
            if (this._nodeIDAniDic) {
                var key;
                for (key in this._nodeIDAniDic) {
                    this._nodeIDAniDic[key] = null;
                }
            }
        };
        __proto._createGraphicData = function () {
            var gList = [];
            var i = 0, len = this.count;
            var animationDataNew = this._animationNewFrames;
            if (!animationDataNew)
                animationDataNew = [];
            var preGraphic;
            for (i = 0; i < len; i++) {
                if (animationDataNew[i] || !preGraphic) {
                    preGraphic = this._createFrameGraphic(i);
                }
                gList.push(preGraphic);
            }
            this._gList = gList;
        };
        __proto._createFrameGraphic = function (frame) {
            var g = RunDriver.createGraphics();
            if (!GraphicAnimation._rootMatrix)
                GraphicAnimation._rootMatrix = new Matrix();
            this._updateNodeGraphic(this._rootNode, frame, GraphicAnimation._rootMatrix, g);
            return g;
        };
        __proto._updateNodeGraphic = function (node, frame, parentTransfrom, g, alpha) {
            (alpha === void 0) && (alpha = 1);
            var tNodeG;
            tNodeG = this._nodeGDic[node.compId] = this._getNodeGraphicData(node.compId, frame, this._nodeGDic[node.compId]);
            var tGraphicAlpha = tNodeG.alpha * alpha;
            if (tGraphicAlpha < 0.01)
                return;
            if (!tNodeG.resultTransform) {
                tNodeG.resultTransform = Matrix.create();
            }
            ;
            var tResultTransform;
            tResultTransform = tNodeG.resultTransform;
            Matrix.mul(tNodeG.transform, parentTransfrom, tResultTransform);
            var tTex;
            if (tNodeG.skin) {
                tTex = this._getTextureByUrl(tNodeG.skin);
                if (tTex) {
                    if (tResultTransform._checkTransform()) {
                        g.drawTexture(tTex, 0, 0, tNodeG.width, tNodeG.height, tResultTransform, tGraphicAlpha);
                        tNodeG.resultTransform = null;
                    }
                    else {
                        g.drawTexture(tTex, tResultTransform.tx, tResultTransform.ty, tNodeG.width, tNodeG.height, null, tGraphicAlpha);
                    }
                }
            }
            ;
            var childs;
            childs = node.child;
            if (!childs)
                return;
            var i = 0, len = 0;
            len = childs.length;
            for (i = 0; i < len; i++) {
                this._updateNodeGraphic(childs[i], frame, tResultTransform, g, tGraphicAlpha);
            }
        };
        __proto._updateNoChilds = function (tNodeG, g) {
            if (!tNodeG.skin)
                return;
            var tTex = this._getTextureByUrl(tNodeG.skin);
            if (!tTex)
                return;
            var tTransform = tNodeG.transform;
            tTransform._checkTransform();
            var onlyTranslate = false;
            onlyTranslate = !tTransform.bTransform;
            if (!onlyTranslate) {
                g.drawTexture(tTex, 0, 0, tNodeG.width, tNodeG.height, tTransform.clone(), tNodeG.alpha);
            }
            else {
                g.drawTexture(tTex, tTransform.tx, tTransform.ty, tNodeG.width, tNodeG.height, null, tNodeG.alpha);
            }
        };
        __proto._updateNodeGraphic2 = function (node, frame, g) {
            var tNodeG;
            tNodeG = this._nodeGDic[node.compId] = this._getNodeGraphicData(node.compId, frame, this._nodeGDic[node.compId]);
            if (!node.child) {
                this._updateNoChilds(tNodeG, g);
                return;
            }
            ;
            var tTransform = tNodeG.transform;
            tTransform._checkTransform();
            var onlyTranslate = false;
            onlyTranslate = !tTransform.bTransform;
            var hasTrans = false;
            hasTrans = onlyTranslate && (tTransform.tx != 0 || tTransform.ty != 0);
            var ifSave = false;
            ifSave = (tTransform.bTransform) || tNodeG.alpha != 1;
            if (ifSave) {
                g.save();
            }
            if (tNodeG.alpha != 1) {
                g.alpha(tNodeG.alpha);
            }
            if (!onlyTranslate) {
                g.transform(tTransform.clone());
            }
            else if (hasTrans) {
                g.translate(tTransform.tx, tTransform.ty);
            }
            ;
            var childs;
            childs = node.child;
            var tTex;
            if (tNodeG.skin) {
                tTex = this._getTextureByUrl(tNodeG.skin);
                if (tTex) {
                    g.drawTexture(tTex, 0, 0, tNodeG.width, tNodeG.height);
                }
            }
            if (childs) {
                var i = 0, len = 0;
                len = childs.length;
                for (i = 0; i < len; i++) {
                    this._updateNodeGraphic2(childs[i], frame, g);
                }
            }
            if (ifSave) {
                g.restore();
            }
            else {
                if (!onlyTranslate) {
                    g.transform(tTransform.clone().invert());
                }
                else if (hasTrans) {
                    g.translate(-tTransform.tx, -tTransform.ty);
                }
            }
        };
        __proto._calculateNodeKeyFrames = function (node) {
            _super.prototype._calculateNodeKeyFrames.call(this, node);
            this._nodeIDAniDic[node.target] = node;
        };
        __proto.getNodeDataByID = function (nodeID) {
            return this._nodeIDAniDic[nodeID];
        };
        __proto._getParams = function (obj, params, frame, obj2) {
            var rst = GraphicAnimation._temParam;
            rst.length = params.length;
            var i = 0, len = params.length;
            for (i = 0; i < len; i++) {
                rst[i] = this._getObjVar(obj, params[i][0], frame, params[i][1], obj2);
            }
            return rst;
        };
        __proto._getObjVar = function (obj, key, frame, noValue, obj2) {
            if (obj.hasOwnProperty(key)) {
                var vArr = obj[key];
                if (frame >= vArr.length)
                    frame = vArr.length - 1;
                return obj[key][frame];
            }
            if (obj2.hasOwnProperty(key)) {
                return obj2[key];
            }
            return noValue;
        };
        __proto._getNodeGraphicData = function (nodeID, frame, rst) {
            if (!rst)
                rst = GraphicNode.create();
            if (!rst.transform) {
                rst.transform = Matrix.create();
            }
            else {
                rst.transform.identity();
            }
            ;
            var node = this.getNodeDataByID(nodeID);
            if (!node)
                return rst;
            var frameData = node.frames;
            var params = this._getParams(frameData, GraphicAnimation._drawTextureCmd, frame, this._nodeDefaultProps[nodeID]);
            var url = params[0];
            var width = NaN, height = NaN;
            var px = params[5], py = params[6];
            var aX = params[13], aY = params[14];
            var sx = params[7], sy = params[8];
            var rotate = params[9];
            var skewX = params[11], skewY = params[12];
            width = params[3];
            height = params[4];
            if (width == 0 || height == 0)
                url = null;
            if (width == -1)
                width = 0;
            if (height == -1)
                height = 0;
            var tex;
            rst.skin = url;
            rst.width = width;
            rst.height = height;
            if (url) {
                tex = this._getTextureByUrl(url);
                if (tex) {
                    if (!width)
                        width = tex.sourceWidth;
                    if (!height)
                        height = tex.sourceHeight;
                }
                else {
                    console_warn("lost skin:", url, ",you may load pics first");
                }
            }
            rst.alpha = params[10];
            var m;
            m = rst.transform;
            if (aX != 0) {
                px = aX * width;
            }
            if (aY != 0) {
                py = aY * height;
            }
            if (px != 0 || py != 0) {
                m.translate(-px, -py);
            }
            ;
            var tm = null;
            if (rotate || sx !== 1 || sy !== 1 || skewX || skewY) {
                tm = GraphicAnimation._tempMt;
                tm.identity();
                tm.bTransform = true;
                var skx = (rotate - skewX) * 0.0174532922222222;
                var sky = (rotate + skewY) * 0.0174532922222222;
                var cx = Math.cos(sky);
                var ssx = Math.sin(sky);
                var cy = Math.sin(skx);
                var ssy = Math.cos(skx);
                tm.a = sx * cx;
                tm.b = sx * ssx;
                tm.c = -sy * cy;
                tm.d = sy * ssy;
                tm.tx = tm.ty = 0;
            }
            if (tm) {
                m = Matrix.mul(m, tm, m);
            }
            m.translate(params[1], params[2]);
            return rst;
        };
        __proto._getTextureByUrl = function (url) {
            return Loader.getRes(url);
        };
        __proto.setAniData = function (uiView, aniName) {
            if (uiView.animations) {
                this._nodeDefaultProps = {};
                this._nodeGDic = {};
                if (this._nodeList)
                    this._nodeList.length = 0;
                this._rootNode = uiView;
                this._parseNodeList(uiView);
                var aniDic = {};
                var anilist = [];
                var animations = uiView.animations;
                var i = 0, len = animations.length;
                var tAniO;
                for (i = 0; i < len; i++) {
                    tAniO = animations[i];
                    this._labels = null;
                    if (aniName && aniName != tAniO.name) {
                        continue;
                    }
                    if (!tAniO)
                        continue;
                    try {
                        this._calGraphicData(tAniO);
                    }
                    catch (e) {
                        console_warn("parse animation fail:" + tAniO.name + ",empty animation created");
                        this._gList = [];
                    }
                    ;
                    var frameO = {};
                    frameO.interval = 1000 / tAniO["frameRate"];
                    frameO.frames = this._gList;
                    frameO.labels = this._labels;
                    frameO.name = tAniO.name;
                    anilist.push(frameO);
                    aniDic[tAniO.name] = frameO;
                }
                this.animationList = anilist;
                this.animationDic = aniDic;
            }
            GraphicAnimation._temParam.length = 0;
        };
        __proto.parseByData = function (aniData) {
            var rootNode, aniO;
            rootNode = aniData.nodeRoot;
            aniO = aniData.aniO;
            delete aniData.nodeRoot;
            delete aniData.aniO;
            this._nodeDefaultProps = {};
            this._nodeGDic = {};
            if (this._nodeList)
                this._nodeList.length = 0;
            this._rootNode = rootNode;
            this._parseNodeList(rootNode);
            this._labels = null;
            try {
                this._calGraphicData(aniO);
            }
            catch (e) {
                console_warn("parse animation fail:" + aniO.name + ",empty animation created");
                this._gList = [];
            }
            ;
            var frameO = aniData;
            frameO.interval = 1000 / aniO["frameRate"];
            frameO.frames = this._gList;
            frameO.labels = this._labels;
            frameO.name = aniO.name;
            return frameO;
        };
        __proto.setUpAniData = function (uiView) {
            if (uiView.animations) {
                var aniDic = {};
                var anilist = [];
                var animations = uiView.animations;
                var i = 0, len = animations.length;
                var tAniO;
                for (i = 0; i < len; i++) {
                    tAniO = animations[i];
                    if (!tAniO)
                        continue;
                    var frameO = {};
                    frameO.name = tAniO.name;
                    frameO.aniO = tAniO;
                    frameO.nodeRoot = uiView;
                    anilist.push(frameO);
                    aniDic[tAniO.name] = frameO;
                }
                this.animationList = anilist;
                this.animationDic = aniDic;
            }
        };
        __proto._clear = function () {
            this.animationList = null;
            this.animationDic = null;
            this._gList = null;
            if (this._nodeGDic) {
                var key;
                var tGNode;
                for (key in this._nodeGDic) {
                    tGNode = this._nodeGDic[key];
                    if (tGNode)
                        tGNode.recover();
                }
            }
            this._nodeGDic = null;
        };
        GraphicAnimation.parseAnimationByData = function (animationObject) {
            if (!GraphicAnimation._I)
                GraphicAnimation._I = new GraphicAnimation();
            var rst;
            rst = GraphicAnimation._I.parseByData(animationObject);
            GraphicAnimation._I._clear();
            return rst;
        };
        GraphicAnimation.parseAnimationData = function (aniData) {
            if (!GraphicAnimation._I)
                GraphicAnimation._I = new GraphicAnimation();
            GraphicAnimation._I.setUpAniData(aniData);
            var rst;
            rst = {};
            rst.animationList = GraphicAnimation._I.animationList;
            rst.animationDic = GraphicAnimation._I.animationDic;
            GraphicAnimation._I._clear();
            return rst;
        };
        GraphicAnimation._drawTextureCmd = [["skin", null], ["x", 0], ["y", 0], ["width", -1], ["height", -1], ["pivotX", 0], ["pivotY", 0], ["scaleX", 1], ["scaleY", 1], ["rotation", 0], ["alpha", 1], ["skewX", 0], ["skewY", 0], ["anchorX", 0], ["anchorY", 0]];
        GraphicAnimation._temParam = [];
        GraphicAnimation._I = null;
        GraphicAnimation._rootMatrix = null;
        __static(GraphicAnimation, ['_tempMt', function () { return this._tempMt = new Matrix(); }
        ]);
        GraphicAnimation.__init$ = function () {
            GraphicNode = (function () {
                function GraphicNode() {
                    this.skin = null;
                    this.transform = null;
                    this.resultTransform = null;
                    this.width = NaN;
                    this.height = NaN;
                    this.alpha = 1;
                }
                __class(GraphicNode, '');
                var __proto = GraphicNode.prototype;
                __proto.recover = function () {
                    this.skin = null;
                    this.width = 0;
                    this.height = 0;
                    this.alpha = 1;
                    if (this.transform) {
                        this.transform.destroy();
                        this.transform = null;
                    }
                    if (this.resultTransform) {
                        this.resultTransform.destroy();
                        this.resultTransform = null;
                    }
                    Pool.recover("GraphicNode", this);
                };
                GraphicNode.create = function () {
                    return Pool.getItemByClass("GraphicNode", GraphicNode);
                };
                return GraphicNode;
            })();
        };
        return GraphicAnimation;
    })(FrameAnimation);
    Laya.__init([EventDispatcher, LoaderManager, Render, Browser, Timer, LocalStorage, TimeLine, GraphicAnimation]);
})(window, document, Laya);
(function (window, document, Laya) {
    var __un = Laya.un, __uns = Laya.uns, __static = Laya.static, __class = Laya.class, __getset = Laya.getset, __newvec = Laya.__newvec;
    var The3Main = (function () {
        function The3Main() { }
        __class(The3Main, 'The3Main');
        return The3Main;
    })();
    new The3Main();
})(window, document, Laya);
if (typeof define === 'function' && define.amd) {
    define('laya.core', ['require', "exports"], function (require, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        for (var i in Laya) {
            var o = Laya[i];
            o && o.__isclass && (exports[i] = o);
        }
    });
}
(function (window, document, Laya) {
    var __un = Laya.un, __uns = Laya.uns, __static = Laya.static, __class = Laya.class, __getset = Laya.getset, __newvec = Laya.__newvec;
    var Arith = laya.maths.Arith, Bezier = laya.maths.Bezier, Bitmap = laya.resource.Bitmap, Browser = laya.utils.Browser;
    var Byte = laya.utils.Byte, Color = laya.utils.Color, ColorFilter = laya.filters.ColorFilter, Config = Laya.Config, Context = laya.resource.Context;
    var Event = laya.events.Event, Filter = laya.filters.Filter, Graphics = laya.display.Graphics, HTMLCanvas = laya.resource.HTMLCanvas;
    var HTMLChar = laya.utils.HTMLChar, HTMLImage = laya.resource.HTMLImage, HTMLSubImage = laya.resource.HTMLSubImage;
    var Handler = laya.utils.Handler, Loader = laya.net.Loader, Matrix = laya.maths.Matrix, Point = laya.maths.Point, Rectangle = laya.maths.Rectangle;
    var Render = laya.renders.Render, RenderContext = laya.renders.RenderContext, RenderSprite = laya.renders.RenderSprite;
    var Resource = laya.resource.Resource, ResourceManager = laya.resource.ResourceManager, RunDriver = laya.utils.RunDriver;
    var Sprite = laya.display.Sprite, Stage = laya.display.Stage, Stat = laya.utils.Stat, StringKey = laya.utils.StringKey;
    var Style = laya.display.css.Style, System = laya.system.System, Text = laya.display.Text, Texture = laya.resource.Texture;
    var TransformInfo = laya.display.css.TransformInfo, URL = laya.net.URL, Utils = laya.utils.Utils, VectorGraphManager = laya.utils.VectorGraphManager;
    var WordText = laya.utils.WordText;
    Laya.interface('laya.webgl.shapes.IShape');
    Laya.interface('laya.webgl.submit.ISubmit');
    Laya.interface('laya.webgl.text.ICharSegment');
    Laya.interface('laya.webgl.canvas.save.ISaveData');
    Laya.interface('laya.webgl.resource.IMergeAtlasBitmap');
    Laya.interface('laya.filters.IFilterActionGL', 'laya.filters.IFilterAction');
    var FilterActionGL = (function () {
        function FilterActionGL() { }
        __class(FilterActionGL, 'laya.filters.webgl.FilterActionGL');
        var __proto = FilterActionGL.prototype;
        Laya.imps(__proto, { "laya.filters.IFilterActionGL": true });
        __proto.setValue = function (shader) { };
        __proto.setValueMix = function (shader) { };
        __proto.apply3d = function (scope, sprite, context, x, y) { return null; };
        __proto.apply = function (srcCanvas) { return null; };
        __getset(0, __proto, 'typeMix', function () {
            return 0;
        });
        return FilterActionGL;
    })();
    var ShaderValue = (function () {
        function ShaderValue() { }
        __class(ShaderValue, 'laya.webgl.shader.ShaderValue');
        return ShaderValue;
    })();
    var AtlasGrid = (function () {
        var TexRowInfo, TexMergeTexSize;
        function AtlasGrid(width, height, atlasID) {
            this._atlasID = 0;
            this._width = 0;
            this._height = 0;
            this._texCount = 0;
            this._rowInfo = null;
            this._cells = null;
            this._failSize = new TexMergeTexSize();
            (width === void 0) && (width = 0);
            (height === void 0) && (height = 0);
            (atlasID === void 0) && (atlasID = 0);
            this._cells = null;
            this._rowInfo = null;
            this._init(width, height);
            this._atlasID = atlasID;
        }
        __class(AtlasGrid, 'laya.webgl.atlas.AtlasGrid');
        var __proto = AtlasGrid.prototype;
        __proto.getAltasID = function () {
            return this._atlasID;
        };
        __proto.setAltasID = function (atlasID) {
            if (atlasID >= 0) {
                this._atlasID = atlasID;
            }
        };
        __proto.addTex = function (type, width, height) {
            var result = this._get(width, height);
            if (result.ret == false) {
                return result;
            }
            this._fill(result.x, result.y, width, height, type);
            this._texCount++;
            return result;
        };
        __proto._release = function () {
            if (this._cells != null) {
                this._cells.length = 0;
                this._cells = null;
            }
            if (this._rowInfo) {
                this._rowInfo.length = 0;
                this._rowInfo = null;
            }
        };
        __proto._init = function (width, height) {
            this._width = width;
            this._height = height;
            this._release();
            if (this._width == 0)
                return false;
            this._cells = new Uint8Array(this._width * this._height * 3);
            this._rowInfo = __newvec(this._height);
            for (var i = 0; i < this._height; i++) {
                this._rowInfo[i] = new TexRowInfo();
            }
            this._clear();
            return true;
        };
        __proto._get = function (width, height) {
            var pFillInfo = new MergeFillInfo();
            if (width >= this._failSize.width && height >= this._failSize.height) {
                return pFillInfo;
            }
            ;
            var rx = -1;
            var ry = -1;
            var nWidth = this._width;
            var nHeight = this._height;
            var pCellBox = this._cells;
            for (var y = 0; y < nHeight; y++) {
                if (this._rowInfo[y].spaceCount < width)
                    continue;
                for (var x = 0; x < nWidth;) {
                    var tm = (y * nWidth + x) * 3;
                    if (pCellBox[tm] != 0 || pCellBox[tm + 1] < width || pCellBox[tm + 2] < height) {
                        x += pCellBox[tm + 1];
                        continue;
                    }
                    rx = x;
                    ry = y;
                    for (var xx = 0; xx < width; xx++) {
                        if (pCellBox[3 * xx + tm + 2] < height) {
                            rx = -1;
                            break;
                        }
                    }
                    if (rx < 0) {
                        x += pCellBox[tm + 1];
                        continue;
                    }
                    pFillInfo.ret = true;
                    pFillInfo.x = rx;
                    pFillInfo.y = ry;
                    return pFillInfo;
                }
            }
            return pFillInfo;
        };
        __proto._fill = function (x, y, w, h, type) {
            var nWidth = this._width;
            var nHeghit = this._height;
            this._check((x + w) <= nWidth && (y + h) <= nHeghit);
            for (var yy = y; yy < (h + y); ++yy) {
                this._check(this._rowInfo[yy].spaceCount >= w);
                this._rowInfo[yy].spaceCount -= w;
                for (var xx = 0; xx < w; xx++) {
                    var tm = (x + yy * nWidth + xx) * 3;
                    this._check(this._cells[tm] == 0);
                    this._cells[tm] = type;
                    this._cells[tm + 1] = w;
                    this._cells[tm + 2] = h;
                }
            }
            if (x > 0) {
                for (yy = 0; yy < h; ++yy) {
                    var s = 0;
                    for (xx = x - 1; xx >= 0; --xx, ++s) {
                        if (this._cells[((y + yy) * nWidth + xx) * 3] != 0)
                            break;
                    }
                    for (xx = s; xx > 0; --xx) {
                        this._cells[((y + yy) * nWidth + x - xx) * 3 + 1] = xx;
                        this._check(xx > 0);
                    }
                }
            }
            if (y > 0) {
                for (xx = x; xx < (x + w); ++xx) {
                    s = 0;
                    for (yy = y - 1; yy >= 0; --yy, s++) {
                        if (this._cells[(xx + yy * nWidth) * 3] != 0)
                            break;
                    }
                    for (yy = s; yy > 0; --yy) {
                        this._cells[(xx + (y - yy) * nWidth) * 3 + 2] = yy;
                        this._check(yy > 0);
                    }
                }
            }
        };
        __proto._check = function (ret) {
            if (ret == false) {
                console_log("xtexMerger 错误啦");
            }
        };
        __proto._clear = function () {
            this._texCount = 0;
            for (var y = 0; y < this._height; y++) {
                this._rowInfo[y].spaceCount = this._width;
            }
            for (var i = 0; i < this._height; i++) {
                for (var j = 0; j < this._width; j++) {
                    var tm = (i * this._width + j) * 3;
                    this._cells[tm] = 0;
                    this._cells[tm + 1] = this._width - j;
                    this._cells[tm + 2] = this._width - i;
                }
            }
            this._failSize.width = this._width + 1;
            this._failSize.height = this._height + 1;
        };
        AtlasGrid.__init$ = function () {
            TexRowInfo = (function () {
                function TexRowInfo() {
                    this.spaceCount = 0;
                }
                __class(TexRowInfo, '');
                return TexRowInfo;
            })();
            TexMergeTexSize = (function () {
                function TexMergeTexSize() {
                    this.width = 0;
                    this.height = 0;
                }
                __class(TexMergeTexSize, '');
                return TexMergeTexSize;
            })();
        };
        return AtlasGrid;
    })();
    var AtlasResourceManager = (function () {
        function AtlasResourceManager(width, height, gridSize, maxTexNum) {
            this._currentAtlasCount = 0;
            this._maxAtlaserCount = 0;
            this._width = 0;
            this._height = 0;
            this._gridSize = 0;
            this._gridNumX = 0;
            this._gridNumY = 0;
            this._init = false;
            this._curAtlasIndex = 0;
            this._setAtlasParam = false;
            this._atlaserArray = null;
            this._needGC = false;
            this._setAtlasParam = true;
            this._width = width;
            this._height = height;
            this._gridSize = gridSize;
            this._maxAtlaserCount = maxTexNum;
            this._gridNumX = width / gridSize;
            this._gridNumY = height / gridSize;
            this._curAtlasIndex = 0;
            this._atlaserArray = [];
        }
        __class(AtlasResourceManager, 'laya.webgl.atlas.AtlasResourceManager');
        var __proto = AtlasResourceManager.prototype;
        __proto.setAtlasParam = function (width, height, gridSize, maxTexNum) {
            if (this._setAtlasParam == true) {
                AtlasResourceManager._sid_ = 0;
                this._width = width;
                this._height = height;
                this._gridSize = gridSize;
                this._maxAtlaserCount = maxTexNum;
                this._gridNumX = width / gridSize;
                this._gridNumY = height / gridSize;
                this._curAtlasIndex = 0;
                this.freeAll();
                return true;
            }
            else {
                console_log("设置大图合集参数错误，只能在开始页面设置各种参数");
                throw -1;
                return false;
            }
            return false;
        };
        __proto.pushData = function (texture) {
            var bitmap = texture.bitmap;
            var nWebGLImageIndex = -1;
            var curAtlas = null;
            var i = 0, n = 0, altasIndex = 0;
            for (i = 0, n = this._atlaserArray.length; i < n; i++) {
                altasIndex = (this._curAtlasIndex + i) % n;
                curAtlas = this._atlaserArray[altasIndex];
                nWebGLImageIndex = curAtlas.findBitmapIsExist(bitmap);
                if (nWebGLImageIndex != -1) {
                    break;
                }
            }
            if (nWebGLImageIndex != -1) {
                var offset = curAtlas.InAtlasWebGLImagesOffsetValue[nWebGLImageIndex];
                offsetX = offset[0];
                offsetY = offset[1];
                curAtlas.addToAtlas(texture, offsetX, offsetY);
                return true;
            }
            else {
                var tex = texture;
                this._setAtlasParam = false;
                var bFound = false;
                var nImageGridX = (Math.ceil((texture.bitmap.width + 2) / this._gridSize));
                var nImageGridY = (Math.ceil((texture.bitmap.height + 2) / this._gridSize));
                var bSuccess = false;
                for (var k = 0; k < 2; k++) {
                    var maxAtlaserCount = this._maxAtlaserCount;
                    for (i = 0; i < maxAtlaserCount; i++) {
                        altasIndex = (this._curAtlasIndex + i) % maxAtlaserCount;
                        (this._atlaserArray.length - 1 >= altasIndex) || (this._atlaserArray.push(new Atlaser(this._gridNumX, this._gridNumY, this._width, this._height, AtlasResourceManager._sid_++)));
                        var atlas = this._atlaserArray[altasIndex];
                        var offsetX = 0, offsetY = 0;
                        var fillInfo = atlas.addTex(1, nImageGridX, nImageGridY);
                        if (fillInfo.ret) {
                            offsetX = fillInfo.x * this._gridSize + 1;
                            offsetY = fillInfo.y * this._gridSize + 1;
                            bitmap.lock = true;
                            atlas.addToAtlasTexture((bitmap), offsetX, offsetY);
                            atlas.addToAtlas(texture, offsetX, offsetY);
                            bSuccess = true;
                            this._curAtlasIndex = altasIndex;
                            break;
                        }
                    }
                    if (bSuccess)
                        break;
                    this._atlaserArray.push(new Atlaser(this._gridNumX, this._gridNumY, this._width, this._height, AtlasResourceManager._sid_++));
                    this._needGC = true;
                    this.garbageCollection();
                    this._curAtlasIndex = this._atlaserArray.length - 1;
                }
                if (!bSuccess) {
                    console_log(">>>AtlasManager pushData error");
                }
                return bSuccess;
            }
        };
        __proto.addToAtlas = function (tex) {
            laya.webgl.atlas.AtlasResourceManager.instance.pushData(tex);
        };
        __proto.garbageCollection = function () {
            if (this._needGC === true) {
                var n = this._atlaserArray.length - this._maxAtlaserCount;
                for (var i = 0; i < n; i++) {
                    this._atlaserArray[i].dispose();
                    console_log("AtlasResourceManager:Dispose the inner Atlas。");
                }
                console_log(">>>>altas garbageCollection =" + n);
                this._atlaserArray.splice(0, n);
                this._needGC = false;
            }
            return true;
        };
        __proto.freeAll = function () {
            for (var i = 0, n = this._atlaserArray.length; i < n; i++) {
                this._atlaserArray[i].dispose();
            }
            this._atlaserArray.length = 0;
            this._curAtlasIndex = 0;
        };
        __proto.getAtlaserCount = function () {
            return this._atlaserArray.length;
        };
        __proto.getAtlaserByIndex = function (index) {
            return this._atlaserArray[index];
        };
        __getset(1, AtlasResourceManager, 'instance', function () {
            if (!AtlasResourceManager._Instance) {
                AtlasResourceManager._Instance = new AtlasResourceManager(laya.webgl.atlas.AtlasResourceManager.atlasTextureWidth, laya.webgl.atlas.AtlasResourceManager.atlasTextureHeight, 16, laya.webgl.atlas.AtlasResourceManager.maxTextureCount);
            }
            return AtlasResourceManager._Instance;
        });
        __getset(1, AtlasResourceManager, 'enabled', function () {
            return Config.atlasEnable;
        });
        __getset(1, AtlasResourceManager, 'atlasLimitWidth', function () {
            return AtlasResourceManager._atlasLimitWidth;
        }, function (value) {
            AtlasResourceManager._atlasLimitWidth = value;
        });
        __getset(1, AtlasResourceManager, 'atlasLimitHeight', function () {
            return AtlasResourceManager._atlasLimitHeight;
        }, function (value) {
            AtlasResourceManager._atlasLimitHeight = value;
        });
        AtlasResourceManager._enable = function () {
            Config.atlasEnable = true;
        };
        AtlasResourceManager._disable = function () {
            Config.atlasEnable = false;
        };
        AtlasResourceManager.__init__ = function () {
            AtlasResourceManager.atlasTextureWidth = 2048;
            AtlasResourceManager.atlasTextureHeight = 2048;
            AtlasResourceManager.maxTextureCount = 6;
            AtlasResourceManager.atlasLimitWidth = 512;
            AtlasResourceManager.atlasLimitHeight = 512;
        };
        AtlasResourceManager._atlasLimitWidth = 0;
        AtlasResourceManager._atlasLimitHeight = 0;
        AtlasResourceManager.gridSize = 16;
        AtlasResourceManager.atlasTextureWidth = 0;
        AtlasResourceManager.atlasTextureHeight = 0;
        AtlasResourceManager.maxTextureCount = 0;
        AtlasResourceManager._atlasRestore = 0;
        AtlasResourceManager.BOARDER_TYPE_NO = 0;
        AtlasResourceManager.BOARDER_TYPE_RIGHT = 1;
        AtlasResourceManager.BOARDER_TYPE_LEFT = 2;
        AtlasResourceManager.BOARDER_TYPE_BOTTOM = 4;
        AtlasResourceManager.BOARDER_TYPE_TOP = 8;
        AtlasResourceManager.BOARDER_TYPE_ALL = 15;
        AtlasResourceManager._sid_ = 0;
        AtlasResourceManager._Instance = null;
        return AtlasResourceManager;
    })();
    var MergeFillInfo = (function () {
        function MergeFillInfo() {
            this.x = 0;
            this.y = 0;
            this.ret = false;
            this.ret = false;
            this.x = 0;
            this.y = 0;
        }
        __class(MergeFillInfo, 'laya.webgl.atlas.MergeFillInfo');
        return MergeFillInfo;
    })();
    var BlendMode = (function () {
        function BlendMode() { }
        __class(BlendMode, 'laya.webgl.canvas.BlendMode');
        BlendMode._init_ = function (gl) {
            BlendMode.fns = [BlendMode.BlendNormal, BlendMode.BlendAdd, BlendMode.BlendMultiply, BlendMode.BlendScreen, BlendMode.BlendOverlay, BlendMode.BlendLight, BlendMode.BlendMask, BlendMode.BlendDestinationOut];
            BlendMode.targetFns = [BlendMode.BlendNormalTarget, BlendMode.BlendAddTarget, BlendMode.BlendMultiplyTarget, BlendMode.BlendScreenTarget, BlendMode.BlendOverlayTarget, BlendMode.BlendLightTarget, BlendMode.BlendMask, BlendMode.BlendDestinationOut];
        };
        BlendMode.BlendNormal = function (gl) {
            gl.blendFunc(/*laya.webgl.WebGLContext.ONE*/1,/*laya.webgl.WebGLContext.ONE_MINUS_SRC_ALPHA*/0x0303);
        };
        BlendMode.BlendAdd = function (gl) {
            gl.blendFunc(/*laya.webgl.WebGLContext.ONE*/1,/*laya.webgl.WebGLContext.DST_ALPHA*/0x0304);
        };
        BlendMode.BlendMultiply = function (gl) {
            gl.blendFunc(0x0306, 0x0303);
        };
        BlendMode.BlendScreen = function (gl) {
            gl.blendFunc(1, 1);
        };
        BlendMode.BlendOverlay = function (gl) {
            gl.blendFunc(1, 0x0301);
        };
        BlendMode.BlendLight = function (gl) {
            gl.blendFunc(1, 1);
        };
        BlendMode.BlendNormalTarget = function (gl) {
            gl.blendFunc(1, 0x0303);
        };
        BlendMode.BlendAddTarget = function (gl) {
            gl.blendFunc(1, 0x0304);
        };
        BlendMode.BlendMultiplyTarget = function (gl) {
            gl.blendFunc(0x0306, 0x0303);
        };
        BlendMode.BlendScreenTarget = function (gl) {
            gl.blendFunc(1, 1);
        };
        BlendMode.BlendOverlayTarget = function (gl) {
            gl.blendFunc(1, 0x0301);
        };
        BlendMode.BlendLightTarget = function (gl) {
            gl.blendFunc(1, 1);
        };
        BlendMode.BlendMask = function (gl) {
            gl.blendFunc(0, 0x0302);
        };
        BlendMode.BlendDestinationOut = function (gl) {
            gl.blendFunc(0, 0);
        };
        BlendMode.activeBlendFunction = null;
        BlendMode.NAMES = ["normal", "add", "multiply", "screen", "overlay", "light", "mask", "destination-out"];
        BlendMode.TOINT = { "normal": 0, "add": 1, "multiply": 2, "screen": 3, "lighter": 1, "overlay": 4, "light": 5, "mask": 6, "destination-out": 7 };
        BlendMode.NORMAL = "normal";
        BlendMode.ADD = "add";
        BlendMode.MULTIPLY = "multiply";
        BlendMode.SCREEN = "screen";
        BlendMode.LIGHT = "light";
        BlendMode.OVERLAY = "overlay";
        BlendMode.DESTINATIONOUT = "destination-out";
        BlendMode.fns = [];
        BlendMode.targetFns = [];
        return BlendMode;
    })();
    var DrawStyle = (function () {
        function DrawStyle(value) {
            this._color = Color.create("black");
            this.setValue(value);
        }
        __class(DrawStyle, 'laya.webgl.canvas.DrawStyle');
        var __proto = DrawStyle.prototype;
        __proto.setValue = function (value) {
            if (value) {
                if ((typeof value == 'string')) {
                    this._color = Color.create(value);
                    return;
                }
                if ((value instanceof laya.utils.Color)) {
                    this._color = value;
                    return;
                }
            }
        };
        __proto.reset = function () {
            this._color = Color.create("black");
        };
        __proto.equal = function (value) {
            if ((typeof value == 'string'))
                return this._color.strColor === value;
            if ((value instanceof laya.utils.Color))
                return this._color.numColor === (value).numColor;
            return false;
        };
        __proto.toColorStr = function () {
            return this._color.strColor;
        };
        DrawStyle.create = function (value) {
            if (value) {
                var color;
                if ((typeof value == 'string'))
                    color = Color.create(value);
                else if ((value instanceof laya.utils.Color))
                    color = value;
                if (color) {
                    return color._drawStyle || (color._drawStyle = new DrawStyle(value));
                }
            }
            return laya.webgl.canvas.DrawStyle.DEFAULT;
        };
        __static(DrawStyle, ['DEFAULT', function () { return this.DEFAULT = new DrawStyle("#000000"); }
        ]);
        return DrawStyle;
    })();
    var Path = (function () {
        function Path() {
            this._x = 0;
            this._y = 0;
            this.dirty = false;
            this.offset = 0;
            this.count = 0;
            this.geoStart = 0;
            this.tempArray = [];
            this.closePath = false;
            this.geomatrys = [];
            var gl = WebGL.mainContext;
            this.ib = IndexBuffer2D.create(0x88E8);
            this.vb = VertexBuffer2D.create(5);
        }
        __class(Path, 'laya.webgl.canvas.Path');
        var __proto = Path.prototype;
        __proto.addPoint = function (pointX, pointY) {
            this.tempArray.push(pointX, pointY);
        };
        __proto.getEndPointX = function () {
            return this.tempArray[this.tempArray.length - 2];
        };
        __proto.getEndPointY = function () {
            return this.tempArray[this.tempArray.length - 1];
        };
        __proto.polygon = function (x, y, points, color, borderWidth, borderColor) {
            var geo;
            this.geomatrys.push(this._curGeomatry = geo = new Polygon(x, y, points, color, borderWidth, borderColor));
            if (!color)
                geo.fill = false;
            if (borderColor == undefined)
                geo.borderWidth = 0;
            return geo;
        };
        __proto.setGeomtry = function (shape) {
            this.geomatrys.push(this._curGeomatry = shape);
        };
        __proto.drawLine = function (x, y, points, width, color) {
            var geo;
            if (this.closePath) {
                this.geomatrys.push(this._curGeomatry = geo = new LoopLine(x, y, points, width, color));
            }
            else {
                this.geomatrys.push(this._curGeomatry = geo = new Line(x, y, points, width, color));
            }
            geo.fill = false;
            return geo;
        };
        __proto.update = function () {
            var si = this.ib._byteLength;
            var len = this.geomatrys.length;
            this.offset = si;
            for (var i = this.geoStart; i < len; i++) {
                this.geomatrys[i].getData(this.ib, this.vb, this.vb._byteLength / 20);
            }
            this.geoStart = len;
            this.count = (this.ib._byteLength - si) / CONST3D2D.BYTES_PIDX;
        };
        __proto.reset = function () {
            this.vb.clear();
            this.ib.clear();
            this.offset = this.count = this.geoStart = 0;
            this.geomatrys.length = 0;
        };
        __proto.recover = function () {
            this._curGeomatry = null;
            this.vb.destory();
            this.vb = null;
            this.ib.destory();
            this.ib = null;
        };
        return Path;
    })();
    var SaveBase = (function () {
        function SaveBase() {
        }
        __class(SaveBase, 'laya.webgl.canvas.save.SaveBase');
        var __proto = SaveBase.prototype;
        Laya.imps(__proto, { "laya.webgl.canvas.save.ISaveData": true });
        __proto.isSaveMark = function () { return false; };
        __proto.restore = function (context) {
            this._dataObj[this._valueName] = this._value;
            SaveBase._cache[SaveBase._cache._length++] = this;
            this._newSubmit && (context._curSubmit = Submit.RENDERBASE, context._renderKey = 0);
        };
        SaveBase._createArray = function () {
            var value = [];
            value._length = 0;
            return value;
        };
        SaveBase._init = function () {
            var namemap = SaveBase._namemap = {};
            namemap[0x1] = "ALPHA";
            namemap[0x2] = "fillStyle";
            namemap[0x8] = "font";
            namemap[0x100] = "lineWidth";
            namemap[0x200] = "strokeStyle";
            namemap[0x2000] = "_mergeID";
            namemap[0x400] = namemap[0x800] = namemap[0x1000] = [];
            namemap[0x4000] = "textBaseline";
            namemap[0x8000] = "textAlign";
            namemap[0x10000] = "_nBlendType";
            namemap[0x100000] = "shader";
            namemap[0x200000] = "filters";
            return namemap;
        };
        SaveBase.save = function (context, type, dataObj, newSubmit) {
            if ((context._saveMark._saveuse & type) !== type) {
                context._saveMark._saveuse |= type;
                var cache = SaveBase._cache;
                var o = cache._length > 0 ? cache[--cache._length] : (new SaveBase());
                o._value = dataObj[o._valueName = SaveBase._namemap[type]];
                o._dataObj = dataObj;
                o._newSubmit = newSubmit;
                var _save = context._save;
                _save[_save._length++] = o;
            }
        };
        SaveBase._cache = laya.webgl.canvas.save.SaveBase._createArray();
        SaveBase._namemap = SaveBase._init();
        return SaveBase;
    })();
    var SaveClipRect = (function () {
        function SaveClipRect() {
            this._clipRect = new Rectangle();
        }
        __class(SaveClipRect, 'laya.webgl.canvas.save.SaveClipRect');
        var __proto = SaveClipRect.prototype;
        Laya.imps(__proto, { "laya.webgl.canvas.save.ISaveData": true });
        __proto.isSaveMark = function () { return false; };
        __proto.restore = function (context) {
            context._clipRect = this._clipSaveRect;
            SaveClipRect._cache[SaveClipRect._cache._length++] = this;
            this._submitScissor.submitLength = context._submits._length - this._submitScissor.submitIndex;
            context._curSubmit = Submit.RENDERBASE;
            context._renderKey = 0;
        };
        SaveClipRect.save = function (context, submitScissor) {
            if ((context._saveMark._saveuse & 0x20000) == 0x20000)
                return;
            context._saveMark._saveuse |= 0x20000;
            var cache = SaveClipRect._cache;
            var o = cache._length > 0 ? cache[--cache._length] : (new SaveClipRect());
            o._clipSaveRect = context._clipRect;
            context._clipRect = o._clipRect.copyFrom(context._clipRect);
            o._submitScissor = submitScissor;
            var _save = context._save;
            _save[_save._length++] = o;
        };
        __static(SaveClipRect, ['_cache', function () { return this._cache = SaveBase._createArray(); }
        ]);
        return SaveClipRect;
    })();
    var SaveClipRectStencil = (function () {
        function SaveClipRectStencil() {
            this._contextX = 0;
            this._contextY = 0;
            this._clipRect = new Rectangle();
            this._rect = new Rectangle();
            this._matrix = new Matrix();
        }
        __class(SaveClipRectStencil, 'laya.webgl.canvas.save.SaveClipRectStencil');
        var __proto = SaveClipRectStencil.prototype;
        Laya.imps(__proto, { "laya.webgl.canvas.save.ISaveData": true });
        __proto.isSaveMark = function () { return false; };
        __proto.restore = function (context) {
            SubmitStencil.restore(context, this._rect, this._saveMatrix, this._contextX, this._contextY);
            context._clipRect = this._clipSaveRect;
            context._curMat = this._saveMatrix;
            context._x = this._contextX;
            context._y = this._contextY;
            SaveClipRectStencil._cache[SaveClipRectStencil._cache._length++] = this;
            context._curSubmit = Submit.RENDERBASE;
        };
        SaveClipRectStencil.save = function (context, submitStencil, x, y, width, height, clipX, clipY, clipWidth, clipHeight) {
            if ((context._saveMark._saveuse & 0x40000) == 0x40000)
                return;
            context._saveMark._saveuse |= 0x40000;
            var cache = SaveClipRectStencil._cache;
            var o = cache._length > 0 ? cache[--cache._length] : (new SaveClipRectStencil());
            o._clipSaveRect = context._clipRect;
            o._clipRect.setTo(clipX, clipY, clipWidth, clipHeight);
            context._clipRect = o._clipRect;
            o._rect.x = x;
            o._rect.y = y;
            o._rect.width = width;
            o._rect.height = height;
            o._contextX = context._x;
            o._contextY = context._y;
            o._saveMatrix = context._curMat;
            context._curMat.copyTo(o._matrix);
            context._curMat = o._matrix;
            o._submitStencil = submitStencil;
            var _save = context._save;
            _save[_save._length++] = o;
        };
        __static(SaveClipRectStencil, ['_cache', function () { return this._cache = SaveBase._createArray(); }
        ]);
        return SaveClipRectStencil;
    })();
    var SaveMark = (function () {
        function SaveMark() {
            this._saveuse = 0;
            ;
        }
        __class(SaveMark, 'laya.webgl.canvas.save.SaveMark');
        var __proto = SaveMark.prototype;
        Laya.imps(__proto, { "laya.webgl.canvas.save.ISaveData": true });
        __proto.isSaveMark = function () {
            return true;
        };
        __proto.restore = function (context) {
            context._saveMark = this._preSaveMark;
            SaveMark._no[SaveMark._no._length++] = this;
        };
        SaveMark.Create = function (context) {
            var no = SaveMark._no;
            var o = no._length > 0 ? no[--no._length] : (new SaveMark());
            o._saveuse = 0;
            o._preSaveMark = context._saveMark;
            context._saveMark = o;
            return o;
        };
        __static(SaveMark, ['_no', function () { return this._no = SaveBase._createArray(); }
        ]);
        return SaveMark;
    })();
    var SaveTransform = (function () {
        function SaveTransform() {
            this._matrix = new Matrix();
        }
        __class(SaveTransform, 'laya.webgl.canvas.save.SaveTransform');
        var __proto = SaveTransform.prototype;
        Laya.imps(__proto, { "laya.webgl.canvas.save.ISaveData": true });
        __proto.isSaveMark = function () { return false; };
        __proto.restore = function (context) {
            context._curMat = this._savematrix;
            SaveTransform._no[SaveTransform._no._length++] = this;
        };
        SaveTransform.save = function (context) {
            var _saveMark = context._saveMark;
            if ((_saveMark._saveuse & 0x800) === 0x800)
                return;
            _saveMark._saveuse |= 0x800;
            var no = SaveTransform._no;
            var o = no._length > 0 ? no[--no._length] : (new SaveTransform());
            o._savematrix = context._curMat;
            context._curMat = context._curMat.copyTo(o._matrix);
            var _save = context._save;
            _save[_save._length++] = o;
        };
        __static(SaveTransform, ['_no', function () { return this._no = SaveBase._createArray(); }
        ]);
        return SaveTransform;
    })();
    var SaveTranslate = (function () {
        function SaveTranslate() {
        }
        __class(SaveTranslate, 'laya.webgl.canvas.save.SaveTranslate');
        var __proto = SaveTranslate.prototype;
        Laya.imps(__proto, { "laya.webgl.canvas.save.ISaveData": true });
        __proto.isSaveMark = function () { return false; };
        __proto.restore = function (context) {
            var mat = context._curMat;
            context._x = this._x;
            context._y = this._y;
            SaveTranslate._no[SaveTranslate._no._length++] = this;
        };
        SaveTranslate.save = function (context) {
            var no = SaveTranslate._no;
            var o = no._length > 0 ? no[--no._length] : (new SaveTranslate());
            o._x = context._x;
            o._y = context._y;
            var _save = context._save;
            _save[_save._length++] = o;
        };
        __static(SaveTranslate, ['_no', function () { return this._no = SaveBase._createArray(); }
        ]);
        return SaveTranslate;
    })();
    var RenderTargetMAX = (function () {
        function RenderTargetMAX() {
            this.target = null;
            this.repaint = false;
            this._width = NaN;
            this._height = NaN;
            this._sp = null;
            this._clipRect = new Rectangle();
        }
        __class(RenderTargetMAX, 'laya.webgl.resource.RenderTargetMAX');
        var __proto = RenderTargetMAX.prototype;
        __proto.setSP = function (sp) {
            this._sp = sp;
        };
        __proto.size = function (w, h) {
            var _$this = this;
            if (this._width === w && this._height === h) {
                this.target.size(w, h);
                return;
            }
            this.repaint = true;
            this._width = w;
            this._height = h;
            if (!this.target)
                this.target = RenderTarget2D.create(w, h);
            else
                this.target.size(w, h);
            if (!this.target.hasListener("recovered")) {
                this.target.on("recovered", this, function (e) {
                    Laya.timer.callLater(_$this._sp, _$this._sp.repaint);
                });
            }
        };
        __proto._flushToTarget = function (context, target) {
            if (target._destroy)
                return;
            var worldScissorTest = RenderState2D.worldScissorTest;
            var preworldClipRect = RenderState2D.worldClipRect;
            RenderState2D.worldClipRect = this._clipRect;
            this._clipRect.x = this._clipRect.y = 0;
            this._clipRect.width = this._width;
            this._clipRect.height = this._height;
            RenderState2D.worldScissorTest = false;
            WebGL.mainContext.disable(0x0C11);
            var preAlpha = RenderState2D.worldAlpha;
            var preMatrix4 = RenderState2D.worldMatrix4;
            var preMatrix = RenderState2D.worldMatrix;
            var preFilters = RenderState2D.worldFilters;
            var preShaderDefines = RenderState2D.worldShaderDefines;
            RenderState2D.worldMatrix = Matrix.EMPTY;
            RenderState2D.restoreTempArray();
            RenderState2D.worldMatrix4 = RenderState2D.TEMPMAT4_ARRAY;
            RenderState2D.worldAlpha = 1;
            RenderState2D.worldFilters = null;
            RenderState2D.worldShaderDefines = null;
            BaseShader.activeShader = null;
            target.start();
            Config.showCanvasMark ? target.clear(0, 1, 0, 0.3) : target.clear(0, 0, 0, 0);
            context.flush();
            target.end();
            BaseShader.activeShader = null;
            RenderState2D.worldAlpha = preAlpha;
            RenderState2D.worldMatrix4 = preMatrix4;
            RenderState2D.worldMatrix = preMatrix;
            RenderState2D.worldFilters = preFilters;
            RenderState2D.worldShaderDefines = preShaderDefines;
            RenderState2D.worldScissorTest = worldScissorTest;
            if (worldScissorTest) {
                var y = RenderState2D.height - preworldClipRect.y - preworldClipRect.height;
                WebGL.mainContext.scissor(preworldClipRect.x, y, preworldClipRect.width, preworldClipRect.height);
                WebGL.mainContext.enable(0x0C11);
            }
            RenderState2D.worldClipRect = preworldClipRect;
        };
        __proto.flush = function (context) {
            if (this.repaint) {
                this._flushToTarget(context, this.target);
                this.repaint = false;
            }
        };
        __proto.drawTo = function (context, x, y, width, height) {
            context.drawTexture(this.target.getTexture(), x, y, width, height, 0, 0);
        };
        __proto.destroy = function () {
            if (this.target) {
                this.target.destroy();
                this.target = null;
                this._sp = null;
            }
        };
        return RenderTargetMAX;
    })();
    var Shader2D = (function () {
        function Shader2D() {
            this.ALPHA = 1;
            this.shaderType = 0;
            this.defines = new ShaderDefines2D();
        }
        __class(Shader2D, 'laya.webgl.shader.d2.Shader2D');
        var __proto = Shader2D.prototype;
        __proto.destroy = function () {
            this.defines = null;
            this.filters = null;
            this.glTexture = null;
            this.strokeStyle = null;
            this.fillStyle = null;
        };
        Shader2D.__init__ = function () {
            Shader.addInclude("parts/ColorFilter_ps_uniform.glsl", "uniform vec4 colorAlpha;\nuniform mat4 colorMat;");
            Shader.addInclude("parts/ColorFilter_ps_logic.glsl", "mat4 alphaMat =colorMat;\n\nalphaMat[0][3] *= gl_FragColor.a;\nalphaMat[1][3] *= gl_FragColor.a;\nalphaMat[2][3] *= gl_FragColor.a;\n\ngl_FragColor = gl_FragColor * alphaMat;\ngl_FragColor += colorAlpha/255.0*gl_FragColor.a;\n");
            Shader.addInclude("parts/GlowFilter_ps_uniform.glsl", "uniform vec4 u_color;\nuniform float u_strength;\nuniform float u_blurX;\nuniform float u_blurY;\nuniform float u_offsetX;\nuniform float u_offsetY;\nuniform float u_textW;\nuniform float u_textH;");
            Shader.addInclude("parts/GlowFilter_ps_logic.glsl", "const float c_IterationTime = 10.0;\nfloat floatIterationTotalTime = c_IterationTime * c_IterationTime;\nvec4 vec4Color = vec4(0.0,0.0,0.0,0.0);\nvec2 vec2FilterDir = vec2(-(u_offsetX)/u_textW,-(u_offsetY)/u_textH);\nvec2 vec2FilterOff = vec2(u_blurX/u_textW/c_IterationTime * 2.0,u_blurY/u_textH/c_IterationTime * 2.0);\nfloat maxNum = u_blurX * u_blurY;\nvec2 vec2Off = vec2(0.0,0.0);\nfloat floatOff = c_IterationTime/2.0;\nfor(float i = 0.0;i<=c_IterationTime; ++i){\n	for(float j = 0.0;j<=c_IterationTime; ++j){\n		vec2Off = vec2(vec2FilterOff.x * (i - floatOff),vec2FilterOff.y * (j - floatOff));\n		vec4Color += texture2D(texture, v_texcoord + vec2FilterDir + vec2Off)/floatIterationTotalTime;\n	}\n}\ngl_FragColor = vec4(u_color.rgb,vec4Color.a * u_strength);\ngl_FragColor.rgb *= gl_FragColor.a;");
            Shader.addInclude("parts/BlurFilter_ps_logic.glsl", "gl_FragColor =   blur();\ngl_FragColor.w*=alpha;");
            Shader.addInclude("parts/BlurFilter_ps_uniform.glsl", "uniform vec4 strength_sig2_2sig2_gauss1;\nuniform vec2 blurInfo;\n\n#define PI 3.141593\n\n//float sigma=strength/3.0;//3σ以外影响很小。即当σ=1的时候，半径为3\n//float sig2 = sigma*sigma;\n//float _2sig2 = 2.0*sig2;\n//return 1.0/(2*PI*sig2)*exp(-(x*x+y*y)/_2sig2)\n//float gauss1 = 1.0/(2.0*PI*sig2);\n\nfloat getGaussian(float x, float y){\n    return strength_sig2_2sig2_gauss1.w*exp(-(x*x+y*y)/strength_sig2_2sig2_gauss1.z);\n}\n\nvec4 blur(){\n    const float blurw = 9.0;\n    vec4 vec4Color = vec4(0.0,0.0,0.0,0.0);\n    vec2 halfsz=vec2(blurw,blurw)/2.0/blurInfo;    \n    vec2 startpos=v_texcoord-halfsz;\n    vec2 ctexcoord = startpos;\n    vec2 step = 1.0/blurInfo;  //每个像素      \n    \n    for(float y = 0.0;y<=blurw; ++y){\n        ctexcoord.x=startpos.x;\n        for(float x = 0.0;x<=blurw; ++x){\n            //TODO 纹理坐标的固定偏移应该在vs中处理\n            vec4Color += texture2D(texture, ctexcoord)*getGaussian(x-blurw/2.0,y-blurw/2.0);\n            ctexcoord.x+=step.x;\n        }\n        ctexcoord.y+=step.y;\n    }\n    return vec4Color;\n}");
            Shader.addInclude("parts/ColorAdd_ps_uniform.glsl", "uniform vec4 colorAdd;\n");
            Shader.addInclude("parts/ColorAdd_ps_logic.glsl", "gl_FragColor = vec4(colorAdd.rgb,colorAdd.a*gl_FragColor.a);\ngl_FragColor.xyz *= colorAdd.a;");
            var vs, ps;
            vs = "attribute vec4 position;\nattribute vec2 texcoord;\nuniform vec2 size;\n\n#ifdef WORLDMAT\nuniform mat4 mmat;\n#endif\nvarying vec2 v_texcoord;\nvoid main() {\n  #ifdef WORLDMAT\n  vec4 pos=mmat*position;\n  gl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\n  #else\n  gl_Position =vec4((position.x/size.x-0.5)*2.0,(0.5-position.y/size.y)*2.0,position.z,1.0);\n  #endif\n  \n  v_texcoord = texcoord;\n}";
            ps = "precision mediump float;\n//precision highp float;\nvarying vec2 v_texcoord;\nuniform sampler2D texture;\nuniform float alpha;\n#include?BLUR_FILTER  \"parts/BlurFilter_ps_uniform.glsl\";\n#include?COLOR_FILTER \"parts/ColorFilter_ps_uniform.glsl\";\n#include?GLOW_FILTER \"parts/GlowFilter_ps_uniform.glsl\";\n#include?COLOR_ADD \"parts/ColorAdd_ps_uniform.glsl\";\n\nvoid main() {\n   vec4 color= texture2D(texture, v_texcoord);\n   color.a*=alpha;\n   color.rgb*=alpha;\n   gl_FragColor=color;\n   #include?COLOR_ADD \"parts/ColorAdd_ps_logic.glsl\";   \n   #include?BLUR_FILTER  \"parts/BlurFilter_ps_logic.glsl\";\n   #include?COLOR_FILTER \"parts/ColorFilter_ps_logic.glsl\";\n   #include?GLOW_FILTER \"parts/GlowFilter_ps_logic.glsl\";\n}";
            Shader.preCompile2D(0,/*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/0x01, vs, ps, null);
            vs = "attribute vec4 position;\nuniform vec2 size;\nuniform mat4 mmat;\nvoid main() {\n  vec4 pos=mmat*position;\n  gl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\n}";
            ps = "precision mediump float;\nuniform vec4 color;\nuniform float alpha;\n#include?COLOR_FILTER \"parts/ColorFilter_ps_uniform.glsl\";\nvoid main() {\n	vec4 a = vec4(color.r, color.g, color.b, color.a);\n	a.w = alpha;\n	a.xyz *= alpha;\n	gl_FragColor = a;\n	#include?COLOR_FILTER \"parts/ColorFilter_ps_logic.glsl\";\n}";
            Shader.preCompile2D(0, 0x02, vs, ps, null);
            vs = "attribute vec4 position;\nattribute vec3 a_color;\nuniform mat4 mmat;\nuniform mat4 u_mmat2;\nuniform vec2 u_pos;\nuniform vec2 size;\nvarying vec3 color;\nvoid main(){\n  vec4 tPos = vec4(position.x + u_pos.x,position.y + u_pos.y,position.z,position.w);\n  vec4 pos=mmat*u_mmat2*tPos;\n  gl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\n  color=a_color;\n}";
            ps = "precision mediump float;\n//precision mediump float;\nvarying vec3 color;\nuniform float alpha;\nvoid main(){\n	//vec4 a=vec4(color.r, color.g, color.b, 1);\n	//a.a*=alpha;\n    gl_FragColor=vec4(color.r, color.g, color.b, alpha);\n	gl_FragColor.rgb*=alpha;\n}";
            Shader.preCompile2D(0, 0x04, vs, ps, null);
            vs = "attribute vec4 position;\nattribute vec2 texcoord;\nuniform vec2 size;\n\n#ifdef WORLDMAT\nuniform mat4 mmat;\n#endif\nvarying vec2 v_texcoord;\nvoid main() {\n  #ifdef WORLDMAT\n  vec4 pos=mmat*position;\n  gl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\n  #else\n  gl_Position =vec4((position.x/size.x-0.5)*2.0,(0.5-position.y/size.y)*2.0,position.z,1.0);\n  #endif\n  \n  v_texcoord = texcoord;\n}";
            ps = "#ifdef FSHIGHPRECISION\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n//precision highp float;\nvarying vec2 v_texcoord;\nuniform sampler2D texture;\nuniform float alpha;\nuniform vec4 u_TexRange;\nuniform vec2 u_offset;\n#include?BLUR_FILTER  \"parts/BlurFilter_ps_uniform.glsl\";\n#include?COLOR_FILTER \"parts/ColorFilter_ps_uniform.glsl\";\n#include?GLOW_FILTER \"parts/GlowFilter_ps_uniform.glsl\";\n#include?COLOR_ADD \"parts/ColorAdd_ps_uniform.glsl\";\n\nvoid main() {\n   vec2 newTexCoord;\n   newTexCoord.x = mod(u_offset.x + v_texcoord.x,u_TexRange.y) + u_TexRange.x;\n   newTexCoord.y = mod(u_offset.y + v_texcoord.y,u_TexRange.w) + u_TexRange.z;\n   vec4 color= texture2D(texture, newTexCoord);\n if(color.a<1.0)color.rgb*=1.0/color.a;  color.a*=alpha;\n   gl_FragColor=color;\n   #include?COLOR_ADD \"parts/ColorAdd_ps_logic.glsl\";   \n   #include?BLUR_FILTER  \"parts/BlurFilter_ps_logic.glsl\";\n   #include?COLOR_FILTER \"parts/ColorFilter_ps_logic.glsl\";\n   #include?GLOW_FILTER \"parts/GlowFilter_ps_logic.glsl\";\n}";
            Shader.preCompile2D(0, 0x100, vs, ps, null);
            vs = "attribute vec2 position;\nattribute vec2 texcoord;\nattribute vec4 color;\nuniform vec2 size;\nuniform float offsetX;\nuniform float offsetY;\nuniform mat4 mmat;\nuniform mat4 u_mmat2;\nvarying vec2 v_texcoord;\nvarying vec4 v_color;\nvoid main() {\n  vec4 pos=mmat*u_mmat2*vec4(offsetX+position.x,offsetY+position.y,0,1 );\n  gl_Position = vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\n  v_color = color;\n  v_color.rgb *= v_color.a;\n  v_texcoord = texcoord;  \n}";
            ps = "precision mediump float;\nvarying vec2 v_texcoord;\nvarying vec4 v_color;\nuniform sampler2D texture;\nuniform float alpha;\nvoid main() {\n	vec4 t_color = texture2D(texture, v_texcoord);\n	gl_FragColor = t_color.rgba * v_color;\n	gl_FragColor *= alpha;\n}";
            Shader.preCompile2D(0, 0x200, vs, ps, null);
        };
        return Shader2D;
    })();
    var ShaderDefines = (function () {
        function ShaderDefines(name2int, int2name, int2nameMap) {
            this._value = 0;
            this._name2int = name2int;
            this._int2name = int2name;
            this._int2nameMap = int2nameMap;
        }
        __class(ShaderDefines, 'laya.webgl.shader.ShaderDefines');
        var __proto = ShaderDefines.prototype;
        __proto.add = function (value) {
            if ((typeof value == 'string'))
                value = this._name2int[value];
            this._value |= value;
            return this._value;
        };
        __proto.addInt = function (value) {
            this._value |= value;
            return this._value;
        };
        __proto.remove = function (value) {
            if ((typeof value == 'string'))
                value = this._name2int[value];
            this._value &= (~value);
            return this._value;
        };
        __proto.isDefine = function (def) {
            return (this._value & def) === def;
        };
        __proto.getValue = function () {
            return this._value;
        };
        __proto.setValue = function (value) {
            this._value = value;
        };
        __proto.toNameDic = function (shaderValue) {
            var r = this._int2nameMap[this._value];
            var res = (r && !shaderValue.kdsSetMaterialMacros) ? r : ShaderDefines._toText(this._value, this._int2name, this._int2nameMap, true);
            if (shaderValue.kdsSetMaterialMacros) {
                for (var i = 0; i < shaderValue.kdsSetMaterialMacros.length; i++) {
                    var kdsMaterialID = shaderValue.kdsSetMaterialMacros[i];
                    res["KDS_M" + kdsMaterialID] = (i + 1);
                }
                for (var i = 0; i < shaderValue.kdsVarMacros.length; i++) {
                    res[shaderValue.kdsVarMacros[i]] = "";
                }
            }
            return res;
        };
        ShaderDefines._reg = function (name, value, _name2int, _int2name) {
            _name2int[name] = value;
            _int2name[value] = name;
        };
        ShaderDefines._toText = function (value, _int2name, _int2nameMap, ignoreCache) {
            var r = _int2nameMap[value];
            if (r && !ignoreCache)
                return r;
            var o = {};
            var d = 1;
            for (var i = 0; i < 32; i++) {
                d = 1 << i;
                if (d > value)
                    break;
                if (value & d) {
                    var name = _int2name[d];
                    if (name && name.indexOf("KDS_M") == 0) continue;
                    name && (o[name] = "");
                }
            }
            _int2nameMap[value] = o;
            return o;
        };
        ShaderDefines._toInt = function (names, _name2int) {
            var words = names.split('.');
            var num = 0;
            for (var i = 0, n = words.length; i < n; i++) {
                var value = _name2int[words[i]];
                if (!value)
                    throw new Error("Defines to int err:" + names + "/" + words[i]);
                num |= value;
            }
            return num;
        };
        return ShaderDefines;
    })();
    var SkinMesh = (function () {
        function SkinMesh() {
            this.mVBBuffer = null;
            this.mIBBuffer = null;
            this.mVBData = null;
            this.mIBData = null;
            this.mEleNum = 0;
            this.mTexture = null;
            this.transform = null;
            this._vs = null;
            this._ps = null;
            this._indexStart = -1;
            this._verticles = null;
            this._uvs = null;
            this._tempMatrix = new Matrix();
        }
        __class(SkinMesh, 'laya.webgl.shader.d2.skinAnishader.SkinMesh');
        var __proto = SkinMesh.prototype;
        __proto.init = function (texture, vs, ps) {
            if (vs) {
                this._vs = vs;
            }
            else {
                this._vs = [];
                var tWidth = texture.width;
                var tHeight = texture.height;
                var tRed = 1;
                var tGreed = 1;
                var tBlue = 1;
                var tAlpha = 1;
                this._vs.push(0, 0, 0, 0, tRed, tGreed, tBlue, tAlpha);
                this._vs.push(tWidth, 0, 1, 0, tRed, tGreed, tBlue, tAlpha);
                this._vs.push(tWidth, tHeight, 1, 1, tRed, tGreed, tBlue, tAlpha);
                this._vs.push(0, tHeight, 0, 1, tRed, tGreed, tBlue, tAlpha);
            }
            if (ps) {
                this._ps = ps;
            }
            else {
                if (!SkinMesh._defaultPS) {
                    SkinMesh._defaultPS = [];
                    SkinMesh._defaultPS.push(0, 1, 3, 3, 1, 2);
                }
                this._ps = SkinMesh._defaultPS;
            }
            this.mVBData = new Float32Array(this._vs);
            this.mIBData = new Uint16Array(this._ps.length);
            this.mIBData["start"] = -1;
            this.mEleNum = this._ps.length;
            this.mTexture = texture;
        };
        __proto.init2 = function (texture, vs, ps, verticles, uvs) {
            if (this.transform)
                this.transform = null;
            if (ps) {
                this._ps = ps;
            }
            else {
                this._ps = [];
                this._ps.push(0, 1, 3, 3, 1, 2);
            }
            this._verticles = verticles;
            this._uvs = uvs;
            this.mEleNum = this._ps.length;
            this.mTexture = texture;
            if (Render.isConchNode || Render.isConchApp) {
                this._initMyData();
                this.mVBData = new Float32Array(this._vs);
            }
        };
        __proto._initMyData = function () {
            var vsI = 0;
            var vI = 0;
            var vLen = this._verticles.length;
            var tempVLen = vLen * 4;
            this._vs = SkinMesh._tempVS;
            var insertNew = false;
            if (Render.isConchNode || Render.isConchApp) {
                this._vs.length = tempVLen;
                insertNew = true;
            }
            else {
                if (this._vs.length < tempVLen) {
                    this._vs.length = tempVLen;
                    insertNew = true;
                }
            }
            SkinMesh._tVSLen = tempVLen;
            if (insertNew) {
                while (vsI < tempVLen) {
                    this._vs[vsI] = this._verticles[vI];
                    this._vs[vsI + 1] = this._verticles[vI + 1];
                    this._vs[vsI + 2] = this._uvs[vI];
                    this._vs[vsI + 3] = this._uvs[vI + 1];
                    this._vs[vsI + 4] = 1;
                    this._vs[vsI + 5] = 1;
                    this._vs[vsI + 6] = 1;
                    this._vs[vsI + 7] = 1;
                    vsI += 8;
                    vI += 2;
                }
            }
            else {
                while (vsI < tempVLen) {
                    this._vs[vsI] = this._verticles[vI];
                    this._vs[vsI + 1] = this._verticles[vI + 1];
                    this._vs[vsI + 2] = this._uvs[vI];
                    this._vs[vsI + 3] = this._uvs[vI + 1];
                    vsI += 8;
                    vI += 2;
                }
            }
        };
        __proto.getData2 = function (vb, ib, start) {
            this.mVBBuffer = vb;
            this.mIBBuffer = ib;
            this._initMyData();
            vb.appendEx2(this._vs, Float32Array, SkinMesh._tVSLen, 4);
            this._indexStart = ib._byteLength;
            var tIB;
            tIB = SkinMesh._tempIB;
            if (tIB.length < this._ps.length) {
                tIB.length = this._ps.length;
            }
            for (var i = 0, n = this._ps.length; i < n; i++) {
                tIB[i] = this._ps[i] + start;
            }
            ib.appendEx2(tIB, Uint16Array, this._ps.length, 2);
        };
        __proto.getData = function (vb, ib, start) {
            this.mVBBuffer = vb;
            this.mIBBuffer = ib;
            vb.append(this.mVBData);
            this._indexStart = ib._byteLength;
            if (this.mIBData["start"] != start) {
                for (var i = 0, n = this._ps.length; i < n; i++) {
                    this.mIBData[i] = this._ps[i] + start;
                }
                this.mIBData["start"] = start;
            }
            ib.append(this.mIBData);
        };
        __proto.render = function (context, x, y) {
            if (Render.isWebGL && this.mTexture) {
                context._renderKey = 0;
                context._shader2D.glTexture = null;
                SkinMeshBuffer.getInstance().addSkinMesh(this);
                var tempSubmit = Submit.createShape(context, this.mIBBuffer, this.mVBBuffer, this.mEleNum, this._indexStart, Value2D.create(0x200, 0));
                this.transform || (this.transform = Matrix.EMPTY);
                this.transform.translate(x, y);
                Matrix.mul(this.transform, context._curMat, this._tempMatrix);
                this.transform.translate(-x, -y);
                var tShaderValue = tempSubmit.shaderValue;
                var tArray = tShaderValue.u_mmat2 || RenderState2D.getMatrArray();
                RenderState2D.mat2MatArray(this._tempMatrix, tArray);
                tShaderValue.textureHost = this.mTexture;
                tShaderValue.offsetX = 0;
                tShaderValue.offsetY = 0;
                tShaderValue.u_mmat2 = tArray;
                tShaderValue.ALPHA = context._shader2D.ALPHA;
                context._submits[context._submits._length++] = tempSubmit;
            }
            else if (Render.isConchApp && this.mTexture) {
                this.transform || (this.transform = Matrix.EMPTY);
                context.setSkinMesh && context.setSkinMesh(x, y, this._ps, this.mVBData, this.mEleNum, 0, this.mTexture, this.transform);
            }
        };
        SkinMesh._tempVS = [];
        SkinMesh._tempIB = [];
        SkinMesh._defaultPS = null;
        SkinMesh._tVSLen = 0;
        return SkinMesh;
    })();
    var SkinMeshBuffer = (function () {
        function SkinMeshBuffer() {
            this.ib = null;
            this.vb = null;
            var gl = WebGL.mainContext;
            this.ib = IndexBuffer2D.create(0x88E8);
            this.vb = VertexBuffer2D.create(8);
        }
        __class(SkinMeshBuffer, 'laya.webgl.shader.d2.skinAnishader.SkinMeshBuffer');
        var __proto = SkinMeshBuffer.prototype;
        __proto.addSkinMesh = function (skinMesh) {
            skinMesh.getData2(this.vb, this.ib, this.vb._byteLength / 32);
        };
        __proto.reset = function () {
            this.vb.clear();
            this.ib.clear();
        };
        SkinMeshBuffer.getInstance = function () {
            return SkinMeshBuffer.instance = SkinMeshBuffer.instance || new SkinMeshBuffer();
        };
        SkinMeshBuffer.instance = null;
        return SkinMeshBuffer;
    })();
    var BasePoly = (function () {
        function BasePoly(x, y, width, height, edges, color, borderWidth, borderColor, round) {
            this.r0 = 0;
            this.fill = true;
            this.r1 = Math.PI / 2;
            (round === void 0) && (round = 0);
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.edges = edges;
            this.color = color;
            this.borderWidth = borderWidth;
            this.borderColor = borderColor;
        }
        __class(BasePoly, 'laya.webgl.shapes.BasePoly');
        var __proto = BasePoly.prototype;
        Laya.imps(__proto, { "laya.webgl.shapes.IShape": true });
        __proto.getData = function (ib, vb, start) { };
        __proto.rebuild = function (points) { };
        __proto.setMatrix = function (mat) { };
        __proto.needUpdate = function (mat) {
            return true;
        };
        __proto.sector = function (outVert, outIndex, start) {
            var x = this.x, y = this.y, edges = this.edges, seg = (this.r1 - this.r0) / edges;
            var w = this.width, h = this.height, color = this.color;
            var r = ((color >> 16) & 0x0000ff) / 255, g = ((color >> 8) & 0xff) / 255, b = (color & 0x0000ff) / 255;
            outVert.push(x, y, r, g, b);
            for (var i = 0; i < edges + 1; i++) {
                outVert.push(x + Math.sin(seg * i + this.r0) * w, y + Math.cos(seg * i + this.r0) * h);
                outVert.push(r, g, b);
            }
            for (i = 0; i < edges; i++) {
                outIndex.push(start, start + i + 1, start + i + 2);
            }
        };
        __proto.createLine2 = function (p, indices, lineWidth, len, outVertex, indexCount) {
            var points = p.concat();
            var result = outVertex;
            var color = this.borderColor;
            var r = ((color >> 16) & 0x0000ff) / 255, g = ((color >> 8) & 0xff) / 255, b = (color & 0x0000ff) / 255;
            var length = points.length / 2;
            var iStart = len, w = lineWidth / 2;
            var px, py, p1x, p1y, p2x, p2y, p3x, p3y;
            var perpx, perpy, perp2x, perp2y, perp3x, perp3y;
            var a1, b1, c1, a2, b2, c2;
            var denom, pdist, dist;
            p1x = points[0];
            p1y = points[1];
            p2x = points[2];
            p2y = points[3];
            perpx = -(p1y - p2y);
            perpy = p1x - p2x;
            dist = Math.sqrt(perpx * perpx + perpy * perpy);
            perpx = perpx / dist * w;
            perpy = perpy / dist * w;
            result.push(p1x - perpx + this.x, p1y - perpy + this.y, r, g, b, p1x + perpx + this.x, p1y + perpy + this.y, r, g, b);
            for (var i = 1; i < length - 1; i++) {
                p1x = points[(i - 1) * 2];
                p1y = points[(i - 1) * 2 + 1];
                p2x = points[(i) * 2];
                p2y = points[(i) * 2 + 1];
                p3x = points[(i + 1) * 2];
                p3y = points[(i + 1) * 2 + 1];
                perpx = -(p1y - p2y);
                perpy = p1x - p2x;
                dist = Math.sqrt(perpx * perpx + perpy * perpy);
                perpx = perpx / dist * w;
                perpy = perpy / dist * w;
                perp2x = -(p2y - p3y);
                perp2y = p2x - p3x;
                dist = Math.sqrt(perp2x * perp2x + perp2y * perp2y);
                perp2x = perp2x / dist * w;
                perp2y = perp2y / dist * w;
                a1 = (-perpy + p1y) - (-perpy + p2y);
                b1 = (-perpx + p2x) - (-perpx + p1x);
                c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);
                a2 = (-perp2y + p3y) - (-perp2y + p2y);
                b2 = (-perp2x + p2x) - (-perp2x + p3x);
                c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);
                denom = a1 * b2 - a2 * b1;
                if (Math.abs(denom) < 0.1) {
                    denom += 10.1;
                    result.push(p2x - perpx + this.x, p2y - perpy + this.y, r, g, b, p2x + perpx + this.x, p2y + perpy + this.y, r, g, b);
                    continue;
                }
                px = (b1 * c2 - b2 * c1) / denom;
                py = (a2 * c1 - a1 * c2) / denom;
                pdist = (px - p2x) * (px - p2x) + (py - p2y) + (py - p2y);
                result.push(px + this.x, py + this.y, r, g, b, p2x - (px - p2x) + this.x, p2y - (py - p2y) + this.y, r, g, b);
            }
            p1x = points[points.length - 4];
            p1y = points[points.length - 3];
            p2x = points[points.length - 2];
            p2y = points[points.length - 1];
            perpx = -(p1y - p2y);
            perpy = p1x - p2x;
            dist = Math.sqrt(perpx * perpx + perpy * perpy);
            perpx = perpx / dist * w;
            perpy = perpy / dist * w;
            result.push(p2x - perpx + this.x, p2y - perpy + this.y, r, g, b, p2x + perpx + this.x, p2y + perpy + this.y, r, g, b);
            var groupLen = indexCount;
            for (i = 1; i < groupLen; i++) {
                indices.push(iStart + (i - 1) * 2, iStart + (i - 1) * 2 + 1, iStart + i * 2 + 1, iStart + i * 2 + 1, iStart + i * 2, iStart + (i - 1) * 2);
            }
            return result;
        };
        __proto.createLine = function (p, indices, lineWidth, len) {
            var points = p.concat();
            var result = p;
            var color = this.borderColor;
            var r = ((color >> 16) & 0x0000ff) / 255, g = ((color >> 8) & 0xff) / 255, b = (color & 0x0000ff) / 255;
            points.splice(0, 5);
            var length = points.length / 5;
            var iStart = len, w = lineWidth / 2;
            var px, py, p1x, p1y, p2x, p2y, p3x, p3y;
            var perpx, perpy, perp2x, perp2y, perp3x, perp3y;
            var a1, b1, c1, a2, b2, c2;
            var denom, pdist, dist;
            p1x = points[0];
            p1y = points[1];
            p2x = points[5];
            p2y = points[6];
            perpx = -(p1y - p2y);
            perpy = p1x - p2x;
            dist = Math.sqrt(perpx * perpx + perpy * perpy);
            perpx = perpx / dist * w;
            perpy = perpy / dist * w;
            result.push(p1x - perpx, p1y - perpy, r, g, b, p1x + perpx, p1y + perpy, r, g, b);
            for (var i = 1; i < length - 1; i++) {
                p1x = points[(i - 1) * 5];
                p1y = points[(i - 1) * 5 + 1];
                p2x = points[(i) * 5];
                p2y = points[(i) * 5 + 1];
                p3x = points[(i + 1) * 5];
                p3y = points[(i + 1) * 5 + 1];
                perpx = -(p1y - p2y);
                perpy = p1x - p2x;
                dist = Math.sqrt(perpx * perpx + perpy * perpy);
                perpx = perpx / dist * w;
                perpy = perpy / dist * w;
                perp2x = -(p2y - p3y);
                perp2y = p2x - p3x;
                dist = Math.sqrt(perp2x * perp2x + perp2y * perp2y);
                perp2x = perp2x / dist * w;
                perp2y = perp2y / dist * w;
                a1 = (-perpy + p1y) - (-perpy + p2y);
                b1 = (-perpx + p2x) - (-perpx + p1x);
                c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);
                a2 = (-perp2y + p3y) - (-perp2y + p2y);
                b2 = (-perp2x + p2x) - (-perp2x + p3x);
                c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);
                denom = a1 * b2 - a2 * b1;
                if (Math.abs(denom) < 0.1) {
                    denom += 10.1;
                    result.push(p2x - perpx, p2y - perpy, r, g, b, p2x + perpx, p2y + perpy, r, g, b);
                    continue;
                }
                px = (b1 * c2 - b2 * c1) / denom;
                py = (a2 * c1 - a1 * c2) / denom;
                pdist = (px - p2x) * (px - p2x) + (py - p2y) + (py - p2y);
                result.push(px, py, r, g, b, p2x - (px - p2x), p2y - (py - p2y), r, g, b);
            }
            p1x = points[points.length - 10];
            p1y = points[points.length - 9];
            p2x = points[points.length - 5];
            p2y = points[points.length - 4];
            perpx = -(p1y - p2y);
            perpy = p1x - p2x;
            dist = Math.sqrt(perpx * perpx + perpy * perpy);
            perpx = perpx / dist * w;
            perpy = perpy / dist * w;
            result.push(p2x - perpx, p2y - perpy, r, g, b, p2x + perpx, p2y + perpy, r, g, b);
            var groupLen = this.edges + 1;
            for (i = 1; i < groupLen; i++) {
                indices.push(iStart + (i - 1) * 2, iStart + (i - 1) * 2 + 1, iStart + i * 2 + 1, iStart + i * 2 + 1, iStart + i * 2, iStart + (i - 1) * 2);
            }
            return result;
        };
        __proto.createLoopLine = function (p, indices, lineWidth, len, outVertex, outIndex) {
            var points = p.concat();
            var result = outVertex ? outVertex : p;
            var color = this.borderColor;
            var r = ((color >> 16) & 0x0000ff) / 255, g = ((color >> 8) & 0xff) / 255, b = (color & 0x0000ff) / 255;
            points.splice(0, 5);
            var firstPoint = [points[0], points[1]];
            var lastPoint = [points[points.length - 5], points[points.length - 4]];
            var midPointX = lastPoint[0] + (firstPoint[0] - lastPoint[0]) * 0.5;
            var midPointY = lastPoint[1] + (firstPoint[1] - lastPoint[1]) * 0.5;
            points.unshift(midPointX, midPointY, 0, 0, 0);
            points.push(midPointX, midPointY, 0, 0, 0);
            var length = points.length / 5;
            var iStart = len, w = lineWidth / 2;
            var px, py, p1x, p1y, p2x, p2y, p3x, p3y;
            var perpx, perpy, perp2x, perp2y, perp3x, perp3y;
            var a1, b1, c1, a2, b2, c2;
            var denom, pdist, dist;
            p1x = points[0];
            p1y = points[1];
            p2x = points[5];
            p2y = points[6];
            perpx = -(p1y - p2y);
            perpy = p1x - p2x;
            dist = Math.sqrt(perpx * perpx + perpy * perpy);
            perpx = perpx / dist * w;
            perpy = perpy / dist * w;
            result.push(p1x - perpx, p1y - perpy, r, g, b, p1x + perpx, p1y + perpy, r, g, b);
            for (var i = 1; i < length - 1; i++) {
                p1x = points[(i - 1) * 5];
                p1y = points[(i - 1) * 5 + 1];
                p2x = points[(i) * 5];
                p2y = points[(i) * 5 + 1];
                p3x = points[(i + 1) * 5];
                p3y = points[(i + 1) * 5 + 1];
                perpx = -(p1y - p2y);
                perpy = p1x - p2x;
                dist = Math.sqrt(perpx * perpx + perpy * perpy);
                perpx = perpx / dist * w;
                perpy = perpy / dist * w;
                perp2x = -(p2y - p3y);
                perp2y = p2x - p3x;
                dist = Math.sqrt(perp2x * perp2x + perp2y * perp2y);
                perp2x = perp2x / dist * w;
                perp2y = perp2y / dist * w;
                a1 = (-perpy + p1y) - (-perpy + p2y);
                b1 = (-perpx + p2x) - (-perpx + p1x);
                c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);
                a2 = (-perp2y + p3y) - (-perp2y + p2y);
                b2 = (-perp2x + p2x) - (-perp2x + p3x);
                c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);
                denom = a1 * b2 - a2 * b1;
                if (Math.abs(denom) < 0.1) {
                    denom += 10.1;
                    result.push(p2x - perpx, p2y - perpy, r, g, b, p2x + perpx, p2y + perpy, r, g, b);
                    continue;
                }
                px = (b1 * c2 - b2 * c1) / denom;
                py = (a2 * c1 - a1 * c2) / denom;
                pdist = (px - p2x) * (px - p2x) + (py - p2y) + (py - p2y);
                result.push(px, py, r, g, b, p2x - (px - p2x), p2y - (py - p2y), r, g, b);
            }
            if (outIndex) {
                indices = outIndex;
            }
            ;
            var groupLen = this.edges + 1;
            for (i = 1; i < groupLen; i++) {
                indices.push(iStart + (i - 1) * 2, iStart + (i - 1) * 2 + 1, iStart + i * 2 + 1, iStart + i * 2 + 1, iStart + i * 2, iStart + (i - 1) * 2);
            }
            indices.push(iStart + (i - 1) * 2, iStart + (i - 1) * 2 + 1, iStart + 1, iStart + 1, iStart, iStart + (i - 1) * 2);
            return result;
        };
        return BasePoly;
    })();
    var Earcut = (function () {
        function Earcut() { }
        __class(Earcut, 'laya.webgl.shapes.Earcut');
        Earcut.earcut = function (data, holeIndices, dim) {
            dim = dim || 2;
            var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = Earcut.linkedList(data, 0, outerLen, dim, true), triangles = [];
            if (!outerNode)
                return triangles;
            var minX, minY, maxX, maxY, x, y, invSize;
            if (hasHoles)
                outerNode = Earcut.eliminateHoles(data, holeIndices, outerNode, dim);
            if (data.length > 80 * dim) {
                minX = maxX = data[0];
                minY = maxY = data[1];
                for (var i = dim; i < outerLen; i += dim) {
                    x = data[i];
                    y = data[i + 1];
                    if (x < minX)
                        minX = x;
                    if (y < minY)
                        minY = y;
                    if (x > maxX)
                        maxX = x;
                    if (y > maxY)
                        maxY = y;
                }
                invSize = Math.max(maxX - minX, maxY - minY);
                invSize = invSize !== 0 ? 1 / invSize : 0;
            }
            Earcut.earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
            return triangles;
        };
        Earcut.linkedList = function (data, start, end, dim, clockwise) {
            var i, last;
            if (clockwise === (Earcut.signedArea(data, start, end, dim) > 0)) {
                for (i = start; i < end; i += dim)
                    last = Earcut.insertNode(i, data[i], data[i + 1], last);
            }
            else {
                for (i = end - dim; i >= start; i -= dim)
                    last = Earcut.insertNode(i, data[i], data[i + 1], last);
            }
            if (last && Earcut.equals(last, last.next)) {
                Earcut.removeNode(last);
                last = last.next;
            }
            return last;
        };
        Earcut.filterPoints = function (start, end) {
            if (!start)
                return start;
            if (!end)
                end = start;
            var p = start, again;
            do {
                again = false;
                if (!p.steiner && (Earcut.equals(p, p.next) || Earcut.area(p.prev, p, p.next) === 0)) {
                    Earcut.removeNode(p);
                    p = end = p.prev;
                    if (p === p.next)
                        break;
                    again = true;
                }
                else {
                    p = p.next;
                }
            } while (again || p !== end);
            return end;
        };
        Earcut.earcutLinked = function (ear, triangles, dim, minX, minY, invSize, pass) {
            if (!ear)
                return;
            if (!pass && invSize)
                Earcut.indexCurve(ear, minX, minY, invSize);
            var stop = ear, prev, next;
            while (ear.prev !== ear.next) {
                prev = ear.prev;
                next = ear.next;
                if (invSize ? Earcut.isEarHashed(ear, minX, minY, invSize) : Earcut.isEar(ear)) {
                    triangles.push(prev.i / dim);
                    triangles.push(ear.i / dim);
                    triangles.push(next.i / dim);
                    Earcut.removeNode(ear);
                    ear = next.next;
                    stop = next.next;
                    continue;
                }
                ear = next;
                if (ear === stop) {
                    if (!pass) {
                        Earcut.earcutLinked(Earcut.filterPoints(ear, null), triangles, dim, minX, minY, invSize, 1);
                    }
                    else if (pass === 1) {
                        ear = Earcut.cureLocalIntersections(ear, triangles, dim);
                        Earcut.earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
                    }
                    else if (pass === 2) {
                        Earcut.splitEarcut(ear, triangles, dim, minX, minY, invSize);
                    }
                    break;
                }
            }
        };
        Earcut.isEar = function (ear) {
            var a = ear.prev, b = ear, c = ear.next;
            if (Earcut.area(a, b, c) >= 0)
                return false;
            var p = ear.next.next;
            while (p !== ear.prev) {
                if (Earcut.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                    Earcut.area(p.prev, p, p.next) >= 0)
                    return false;
                p = p.next;
            }
            return true;
        };
        Earcut.isEarHashed = function (ear, minX, minY, invSize) {
            var a = ear.prev, b = ear, c = ear.next;
            if (Earcut.area(a, b, c) >= 0)
                return false;
            var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x), minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y), maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x), maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);
            var minZ = Earcut.zOrder(minTX, minTY, minX, minY, invSize), maxZ = Earcut.zOrder(maxTX, maxTY, minX, minY, invSize);
            var p = ear.nextZ;
            while (p && p.z <= maxZ) {
                if (p !== ear.prev && p !== ear.next &&
                    Earcut.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                    Earcut.area(p.prev, p, p.next) >= 0)
                    return false;
                p = p.nextZ;
            }
            p = ear.prevZ;
            while (p && p.z >= minZ) {
                if (p !== ear.prev && p !== ear.next &&
                    Earcut.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                    Earcut.area(p.prev, p, p.next) >= 0)
                    return false;
                p = p.prevZ;
            }
            return true;
        };
        Earcut.cureLocalIntersections = function (start, triangles, dim) {
            var p = start;
            do {
                var a = p.prev, b = p.next.next;
                if (!Earcut.equals(a, b) && Earcut.intersects(a, p, p.next, b) && Earcut.locallyInside(a, b) && Earcut.locallyInside(b, a)) {
                    triangles.push(a.i / dim);
                    triangles.push(p.i / dim);
                    triangles.push(b.i / dim);
                    Earcut.removeNode(p);
                    Earcut.removeNode(p.next);
                    p = start = b;
                }
                p = p.next;
            } while (p !== start);
            return p;
        };
        Earcut.splitEarcut = function (start, triangles, dim, minX, minY, invSize) {
            var a = start;
            do {
                var b = a.next.next;
                while (b !== a.prev) {
                    if (a.i !== b.i && Earcut.isValidDiagonal(a, b)) {
                        var c = Earcut.splitPolygon(a, b);
                        a = Earcut.filterPoints(a, a.next);
                        c = Earcut.filterPoints(c, c.next);
                        Earcut.earcutLinked(a, triangles, dim, minX, minY, invSize);
                        Earcut.earcutLinked(c, triangles, dim, minX, minY, invSize);
                        return;
                    }
                    b = b.next;
                }
                a = a.next;
            } while (a !== start);
        };
        Earcut.eliminateHoles = function (data, holeIndices, outerNode, dim) {
            var queue = [], i, len, start, end, list;
            for (i = 0, len = holeIndices.length; i < len; i++) {
                start = holeIndices[i] * dim;
                end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
                list = Earcut.linkedList(data, start, end, dim, false);
                if (list === list.next)
                    list.steiner = true;
                queue.push(Earcut.getLeftmost(list));
            }
            queue.sort(Earcut.compareX);
            for (i = 0; i < queue.length; i++) {
                Earcut.eliminateHole(queue[i], outerNode);
                outerNode = Earcut.filterPoints(outerNode, outerNode.next);
            }
            return outerNode;
        };
        Earcut.compareX = function (a, b) {
            return a.x - b.x;
        };
        Earcut.eliminateHole = function (hole, outerNode) {
            outerNode = Earcut.findHoleBridge(hole, outerNode);
            if (outerNode) {
                var b = Earcut.splitPolygon(outerNode, hole);
                Earcut.filterPoints(b, b.next);
            }
        };
        Earcut.findHoleBridge = function (hole, outerNode) {
            var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
            do {
                if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
                    var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                    if (x <= hx && x > qx) {
                        qx = x;
                        if (x === hx) {
                            if (hy === p.y)
                                return p;
                            if (hy === p.next.y)
                                return p.next;
                        }
                        m = p.x < p.next.x ? p : p.next;
                    }
                }
                p = p.next;
            } while (p !== outerNode);
            if (!m)
                return null;
            if (hx === qx)
                return m.prev;
            var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
            p = m.next;
            while (p !== stop) {
                if (hx >= p.x && p.x >= mx && hx !== p.x &&
                    Earcut.pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
                    tan = Math.abs(hy - p.y) / (hx - p.x);
                    if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && Earcut.locallyInside(p, hole)) {
                        m = p;
                        tanMin = tan;
                    }
                }
                p = p.next;
            }
            return m;
        };
        Earcut.indexCurve = function (start, minX, minY, invSize) {
            var p = start;
            do {
                if (p.z === null)
                    p.z = Earcut.zOrder(p.x, p.y, minX, minY, invSize);
                p.prevZ = p.prev;
                p.nextZ = p.next;
                p = p.next;
            } while (p !== start);
            p.prevZ.nextZ = null;
            p.prevZ = null;
            Earcut.sortLinked(p);
        };
        Earcut.sortLinked = function (list) {
            var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
            do {
                p = list;
                list = null;
                tail = null;
                numMerges = 0;
                while (p) {
                    numMerges++;
                    q = p;
                    pSize = 0;
                    for (i = 0; i < inSize; i++) {
                        pSize++;
                        q = q.nextZ;
                        if (!q)
                            break;
                    }
                    qSize = inSize;
                    while (pSize > 0 || (qSize > 0 && q)) {
                        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                            e = p;
                            p = p.nextZ;
                            pSize--;
                        }
                        else {
                            e = q;
                            q = q.nextZ;
                            qSize--;
                        }
                        if (tail)
                            tail.nextZ = e;
                        else
                            list = e;
                        e.prevZ = tail;
                        tail = e;
                    }
                    p = q;
                }
                tail.nextZ = null;
                inSize *= 2;
            } while (numMerges > 1);
            return list;
        };
        Earcut.zOrder = function (x, y, minX, minY, invSize) {
            x = 32767 * (x - minX) * invSize;
            y = 32767 * (y - minY) * invSize;
            x = (x | (x << 8)) & 0x00FF00FF;
            x = (x | (x << 4)) & 0x0F0F0F0F;
            x = (x | (x << 2)) & 0x33333333;
            x = (x | (x << 1)) & 0x55555555;
            y = (y | (y << 8)) & 0x00FF00FF;
            y = (y | (y << 4)) & 0x0F0F0F0F;
            y = (y | (y << 2)) & 0x33333333;
            y = (y | (y << 1)) & 0x55555555;
            return x | (y << 1);
        };
        Earcut.getLeftmost = function (start) {
            var p = start, leftmost = start;
            do {
                if (p.x < leftmost.x)
                    leftmost = p;
                p = p.next;
            } while (p !== start);
            return leftmost;
        };
        Earcut.pointInTriangle = function (ax, ay, bx, by, cx, cy, px, py) {
            return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
                (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
                (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
        };
        Earcut.isValidDiagonal = function (a, b) {
            return a.next.i !== b.i && a.prev.i !== b.i && !Earcut.intersectsPolygon(a, b) &&
                Earcut.locallyInside(a, b) && Earcut.locallyInside(b, a) && Earcut.middleInside(a, b);
        };
        Earcut.area = function (p, q, r) {
            return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
        };
        Earcut.equals = function (p1, p2) {
            return p1.x === p2.x && p1.y === p2.y;
        };
        Earcut.intersects = function (p1, q1, p2, q2) {
            if ((Earcut.equals(p1, q1) && Earcut.equals(p2, q2)) ||
                (Earcut.equals(p1, q2) && Earcut.equals(p2, q1)))
                return true;
            return Earcut.area(p1, q1, p2) > 0 !== Earcut.area(p1, q1, q2) > 0 &&
                Earcut.area(p2, q2, p1) > 0 !== Earcut.area(p2, q2, q1) > 0;
        };
        Earcut.intersectsPolygon = function (a, b) {
            var p = a;
            do {
                if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                    Earcut.intersects(p, p.next, a, b))
                    return true;
                p = p.next;
            } while (p !== a);
            return false;
        };
        Earcut.locallyInside = function (a, b) {
            return Earcut.area(a.prev, a, a.next) < 0 ?
                Earcut.area(a, b, a.next) >= 0 && Earcut.area(a, a.prev, b) >= 0 :
                Earcut.area(a, b, a.prev) < 0 || Earcut.area(a, a.next, b) < 0;
        };
        Earcut.middleInside = function (a, b) {
            var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
            do {
                if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                    (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
                    inside = !inside;
                p = p.next;
            } while (p !== a);
            return inside;
        };
        Earcut.splitPolygon = function (a, b) {
            var a2 = new EarcutNode(a.i, a.x, a.y), b2 = new EarcutNode(b.i, b.x, b.y), an = a.next, bp = b.prev;
            a.next = b;
            b.prev = a;
            a2.next = an;
            an.prev = a2;
            b2.next = a2;
            a2.prev = b2;
            bp.next = b2;
            b2.prev = bp;
            return b2;
        };
        Earcut.insertNode = function (i, x, y, last) {
            var p = new EarcutNode(i, x, y);
            if (!last) {
                p.prev = p;
                p.next = p;
            }
            else {
                p.next = last.next;
                p.prev = last;
                last.next.prev = p;
                last.next = p;
            }
            return p;
        };
        Earcut.removeNode = function (p) {
            p.next.prev = p.prev;
            p.prev.next = p.next;
            if (p.prevZ)
                p.prevZ.nextZ = p.nextZ;
            if (p.nextZ)
                p.nextZ.prevZ = p.prevZ;
        };
        Earcut.signedArea = function (data, start, end, dim) {
            var sum = 0;
            for (var i = start, j = end - dim; i < end; i += dim) {
                sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
                j = i;
            }
            return sum;
        };
        return Earcut;
    })();
    var EarcutNode = (function () {
        function EarcutNode(i, x, y) {
            this.i = null;
            this.x = null;
            this.y = null;
            this.prev = null;
            this.next = null;
            this.z = null;
            this.prevZ = null;
            this.nextZ = null;
            this.steiner = null;
            this.i = i;
            this.x = x;
            this.y = y;
            this.prev = null;
            this.next = null;
            this.z = null;
            this.prevZ = null;
            this.nextZ = null;
            this.steiner = false;
        }
        __class(EarcutNode, 'laya.webgl.shapes.EarcutNode');
        return EarcutNode;
    })();
    var GeometryData = (function () {
        function GeometryData(lineWidth, lineColor, lineAlpha, fillColor, fillAlpha, fill, shape) {
            this.lineWidth = lineWidth;
            this.lineColor = lineColor;
            this.lineAlpha = lineAlpha;
            this.fillColor = fillColor;
            this.fillAlpha = fillAlpha;
            this.shape = shape;
            this.fill = fill;
        }
        __class(GeometryData, 'laya.webgl.shapes.GeometryData');
        var __proto = GeometryData.prototype;
        __proto.clone = function () {
            return new GeometryData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.fill, this.shape);
        };
        __proto.getIndexData = function () {
            return null;
        };
        __proto.getVertexData = function () {
            return null;
        };
        __proto.destroy = function () {
            this.shape = null;
        };
        return GeometryData;
    })();
    var Vertex = (function () {
        function Vertex(p) {
            if ((p instanceof Float32Array))
                this.points = p;
            else if ((p instanceof Array)) {
                var len = p.length;
                this.points = new Float32Array(p);
            }
        }
        __class(Vertex, 'laya.webgl.shapes.Vertex');
        var __proto = Vertex.prototype;
        Laya.imps(__proto, { "laya.webgl.shapes.IShape": true });
        __proto.getData = function (ib, vb, start) { };
        __proto.needUpdate = function (mat) {
            return false;
        };
        __proto.rebuild = function (points) { };
        __proto.setMatrix = function (mat) { };
        return Vertex;
    })();
    var Submit = (function () {
        function Submit(renderType) {
            (renderType === void 0) && (renderType = 10000);
            this._renderType = renderType;
        }
        __class(Submit, 'laya.webgl.submit.Submit');
        var __proto = Submit.prototype;
        Laya.imps(__proto, { "laya.webgl.submit.ISubmit": true });
        __proto.releaseRender = function () {
            var cache = Submit._cache;
            cache[cache._length++] = this;
            this.shaderValue.release();
            this._vb = null;
        };
        __proto.getRenderType = function () {
            return this._renderType;
        };
        __proto.renderSubmit = function () {
            if (this._numEle === 0)
                return 1;
            var _tex = this.shaderValue.textureHost;
            if (_tex) {
                var source = _tex.source;
                if (!_tex.bitmap || !source)
                    return 1;
                this.shaderValue.texture = source;
            }
            this._vb.bind_upload(this._ib);
            var gl = WebGL.mainContext;
            this.shaderValue.upload();
            if (BlendMode.activeBlendFunction !== this._blendFn) {
                gl.enable(0x0BE2);
                this._blendFn(gl);
                BlendMode.activeBlendFunction = this._blendFn;
            }
            Stat.drawCall++;
            Stat.trianglesFaces += this._numEle / 3;
            gl.drawElements(0x0004, this._numEle, 0x1403, this._startIdx);
            return 1;
        };
        Submit.__init__ = function () {
            var s = Submit.RENDERBASE = new Submit(-1);
            s.shaderValue = new Value2D(0, 0);
            s.shaderValue.ALPHA = -1234;
        };
        Submit.createSubmit = function (context, ib, vb, pos, sv) {
            var o = Submit._cache._length ? Submit._cache[--Submit._cache._length] : new Submit();
            if (vb == null) {
                vb = o._selfVb || (o._selfVb = VertexBuffer2D.create(-1));
                vb.clear();
                pos = 0;
            }
            o._ib = ib;
            o._vb = vb;
            o._startIdx = pos * CONST3D2D.BYTES_PIDX;
            o._numEle = 0;
            var blendType = context._nBlendType;
            o._blendFn = context._targets ? BlendMode.targetFns[blendType] : BlendMode.fns[blendType];
            o.shaderValue = sv;
            o.shaderValue.setValue(context._shader2D);
            var filters = context._shader2D.filters;
            filters && o.shaderValue.setFilters(filters);
            return o;
        };
        Submit.createShape = function (ctx, ib, vb, numEle, offset, sv) {
            var o = (!Submit._cache._length) ? (new Submit()) : Submit._cache[--Submit._cache._length];
            o._ib = ib;
            o._vb = vb;
            o._numEle = numEle;
            o._startIdx = offset;
            o.shaderValue = sv;
            o.shaderValue.setValue(ctx._shader2D);
            var blendType = ctx._nBlendType;
            o._blendFn = ctx._targets ? BlendMode.targetFns[blendType] : BlendMode.fns[blendType];
            return o;
        };
        Submit.TYPE_2D = 10000;
        Submit.TYPE_CANVAS = 10003;
        Submit.TYPE_CMDSETRT = 10004;
        Submit.TYPE_CUSTOM = 10005;
        Submit.TYPE_BLURRT = 10006;
        Submit.TYPE_CMDDESTORYPRERT = 10007;
        Submit.TYPE_DISABLESTENCIL = 10008;
        Submit.TYPE_OTHERIBVB = 10009;
        Submit.TYPE_PRIMITIVE = 10010;
        Submit.TYPE_RT = 10011;
        Submit.TYPE_BLUR_RT = 10012;
        Submit.TYPE_TARGET = 10013;
        Submit.TYPE_CHANGE_VALUE = 10014;
        Submit.TYPE_SHAPE = 10015;
        Submit.TYPE_TEXTURE = 10016;
        Submit.TYPE_FILLTEXTURE = 10017;
        Submit.RENDERBASE = null;
        Submit._cache = (Submit._cache = [], Submit._cache._length = 0, Submit._cache);
        return Submit;
    })();
    var SubmitCMD = (function () {
        function SubmitCMD() {
            this.fun = null;
            this.args = null;
        }
        __class(SubmitCMD, 'laya.webgl.submit.SubmitCMD');
        var __proto = SubmitCMD.prototype;
        Laya.imps(__proto, { "laya.webgl.submit.ISubmit": true });
        __proto.renderSubmit = function () {
            this.fun.apply(null, this.args);
            return 1;
        };
        __proto.getRenderType = function () {
            return 0;
        };
        __proto.releaseRender = function () {
            var cache = SubmitCMD._cache;
            cache[cache._length++] = this;
        };
        SubmitCMD.create = function (args, fun) {
            var o = SubmitCMD._cache._length ? SubmitCMD._cache[--SubmitCMD._cache._length] : new SubmitCMD();
            o.fun = fun;
            o.args = args;
            return o;
        };
        SubmitCMD._cache = (SubmitCMD._cache = [], SubmitCMD._cache._length = 0, SubmitCMD._cache);
        return SubmitCMD;
    })();
    var SubmitCMDScope = (function () {
        function SubmitCMDScope() {
            this.variables = {};
        }
        __class(SubmitCMDScope, 'laya.webgl.submit.SubmitCMDScope');
        var __proto = SubmitCMDScope.prototype;
        __proto.getValue = function (name) {
            return this.variables[name];
        };
        __proto.addValue = function (name, value) {
            return this.variables[name] = value;
        };
        __proto.setValue = function (name, value) {
            if (this.variables.hasOwnProperty(name)) {
                return this.variables[name] = value;
            }
            return null;
        };
        __proto.clear = function () {
            for (var key in this.variables) {
                delete this.variables[key];
            }
        };
        __proto.recycle = function () {
            this.clear();
            SubmitCMDScope.POOL.push(this);
        };
        SubmitCMDScope.create = function () {
            var scope = SubmitCMDScope.POOL.pop();
            scope || (scope = new SubmitCMDScope());
            return scope;
        };
        SubmitCMDScope.POOL = [];
        return SubmitCMDScope;
    })();
    var SubmitOtherIBVB = (function () {
        function SubmitOtherIBVB() {
            this.offset = 0;
            this.startIndex = 0;
            ;
            this._mat = Matrix.create();
        }
        __class(SubmitOtherIBVB, 'laya.webgl.submit.SubmitOtherIBVB');
        var __proto = SubmitOtherIBVB.prototype;
        Laya.imps(__proto, { "laya.webgl.submit.ISubmit": true });
        __proto.releaseRender = function () {
            var cache = SubmitOtherIBVB._cache;
            cache[cache._length++] = this;
        };
        __proto.getRenderType = function () {
            return 10009;
        };
        __proto.renderSubmit = function () {
            var _tex = this._shaderValue.textureHost;
            if (_tex) {
                var source = _tex.source;
                if (!_tex.bitmap || !source)
                    return 1;
                this._shaderValue.texture = source;
            }
            this._vb.bind_upload(this._ib);
            var w = RenderState2D.worldMatrix4;
            var wmat = Matrix.TEMP;
            Matrix.mulPre(this._mat, w[0], w[1], w[4], w[5], w[12], w[13], wmat);
            var tmp = RenderState2D.worldMatrix4 = SubmitOtherIBVB.tempMatrix4;
            tmp[0] = wmat.a;
            tmp[1] = wmat.b;
            tmp[4] = wmat.c;
            tmp[5] = wmat.d;
            tmp[12] = wmat.tx;
            tmp[13] = wmat.ty;
            this._shader._offset = this.offset;
            this._shaderValue.refresh();
            this._shader.upload(this._shaderValue);
            this._shader._offset = 0;
            var gl = WebGL.mainContext;
            if (BlendMode.activeBlendFunction !== this._blendFn) {
                gl.enable(0x0BE2);
                this._blendFn(gl);
                BlendMode.activeBlendFunction = this._blendFn;
            }
            Stat.drawCall++;
            Stat.trianglesFaces += this._numEle / 3;
            gl.drawElements(0x0004, this._numEle, 0x1403, this.startIndex);
            RenderState2D.worldMatrix4 = w;
            BaseShader.activeShader = null;
            return 1;
        };
        SubmitOtherIBVB.create = function (context, vb, ib, numElement, shader, shaderValue, startIndex, offset, type) {
            (type === void 0) && (type = 0);
            var o = (!SubmitOtherIBVB._cache._length) ? (new SubmitOtherIBVB()) : SubmitOtherIBVB._cache[--SubmitOtherIBVB._cache._length];
            o._ib = ib;
            o._vb = vb;
            o._numEle = numElement;
            o._shader = shader;
            o._shaderValue = shaderValue;
            var blendType = context._nBlendType;
            o._blendFn = context._targets ? BlendMode.targetFns[blendType] : BlendMode.fns[blendType];
            switch (type) {
                case 0:
                    o.offset = 0;
                    o.startIndex = offset / (CONST3D2D.BYTES_PE * vb.vertexStride) * 1.5;
                    o.startIndex *= CONST3D2D.BYTES_PIDX;
                    break;
                case 1:
                    o.startIndex = startIndex;
                    o.offset = offset;
                    break;
            }
            return o;
        };
        SubmitOtherIBVB._cache = (SubmitOtherIBVB._cache = [], SubmitOtherIBVB._cache._length = 0, SubmitOtherIBVB._cache);
        SubmitOtherIBVB.tempMatrix4 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,];
        return SubmitOtherIBVB;
    })();
    var SubmitScissor = (function () {
        function SubmitScissor() {
            this.submitIndex = 0;
            this.submitLength = 0;
            this.context = null;
            this.clipRect = new Rectangle();
            this.screenRect = new Rectangle();
        }
        __class(SubmitScissor, 'laya.webgl.submit.SubmitScissor');
        var __proto = SubmitScissor.prototype;
        Laya.imps(__proto, { "laya.webgl.submit.ISubmit": true });
        __proto._scissor = function (x, y, w, h) {
            var m = RenderState2D.worldMatrix4;
            var a = m[0], d = m[5], tx = m[12], ty = m[13];
            x = x * a + tx;
            y = y * d + ty;
            w *= a;
            h *= d;
            if (w < 1 || h < 1) {
                return false;
            }
            ;
            var r = x + w;
            var b = y + h;
            x < 0 && (x = 0, w = r - x);
            y < 0 && (y = 0, h = b - y);
            var screen = RenderState2D.worldClipRect;
            x = Math.max(x, screen.x);
            y = Math.max(y, screen.y);
            w = Math.min(r, screen.right) - x;
            h = Math.min(b, screen.bottom) - y;
            if (w < 1 || h < 1) {
                return false;
            }
            ;
            var worldScissorTest = RenderState2D.worldScissorTest;
            this.screenRect.copyFrom(screen);
            screen.x = x;
            screen.y = y;
            screen.width = w;
            screen.height = h;
            RenderState2D.worldScissorTest = true;
            y = RenderState2D.height - y - h;
            WebGL.mainContext.scissor(x, y, w, h);
            WebGL.mainContext.enable(0x0C11);
            this.context.submitElement(this.submitIndex, this.submitIndex + this.submitLength);
            if (worldScissorTest) {
                y = RenderState2D.height - this.screenRect.y - this.screenRect.height;
                WebGL.mainContext.scissor(this.screenRect.x, y, this.screenRect.width, this.screenRect.height);
                WebGL.mainContext.enable(0x0C11);
            }
            else {
                WebGL.mainContext.disable(0x0C11);
                RenderState2D.worldScissorTest = false;
            }
            screen.copyFrom(this.screenRect);
            return true;
        };
        __proto._scissorWithTagart = function (x, y, w, h) {
            if (w < 1 || h < 1) {
                return false;
            }
            ;
            var r = x + w;
            var b = y + h;
            x < 0 && (x = 0, w = r - x);
            y < 0 && (y = 0, h = b - y);
            var screen = RenderState2D.worldClipRect;
            x = Math.max(x, screen.x);
            y = Math.max(y, screen.y);
            w = Math.min(r, screen.right) - x;
            h = Math.min(b, screen.bottom) - y;
            if (w < 1 || h < 1) {
                return false;
            }
            ;
            var worldScissorTest = RenderState2D.worldScissorTest;
            this.screenRect.copyFrom(screen);
            RenderState2D.worldScissorTest = true;
            screen.x = x;
            screen.y = y;
            screen.width = w;
            screen.height = h;
            y = RenderState2D.height - y - h;
            WebGL.mainContext.scissor(x, y, w, h);
            WebGL.mainContext.enable(0x0C11);
            this.context.submitElement(this.submitIndex, this.submitIndex + this.submitLength);
            if (worldScissorTest) {
                y = RenderState2D.height - this.screenRect.y - this.screenRect.height;
                WebGL.mainContext.scissor(this.screenRect.x, y, this.screenRect.width, this.screenRect.height);
                WebGL.mainContext.enable(0x0C11);
            }
            else {
                WebGL.mainContext.disable(0x0C11);
                RenderState2D.worldScissorTest = false;
            }
            screen.copyFrom(this.screenRect);
            return true;
        };
        __proto.renderSubmit = function () {
            this.submitLength = Math.min(this.context._submits._length - 1, this.submitLength);
            if (this.submitLength < 1 || this.clipRect.width < 1 || this.clipRect.height < 1)
                return this.submitLength + 1;
            if (this.context._targets)
                this._scissorWithTagart(this.clipRect.x, this.clipRect.y, this.clipRect.width, this.clipRect.height);
            else
                this._scissor(this.clipRect.x, this.clipRect.y, this.clipRect.width, this.clipRect.height);
            return this.submitLength + 1;
        };
        __proto.getRenderType = function () {
            return 0;
        };
        __proto.releaseRender = function () {
            var cache = SubmitScissor._cache;
            cache[cache._length++] = this;
            this.context = null;
        };
        SubmitScissor.create = function (context) {
            var o = SubmitScissor._cache._length ? SubmitScissor._cache[--SubmitScissor._cache._length] : new SubmitScissor();
            o.context = context;
            return o;
        };
        SubmitScissor._cache = (SubmitScissor._cache = [], SubmitScissor._cache._length = 0, SubmitScissor._cache);
        return SubmitScissor;
    })();
    var SubmitStencil = (function () {
        function SubmitStencil() {
            this.step = 0;
            this.blendMode = null;
            this.level = 0;
        }
        __class(SubmitStencil, 'laya.webgl.submit.SubmitStencil');
        var __proto = SubmitStencil.prototype;
        Laya.imps(__proto, { "laya.webgl.submit.ISubmit": true });
        __proto.renderSubmit = function () {
            switch (this.step) {
                case 1:
                    this.do1();
                    break;
                case 2:
                    this.do2();
                    break;
                case 3:
                    this.do3();
                    break;
                case 4:
                    this.do4();
                    break;
                case 5:
                    this.do5();
                    break;
                case 6:
                    this.do6();
                    break;
                case 7:
                    this.do7();
                    break;
                case 8:
                    this.do8();
                    break;
            }
            return 1;
        };
        __proto.getRenderType = function () {
            return 0;
        };
        __proto.releaseRender = function () {
            var cache = SubmitStencil._cache;
            cache[cache._length++] = this;
        };
        __proto.do1 = function () {
            var gl = WebGL.mainContext;
            gl.enable(0x0B90);
            gl.clear(0x00000400);
            gl.colorMask(false, false, false, false);
            gl.stencilFunc(0x0202, this.level, 0xFF);
            gl.stencilOp(0x1E00, 0x1E00, 0x1E02);
        };
        __proto.do2 = function () {
            var gl = WebGL.mainContext;
            gl.stencilFunc(0x0202, this.level + 1, 0xFF);
            gl.colorMask(true, true, true, true);
            gl.stencilOp(0x1E00, 0x1E00, 0x1E00);
        };
        __proto.do3 = function () {
            var gl = WebGL.mainContext;
            gl.colorMask(true, true, true, true);
            gl.stencilOp(0x1E00, 0x1E00, 0x1E00);
            gl.clear(0x00000400);
            gl.disable(0x0B90);
        };
        __proto.do4 = function () {
            var gl = WebGL.mainContext;
            if (this.level == 0) {
                gl.enable(0x0B90);
                gl.clear(0x00000400);
            }
            gl.colorMask(false, false, false, false);
            gl.stencilFunc(0x0207, 0, 0xFF);
            gl.stencilOp(0x1E00, 0x1E00, 0x1E02);
        };
        __proto.do5 = function () {
            var gl = WebGL.mainContext;
            gl.stencilFunc(0x0202, this.level, 0xFF);
            gl.colorMask(true, true, true, true);
            gl.stencilOp(0x1E00, 0x1E00, 0x1E00);
        };
        __proto.do6 = function () {
            var gl = WebGL.mainContext;
            BlendMode.targetFns[BlendMode.TOINT[this.blendMode]](gl);
        };
        __proto.do7 = function () {
            var gl = WebGL.mainContext;
            gl.colorMask(false, false, false, false);
            gl.stencilOp(0x1E00, 0x1E00, 0x1E03);
        };
        __proto.do8 = function () {
            var gl = WebGL.mainContext;
            gl.colorMask(true, true, true, true);
            gl.stencilFunc(0x0202, this.level, 0xFF);
            gl.stencilOp(0x1E00, 0x1E00, 0x1E00);
        };
        SubmitStencil.restore = function (context, clip, m, _x, _y) {
            var submitStencil;
            context._renderKey = 0;
            if (SubmitStencil._mask > 0) {
                SubmitStencil._mask--;
            }
            if (SubmitStencil._mask == 0) {
                submitStencil = laya.webgl.submit.SubmitStencil.create(3);
                context.addRenderObject(submitStencil);
                context._curSubmit = Submit.RENDERBASE;
            }
            else {
                submitStencil = laya.webgl.submit.SubmitStencil.create(7);
                context.addRenderObject(submitStencil);
                var vb = context._vb;
                var nPos = (vb._byteLength >> 2);
                if (GlUtils.fillRectImgVb(vb, null, clip.x, clip.y, clip.width, clip.height, Texture.DEF_UV, m, _x, _y, 0, 0)) {
                    var shader = context._shader2D;
                    shader.glTexture = null;
                    var submit = context._curSubmit = Submit.createSubmit(context, context._ib, vb, ((vb._byteLength - 16 * 4) / 32) * 3, Value2D.create(0x02, 0));
                    submit.shaderValue.ALPHA = 1.0;
                    context._submits[context._submits._length++] = submit;
                    context._curSubmit._numEle += 6;
                    context._curSubmit = Submit.RENDERBASE;
                }
                else {
                    alert("clipRect calc stencil rect error");
                }
                submitStencil = laya.webgl.submit.SubmitStencil.create(8);
                context.addRenderObject(submitStencil);
            }
        };
        SubmitStencil.restore2 = function (context, submit) {
            var submitStencil;
            context._renderKey = 0;
            if (SubmitStencil._mask > 0) {
                SubmitStencil._mask--;
            }
            if (SubmitStencil._mask == 0) {
                submitStencil = laya.webgl.submit.SubmitStencil.create(3);
                context.addRenderObject(submitStencil);
                context._curSubmit = Submit.RENDERBASE;
            }
            else {
                submitStencil = laya.webgl.submit.SubmitStencil.create(7);
                context.addRenderObject(submitStencil);
                context._submits[context._submits._length++] = submit;
                submitStencil = laya.webgl.submit.SubmitStencil.create(8);
                context.addRenderObject(submitStencil);
            }
        };
        SubmitStencil.create = function (step) {
            var o = SubmitStencil._cache._length ? SubmitStencil._cache[--SubmitStencil._cache._length] : new SubmitStencil();
            o.step = step;
            if (step == 5)
                ++SubmitStencil._mask;
            o.level = SubmitStencil._mask;
            return o;
        };
        SubmitStencil._cache = (SubmitStencil._cache = [], SubmitStencil._cache._length = 0, SubmitStencil._cache);
        SubmitStencil._mask = 0;
        return SubmitStencil;
    })();
    var SubmitTarget = (function () {
        function SubmitTarget() {
            this._renderType = 0;
            this._vb = null;
            this._ib = null;
            this._startIdx = 0;
            this._numEle = 0;
            this.shaderValue = null;
            this.blendType = 0;
            this.proName = null;
            this.scope = null;
        }
        __class(SubmitTarget, 'laya.webgl.submit.SubmitTarget');
        var __proto = SubmitTarget.prototype;
        Laya.imps(__proto, { "laya.webgl.submit.ISubmit": true });
        __proto.renderSubmit = function () {
            this._vb.bind_upload(this._ib);
            var target = this.scope.getValue(this.proName);
            if (target) {
                this.shaderValue.texture = target.source;
                if (this.shaderValue["strength"] && !this.shaderValue["blurInfo"]) {
                    this.shaderValue["blurInfo"] = [target.width, target.height];
                }
                this.shaderValue.upload();
                this.blend();
                Stat.drawCall++;
                Stat.trianglesFaces += this._numEle / 3;
                WebGL.mainContext.drawElements(0x0004, this._numEle, 0x1403, this._startIdx);
            }
            return 1;
        };
        __proto.blend = function () {
            if (BlendMode.activeBlendFunction !== BlendMode.fns[this.blendType]) {
                var gl = WebGL.mainContext;
                gl.enable(0x0BE2);
                BlendMode.fns[this.blendType](gl);
                BlendMode.activeBlendFunction = BlendMode.fns[this.blendType];
            }
        };
        __proto.getRenderType = function () {
            return 0;
        };
        __proto.releaseRender = function () {
            var cache = SubmitTarget._cache;
            cache[cache._length++] = this;
        };
        SubmitTarget.create = function (context, ib, vb, pos, sv, proName) {
            var o = SubmitTarget._cache._length ? SubmitTarget._cache[--SubmitTarget._cache._length] : new SubmitTarget();
            o._ib = ib;
            o._vb = vb;
            o.proName = proName;
            o._startIdx = pos * CONST3D2D.BYTES_PIDX;
            o._numEle = 0;
            o.blendType = context._nBlendType;
            o.shaderValue = sv;
            o.shaderValue.setValue(context._shader2D);
            return o;
        };
        SubmitTarget._cache = (SubmitTarget._cache = [], SubmitTarget._cache._length = 0, SubmitTarget._cache);
        return SubmitTarget;
    })();
    var CharSegment = (function () {
        function CharSegment() {
            this._sourceStr = null;
        }
        __class(CharSegment, 'laya.webgl.text.CharSegment');
        var __proto = CharSegment.prototype;
        Laya.imps(__proto, { "laya.webgl.text.ICharSegment": true });
        __proto.textToSpit = function (str) {
            this._sourceStr = str;
        };
        __proto.getChar = function (i) {
            return this._sourceStr.charAt(i);
        };
        __proto.getCharCode = function (i) {
            return this._sourceStr.charCodeAt(i);
        };
        __proto.length = function () {
            return this._sourceStr.length;
        };
        return CharSegment;
    })();
    var DrawText = (function () {
        var CharValue;
        function DrawText() { }
        __class(DrawText, 'laya.webgl.text.DrawText');
        DrawText.__init__ = function () {
            DrawText._charsTemp = new Array;
            DrawText._drawValue = new CharValue();
            DrawText._charSeg = new CharSegment();
        };
        DrawText.customCharSeg = function (charseg) {
            DrawText._charSeg = charseg;
        };
        DrawText.getChar = function (char, id, drawValue) {
            var result = WebGLCharImage.createOneChar(char, drawValue);
            if (id != -1)
                DrawText._charsCache[id] = result;
            return result;
        };
        DrawText._drawSlow = function (save, ctx, txt, words, curMat, font, textAlign, fillColor, borderColor, lineWidth, x, y, sx, sy, underLine) {
            var drawValue = DrawText._drawValue.value(font, fillColor, borderColor, lineWidth, sx, sy, underLine);
            var i = 0, n = 0;
            var chars = DrawText._charsTemp;
            var width = 0, oneChar, htmlWord, id = NaN;
            var isWordText = txt instanceof laya.utils.WordText;
            var txtLetterSpacing = isWordText ? txt._letterSpacing : 0;
            if (words) {
                chars.length = words.length;
                for (i = 0, n = words.length; i < n; i++) {
                    htmlWord = words[i];
                    id = htmlWord.charNum + drawValue.txtID;
                    chars[i] = oneChar = DrawText._charsCache[id] || DrawText.getChar(htmlWord.char, id, drawValue);
                    oneChar.active();
                }
            }
            else {
                var text = isWordText ? txt.toString() : txt;
                if (Text.CharacterCache) {
                    DrawText._charSeg.textToSpit(text);
                    var len = DrawText._charSeg.length();
                    chars.length = len;
                    for (i = 0, n = len; i < n; i++) {
                        id = DrawText._charSeg.getCharCode(i) + drawValue.txtID;
                        chars[i] = oneChar = DrawText._charsCache[id] || DrawText.getChar(DrawText._charSeg.getChar(i), id, drawValue);
                        oneChar.active();
                        width += oneChar.cw;
                    }
                }
                else {
                    chars.length = 0;
                    oneChar = DrawText.getChar(text, -1, drawValue);
                    oneChar.active();
                    width += oneChar.cw;
                    chars[0] = oneChar;
                }
            }
            ;
            var dx = 0;
            if (textAlign !== null && textAlign !== "left")
                dx = -(textAlign == "center" ? (width / 2) : width);
            var uv, bdSz = NaN, texture, value, saveLength = 0;
            if (words) {
                for (i = 0, n = chars.length; i < n; i++) {
                    oneChar = chars[i];
                    if (!oneChar.isSpace) {
                        htmlWord = words[i];
                        bdSz = oneChar.borderSize;
                        texture = oneChar.texture;
                        ctx._drawText(texture, x + dx + htmlWord.x * sx - bdSz, y + htmlWord.y * sy - bdSz, texture.width, texture.height, curMat, 0, 0, 0, 0);
                    }
                }
            }
            else {
                for (i = 0, n = chars.length; i < n; i++) {
                    oneChar = chars[i];
                    if (!oneChar.isSpace) {
                        bdSz = oneChar.borderSize;
                        texture = oneChar.texture;
                        var toX = dx - bdSz + i * txtLetterSpacing
                        ctx._drawText(texture, x + toX, y - bdSz, texture.width, texture.height, curMat, 0, 0, 0, 0);
                        save && (value = save[saveLength++], value || (value = save[saveLength - 1] = []), value[0] = texture, value[1] = toX, value[2] = -bdSz);
                    }
                    dx += oneChar.cw;
                }
                save && (save.length = saveLength);
            }
        };
        DrawText._drawFast = function (save, ctx, curMat, x, y) {
            var texture, value;
            for (var i = 0, n = save.length; i < n; i++) {
                value = save[i];
                texture = value[0];
                texture.active();
                ctx._drawText(texture, x + value[1], y + value[2], texture.width, texture.height, curMat, 0, 0, 0, 0);
            }
        };
        DrawText.drawText = function (ctx, txt, words, curMat, font, textAlign, fillColor, borderColor, lineWidth, x, y, underLine) {
            (underLine === void 0) && (underLine = 0);
            if ((txt && txt.length === 0) || (words && words.length === 0))
                return;
            var sx = curMat.a, sy = curMat.d;
            (curMat.b !== 0 || curMat.c !== 0) && (sx = sy = 1);
            var scale = sx !== 1 || sy !== 1;
            if (scale && Laya.stage.transform) {
                var t = Laya.stage.transform;
                scale = t.a === sx && t.d === sy;
            }
            else
                scale = false;
            if (scale) {
                curMat = curMat.copyTo(WebGLContext2D._tmpMatrix);
                var tempTx = curMat.tx;
                var tempTy = curMat.ty;
                curMat.scale(1 / sx, 1 / sy);
                curMat._checkTransform();
                x *= sx;
                y *= sy;
                x += tempTx - curMat.tx;
                y += tempTy - curMat.ty;
            }
            else
                sx = sy = 1;
            if (words) {
                DrawText._drawSlow(null, ctx, txt, words, curMat, font, textAlign, fillColor, borderColor, lineWidth, x, y, sx, sy, underLine);
            }
            else {
                if (txt.toUpperCase === null) {
                    var idNum = sx + sy * 100000;
                    var myCache = txt;
                    if (!myCache.changed && myCache.id === idNum) {
                        DrawText._drawFast(myCache.save, ctx, curMat, x, y);
                    }
                    else {
                        myCache.id = idNum;
                        myCache.changed = false;
                        DrawText._drawSlow(myCache.save, ctx, txt, words, curMat, font, textAlign, fillColor, borderColor, lineWidth, x, y, sx, sy, underLine);
                    }
                    return;
                }
                ;
                var id = txt + font.toString() + fillColor + borderColor + lineWidth + sx + sy + textAlign;
                var cache = DrawText._textsCache[id];
                if (Text.CharacterCache) {
                    if (cache) {
                        DrawText._drawFast(cache, ctx, curMat, x, y);
                    }
                    else {
                        DrawText._textsCache.__length || (DrawText._textsCache.__length = 0);
                        if (DrawText._textsCache.__length > Config.WebGLTextCacheCount) {
                            DrawText._textsCache = {};
                            DrawText._textsCache.__length = 0;
                            DrawText._curPoolIndex = 0;
                        }
                        DrawText._textCachesPool[DrawText._curPoolIndex] ? (cache = DrawText._textsCache[id] = DrawText._textCachesPool[DrawText._curPoolIndex], cache.length = 0) : (DrawText._textCachesPool[DrawText._curPoolIndex] = cache = DrawText._textsCache[id] = []);
                        DrawText._textsCache.__length++;
                        DrawText._curPoolIndex++;
                        DrawText._drawSlow(cache, ctx, txt, words, curMat, font, textAlign, fillColor, borderColor, lineWidth, x, y, sx, sy, underLine);
                    }
                }
                else {
                    DrawText._drawSlow(cache, ctx, txt, words, curMat, font, textAlign, fillColor, borderColor, lineWidth, x, y, sx, sy, underLine);
                }
            }
        };
        DrawText._charsTemp = null;
        DrawText._textCachesPool = [];
        DrawText._curPoolIndex = 0;
        DrawText._charsCache = {};
        DrawText._textsCache = {};
        DrawText._drawValue = null;
        DrawText.d = [];
        DrawText._charSeg = null;
        DrawText.__init$ = function () {
            CharValue = (function () {
                function CharValue() {
                }
                __class(CharValue, '');
                var __proto = CharValue.prototype;
                __proto.value = function (font, fillColor, borderColor, lineWidth, scaleX, scaleY, underLine) {
                    this.font = font;
                    this.fillColor = fillColor;
                    this.borderColor = borderColor;
                    this.lineWidth = lineWidth;
                    this.scaleX = scaleX;
                    this.scaleY = scaleY;
                    this.underLine = underLine;
                    var key = font.toString() + scaleX + scaleY + lineWidth + fillColor + borderColor + underLine;
                    this.txtID = CharValue._keymap[key];
                    if (!this.txtID) {
                        this.txtID = (++CharValue._keymapCount) * 0.0000001;
                        CharValue._keymap[key] = this.txtID;
                    }
                    return this;
                };
                CharValue.clear = function () {
                    CharValue._keymap = {};
                    CharValue._keymapCount = 1;
                };
                CharValue._keymap = {};
                CharValue._keymapCount = 1;
                return CharValue;
            })();
        };
        return DrawText;
    })();
    var FontInContext = (function () {
        function FontInContext(font) {
            this._index = 0;
            this._size = 14;
            this._italic = -2;
            FontInContext._cache2 = FontInContext._cache2 || [];
            this.setFont(font || "14px Arial");
        }
        __class(FontInContext, 'laya.webgl.text.FontInContext');
        var __proto = FontInContext.prototype;
        __proto.setFont = function (value) {
            var arr = FontInContext._cache2[value];
            if (!arr) {
                this._words = value.split(' ');
                for (var i = 0, n = this._words.length; i < n; i++) {
                    if (this._words[i].indexOf('px') > 0) {
                        this._index = i;
                        break;
                    }
                }
                this._size = parseInt(this._words[this._index]);
                FontInContext._cache2[value] = [this._words, this._size];
            }
            else {
                this._words = arr[0];
                this._size = arr[1];
            }
            this._text = null;
            this._italic = -2;
        };
        __proto.getItalic = function () {
            this._italic === -2 && (this._italic = this.hasType("italic"));
            return this._italic;
        };
        __proto.hasType = function (name) {
            for (var i = 0, n = this._words.length; i < n; i++)
                if (this._words[i] === name)
                    return i;
            return -1;
        };
        __proto.removeType = function (name) {
            for (var i = 0, n = this._words.length; i < n; i++)
                if (this._words[i] === name) {
                    this._words.splice(i, 1);
                    if (this._index > i)
                        this._index--;
                    break;
                }
            this._text = null;
            this._italic = -2;
        };
        __proto.copyTo = function (dec) {
            dec._text = this._text;
            dec._size = this._size;
            dec._index = this._index;
            dec._words = this._words.slice();
            dec._italic = -2;
            return dec;
        };
        __proto.toString = function () {
            return this._text ? this._text : (this._text = this._words.join(' '));
        };
        __getset(0, __proto, 'size', function () {
            return this._size;
        }, function (value) {
            this._size = value;
            this._words[this._index] = value + "px";
            this._text = null;
        });
        FontInContext.create = function (font) {
            var r = FontInContext._cache[font];
            if (r)
                return r;
            r = FontInContext._cache[font] = new FontInContext(font);
            return r;
        };
        FontInContext.EMPTY = new FontInContext();
        FontInContext._cache = {};
        FontInContext._cache2 = null;
        return FontInContext;
    })();
    var CONST3D2D = (function () {
        function CONST3D2D() { }
        __class(CONST3D2D, 'laya.webgl.utils.CONST3D2D');
        CONST3D2D.defaultMatrix4 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        CONST3D2D.defaultMinusYMatrix4 = [1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        CONST3D2D.uniformMatrix3 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0];
        CONST3D2D._TMPARRAY = [];
        CONST3D2D._OFFSETX = 0;
        CONST3D2D._OFFSETY = 0;
        __static(CONST3D2D, ['BYTES_PE', function () { return this.BYTES_PE = Float32Array.BYTES_PER_ELEMENT; }, 'BYTES_PIDX', function () { return this.BYTES_PIDX = Uint16Array.BYTES_PER_ELEMENT; }
        ]);
        return CONST3D2D;
    })();
    var GlUtils = (function () {
        function GlUtils() { }
        __class(GlUtils, 'laya.webgl.utils.GlUtils');
        GlUtils.make2DProjection = function (width, height, depth) {
            return [2.0 / width, 0, 0, 0, 0, -2.0 / height, 0, 0, 0, 0, 2.0 / depth, 0, -1, 1, 0, 1,];
        };
        GlUtils.fillIBQuadrangle = function (buffer, count) {
            if (count > 65535 / 4) {
                throw Error("IBQuadrangle count:" + count + " must<:" + Math.floor(65535 / 4));
                return false;
            }
            count = Math.floor(count);
            buffer._resizeBuffer((count + 1) * 6 * 2, false);
            buffer.byteLength = buffer.bufferLength;
            var bufferData = buffer.getUint16Array();
            var idx = 0;
            for (var i = 0; i < count; i++) {
                bufferData[idx++] = i * 4;
                bufferData[idx++] = i * 4 + 2;
                bufferData[idx++] = i * 4 + 1;
                bufferData[idx++] = i * 4;
                bufferData[idx++] = i * 4 + 3;
                bufferData[idx++] = i * 4 + 2;
            }
            buffer.setNeedUpload();
            return true;
        };
        GlUtils.expandIBQuadrangle = function (buffer, count) {
            buffer.bufferLength >= (count * 6 * 2) || GlUtils.fillIBQuadrangle(buffer, count);
        };
        GlUtils.mathCeilPowerOfTwo = function (value) {
            value--;
            value |= value >> 1;
            value |= value >> 2;
            value |= value >> 4;
            value |= value >> 8;
            value |= value >> 16;
            value++;
            return value;
        };
        GlUtils.fillQuadrangleImgVb = function (vb, x, y, point4, uv, m, _x, _y) {
            'use strict';
            var vpos = (vb._byteLength >> 2) + 16;
            vb.byteLength = (vpos << 2);
            var vbdata = vb.getFloat32Array();
            vpos -= 16;
            vbdata[vpos + 2] = uv[0];
            vbdata[vpos + 3] = uv[1];
            vbdata[vpos + 6] = uv[2];
            vbdata[vpos + 7] = uv[3];
            vbdata[vpos + 10] = uv[4];
            vbdata[vpos + 11] = uv[5];
            vbdata[vpos + 14] = uv[6];
            vbdata[vpos + 15] = uv[7];
            var a = m.a, b = m.b, c = m.c, d = m.d;
            if (a !== 1 || b !== 0 || c !== 0 || d !== 1) {
                m.bTransform = true;
                var tx = m.tx + _x, ty = m.ty + _y;
                vbdata[vpos] = (point4[0] + x) * a + (point4[1] + y) * c + tx;
                vbdata[vpos + 1] = (point4[0] + x) * b + (point4[1] + y) * d + ty;
                vbdata[vpos + 4] = (point4[2] + x) * a + (point4[3] + y) * c + tx;
                vbdata[vpos + 5] = (point4[2] + x) * b + (point4[3] + y) * d + ty;
                vbdata[vpos + 8] = (point4[4] + x) * a + (point4[5] + y) * c + tx;
                vbdata[vpos + 9] = (point4[4] + x) * b + (point4[5] + y) * d + ty;
                vbdata[vpos + 12] = (point4[6] + x) * a + (point4[7] + y) * c + tx;
                vbdata[vpos + 13] = (point4[6] + x) * b + (point4[7] + y) * d + ty;
            }
            else {
                m.bTransform = false;
                x += m.tx + _x;
                y += m.ty + _y;
                vbdata[vpos] = x + point4[0];
                vbdata[vpos + 1] = y + point4[1];
                vbdata[vpos + 4] = x + point4[2];
                vbdata[vpos + 5] = y + point4[3];
                vbdata[vpos + 8] = x + point4[4];
                vbdata[vpos + 9] = y + point4[5];
                vbdata[vpos + 12] = x + point4[6];
                vbdata[vpos + 13] = y + point4[7];
            }
            vb._upload = true;
            return true;
        };
        GlUtils.fillTranglesVB = function (vb, x, y, points, m, _x, _y) {
            var vpos = (vb._byteLength >> 2) + points.length;
            vb.byteLength = (vpos << 2);
            var vbdata = vb.getFloat32Array();
            vpos -= points.length;
            var len = points.length;
            var a = m.a, b = m.b, c = m.c, d = m.d;
            for (var i = 0; i < len; i += 4) {
                vbdata[vpos + i + 2] = points[i + 2];
                vbdata[vpos + i + 3] = points[i + 3];
                if (a !== 1 || b !== 0 || c !== 0 || d !== 1) {
                    m.bTransform = true;
                    var tx = m.tx + _x, ty = m.ty + _y;
                    vbdata[vpos + i] = (points[i] + x) * a + (points[i + 1] + y) * c + tx;
                    vbdata[vpos + i + 1] = (points[i] + x) * b + (points[i + 1] + y) * d + ty;
                }
                else {
                    m.bTransform = false;
                    x += m.tx + _x;
                    y += m.ty + _y;
                    vbdata[vpos + i] = x + points[i];
                    vbdata[vpos + i + 1] = y + points[i + 1];
                }
            }
            vb._upload = true;
            return true;
        };
        GlUtils.copyPreImgVb = function (vb, dx, dy) {
            var vpos = (vb._byteLength >> 2);
            vb.byteLength = ((vpos + 16) << 2);
            var vbdata = vb.getFloat32Array();
            for (var i = 0, ci = vpos - 16; i < 4; i++) {
                vbdata[vpos] = vbdata[ci] + dx;
                ++vpos;
                ++ci;
                vbdata[vpos] = vbdata[ci] + dy;
                ++vpos;
                ++ci;
                vbdata[vpos] = vbdata[ci];
                ++vpos;
                ++ci;
                vbdata[vpos] = vbdata[ci];
                ++vpos;
                ++ci;
            }
            vb._upload = true;
        };
        GlUtils.fillRectImgVb = function (vb, clip, x, y, width, height, uv, m, _x, _y, dx, dy, round) {
            (round === void 0) && (round = false);
            var mType = 1;
            var toBx, toBy, toEx, toEy;
            var cBx, cBy, cEx, cEy;
            var w0, h0, tx, ty;
            var finalX, finalY, offsetX, offsetY;
            var a = m.a, b = m.b, c = m.c, d = m.d;
            var useClip = clip && clip.width < 99999999;
            if (a !== 1 || b !== 0 || c !== 0 || d !== 1) {
                m.bTransform = true;
                if (b === 0 && c === 0) {
                    mType = 23;
                    w0 = width + x, h0 = height + y;
                    tx = m.tx + _x, ty = m.ty + _y;
                    toBx = a * x + tx;
                    toEx = a * w0 + tx;
                    toBy = d * y + ty;
                    toEy = d * h0 + ty;
                }
            }
            else {
                mType = 23;
                m.bTransform = false;
                toBx = x + m.tx + _x;
                toEx = toBx + width;
                toBy = y + m.ty + _y;
                toEy = toBy + height;
            }
            if (useClip) {
                cBx = clip.x, cBy = clip.y, cEx = clip.width + cBx, cEy = clip.height + cBy;
            }
            if (mType !== 1) {
                if (Math.min(toBx, toEx) >= cEx)
                    return false;
                if (Math.min(toBy, toEy) >= cEy)
                    return false;
                if (Math.max(toEx, toBx) <= cBx)
                    return false;
                if (Math.max(toEy, toBy) <= cBy)
                    return false;
            }
            ;
            var vpos = (vb._byteLength >> 2);
            vb.byteLength = ((vpos + 16) << 2);
            var vbdata = vb.getFloat32Array();
            vbdata[vpos + 2] = uv[0];
            vbdata[vpos + 3] = uv[1];
            vbdata[vpos + 6] = uv[2];
            vbdata[vpos + 7] = uv[3];
            vbdata[vpos + 10] = uv[4];
            vbdata[vpos + 11] = uv[5];
            vbdata[vpos + 14] = uv[6];
            vbdata[vpos + 15] = uv[7];
            switch (mType) {
                case 1:
                    tx = m.tx + _x, ty = m.ty + _y;
                    w0 = width + x, h0 = height + y;
                    var w1 = x, h1 = y;
                    var aw1 = a * w1, ch1 = c * h1, dh1 = d * h1, bw1 = b * w1;
                    var aw0 = a * w0, ch0 = c * h0, dh0 = d * h0, bw0 = b * w0;
                    if (round) {
                        finalX = aw1 + ch1 + tx;
                        offsetX = Math.round(finalX) - finalX;
                        finalY = dh1 + bw1 + ty;
                        offsetY = Math.round(finalY) - finalY;
                        vbdata[vpos] = finalX + offsetX;
                        vbdata[vpos + 1] = finalY + offsetY;
                        vbdata[vpos + 4] = aw0 + ch1 + tx + offsetX;
                        vbdata[vpos + 5] = dh1 + bw0 + ty + offsetY;
                        vbdata[vpos + 8] = aw0 + ch0 + tx + offsetX;
                        vbdata[vpos + 9] = dh0 + bw0 + ty + offsetY;
                        vbdata[vpos + 12] = aw1 + ch0 + tx + offsetX;
                        vbdata[vpos + 13] = dh0 + bw1 + ty + offsetY;
                    }
                    else {
                        vbdata[vpos] = aw1 + ch1 + tx;
                        vbdata[vpos + 1] = dh1 + bw1 + ty;
                        vbdata[vpos + 4] = aw0 + ch1 + tx;
                        vbdata[vpos + 5] = dh1 + bw0 + ty;
                        vbdata[vpos + 8] = aw0 + ch0 + tx;
                        vbdata[vpos + 9] = dh0 + bw0 + ty;
                        vbdata[vpos + 12] = aw1 + ch0 + tx;
                        vbdata[vpos + 13] = dh0 + bw1 + ty;
                    }
                    break;
                case 23:
                    if (round) {
                        finalX = toBx + dx;
                        offsetX = Math.round(finalX) - finalX;
                        finalY = toBy;
                        offsetY = Math.round(finalY) - finalY;
                        vbdata[vpos] = finalX + offsetX;
                        vbdata[vpos + 1] = finalY + offsetY;
                        vbdata[vpos + 4] = toEx + dx + offsetX;
                        vbdata[vpos + 5] = toBy + offsetY;
                        vbdata[vpos + 8] = toEx + offsetX;
                        vbdata[vpos + 9] = toEy + offsetY;
                        vbdata[vpos + 12] = toBx + offsetX;
                        vbdata[vpos + 13] = toEy + offsetY;
                    }
                    else {
                        vbdata[vpos] = toBx + dx;
                        vbdata[vpos + 1] = toBy;
                        vbdata[vpos + 4] = toEx + dx;
                        vbdata[vpos + 5] = toBy;
                        vbdata[vpos + 8] = toEx;
                        vbdata[vpos + 9] = toEy;
                        vbdata[vpos + 12] = toBx;
                        vbdata[vpos + 13] = toEy;
                    }
                    break;
            }
            vb._upload = true;
            return true;
        };
        GlUtils.fillLineVb = function (vb, clip, fx, fy, tx, ty, width, mat) {
            'use strict';
            var linew = width * .5;
            var data = GlUtils._fillLineArray;
            var perpx = -(fy - ty), perpy = fx - tx;
            var dist = Math.sqrt(perpx * perpx + perpy * perpy);
            perpx /= dist, perpy /= dist, perpx *= linew, perpy *= linew;
            data[0] = fx - perpx, data[1] = fy - perpy, data[4] = fx + perpx, data[5] = fy + perpy, data[8] = tx + perpx, data[9] = ty + perpy, data[12] = tx - perpx, data[13] = ty - perpy;
            mat && mat.transformPointArray(data, data);
            var vpos = (vb._byteLength >> 2) + 16;
            vb.byteLength = (vpos << 2);
            vb.insertData(data, vpos - 16);
            return true;
        };
        GlUtils._fillLineArray = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        return GlUtils;
    })();
    var MatirxArray = (function () {
        function MatirxArray() { }
        __class(MatirxArray, 'laya.webgl.utils.MatirxArray');
        MatirxArray.ArrayMul = function (a, b, o) {
            if (!a) {
                MatirxArray.copyArray(b, o);
                return;
            }
            if (!b) {
                MatirxArray.copyArray(a, o);
                return;
            }
            ;
            var ai0 = NaN, ai1 = NaN, ai2 = NaN, ai3 = NaN;
            for (var i = 0; i < 4; i++) {
                ai0 = a[i];
                ai1 = a[i + 4];
                ai2 = a[i + 8];
                ai3 = a[i + 12];
                o[i] = ai0 * b[0] + ai1 * b[1] + ai2 * b[2] + ai3 * b[3];
                o[i + 4] = ai0 * b[4] + ai1 * b[5] + ai2 * b[6] + ai3 * b[7];
                o[i + 8] = ai0 * b[8] + ai1 * b[9] + ai2 * b[10] + ai3 * b[11];
                o[i + 12] = ai0 * b[12] + ai1 * b[13] + ai2 * b[14] + ai3 * b[15];
            }
        };
        MatirxArray.copyArray = function (f, t) {
            if (!f)
                return;
            if (!t)
                return;
            for (var i = 0; i < f.length; i++) {
                t[i] = f[i];
            }
        };
        return MatirxArray;
    })();
    var Mesh2D = (function () {
        function Mesh2D(stride, vballoc, iballoc) {
            this._stride = 0;
            this.vertNum = 0;
            this.indexNum = 0;
            this._applied = false;
            this._vb = null;
            this._ib = null;
            this._vao = null;
            this._attribInfo = null;
            this._quadNum = 0;
            this.canReuse = false;
            this._stride = stride;
            this._vb = new VertexBuffer2D(stride, 0x88E8);
            if (vballoc) {
                this._vb._resizeBuffer(vballoc, false);
            }
            else { }
            this._ib = new IndexBuffer2D();
            if (iballoc) {
                this._ib._resizeBuffer(iballoc, false);
            }
        }
        __class(Mesh2D, 'laya.webgl.utils.Mesh2D');
        var __proto = Mesh2D.prototype;
        __proto.cloneWithNewVB = function () {
            var mesh = new Mesh2D(this._stride, 0, 0);
            mesh._ib = this._ib;
            mesh._quadNum = this._quadNum;
            mesh._attribInfo = this._attribInfo;
            return mesh;
        };
        __proto.cloneWithNewVBIB = function () {
            var mesh = new Mesh2D(this._stride, 0, 0);
            mesh._attribInfo = this._attribInfo;
            return mesh;
        };
        __proto.getVBW = function () {
            this._vb.setNeedUpload();
            return this._vb;
        };
        __proto.getVBR = function () {
            return this._vb;
        };
        __proto.getIBR = function () {
            return this._ib;
        };
        __proto.getIBW = function () {
            this._ib.setNeedUpload();
            return this._ib;
        };
        __proto.createQuadIB = function (QuadNum) {
            this._quadNum = QuadNum;
            this._ib._resizeBuffer(QuadNum * 6 * 2, false);
            this._ib.byteLength = this._ib.bufferLength;
            var bd = this._ib.getUint16Array();
            var idx = 0;
            var curvert = 0;
            for (var i = 0; i < QuadNum; i++) {
                bd[idx++] = curvert;
                bd[idx++] = curvert + 2;
                bd[idx++] = curvert + 1;
                bd[idx++] = curvert;
                bd[idx++] = curvert + 3;
                bd[idx++] = curvert + 2;
                curvert += 4;
            }
            this._ib.setNeedUpload();
        };
        __proto.setAttributes = function (attribs) {
            this._attribInfo = attribs;
            if (this._attribInfo.length % 3 != 0) {
                throw 'Mesh2D setAttributes error!';
            }
        };
        __proto.getEleNum = function () {
            return this._ib.getBuffer().byteLength / 2;
        };
        __proto.releaseMesh = function () { };
        __proto.destroy = function () { };
        __proto.clearVB = function () {
            this._vb.clear();
        };
        Mesh2D._gvaoid = 0;
        return Mesh2D;
    })();
    var RenderState2D = (function () {
        function RenderState2D() { }
        __class(RenderState2D, 'laya.webgl.utils.RenderState2D');
        RenderState2D.getMatrArray = function () {
            return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        };
        RenderState2D.mat2MatArray = function (mat, matArray) {
            var m = mat;
            var m4 = matArray;
            m4[0] = m.a;
            m4[1] = m.b;
            m4[2] = RenderState2D.EMPTYMAT4_ARRAY[2];
            m4[3] = RenderState2D.EMPTYMAT4_ARRAY[3];
            m4[4] = m.c;
            m4[5] = m.d;
            m4[6] = RenderState2D.EMPTYMAT4_ARRAY[6];
            m4[7] = RenderState2D.EMPTYMAT4_ARRAY[7];
            m4[8] = RenderState2D.EMPTYMAT4_ARRAY[8];
            m4[9] = RenderState2D.EMPTYMAT4_ARRAY[9];
            m4[10] = RenderState2D.EMPTYMAT4_ARRAY[10];
            m4[11] = RenderState2D.EMPTYMAT4_ARRAY[11];
            m4[12] = m.tx;
            m4[13] = m.ty;
            m4[14] = RenderState2D.EMPTYMAT4_ARRAY[14];
            m4[15] = RenderState2D.EMPTYMAT4_ARRAY[15];
            return matArray;
        };
        RenderState2D.restoreTempArray = function () {
            RenderState2D.TEMPMAT4_ARRAY[0] = 1;
            RenderState2D.TEMPMAT4_ARRAY[1] = 0;
            RenderState2D.TEMPMAT4_ARRAY[4] = 0;
            RenderState2D.TEMPMAT4_ARRAY[5] = 1;
            RenderState2D.TEMPMAT4_ARRAY[12] = 0;
            RenderState2D.TEMPMAT4_ARRAY[13] = 0;
        };
        RenderState2D.clear = function () {
            RenderState2D.worldScissorTest = false;
            RenderState2D.worldShaderDefines = null;
            RenderState2D.worldFilters = null;
            RenderState2D.worldAlpha = 1;
            RenderState2D.worldClipRect.x = RenderState2D.worldClipRect.y = 0;
            RenderState2D.worldClipRect.width = RenderState2D.width;
            RenderState2D.worldClipRect.height = RenderState2D.height;
            RenderState2D.curRenderTarget = null;
        };
        RenderState2D._MAXSIZE = 99999999;
        RenderState2D.EMPTYMAT4_ARRAY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        RenderState2D.TEMPMAT4_ARRAY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        RenderState2D.worldMatrix4 = RenderState2D.TEMPMAT4_ARRAY;
        RenderState2D.worldAlpha = 1.0;
        RenderState2D.worldScissorTest = false;
        RenderState2D.worldFilters = null;
        RenderState2D.worldShaderDefines = null;
        RenderState2D.curRenderTarget = null;
        RenderState2D.width = 0;
        RenderState2D.height = 0;
        __static(RenderState2D, ['worldMatrix', function () { return this.worldMatrix = new Matrix(); }, 'worldClipRect', function () { return this.worldClipRect = new Rectangle(0, 0, 99999999, 99999999); }
        ]);
        return RenderState2D;
    })();
    var ShaderCompile = (function () {
        var ShaderNode, InlcudeFile;
        function ShaderCompile(name, vs, ps, nameMap, defs) {
            var _$this = this;
            function _compile(script) {
                var includefiles = [];
                var top = new ShaderNode(includefiles);
                _$this._compileToTree(top, script.split('\n'), 0, includefiles, defs);
                return top;
            }
            ;
            var startTime = Browser.now();
            this._VS = _compile(vs);
            this._PS = _compile(ps);
            this._nameMap = nameMap;
            if ((Browser.now() - startTime) > 2)
                console_log("ShaderCompile use time:" + (Browser.now() - startTime) + "  size:" + vs.length + "/" + ps.length);
        }
        __class(ShaderCompile, 'laya.webgl.utils.ShaderCompile');
        var __proto = ShaderCompile.prototype;
        __proto._compileToTree = function (parent, lines, start, includefiles, defs) {
            var node, preNode;
            var text, name, fname;
            var ofs = 0, words, noUseNode;
            var i = 0, n = 0, j = 0;
            for (i = start; i < lines.length; i++) {
                text = lines[i];
                if (text.length < 1)
                    continue;
                ofs = text.indexOf("//");
                if (ofs === 0)
                    continue;
                if (ofs >= 0)
                    text = text.substr(0, ofs);
                node = noUseNode || new ShaderNode(includefiles);
                noUseNode = null;
                node.text = text;
                node.noCompile = true;
                if ((ofs = text.indexOf("#")) >= 0) {
                    name = "#";
                    for (j = ofs + 1, n = text.length; j < n; j++) {
                        var c = text.charAt(j);
                        if (c === ' ' || c === '\t' || c === '?')
                            break;
                        name += c;
                    }
                    node.name = name;
                    switch (name) {
                        case "#ifdef":
                        case "#ifndef":
                            node.src = text;
                            node.noCompile = text.match(/[!&|()=<>]/) != null;
                            if (!node.noCompile) {
                                words = text.replace(/^\s*/, '').split(/\s+/);
                                node.setCondition(words[1], name === "#ifdef" ? 1 : 2);
                                node.text = "//" + node.text;
                            }
                            else {
                                console_log("function():Boolean{return " + text.substr(ofs + node.name.length) + "}");
                            }
                            node.setParent(parent);
                            parent = node;
                            if (defs) {
                                words = text.substr(j).split(ShaderCompile._splitToWordExps3);
                                for (j = 0; j < words.length; j++) {
                                    text = words[j];
                                    text.length && (defs[text] = true);
                                }
                            }
                            continue;
                        case "#if":
                            node.src = text;
                            node.noCompile = true;
                            node.setParent(parent);
                            parent = node;
                            if (defs) {
                                words = text.substr(j).split(ShaderCompile._splitToWordExps3);
                                for (j = 0; j < words.length; j++) {
                                    text = words[j];
                                    text.length && text != "defined" && (defs[text] = true);
                                }
                            }
                            continue;
                        case "#else":
                            node.src = text;
                            parent = parent.parent;
                            preNode = parent.childs[parent.childs.length - 1];
                            node.noCompile = preNode.noCompile;
                            if (!(node.noCompile)) {
                                node.condition = preNode.condition;
                                node.conditionType = preNode.conditionType == 1 ? 2 : 1;
                                node.text = "//" + node.text + " " + preNode.text + " " + node.conditionType;
                            }
                            node.setParent(parent);
                            parent = node;
                            continue;
                        case "#endif":
                            parent = parent.parent;
                            preNode = parent.childs[parent.childs.length - 1];
                            node.noCompile = preNode.noCompile;
                            if (!(node.noCompile)) {
                                node.text = "//" + node.text;
                            }
                            node.setParent(parent);
                            continue;
                        case "#include":
                            words = ShaderCompile.splitToWords(text, null);
                            var inlcudeFile = ShaderCompile.includes[words[1]];
                            if (!inlcudeFile) {
                                throw "ShaderCompile error no this include file:" + words[1];
                                return;
                            }
                            if ((ofs = words[0].indexOf("?")) < 0) {
                                node.setParent(parent);
                                text = inlcudeFile.getWith(words[2] == 'with' ? words[3] : null);
                                this._compileToTree(node, text.split('\n'), 0, includefiles, defs);
                                node.text = "";
                                continue;
                            }
                            node.setCondition(words[0].substr(ofs + 1), 1);
                            node.text = inlcudeFile.getWith(words[2] == 'with' ? words[3] : null);
                            break;
                        case "#import":
                            words = ShaderCompile.splitToWords(text, null);
                            fname = words[1];
                            includefiles.push({ node: node, file: ShaderCompile.includes[fname], ofs: node.text.length });
                            continue;
                    }
                }
                else {
                    preNode = parent.childs[parent.childs.length - 1];
                    if (preNode && !preNode.name) {
                        includefiles.length > 0 && ShaderCompile.splitToWords(text, preNode);
                        noUseNode = node;
                        preNode.text += "\n" + text;
                        continue;
                    }
                    includefiles.length > 0 && ShaderCompile.splitToWords(text, node);
                }
                node.setParent(parent);
            }
        };
        __proto.createShader = function (define, shaderName, createShader) {
            var defMap = {};
            // 按照顺序取得代码
            var kds_logic_ps_codes = "";
            var kds_logic_ps_codesArr = [];
            var defineStr = "";
            if (define) {
                for (var i in define) {
                    defineStr += "#define " + i + "\n";
                    defMap[i] = true;
                    if (Shader.KDSPSShaderLogicArr) {
                        var logic_ps_code = Shader.KDSPSShaderLogicArr[i];
                        if (logic_ps_code != null) {
                            var logicOrder = define[i];
                            kds_logic_ps_codesArr[logicOrder - 1] = logic_ps_code;
                        }
                    }
                }
            }
            ;
            kds_logic_ps_codes = kds_logic_ps_codesArr.join("");
            var vs = this._VS.toscript(defMap, []);
            var ps = this._PS.toscript(defMap, [], kds_logic_ps_codes);
            return (createShader || Shader.create)(defineStr + vs.join('\n'), defineStr + ps.join('\n'), shaderName, this._nameMap);
        };
        ShaderCompile._parseOne = function (attributes, uniforms, words, i, word, b) {
            var one = { type: ShaderCompile.shaderParamsMap[words[i + 1]], name: words[i + 2], size: isNaN(parseInt(words[i + 3])) ? 1 : parseInt(words[i + 3]) };
            if (b) {
                if (word == "attribute") {
                    attributes.push(one);
                }
                else {
                    uniforms.push(one);
                }
            }
            if (words[i + 3] == ':') {
                one.type = words[i + 4];
                i += 2;
            }
            i += 2;
            return i;
        };
        ShaderCompile.addInclude = function (fileName, txt, force) {
            if (!txt || txt.length === 0)
                throw new Error("add shader include file err:" + fileName);
            if (!force && ShaderCompile.includes[fileName])
                throw new Error("add shader include file err, has add:" + fileName);
            ShaderCompile.includes[fileName] = new InlcudeFile(txt);
        };
        ShaderCompile.preGetParams = function (vs, ps) {
            var text = [vs, ps];
            var result = {};
            var attributes = [];
            var uniforms = [];
            var definesInfo = {};
            var definesName = [];
            result.attributes = attributes;
            result.uniforms = uniforms;
            result.defines = definesInfo;
            var i = 0, n = 0, one;
            for (var s = 0; s < 2; s++) {
                text[s] = text[s].replace(ShaderCompile._removeAnnotation, "");
                var words = text[s].match(ShaderCompile._reg);
                var tempelse;
                for (i = 0, n = words.length; i < n; i++) {
                    var word = words[i];
                    if (word != "attribute" && word != "uniform") {
                        if (word == "#define") {
                            word = words[++i];
                            definesName[word] = 1;
                            continue;
                        }
                        else if (word == "#ifdef") {
                            tempelse = words[++i];
                            var def = definesInfo[tempelse] = definesInfo[tempelse] || [];
                            for (i++; i < n; i++) {
                                word = words[i];
                                if (word != "attribute" && word != "uniform") {
                                    if (word == "#else") {
                                        for (i++; i < n; i++) {
                                            word = words[i];
                                            if (word != "attribute" && word != "uniform") {
                                                if (word == "#endif") {
                                                    break;
                                                }
                                                continue;
                                            }
                                            i = ShaderCompile._parseOne(attributes, uniforms, words, i, word, !definesName[tempelse]);
                                        }
                                    }
                                    continue;
                                }
                                i = ShaderCompile._parseOne(attributes, uniforms, words, i, word, definesName[tempelse]);
                            }
                        }
                        continue;
                    }
                    i = ShaderCompile._parseOne(attributes, uniforms, words, i, word, true);
                }
            }
            return result;
        };
        ShaderCompile.splitToWords = function (str, block) {
            var out = [];
            var c;
            var ofs = -1;
            var word;
            for (var i = 0, n = str.length; i < n; i++) {
                c = str.charAt(i);
                if (" \t=+-*/&%!<>()'\",;".indexOf(c) >= 0) {
                    if (ofs >= 0 && (i - ofs) > 1) {
                        word = str.substr(ofs, i - ofs);
                        out.push(word);
                    }
                    if (c == '"' || c == "'") {
                        var ofs2 = str.indexOf(c, i + 1);
                        if (ofs2 < 0) {
                            throw "Sharder err:" + str;
                        }
                        out.push(str.substr(i + 1, ofs2 - i - 1));
                        i = ofs2;
                        ofs = -1;
                        continue;
                    }
                    if (c == '(' && block && out.length > 0) {
                        word = out[out.length - 1] + ";";
                        if ("vec4;main;".indexOf(word) < 0)
                            block.useFuns += word;
                    }
                    ofs = -1;
                    continue;
                }
                if (ofs < 0)
                    ofs = i;
            }
            if (ofs < n && (n - ofs) > 1) {
                word = str.substr(ofs, n - ofs);
                out.push(word);
            }
            return out;
        };
        ShaderCompile.IFDEF_NO = 0;
        ShaderCompile.IFDEF_YES = 1;
        ShaderCompile.IFDEF_ELSE = 2;
        ShaderCompile.IFDEF_PARENT = 3;
        ShaderCompile._removeAnnotation = new RegExp("(/\\*([^*]|[\\r\\\n]|(\\*+([^*/]|[\\r\\n])))*\\*+/)|(//.*)", "g");
        ShaderCompile._reg = new RegExp("(\".*\")|('.*')|([#\\w\\*-\\.+/()=<>{}\\\\]+)|([,;:\\\\])", "g");
        ShaderCompile._splitToWordExps = new RegExp("[(\".*\")]+|[('.*')]+|([ \\t=\\+\\-*/&%!<>!%\(\),;])", "g");
        ShaderCompile.includes = {};
        __static(ShaderCompile, ['shaderParamsMap', function () { return this.shaderParamsMap = { "float": 0x1406, "int": 0x1404, "bool": 0x8B56, "vec2": 0x8B50, "vec3": 0x8B51, "vec4": 0x8B52, "ivec2": 0x8B53, "ivec3": 0x8B54, "ivec4": 0x8B55, "bvec2": 0x8B57, "bvec3": 0x8B58, "bvec4": 0x8B59, "mat2": 0x8B5A, "mat3": 0x8B5B, "mat4": 0x8B5C, "sampler2D": 0x8B5E, "samplerCube": 0x8B60 }; }, '_splitToWordExps3', function () { return this._splitToWordExps3 = new RegExp("[ \\t=\\+\\-*/&%!<>!%\(\),;\\|]", "g"); }
        ]);
        ShaderCompile.__init$ = function () {
            ShaderNode = (function () {
                function ShaderNode(includefiles) {
                    this.childs = [];
                    this.text = "";
                    this.parent = null;
                    this.name = null;
                    this.noCompile = false;
                    this.includefiles = null;
                    this.condition = null;
                    this.conditionType = 0;
                    this.useFuns = "";
                    this.z = 0;
                    this.src = null;
                    this.includefiles = includefiles;
                }
                __class(ShaderNode, '');
                var __proto = ShaderNode.prototype;
                __proto.setParent = function (parent) {
                    parent.childs.push(this);
                    this.z = parent.z + 1;
                    this.parent = parent;
                };
                __proto.setCondition = function (condition, type) {
                    if (condition) {
                        this.conditionType = type;
                        condition = condition.replace(/(\s*$)/g, "");
                        this.condition = function () {
                            return this[condition];
                        };
                        this.condition.__condition = condition;
                    }
                };
                __proto.toscript = function (def, out, kds_logic_ps_codes) {
                    return this._toscript(def, out, ++ShaderNode.__id, kds_logic_ps_codes);
                };
                __proto._toscript = function (def, out, id, kds_logic_ps_codes) {
                    if (this.childs.length < 1 && !this.text)
                        return out;
                    var outIndex = out.length;
                    if (this.condition) {
                        var ifdef = !!this.condition.call(def);
                        this.conditionType === 2 && (ifdef = !ifdef);
                        if (!ifdef)
                            return out;
                    }
                    // 替换，按照顺序执行
                    if (this.text.indexOf("KDS_PS_SHADER_LOGICS") != -1) {
                        out.push(kds_logic_ps_codes);
                    }
                    else {
                        this.text && out.push(this.text);
                    }
                    this.childs.length > 0 && this.childs.forEach(function (o, index, arr) {
                        o._toscript(def, out, id, kds_logic_ps_codes);
                    });
                    if (this.includefiles.length > 0 && this.useFuns.length > 0) {
                        var funsCode;
                        for (var i = 0, n = this.includefiles.length; i < n; i++) {
                            if (this.includefiles[i].curUseID == id) {
                                continue;
                            }
                            funsCode = this.includefiles[i].file.getFunsScript(this.useFuns);
                            if (funsCode.length > 0) {
                                this.includefiles[i].curUseID = id;
                                out[0] = funsCode + out[0];
                            }
                        }
                    }
                    return out;
                };
                ShaderNode.__id = 1;
                return ShaderNode;
            })();
            InlcudeFile = (function () {
                function InlcudeFile(txt) {
                    this.script = null;
                    this.codes = {};
                    this.funs = {};
                    this.curUseID = -1;
                    this.funnames = "";
                    this.script = txt;
                    var begin = 0, ofs = 0, end = 0;
                    while (true) {
                        begin = txt.indexOf("#begin", begin);
                        if (begin < 0)
                            break;
                        end = begin + 5;
                        while (true) {
                            end = txt.indexOf("#end", end);
                            if (end < 0)
                                break;
                            if (txt.charAt(end + 4) === 'i')
                                end += 5;
                            else
                                break;
                        }
                        if (end < 0) {
                            throw "add include err,no #end:" + txt;
                            return;
                        }
                        ofs = txt.indexOf('\n', begin);
                        var words = ShaderCompile.splitToWords(txt.substr(begin, ofs - begin), null);
                        if (words[1] == 'code') {
                            this.codes[words[2]] = txt.substr(ofs + 1, end - ofs - 1);
                        }
                        else if (words[1] == 'function') {
                            ofs = txt.indexOf("function", begin);
                            ofs += "function".length;
                            this.funs[words[3]] = txt.substr(ofs + 1, end - ofs - 1);
                            this.funnames += words[3] + ";";
                        }
                        begin = end + 1;
                    }
                }
                __class(InlcudeFile, '');
                var __proto = InlcudeFile.prototype;
                __proto.getWith = function (name) {
                    var r = name ? this.codes[name] : this.script;
                    if (!r) {
                        throw "get with error:" + name;
                    }
                    return r;
                };
                __proto.getFunsScript = function (funsdef) {
                    var r = "";
                    for (var i in this.funs) {
                        if (funsdef.indexOf(i + ";") >= 0) {
                            r += this.funs[i];
                        }
                    }
                    return r;
                };
                return InlcudeFile;
            })();
        };
        return ShaderCompile;
    })();
    var WebGL = (function () {
        function WebGL() { }
        __class(WebGL, 'laya.webgl.WebGL');
        WebGL._uint8ArraySlice = function () {
            var _this = this;
            var sz = _this.length;
            var dec = new Uint8Array(_this.length);
            for (var i = 0; i < sz; i++)
                dec[i] = _this[i];
            return dec;
        };
        WebGL._float32ArraySlice = function () {
            var _this = this;
            var sz = _this.length;
            var dec = new Float32Array(_this.length);
            for (var i = 0; i < sz; i++)
                dec[i] = _this[i];
            return dec;
        };
        WebGL._uint16ArraySlice = function (__arg) {
            var arg = arguments;
            var _this = this;
            var sz = 0;
            var dec;
            var i = 0;
            if (arg.length === 0) {
                sz = _this.length;
                dec = new Uint16Array(sz);
                for (i = 0; i < sz; i++)
                    dec[i] = _this[i];
            }
            else if (arg.length === 2) {
                var start = arg[0];
                var end = arg[1];
                if (end > start) {
                    sz = end - start;
                    dec = new Uint16Array(sz);
                    for (i = start; i < end; i++)
                        dec[i - start] = _this[i];
                }
                else {
                    dec = new Uint16Array(0);
                }
            }
            return dec;
        };
        WebGL.expandContext = function () {
            var from = Context.prototype;
            var to = CanvasRenderingContext2D.prototype;
            to.fillTrangles = from.fillTrangles;
            Buffer2D.__int__(null);
            to.setIBVB = function (x, y, ib, vb, numElement, mat, shader, shaderValues, startIndex, offset) {
                (startIndex === void 0) && (startIndex = 0);
                (offset === void 0) && (offset = 0);
                if (ib === null) {
                    this._ib = this._ib || IndexBuffer2D.QuadrangleIB;
                    ib = this._ib;
                    GlUtils.expandIBQuadrangle(ib, (vb._byteLength / (4 * 16) + 8));
                }
                this._setIBVB(x, y, ib, vb, numElement, mat, shader, shaderValues, startIndex, offset);
            };
            to.fillTrangles = function (tex, x, y, points, m) {
                this._curMat = this._curMat || Matrix.create();
                this._vb = this._vb || VertexBuffer2D.create();
                if (!this._ib) {
                    this._ib = IndexBuffer2D.create();
                    GlUtils.fillIBQuadrangle(this._ib, length / 4);
                }
                ;
                var vb = this._vb;
                var length = points.length >> 4;
                GlUtils.fillTranglesVB(vb, x, y, points, m || this._curMat, 0, 0);
                GlUtils.expandIBQuadrangle(this._ib, (vb._byteLength / (4 * 16) + 8));
                var shaderValues = new Value2D(0x01, 0);
                shaderValues.textureHost = tex;
                var sd = new Shader2X("attribute vec2 position; attribute vec2 texcoord; uniform vec2 size; uniform mat4 mmat; varying vec2 v_texcoord; void main() { vec4 p=vec4(position.xy,0.0,1.0);vec4 pos=mmat*p; gl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0); v_texcoord = texcoord; }", "precision mediump float; varying vec2 v_texcoord; uniform sampler2D texture; void main() {vec4 color= texture2D(texture, v_texcoord); color.a*=1.0; gl_FragColor= color;}");
                vb._vertType = 3;
                this._setIBVB(x, y, this._ib, vb, length * 6, m, sd, shaderValues, 0, 0);
            };
        };
        WebGL.enable = function () {
            Browser.__init__();
            if (Render.isConchApp) {
                if (!Render.isConchWebGL) {
                    RunDriver.skinAniSprite = function () {
                        var tSkinSprite = new SkinMesh();
                        return tSkinSprite;
                    };
                    WebGL.expandContext();
                    return false;
                }
            }
            RunDriver.getWebGLContext = function getWebGLContext(canvas) {
                var gl;
                var names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
                for (var i = 0; i < names.length; i++) {
                    try {
                        gl = canvas.getContext(names[i], { stencil: Config.isStencil, alpha: Config.isAlpha, antialias: Config.isAntialias, premultipliedAlpha: Config.premultipliedAlpha, preserveDrawingBuffer: Config.preserveDrawingBuffer });
                    }
                    catch (e) { }
                    if (gl)
                        return gl;
                }
                return null;
            };
            WebGL.mainContext = RunDriver.getWebGLContext(Render._mainCanvas);
            if (WebGL.mainContext == null)
                return false;
            if (Render.isWebGL)
                return true;
            HTMLImage.create = function (src, def) {
                return new WebGLImage(src, def);
            };
            HTMLSubImage.create = function (canvas, offsetX, offsetY, width, height, atlasImage, src) {
                return new WebGLSubImage(canvas, offsetX, offsetY, width, height, atlasImage, src);
            };
            Render.WebGL = WebGL;
            Render.isWebGL = true;
            DrawText.__init__();
            RunDriver.createRenderSprite = function (type, next) {
                return new RenderSprite3D(type, next);
            };
            RunDriver.createWebGLContext2D = function (c) {
                return new WebGLContext2D(c);
            };
            RunDriver.changeWebGLSize = function (width, height) {
                laya.webgl.WebGL.onStageResize(width, height);
            };
            RunDriver.createGraphics = function () {
                return new GraphicsGL();
            };
            var action = RunDriver.createFilterAction;
            RunDriver.createFilterAction = action ? action : function (type) {
                return new ColorFilterActionGL();
            };
            RunDriver.clear = function (color) {
                RenderState2D.worldScissorTest && laya.webgl.WebGL.mainContext.disable(0x0C11);
                var ctx = Render.context.ctx;
                var c = (ctx._submits._length == 0 || Config.preserveDrawingBuffer) ? Color.create(color)._color : Stage._wgColor;
                if (c)
                    ctx.clearBG(c[0], c[1], c[2], c[3]);
                RenderState2D.clear();
            };
            RunDriver.addToAtlas = function (texture, force) {
                (force === void 0) && (force = false);
                var bitmap = texture.bitmap;
                if (!Render.optimizeTextureMemory(texture.url, texture)) {
                    (bitmap).enableMerageInAtlas = false;
                    return;
                }
                if ((Laya.__typeof(bitmap, 'laya.webgl.resource.IMergeAtlasBitmap')) && ((bitmap).allowMerageInAtlas)) {
                    bitmap.on("recovered", texture, texture.addTextureToAtlas);
                }
            };
            RunDriver.isAtlas = function (bitmap) {
                return (bitmap instanceof laya.webgl.atlas.AtlasWebGLCanvas);
            };
            AtlasResourceManager._enable();
            RunDriver.beginFlush = function () {
                var atlasResourceManager = AtlasResourceManager.instance;
                var count = atlasResourceManager.getAtlaserCount();
                for (var i = 0; i < count; i++) {
                    var atlerCanvas = atlasResourceManager.getAtlaserByIndex(i).texture;
                    (atlerCanvas._flashCacheImageNeedFlush) && (RunDriver.flashFlushImage(atlerCanvas));
                }
            };
            RunDriver.drawToCanvas = function (sprite, _renderType, canvasWidth, canvasHeight, offsetX, offsetY) {
                if (canvasWidth <= 0 || canvasHeight <= 0) {
                    console_log("[error] canvasWidth and canvasHeight should greater than zero");
                }
                offsetX -= sprite.x;
                offsetY -= sprite.y;
                var renderTarget = RenderTarget2D.create(canvasWidth, canvasHeight, 0x1908, 0x1401, 0, false);
                renderTarget.start();
                renderTarget.clear(0, 0, 0, 0);
                Render.context.clear();
                RenderSprite.renders[_renderType]._fun(sprite, Render.context, offsetX, RenderState2D.height - canvasHeight + offsetY);
                Render.context.flush();
                renderTarget.end();
                var pixels = renderTarget.getData(0, 0, renderTarget.width, renderTarget.height);
                renderTarget.recycle();
                var htmlCanvas = new WebGLCanvas();
                htmlCanvas._canvas = Browser.createElement("canvas");
                htmlCanvas.size(canvasWidth, canvasHeight);
                var context = htmlCanvas._canvas.getContext('2d');
                Browser.canvas.size(canvasWidth, canvasHeight);
                var tempContext = Browser.context;
                var imgData = tempContext.createImageData(canvasWidth, canvasHeight);
                imgData.data.set(new Uint8ClampedArray(pixels.buffer));
                htmlCanvas._imgData = imgData;
                tempContext.putImageData(imgData, 0, 0);
                context.save();
                context.translate(0, canvasHeight);
                context.scale(1, -1);
                context.drawImage(Browser.canvas.source, 0, 0);
                context.restore();
                return htmlCanvas;
            };
            RunDriver.createFilterAction = function (type) {
                var action;
                switch (type) {
                    case 0x20:
                        action = new ColorFilterActionGL();
                        break;
                }
                return action;
            };
            RunDriver.addTextureToAtlas = function (texture) {
                texture._uvID++;
                AtlasResourceManager._atlasRestore++;
                ((texture.bitmap).enableMerageInAtlas) && (AtlasResourceManager.instance.addToAtlas(texture));
            };
            RunDriver.getTexturePixels = function (value, x, y, width, height) {
                (Render.context.ctx).clear();
                var tSprite = new Sprite();
                tSprite.graphics.drawTexture(value, -x, -y);
                var tRenderTarget = RenderTarget2D.create(width, height);
                tRenderTarget.start();
                tRenderTarget.clear(0, 0, 0, 0);
                tSprite.render(Render.context, 0, 0);
                (Render.context.ctx).flush();
                tRenderTarget.end();
                var tUint8Array = tRenderTarget.getData(0, 0, width, height);
                var tArray = [];
                var tIndex = 0;
                for (var i = height - 1; i >= 0; i--) {
                    for (var j = 0; j < width; j++) {
                        tIndex = (i * width + j) * 4;
                        tArray.push(tUint8Array[tIndex]);
                        tArray.push(tUint8Array[tIndex + 1]);
                        tArray.push(tUint8Array[tIndex + 2]);
                        tArray.push(tUint8Array[tIndex + 3]);
                    }
                }
                return tArray;
            };
            RunDriver.skinAniSprite = function () {
                var tSkinSprite = new SkinMesh();
                return tSkinSprite;
            };
            HTMLCanvas.create = function (type, canvas) {
                var ret = new WebGLCanvas();
                ret._imgData = canvas;
                ret.flipY = false;
                return ret;
            };
            Filter._filterStart = function (scope, sprite, context, x, y) {
                var b = scope.getValue("bounds");
                var source = RenderTarget2D.create(b.width, b.height);
                source.start();
                source.clear(0, 0, 0, 0);
                scope.addValue("src", source);
                scope.addValue("ScissorTest", RenderState2D.worldScissorTest);
                if (RenderState2D.worldScissorTest) {
                    var tClilpRect = new Rectangle();
                    tClilpRect.copyFrom((context.ctx)._clipRect);
                    scope.addValue("clipRect", tClilpRect);
                    RenderState2D.worldScissorTest = false;
                    laya.webgl.WebGL.mainContext.disable(0x0C11);
                }
            };
            Filter._filterEnd = function (scope, sprite, context, x, y) {
                var b = scope.getValue("bounds");
                var source = scope.getValue("src");
                source.end();
                var out = RenderTarget2D.create(b.width, b.height);
                out.start();
                out.clear(0, 0, 0, 0);
                scope.addValue("out", out);
                sprite._set$P('_filterCache', out);
                sprite._set$P('_isHaveGlowFilter', scope.getValue("_isHaveGlowFilter"));
            };
            Filter._EndTarget = function (scope, context) {
                var source = scope.getValue("src");
                source.recycle();
                var out = scope.getValue("out");
                out.end();
                var b = scope.getValue("ScissorTest");
                if (b) {
                    RenderState2D.worldScissorTest = true;
                    laya.webgl.WebGL.mainContext.enable(0x0C11);
                    context.ctx.save();
                    var tClipRect = scope.getValue("clipRect");
                    (context.ctx).clipRect(tClipRect.x, tClipRect.y, tClipRect.width, tClipRect.height);
                }
            };
            Filter._useSrc = function (scope) {
                var source = scope.getValue("out");
                source.end();
                source = scope.getValue("src");
                source.start();
                source.clear(0, 0, 0, 0);
            };
            Filter._endSrc = function (scope) {
                var source = scope.getValue("src");
                source.end();
            };
            Filter._useOut = function (scope) {
                var source = scope.getValue("src");
                source.end();
                source = scope.getValue("out");
                source.start();
                source.clear(0, 0, 0, 0);
            };
            Filter._endOut = function (scope) {
                var source = scope.getValue("out");
                source.end();
            };
            Filter._recycleScope = function (scope) {
                scope.recycle();
            };
            Filter._filter = function (sprite, context, x, y) {
                var next = this._next;
                if (next) {
                    var filters = sprite.filters, len = filters.length;
                    // 如果是放大的话则只能使用一组滤镜（以免缓存为贴图后马赛克现象）
                    if (len > 0 && (sprite.scaleX > 1 || sprite.scaleX > 1)) {
                        context.ctx.save();
                        context.ctx.setFilters([filters[0]]);
                        next._fun.call(next, sprite, context, x, y);
                        context.ctx.restore();
                        return;
                    }
                    else if ((len == 1 && (filters[0].type == 0x20))) {
                        context.ctx.save();
                        context.ctx.setFilters([filters[0]]);
                        next._fun.call(next, sprite, context, x, y);
                        context.ctx.restore();
                        return;
                    }
                    // 自定义shader，平铺+多滤镜会黑，所以该shader保证只有一个即可
                    else if (len == 1 && (filters[0].type == 0x800) && sprite.hasTilingAttribute) {
                        context.ctx.save();
                        context.ctx.setFilters([filters[0]]);
                        next._fun.call(next, sprite, context, x, y);
                        context.ctx.restore();
                        return;
                    }
                    ;
                    var shaderValue;
                    var b;
                    var scope = SubmitCMDScope.create();
                    var p = Point.TEMP;
                    var tMatrix = context.ctx._getTransformMatrix();
                    var mat = Matrix.create();
                    tMatrix.copyTo(mat);
                    var tPadding = 0;
                    var tHalfPadding = 0;
                    var tIsHaveGlowFilter = false;
                    var out = sprite._$P._filterCache ? sprite._$P._filterCache : null;
                    if (!out || sprite._repaint) {
                        tIsHaveGlowFilter = sprite._isHaveGlowFilter();
                        scope.addValue("_isHaveGlowFilter", tIsHaveGlowFilter);
                        if (tIsHaveGlowFilter) {
                            tPadding = 50;
                            tHalfPadding = 25;
                        }
                        b = new Rectangle();
                        b.copyFrom((sprite).getSelfBounds());
                        b.x += (sprite).x;
                        b.y += (sprite).y;
                        b.x -= (sprite).pivotX + 4;
                        b.y -= (sprite).pivotY + 4;
                        var tSX = b.x;
                        var tSY = b.y;
                        b.width += (tPadding + 8);
                        b.height += (tPadding + 8);
                        p.x = b.x * mat.a + b.y * mat.c;
                        p.y = b.y * mat.d + b.x * mat.b;
                        b.x = p.x;
                        b.y = p.y;
                        p.x = b.width * mat.a + b.height * mat.c;
                        p.y = b.height * mat.d + b.width * mat.b;
                        b.width = p.x;
                        b.height = p.y;
                        if (b.width <= 0 || b.height <= 0) {
                            return;
                        }
                        out && out.recycle();
                        scope.addValue("bounds", b);
                        var submit = SubmitCMD.create([scope, sprite, context, 0, 0], Filter._filterStart);
                        context.addRenderObject(submit);
                        (context.ctx)._renderKey = 0;
                        (context.ctx)._shader2D.glTexture = null;
                        var tX = sprite.x - tSX + tHalfPadding;
                        var tY = sprite.y - tSY + tHalfPadding;
                        next._fun.call(next, sprite, context, tX, tY);
                        submit = SubmitCMD.create([scope, sprite, context, 0, 0], Filter._filterEnd);
                        context.addRenderObject(submit);
                        for (var i = 0; i < len; i++) {
                            if (i != 0) {
                                submit = SubmitCMD.create([scope], Filter._useSrc);
                                context.addRenderObject(submit);
                                shaderValue = Value2D.create(0x01, 0);
                                Matrix.TEMP.identity();
                                context.ctx.drawTarget(scope, 0, 0, b.width, b.height, Matrix.TEMP, "out", shaderValue, null, BlendMode.TOINT.overlay);
                                submit = SubmitCMD.create([scope], Filter._useOut);
                                context.addRenderObject(submit);
                            }
                            ;
                            var fil = filters[i];
                            fil.action.apply3d(scope, sprite, context, 0, 0);
                        }
                        submit = SubmitCMD.create([scope, context], Filter._EndTarget);
                        context.addRenderObject(submit);
                    }
                    else {
                        tIsHaveGlowFilter = sprite._$P._isHaveGlowFilter ? sprite._$P._isHaveGlowFilter : false;
                        if (tIsHaveGlowFilter) {
                            tPadding = 50;
                            tHalfPadding = 25;
                        }
                        b = sprite.getBounds();
                        if (b.width <= 0 || b.height <= 0) {
                            return;
                        }
                        b.width += tPadding;
                        b.height += tPadding;
                        p.x = b.x * mat.a + b.y * mat.c;
                        p.y = b.y * mat.d + b.x * mat.b;
                        b.x = p.x;
                        b.y = p.y;
                        p.x = b.width * mat.a + b.height * mat.c;
                        p.y = b.height * mat.d + b.width * mat.b;
                        b.width = p.x;
                        b.height = p.y;
                        scope.addValue("out", out);
                    }
                    x = x - tHalfPadding - sprite.x;
                    y = y - tHalfPadding - sprite.y;
                    p.setTo(x, y);
                    mat.transformPoint(p);
                    x = p.x + b.x;
                    y = p.y + b.y;
                    shaderValue = Value2D.create(0x01, 0);
                    Matrix.TEMP.identity();
                    (context.ctx).drawTarget(scope, x, y, b.width, b.height, Matrix.TEMP, "out", shaderValue, null, BlendMode.TOINT.overlay);
                    submit = SubmitCMD.create([scope], Filter._recycleScope);
                    context.addRenderObject(submit);
                    mat.destroy();
                }
            };
            Float32Array.prototype.slice || (Float32Array.prototype.slice = WebGL._float32ArraySlice);
            Uint16Array.prototype.slice || (Uint16Array.prototype.slice = WebGL._uint16ArraySlice);
            Uint8Array.prototype.slice || (Uint8Array.prototype.slice = WebGL._uint8ArraySlice);
            return true;
        };
        WebGL.onStageResize = function (width, height) {
            if (WebGL.mainContext == null)
                return;
            WebGL.mainContext.viewport(0, 0, width, height);
            RenderState2D.width = width;
            RenderState2D.height = height;
        };
        WebGL.onInvalidGLRes = function () {
            AtlasResourceManager.instance.freeAll();
            ResourceManager.releaseContentManagers(true);
            WebGL.doNodeRepaint(Laya.stage);
            WebGL.mainContext.viewport(0, 0, RenderState2D.width, RenderState2D.height);
            Laya.stage.event("devicelost");
        };
        WebGL.doNodeRepaint = function (sprite) {
            (sprite.numChildren == 0) && (sprite.repaint());
            for (var i = 0; i < sprite.numChildren; i++)
                WebGL.doNodeRepaint(sprite.getChildAt(i));
        };
        WebGL.init = function (canvas, width, height) {
            WebGL.mainCanvas = canvas;
            HTMLCanvas._createContext = function (canvas) {
                return new WebGLContext2D(canvas);
            };
            WebGLCanvas._createContext = function (canvas) {
                return new WebGLContext2D(canvas);
            };
            var gl = laya.webgl.WebGL.mainContext;
            if (gl.getShaderPrecisionFormat != null) {
                var vertexPrecisionFormat = gl.getShaderPrecisionFormat(0x8B31, 0x8DF2);
                var framePrecisionFormat = gl.getShaderPrecisionFormat(0x8B30, 0x8DF2);
                WebGL.shaderHighPrecision = (vertexPrecisionFormat.precision && framePrecisionFormat.precision) ? true : false;
            }
            else {
                WebGL.shaderHighPrecision = false;
            }
            WebGL.compressAstc = gl.getExtension("WEBGL_compressed_texture_astc");
            WebGL.compressAtc = gl.getExtension("WEBGL_compressed_texture_atc");
            WebGL.compressEtc = gl.getExtension("WEBGL_compressed_texture_etc");
            WebGL.compressEtc1 = gl.getExtension("WEBGL_compressed_texture_etc1");
            WebGL.compressPvrtc = gl.getExtension("WEBGL_compressed_texture_pvrtc");
            WebGL.compressS3tc = gl.getExtension("WEBGL_compressed_texture_s3tc");
            WebGL.compressS3tc_srgb = gl.getExtension("WEBGL_compressed_texture_s3tc_srgb");
            gl.deleteTexture1 = gl.deleteTexture;
            gl.deleteTexture = function (t) {
                if (t == WebGLContext.curBindTexValue) {
                    WebGLContext.curBindTexValue = null;
                }
                gl.deleteTexture1(t);
            };
            WebGL.onStageResize(width, height);
            if (WebGL.mainContext == null)
                throw new Error("webGL getContext err!");
            System.__init__();
            AtlasResourceManager.__init__();
            ShaderDefines2D.__init__();
            Submit.__init__();
            WebGLContext2D.__init__();
            Value2D.__init__();
            Shader2D.__init__();
            Buffer2D.__int__(gl);
            BlendMode._init_(gl);
            if (Render.isConchApp) {
                conch.setOnInvalidGLRes(WebGL.onInvalidGLRes);
            }
        };
        WebGL.compressAstc = null;
        WebGL.compressAtc = null;
        WebGL.compressEtc = null;
        WebGL.compressEtc1 = null;
        WebGL.compressPvrtc = null;
        WebGL.compressS3tc = null;
        WebGL.compressS3tc_srgb = null;
        WebGL.mainCanvas = null;
        WebGL.mainContext = null;
        WebGL.antialias = true;
        WebGL.shaderHighPrecision = false;
        WebGL._bg_null = [0, 0, 0, 0];
        return WebGL;
    })();
    var WebGLContext = (function () {
        function WebGLContext() { }
        __class(WebGLContext, 'laya.webgl.WebGLContext');
        WebGLContext.UseProgram = function (program) {
            if (WebGLContext._useProgram === program)
                return false;
            WebGL.mainContext.useProgram(program);
            WebGLContext._useProgram = program;
            return true;
        };
        WebGLContext.setDepthTest = function (gl, value) {
            value !== WebGLContext._depthTest && (WebGLContext._depthTest = value, value ? gl.enable(0x0B71) : gl.disable(0x0B71));
        };
        WebGLContext.setDepthMask = function (gl, value) {
            value !== WebGLContext._depthMask && (WebGLContext._depthMask = value, gl.depthMask(value));
        };
        WebGLContext.setDepthFunc = function (gl, value) {
            value !== WebGLContext._depthFunc && (WebGLContext._depthFunc = value, gl.depthFunc(value));
        };
        WebGLContext.setBlend = function (gl, value) {
            value !== WebGLContext._blend && (WebGLContext._blend = value, value ? gl.enable(0x0BE2) : gl.disable(0x0BE2));
        };
        WebGLContext.setBlendFunc = function (gl, sFactor, dFactor) {
            (sFactor !== WebGLContext._sFactor || dFactor !== WebGLContext._dFactor) && (WebGLContext._sFactor = sFactor, WebGLContext._dFactor = dFactor, gl.blendFunc(sFactor, dFactor));
        };
        WebGLContext.setCullFace = function (gl, value) {
            value !== WebGLContext._cullFace && (WebGLContext._cullFace = value, value ? gl.enable(0x0B44) : gl.disable(0x0B44));
        };
        WebGLContext.setFrontFace = function (gl, value) {
            value !== WebGLContext._frontFace && (WebGLContext._frontFace = value, gl.frontFace(value));
        };
        WebGLContext.bindTexture = function (gl, target, texture) {
            gl.bindTexture(target, texture);
            WebGLContext.curBindTexTarget = target;
            WebGLContext.curBindTexValue = texture;
        };
        WebGLContext.DEPTH_BUFFER_BIT = 0x00000100;
        WebGLContext.STENCIL_BUFFER_BIT = 0x00000400;
        WebGLContext.COLOR_BUFFER_BIT = 0x00004000;
        WebGLContext.POINTS = 0x0000;
        WebGLContext.LINES = 0x0001;
        WebGLContext.LINE_LOOP = 0x0002;
        WebGLContext.LINE_STRIP = 0x0003;
        WebGLContext.TRIANGLES = 0x0004;
        WebGLContext.TRIANGLE_STRIP = 0x0005;
        WebGLContext.TRIANGLE_FAN = 0x0006;
        WebGLContext.ZERO = 0;
        WebGLContext.ONE = 1;
        WebGLContext.SRC_COLOR = 0x0300;
        WebGLContext.ONE_MINUS_SRC_COLOR = 0x0301;
        WebGLContext.SRC_ALPHA = 0x0302;
        WebGLContext.ONE_MINUS_SRC_ALPHA = 0x0303;
        WebGLContext.DST_ALPHA = 0x0304;
        WebGLContext.ONE_MINUS_DST_ALPHA = 0x0305;
        WebGLContext.DST_COLOR = 0x0306;
        WebGLContext.ONE_MINUS_DST_COLOR = 0x0307;
        WebGLContext.SRC_ALPHA_SATURATE = 0x0308;
        WebGLContext.FUNC_ADD = 0x8006;
        WebGLContext.BLEND_EQUATION = 0x8009;
        WebGLContext.BLEND_EQUATION_RGB = 0x8009;
        WebGLContext.BLEND_EQUATION_ALPHA = 0x883D;
        WebGLContext.FUNC_SUBTRACT = 0x800A;
        WebGLContext.FUNC_REVERSE_SUBTRACT = 0x800B;
        WebGLContext.BLEND_DST_RGB = 0x80C8;
        WebGLContext.BLEND_SRC_RGB = 0x80C9;
        WebGLContext.BLEND_DST_ALPHA = 0x80CA;
        WebGLContext.BLEND_SRC_ALPHA = 0x80CB;
        WebGLContext.CONSTANT_COLOR = 0x8001;
        WebGLContext.ONE_MINUS_CONSTANT_COLOR = 0x8002;
        WebGLContext.CONSTANT_ALPHA = 0x8003;
        WebGLContext.ONE_MINUS_CONSTANT_ALPHA = 0x8004;
        WebGLContext.BLEND_COLOR = 0x8005;
        WebGLContext.ARRAY_BUFFER = 0x8892;
        WebGLContext.ELEMENT_ARRAY_BUFFER = 0x8893;
        WebGLContext.ARRAY_BUFFER_BINDING = 0x8894;
        WebGLContext.ELEMENT_ARRAY_BUFFER_BINDING = 0x8895;
        WebGLContext.STREAM_DRAW = 0x88E0;
        WebGLContext.STATIC_DRAW = 0x88E4;
        WebGLContext.DYNAMIC_DRAW = 0x88E8;
        WebGLContext.BUFFER_SIZE = 0x8764;
        WebGLContext.BUFFER_USAGE = 0x8765;
        WebGLContext.CURRENT_VERTEX_ATTRIB = 0x8626;
        WebGLContext.FRONT = 0x0404;
        WebGLContext.BACK = 0x0405;
        WebGLContext.CULL_FACE = 0x0B44;
        WebGLContext.FRONT_AND_BACK = 0x0408;
        WebGLContext.BLEND = 0x0BE2;
        WebGLContext.DITHER = 0x0BD0;
        WebGLContext.STENCIL_TEST = 0x0B90;
        WebGLContext.DEPTH_TEST = 0x0B71;
        WebGLContext.SCISSOR_TEST = 0x0C11;
        WebGLContext.POLYGON_OFFSET_FILL = 0x8037;
        WebGLContext.SAMPLE_ALPHA_TO_COVERAGE = 0x809E;
        WebGLContext.SAMPLE_COVERAGE = 0x80A0;
        WebGLContext.NO_ERROR = 0;
        WebGLContext.INVALID_ENUM = 0x0500;
        WebGLContext.INVALID_VALUE = 0x0501;
        WebGLContext.INVALID_OPERATION = 0x0502;
        WebGLContext.OUT_OF_MEMORY = 0x0505;
        WebGLContext.CW = 0x0900;
        WebGLContext.CCW = 0x0901;
        WebGLContext.LINE_WIDTH = 0x0B21;
        WebGLContext.ALIASED_POINT_SIZE_RANGE = 0x846D;
        WebGLContext.ALIASED_LINE_WIDTH_RANGE = 0x846E;
        WebGLContext.CULL_FACE_MODE = 0x0B45;
        WebGLContext.FRONT_FACE = 0x0B46;
        WebGLContext.DEPTH_RANGE = 0x0B70;
        WebGLContext.DEPTH_WRITEMASK = 0x0B72;
        WebGLContext.DEPTH_CLEAR_VALUE = 0x0B73;
        WebGLContext.DEPTH_FUNC = 0x0B74;
        WebGLContext.STENCIL_CLEAR_VALUE = 0x0B91;
        WebGLContext.STENCIL_FUNC = 0x0B92;
        WebGLContext.STENCIL_FAIL = 0x0B94;
        WebGLContext.STENCIL_PASS_DEPTH_FAIL = 0x0B95;
        WebGLContext.STENCIL_PASS_DEPTH_PASS = 0x0B96;
        WebGLContext.STENCIL_REF = 0x0B97;
        WebGLContext.STENCIL_VALUE_MASK = 0x0B93;
        WebGLContext.STENCIL_WRITEMASK = 0x0B98;
        WebGLContext.STENCIL_BACK_FUNC = 0x8800;
        WebGLContext.STENCIL_BACK_FAIL = 0x8801;
        WebGLContext.STENCIL_BACK_PASS_DEPTH_FAIL = 0x8802;
        WebGLContext.STENCIL_BACK_PASS_DEPTH_PASS = 0x8803;
        WebGLContext.STENCIL_BACK_REF = 0x8CA3;
        WebGLContext.STENCIL_BACK_VALUE_MASK = 0x8CA4;
        WebGLContext.STENCIL_BACK_WRITEMASK = 0x8CA5;
        WebGLContext.VIEWPORT = 0x0BA2;
        WebGLContext.SCISSOR_BOX = 0x0C10;
        WebGLContext.COLOR_CLEAR_VALUE = 0x0C22;
        WebGLContext.COLOR_WRITEMASK = 0x0C23;
        WebGLContext.UNPACK_ALIGNMENT = 0x0CF5;
        WebGLContext.PACK_ALIGNMENT = 0x0D05;
        WebGLContext.MAX_TEXTURE_SIZE = 0x0D33;
        WebGLContext.MAX_VIEWPORT_DIMS = 0x0D3A;
        WebGLContext.SUBPIXEL_BITS = 0x0D50;
        WebGLContext.RED_BITS = 0x0D52;
        WebGLContext.GREEN_BITS = 0x0D53;
        WebGLContext.BLUE_BITS = 0x0D54;
        WebGLContext.ALPHA_BITS = 0x0D55;
        WebGLContext.DEPTH_BITS = 0x0D56;
        WebGLContext.STENCIL_BITS = 0x0D57;
        WebGLContext.POLYGON_OFFSET_UNITS = 0x2A00;
        WebGLContext.POLYGON_OFFSET_FACTOR = 0x8038;
        WebGLContext.TEXTURE_BINDING_2D = 0x8069;
        WebGLContext.SAMPLE_BUFFERS = 0x80A8;
        WebGLContext.SAMPLES = 0x80A9;
        WebGLContext.SAMPLE_COVERAGE_VALUE = 0x80AA;
        WebGLContext.SAMPLE_COVERAGE_INVERT = 0x80AB;
        WebGLContext.NUM_COMPRESSED_TEXTURE_FORMATS = 0x86A2;
        WebGLContext.COMPRESSED_TEXTURE_FORMATS = 0x86A3;
        WebGLContext.DONT_CARE = 0x1100;
        WebGLContext.FASTEST = 0x1101;
        WebGLContext.NICEST = 0x1102;
        WebGLContext.GENERATE_MIPMAP_HINT = 0x8192;
        WebGLContext.BYTE = 0x1400;
        WebGLContext.UNSIGNED_BYTE = 0x1401;
        WebGLContext.SHORT = 0x1402;
        WebGLContext.UNSIGNED_SHORT = 0x1403;
        WebGLContext.INT = 0x1404;
        WebGLContext.UNSIGNED_INT = 0x1405;
        WebGLContext.FLOAT = 0x1406;
        WebGLContext.DEPTH_COMPONENT = 0x1902;
        WebGLContext.ALPHA = 0x1906;
        WebGLContext.RGB = 0x1907;
        WebGLContext.RGBA = 0x1908;
        WebGLContext.LUMINANCE = 0x1909;
        WebGLContext.LUMINANCE_ALPHA = 0x190A;
        WebGLContext.UNSIGNED_SHORT_4_4_4_4 = 0x8033;
        WebGLContext.UNSIGNED_SHORT_5_5_5_1 = 0x8034;
        WebGLContext.UNSIGNED_SHORT_5_6_5 = 0x8363;
        WebGLContext.FRAGMENT_SHADER = 0x8B30;
        WebGLContext.VERTEX_SHADER = 0x8B31;
        WebGLContext.MAX_VERTEX_ATTRIBS = 0x8869;
        WebGLContext.MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB;
        WebGLContext.MAX_VARYING_VECTORS = 0x8DFC;
        WebGLContext.MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D;
        WebGLContext.MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C;
        WebGLContext.MAX_TEXTURE_IMAGE_UNITS = 0x8872;
        WebGLContext.MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD;
        WebGLContext.SHADER_TYPE = 0x8B4F;
        WebGLContext.DELETE_STATUS = 0x8B80;
        WebGLContext.LINK_STATUS = 0x8B82;
        WebGLContext.VALIDATE_STATUS = 0x8B83;
        WebGLContext.ATTACHED_SHADERS = 0x8B85;
        WebGLContext.ACTIVE_UNIFORMS = 0x8B86;
        WebGLContext.ACTIVE_ATTRIBUTES = 0x8B89;
        WebGLContext.SHADING_LANGUAGE_VERSION = 0x8B8C;
        WebGLContext.CURRENT_PROGRAM = 0x8B8D;
        WebGLContext.NEVER = 0x0200;
        WebGLContext.LESS = 0x0201;
        WebGLContext.EQUAL = 0x0202;
        WebGLContext.LEQUAL = 0x0203;
        WebGLContext.GREATER = 0x0204;
        WebGLContext.NOTEQUAL = 0x0205;
        WebGLContext.GEQUAL = 0x0206;
        WebGLContext.ALWAYS = 0x0207;
        WebGLContext.KEEP = 0x1E00;
        WebGLContext.REPLACE = 0x1E01;
        WebGLContext.INCR = 0x1E02;
        WebGLContext.DECR = 0x1E03;
        WebGLContext.INVERT = 0x150A;
        WebGLContext.INCR_WRAP = 0x8507;
        WebGLContext.DECR_WRAP = 0x8508;
        WebGLContext.VENDOR = 0x1F00;
        WebGLContext.RENDERER = 0x1F01;
        WebGLContext.VERSION = 0x1F02;
        WebGLContext.NEAREST = 0x2600;
        WebGLContext.LINEAR = 0x2601;
        WebGLContext.NEAREST_MIPMAP_NEAREST = 0x2700;
        WebGLContext.LINEAR_MIPMAP_NEAREST = 0x2701;
        WebGLContext.NEAREST_MIPMAP_LINEAR = 0x2702;
        WebGLContext.LINEAR_MIPMAP_LINEAR = 0x2703;
        WebGLContext.TEXTURE_MAG_FILTER = 0x2800;
        WebGLContext.TEXTURE_MIN_FILTER = 0x2801;
        WebGLContext.TEXTURE_WRAP_S = 0x2802;
        WebGLContext.TEXTURE_WRAP_T = 0x2803;
        WebGLContext.TEXTURE_2D = 0x0DE1;
        WebGLContext.TEXTURE = 0x1702;
        WebGLContext.TEXTURE_CUBE_MAP = 0x8513;
        WebGLContext.TEXTURE_BINDING_CUBE_MAP = 0x8514;
        WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;
        WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;
        WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;
        WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;
        WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;
        WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851A;
        WebGLContext.MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C;
        WebGLContext.TEXTURE0 = 0x84C0;
        WebGLContext.TEXTURE1 = 0x84C1;
        WebGLContext.TEXTURE2 = 0x84C2;
        WebGLContext.TEXTURE3 = 0x84C3;
        WebGLContext.TEXTURE4 = 0x84C4;
        WebGLContext.TEXTURE5 = 0x84C5;
        WebGLContext.TEXTURE6 = 0x84C6;
        WebGLContext.TEXTURE7 = 0x84C7;
        WebGLContext.TEXTURE8 = 0x84C8;
        WebGLContext.TEXTURE9 = 0x84C9;
        WebGLContext.TEXTURE10 = 0x84CA;
        WebGLContext.TEXTURE11 = 0x84CB;
        WebGLContext.TEXTURE12 = 0x84CC;
        WebGLContext.TEXTURE13 = 0x84CD;
        WebGLContext.TEXTURE14 = 0x84CE;
        WebGLContext.TEXTURE15 = 0x84CF;
        WebGLContext.TEXTURE16 = 0x84D0;
        WebGLContext.TEXTURE17 = 0x84D1;
        WebGLContext.TEXTURE18 = 0x84D2;
        WebGLContext.TEXTURE19 = 0x84D3;
        WebGLContext.TEXTURE20 = 0x84D4;
        WebGLContext.TEXTURE21 = 0x84D5;
        WebGLContext.TEXTURE22 = 0x84D6;
        WebGLContext.TEXTURE23 = 0x84D7;
        WebGLContext.TEXTURE24 = 0x84D8;
        WebGLContext.TEXTURE25 = 0x84D9;
        WebGLContext.TEXTURE26 = 0x84DA;
        WebGLContext.TEXTURE27 = 0x84DB;
        WebGLContext.TEXTURE28 = 0x84DC;
        WebGLContext.TEXTURE29 = 0x84DD;
        WebGLContext.TEXTURE30 = 0x84DE;
        WebGLContext.TEXTURE31 = 0x84DF;
        WebGLContext.ACTIVE_TEXTURE = 0x84E0;
        WebGLContext.REPEAT = 0x2901;
        WebGLContext.CLAMP_TO_EDGE = 0x812F;
        WebGLContext.MIRRORED_REPEAT = 0x8370;
        WebGLContext.FLOAT_VEC2 = 0x8B50;
        WebGLContext.FLOAT_VEC3 = 0x8B51;
        WebGLContext.FLOAT_VEC4 = 0x8B52;
        WebGLContext.INT_VEC2 = 0x8B53;
        WebGLContext.INT_VEC3 = 0x8B54;
        WebGLContext.INT_VEC4 = 0x8B55;
        WebGLContext.BOOL = 0x8B56;
        WebGLContext.BOOL_VEC2 = 0x8B57;
        WebGLContext.BOOL_VEC3 = 0x8B58;
        WebGLContext.BOOL_VEC4 = 0x8B59;
        WebGLContext.FLOAT_MAT2 = 0x8B5A;
        WebGLContext.FLOAT_MAT3 = 0x8B5B;
        WebGLContext.FLOAT_MAT4 = 0x8B5C;
        WebGLContext.SAMPLER_2D = 0x8B5E;
        WebGLContext.SAMPLER_CUBE = 0x8B60;
        WebGLContext.VERTEX_ATTRIB_ARRAY_ENABLED = 0x8622;
        WebGLContext.VERTEX_ATTRIB_ARRAY_SIZE = 0x8623;
        WebGLContext.VERTEX_ATTRIB_ARRAY_STRIDE = 0x8624;
        WebGLContext.VERTEX_ATTRIB_ARRAY_TYPE = 0x8625;
        WebGLContext.VERTEX_ATTRIB_ARRAY_NORMALIZED = 0x886A;
        WebGLContext.VERTEX_ATTRIB_ARRAY_POINTER = 0x8645;
        WebGLContext.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889F;
        WebGLContext.COMPILE_STATUS = 0x8B81;
        WebGLContext.LOW_FLOAT = 0x8DF0;
        WebGLContext.MEDIUM_FLOAT = 0x8DF1;
        WebGLContext.HIGH_FLOAT = 0x8DF2;
        WebGLContext.LOW_INT = 0x8DF3;
        WebGLContext.MEDIUM_INT = 0x8DF4;
        WebGLContext.HIGH_INT = 0x8DF5;
        WebGLContext.FRAMEBUFFER = 0x8D40;
        WebGLContext.RENDERBUFFER = 0x8D41;
        WebGLContext.RGBA4 = 0x8056;
        WebGLContext.RGB5_A1 = 0x8057;
        WebGLContext.RGB565 = 0x8D62;
        WebGLContext.DEPTH_COMPONENT16 = 0x81A5;
        WebGLContext.STENCIL_INDEX = 0x1901;
        WebGLContext.STENCIL_INDEX8 = 0x8D48;
        WebGLContext.DEPTH_STENCIL = 0x84F9;
        WebGLContext.RENDERBUFFER_WIDTH = 0x8D42;
        WebGLContext.RENDERBUFFER_HEIGHT = 0x8D43;
        WebGLContext.RENDERBUFFER_INTERNAL_FORMAT = 0x8D44;
        WebGLContext.RENDERBUFFER_RED_SIZE = 0x8D50;
        WebGLContext.RENDERBUFFER_GREEN_SIZE = 0x8D51;
        WebGLContext.RENDERBUFFER_BLUE_SIZE = 0x8D52;
        WebGLContext.RENDERBUFFER_ALPHA_SIZE = 0x8D53;
        WebGLContext.RENDERBUFFER_DEPTH_SIZE = 0x8D54;
        WebGLContext.RENDERBUFFER_STENCIL_SIZE = 0x8D55;
        WebGLContext.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 0x8CD0;
        WebGLContext.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 0x8CD1;
        WebGLContext.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 0x8CD2;
        WebGLContext.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3;
        WebGLContext.COLOR_ATTACHMENT0 = 0x8CE0;
        WebGLContext.DEPTH_ATTACHMENT = 0x8D00;
        WebGLContext.STENCIL_ATTACHMENT = 0x8D20;
        WebGLContext.DEPTH_STENCIL_ATTACHMENT = 0x821A;
        WebGLContext.NONE = 0;
        WebGLContext.FRAMEBUFFER_COMPLETE = 0x8CD5;
        WebGLContext.FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6;
        WebGLContext.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7;
        WebGLContext.FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 0x8CD9;
        WebGLContext.FRAMEBUFFER_UNSUPPORTED = 0x8CDD;
        WebGLContext.FRAMEBUFFER_BINDING = 0x8CA6;
        WebGLContext.RENDERBUFFER_BINDING = 0x8CA7;
        WebGLContext.MAX_RENDERBUFFER_SIZE = 0x84E8;
        WebGLContext.INVALID_FRAMEBUFFER_OPERATION = 0x0506;
        WebGLContext.UNPACK_FLIP_Y_WEBGL = 0x9240;
        WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241;
        WebGLContext.CONTEXT_LOST_WEBGL = 0x9242;
        WebGLContext.UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;
        WebGLContext.BROWSER_DEFAULT_WEBGL = 0x9244;
        WebGLContext._useProgram = null;
        WebGLContext._depthTest = true;
        WebGLContext._depthMask = true;
        WebGLContext._blend = false;
        WebGLContext._cullFace = false;
        WebGLContext.curBindTexTarget = null;
        WebGLContext.curBindTexValue = null;
        __static(WebGLContext, ['_depthFunc', function () { return this._depthFunc = 0x0201; }, '_sFactor', function () { return this._sFactor = 1; }, '_dFactor', function () { return this._dFactor = 0; }, '_frontFace', function () { return this._frontFace = 0x0901; }
        ]);
        return WebGLContext;
    })();
    var GraphicsGL = (function (_super) {
        function GraphicsGL() {
            GraphicsGL.__super.call(this);
        }
        __class(GraphicsGL, 'laya.webgl.display.GraphicsGL', _super);
        var __proto = GraphicsGL.prototype;
        __proto.setShader = function (shader) {
            this._saveToCmd(Render.context._setShader, [shader]);
        };
        __proto.setIBVB = function (x, y, ib, vb, numElement, shader) {
            this._saveToCmd(Render.context._setIBVB, [x, y, ib, vb, numElement, shader]);
        };
        __proto.drawParticle = function (x, y, ps) {
            var pt = RunDriver.createParticleTemplate2D(ps);
            pt.x = x;
            pt.y = y;
            this._saveToCmd(Render.context._drawParticle, [pt]);
        };
        return GraphicsGL;
    })(Graphics);
    var WebGLContext2D = (function (_super) {
        var ContextParams;
        function WebGLContext2D(c) {
            this._x = 0;
            this._y = 0;
            this._id = ++WebGLContext2D._COUNT;
            this._path = null;
            this._drawCount = 1;
            this._maxNumEle = 0;
            this._clear = false;
            this._isMain = false;
            this._atlasResourceChange = 0;
            this._submits = null;
            this._curSubmit = null;
            this._ib = null;
            this._vb = null;
            this._nBlendType = 0;
            this._saveMark = null;
            this._shader2D = null;
            this.meshlist = [];
            this.mId = -1;
            this.mHaveKey = false;
            this.mHaveLineKey = false;
            this.mX = 0;
            this.mY = 0;
            WebGLContext2D.__super.call(this);
            this._width = 99999999;
            this._height = 99999999;
            this._clipRect = WebGLContext2D.MAXCLIPRECT;
            this.mOutPoint;
            this._canvas = c;
            WebGLContext2D._contextcount++;
            if (Render.isFlash) {
                this._ib = IndexBuffer2D.create(0x88E4);
                GlUtils.fillIBQuadrangle(this._ib, 16);
            }
            else
                this._ib = IndexBuffer2D.QuadrangleIB;
            this.clear();
        }
        __class(WebGLContext2D, 'laya.webgl.canvas.WebGLContext2D', _super);
        var __proto = WebGLContext2D.prototype;
        __proto.setIsMainContext = function () {
            this._isMain = true;
        };
        __proto.clearBG = function (r, g, b, a) {
            var gl = WebGL.mainContext;
            gl.clearColor(r, g, b, a);
            gl.clear(0x00004000);
        };
        __proto._getSubmits = function () {
            return this._submits;
        };
        __proto._releaseMem = function () {
            if (!this._submits)
                return;
            this._curMat.destroy();
            this._curMat = null;
            this._shader2D.destroy();
            this._shader2D = null;
            for (var i = 0, n = this._submits._length; i < n; i++)
                this._submits[i].releaseRender();
            this._submits.length = 0;
            this._submits._length = 0;
            this._submits = null;
            this._curSubmit = null;
            this._path && this._path.recover();
            this._path = null;
            this._other && (this._other.font = null);
            this._save = null;
            if (this._vb) {
                this._vb.releaseResource();
                this._vb.destroy();
                this._vb.destory();
                this._vb = null;
            }
        };
        __proto.destroy = function () {
            --WebGLContext2D._contextcount;
            this.sprite = null;
            this._releaseMem();
            this._targets && this._targets.destroy();
            this._targets = null;
            this._canvas = null;
            this._ib && (this._ib != IndexBuffer2D.QuadrangleIB) && this._ib.releaseResource();
        };
        __proto.clear = function () {
            if (!this._submits) {
                this._other = ContextParams.DEFAULT;
                this._curMat = Matrix.create();
                this._vb = VertexBuffer2D.create(-1);
                this._submits = [];
                this._save = [SaveMark.Create(this)];
                this._save.length = 10;
                this._shader2D = new Shader2D();
                this._triangleMesh = MeshTexture.getAMesh();
            }
            this._vb.clear();
            this._targets && (this._targets.repaint = true);
            this._other = ContextParams.DEFAULT;
            this._clear = true;
            this._repaint = false;
            this._drawCount = 1;
            this._renderKey = 0;
            this._other.lineWidth = this._shader2D.ALPHA = 1.0;
            this._nBlendType = 0;
            this._clipRect = WebGLContext2D.MAXCLIPRECT;
            this._curSubmit = Submit.RENDERBASE;
            this._shader2D.glTexture = null;
            this._shader2D.fillStyle = this._shader2D.strokeStyle = DrawStyle.DEFAULT;
            for (var i = 0, n = this._submits._length; i < n; i++)
                this._submits[i].releaseRender();
            this._submits._length = 0;
            this._curMat.identity();
            this._other.clear();
            this._saveMark = this._save[0];
            this._save._length = 1;
        };
        __proto.size = function (w, h) {
            if (this._width != w || this._height != h) {
                if (w == 0 || h == 0) {
                    if (this._vb._byteLength != 0) {
                        this._width = w;
                        this._height = h;
                        this._vb.clear();
                        this._vb.upload();
                    }
                    for (var i = 0, n = this._submits._length; i < n; i++)
                        this._submits[i].releaseRender();
                    this._submits.length = 0;
                    this._submits._length = 0;
                    this._curSubmit = null;
                    this._path && this._path.recover();
                    this._path = null;
                    this.sprite = null;
                    this._targets && (this._targets.destroy());
                    this._targets = null;
                }
                else {
                    this._width = w;
                    this._height = h;
                    this._targets && (this._targets.size(w, h));
                    this._canvas.memorySize -= this._canvas.memorySize;
                }
            }
            if (w === 0 && h === 0)
                this._releaseMem();
        };
        __proto._getTransformMatrix = function () {
            return this._curMat;
        };
        __proto.translate = function (x, y) {
            if (x !== 0 || y !== 0) {
                SaveTranslate.save(this);
                if (this._curMat.bTransform) {
                    SaveTransform.save(this);
                    this._curMat.transformPointN(Point.TEMP.setTo(x, y));
                    x = Point.TEMP.x;
                    y = Point.TEMP.y;
                }
                this._x += x;
                this._y += y;
            }
        };
        __proto.save = function () {
            this._save[this._save._length++] = SaveMark.Create(this);
        };
        __proto.restore = function () {
            var sz = this._save._length;
            if (sz < 1)
                return;
            for (var i = sz - 1; i >= 0; i--) {
                var o = this._save[i];
                o.restore(this);
                if (o.isSaveMark()) {
                    this._save._length = i;
                    return;
                }
            }
        };
        __proto._fillText = function (txt, words, x, y, fontStr, color, strokeColor, lineWidth, textAlign, underLine) {
            (underLine === void 0) && (underLine = 0);
            var shader = this._shader2D;
            var curShader = this._curSubmit.shaderValue;
            var font = fontStr ? FontInContext.create(fontStr) : this._other.font;
            if (AtlasResourceManager.enabled) {
                if (shader.ALPHA !== curShader.ALPHA)
                    shader.glTexture = null;
                DrawText.drawText(this, txt, words, this._curMat, font, textAlign || this._other.textAlign, color, strokeColor, lineWidth, x, y, underLine);
            }
            else {
                var preDef = this._shader2D.defines.getValue();
                var colorAdd = color ? Color.create(color)._color : shader.colorAdd;
                if (shader.ALPHA !== curShader.ALPHA || colorAdd !== shader.colorAdd || curShader.colorAdd !== shader.colorAdd) {
                    shader.glTexture = null;
                    shader.colorAdd = colorAdd;
                }
                DrawText.drawText(this, txt, words, this._curMat, font, textAlign || this._other.textAlign, color, strokeColor, lineWidth, x, y, underLine);
            }
        };
        __proto.fillWords = function (words, x, y, fontStr, color, underLine) {
            this._fillText(null, words, x, y, fontStr, color, null, -1, null, underLine);
        };
        __proto.fillBorderWords = function (words, x, y, font, color, borderColor, lineWidth) {
            this._fillBorderText(null, words, x, y, font, color, borderColor, lineWidth, null);
        };
        __proto.fillText = function (txt, x, y, fontStr, color, textAlign) {
            this._fillText(txt, null, x, y, fontStr, color, null, -1, textAlign);
        };
        __proto.strokeText = function (txt, x, y, fontStr, color, lineWidth, textAlign) {
            this._fillText(txt, null, x, y, fontStr, null, color, lineWidth || 1, textAlign);
        };
        __proto.fillBorderText = function (txt, x, y, fontStr, fillColor, borderColor, lineWidth, textAlign) {
            this._fillBorderText(txt, null, x, y, fontStr, fillColor, borderColor, lineWidth, textAlign);
        };
        __proto._fillBorderText = function (txt, words, x, y, fontStr, fillColor, borderColor, lineWidth, textAlign) {
            if (!AtlasResourceManager.enabled) {
                this._fillText(txt, words, x, y, fontStr, null, borderColor, lineWidth || 1, textAlign);
                this._fillText(txt, words, x, y, fontStr, fillColor, null, -1, textAlign);
                return;
            }
            ;
            var shader = this._shader2D;
            var curShader = this._curSubmit.shaderValue;
            if (shader.ALPHA !== curShader.ALPHA)
                shader.glTexture = null;
            var font = fontStr ? (WebGLContext2D._fontTemp.setFont(fontStr), WebGLContext2D._fontTemp) : this._other.font;
            DrawText.drawText(this, txt, words, this._curMat, font, textAlign || this._other.textAlign, fillColor, borderColor, lineWidth || 1, x, y, 0);
        };
        __proto.fillRect = function (x, y, width, height, fillStyle) {
            var vb = this._vb;
            if (GlUtils.fillRectImgVb(vb, this._clipRect, x, y, width, height, Texture.DEF_UV, this._curMat, this._x, this._y, 0, 0)) {
                this._renderKey = 0;
                var pre = this._shader2D.fillStyle;
                fillStyle && (this._shader2D.fillStyle = DrawStyle.create(fillStyle));
                var shader = this._shader2D;
                var curShader = this._curSubmit.shaderValue;
                if (shader.fillStyle !== curShader.fillStyle || shader.ALPHA !== curShader.ALPHA) {
                    shader.glTexture = null;
                    var submit = this._curSubmit = Submit.createSubmit(this, this._ib, vb, ((vb._byteLength - 16 * 4) / 32) * 3, Value2D.create(0x02, 0));
                    submit.shaderValue.color = shader.fillStyle._color._color;
                    submit.shaderValue.ALPHA = shader.ALPHA;
                    this._submits[this._submits._length++] = submit;
                }
                this._curSubmit._numEle += 6;
                this._shader2D.fillStyle = pre;
            }
        };
        __proto.fillTexture = function (texture, x, y, width, height, type, offset, other) {
            if (!(texture.loaded && texture.bitmap && texture.source)) {
                if (this.sprite) {
                    Laya.timer.callLater(this, this._repaintSprite);
                }
                return;
            }
            ;
            var vb = this._vb;
            var w = texture.bitmap.width, h = texture.bitmap.height, uv = texture.uv;
            var ox = offset.x % texture.width, oy = offset.y % texture.height;
            if (w != other.w || h != other.h) {
                if (!other.w && !other.h) {
                    other.oy = other.ox = 0;
                    switch (type) {
                        case "repeat":
                            other.width = width;
                            other.height = height;
                            break;
                        case "no-repeat":
                            if (ox < 0) {
                                if (texture.width + ox > width) {
                                    other.width = width;
                                } else {
                                    other.width = texture.width + ox;
                                }
                            } else {
                                other.ox = ox;
                                if (texture.width + ox > width) {
                                    other.width = width - ox;
                                } else {
                                    other.width = texture.width;
                                }
                            }
                            if (oy < 0) {
                                if (texture.height + oy > height) {
                                    other.height = height;
                                } else {
                                    other.height = texture.height + oy;
                                }
                            } else {
                                other.oy = oy;
                                if (texture.height + oy > height) {
                                    other.height = height - oy;
                                } else {
                                    other.height = texture.height;
                                }
                            }
                            break;
                        case "repeat-x":
                            other.width = width;
                            if (oy < 0) {
                                if (texture.height + oy > height) {
                                    other.height = height;
                                }
                                else {
                                    other.height = texture.height + oy;
                                }
                            }
                            else {
                                other.oy = oy;
                                if (texture.height + oy > height) {
                                    other.height = height - oy;
                                }
                                else {
                                    other.height = texture.height;
                                }
                            }
                            break;
                        case "repeat-y":
                            if (ox < 0) {
                                if (texture.width + ox > width) {
                                    other.width = width;
                                }
                                else {
                                    other.width = texture.width + ox;
                                }
                            }
                            else {
                                other.ox = ox;
                                if (texture.width + ox > width) {
                                    other.width = width - ox;
                                }
                                else {
                                    other.width = texture.width;
                                }
                            }
                            other.height = height;
                            break;
                        default:
                            other.width = width;
                            other.height = height;
                            break;
                    }
                }
                other.w = w;
                other.h = h;
                other.uv = [0, 0, other.width / w, 0, other.width / w, other.height / h, 0, other.height / h];
            }
            x += other.ox;
            y += other.oy;
            ox -= other.ox;
            oy -= other.oy;
            if (GlUtils.fillRectImgVb(vb, this._clipRect, x, y, other.width, other.height, other.uv, this._curMat, this._x, this._y, 0, 0)) {
                this._renderKey = 0;
                var submit = SubmitTexture.create(this, this._ib, vb, ((vb._byteLength - 16 * 4) / 32) * 3, Value2D.create(0x100, 0));
                this._submits[this._submits._length++] = submit;
                var shaderValue = submit.shaderValue;
                shaderValue.textureHost = texture;
                var tTextureX = uv[0] * w;
                var tTextureY = uv[1] * h;
                var tTextureW = (uv[2] - uv[0]) * w;
                var tTextureH = (uv[5] - uv[3]) * h;
                var tx = -ox / w;
                var ty = -oy / h;
                shaderValue.u_TexRange[0] = tTextureX / w;
                shaderValue.u_TexRange[1] = tTextureW / w;
                shaderValue.u_TexRange[2] = tTextureY / h;
                shaderValue.u_TexRange[3] = tTextureH / h;
                shaderValue.u_offset[0] = tx;
                shaderValue.u_offset[1] = ty;
                if (AtlasResourceManager.enabled && !this._isMain)
                    submit.addTexture(texture, (vb._byteLength >> 2) - 16);
                this._curSubmit = submit;
                submit._renderType = 10017;
                submit._numEle += 6;
            }
        };
        __proto.setShader = function (shader) {
            SaveBase.save(this, 0x100000, this._shader2D, true);
            this._shader2D.shader = shader;
        };
        __proto.setFilters = function (value) {
            SaveBase.save(this, 0x200000, this._shader2D, true);
            this._shader2D.filters = value;
            this._curSubmit = Submit.RENDERBASE;
            this._renderKey = 0;
            this._drawCount++;
        };
        __proto.drawTexture = function (tex, x, y, width, height, tx, ty) {
            this._drawTextureM(tex, x, y, width, height, tx, ty, null, 1);
        };
        __proto.addTextureVb = function (invb, x, y) {
            var finalVB = this._curSubmit._vb || this._vb;
            var vpos = (finalVB._byteLength >> 2);
            finalVB.byteLength = ((vpos + 16) << 2);
            var vbdata = finalVB.getFloat32Array();
            for (var i = 0, ci = 0; i < 16; i += 4) {
                vbdata[vpos++] = invb[i] + x;
                vbdata[vpos++] = invb[i + 1] + y;
                vbdata[vpos++] = invb[i + 2];
                vbdata[vpos++] = invb[i + 3];
            }
            this._curSubmit._numEle += 6;
            this._maxNumEle = Math.max(this._maxNumEle, this._curSubmit._numEle);
            finalVB._upload = true;
        };
        __proto.willDrawTexture = function (tex, alpha) {
            if (!(tex.loaded && tex.bitmap && tex.source)) {
                if (this.sprite) {
                    Laya.timer.callLater(this, this._repaintSprite);
                }
                return 0;
            }
            ;
            var webGLImg = tex.bitmap;
            var rid = webGLImg.id + this._shader2D.ALPHA * alpha + 10016;
            if (rid == this._renderKey)
                return rid;
            var shader = this._shader2D;
            var preAlpha = shader.ALPHA;
            var curShader = this._curSubmit.shaderValue;
            shader.ALPHA *= alpha;
            this._renderKey = rid;
            this._drawCount++;
            shader.glTexture = webGLImg;
            var vb = this._vb;
            var submit = null;
            var vbSize = (vb._byteLength / 32) * 3;
            submit = SubmitTexture.create(this, this._ib, vb, vbSize, Value2D.create(0x01, 0));
            this._submits[this._submits._length++] = submit;
            submit.shaderValue.textureHost = tex;
            submit._renderType = 10016;
            submit._preIsSameTextureShader = this._curSubmit._renderType === 10016 && shader.ALPHA === curShader.ALPHA;
            this._curSubmit = submit;
            shader.ALPHA = preAlpha;
            return rid;
        };
        __proto.drawTextures = function (tex, pos, tx, ty) {
            if (!(tex.loaded && tex.bitmap && tex.source)) {
                this.sprite && Laya.timer.callLater(this, this._repaintSprite);
                return;
            }
            ;
            var pre = this._clipRect;
            this._clipRect = WebGLContext2D.MAXCLIPRECT;
            if (!this._drawTextureM(tex, pos[0], pos[1], tex.width, tex.height, tx, ty, null, 1)) {
                alert("drawTextures err");
                return;
            }
            this._clipRect = pre;
            Stat.drawCall++;
            if (pos.length < 4)
                return;
            var finalVB = this._curSubmit._vb || this._vb;
            var sx = this._curMat.a, sy = this._curMat.d;
            for (var i = 2, sz = pos.length; i < sz; i += 2) {
                GlUtils.copyPreImgVb(finalVB, (pos[i] - pos[i - 2]) * sx, (pos[i + 1] - pos[i - 1]) * sy);
                this._curSubmit._numEle += 6;
            }
            this._maxNumEle = Math.max(this._maxNumEle, this._curSubmit._numEle);
        };
        __proto._drawTextureM = function (tex, x, y, width, height, tx, ty, m, alpha) {
            if (!(tex.loaded && tex.source)) {
                if (this.sprite) {
                    Laya.timer.callLater(this, this._repaintSprite);
                }
                return false;
            }
            ;
            var finalVB = this._curSubmit._vb || this._vb;
            var webGLImg = tex.bitmap;
            x += tx;
            y += ty;
            this._drawCount++;
            var rid = webGLImg.id + this._shader2D.ALPHA * alpha + 10016;
            if (rid != this._renderKey) {
                this._renderKey = rid;
                var curShader = this._curSubmit.shaderValue;
                var shader = this._shader2D;
                var alphaBack = shader.ALPHA;
                shader.ALPHA *= alpha;
                shader.glTexture = webGLImg;
                var vb = this._vb;
                var submit = null;
                var vbSize = (vb._byteLength / 32) * 3;
                submit = SubmitTexture.create(this, this._ib, vb, vbSize, Value2D.create(0x01, 0));
                this._submits[this._submits._length++] = submit;
                submit.shaderValue.textureHost = tex;
                submit._renderType = 10016;
                submit._preIsSameTextureShader = this._curSubmit._renderType === 10016 && shader.ALPHA === curShader.ALPHA;
                this._curSubmit = submit;
                finalVB = this._curSubmit._vb || this._vb;
                shader.ALPHA = alphaBack;
            }
            if (GlUtils.fillRectImgVb(finalVB, this._clipRect, x, y, width || tex.width, height || tex.height, tex.uv, m || this._curMat, this._x, this._y, 0, 0)) {
                if (AtlasResourceManager.enabled && !this._isMain)
                    (this._curSubmit).addTexture(tex, (finalVB._byteLength >> 2) - 16);
                this._curSubmit._numEle += 6;
                this._maxNumEle = Math.max(this._maxNumEle, this._curSubmit._numEle);
                return true;
            }
            return false;
        };
        __proto._repaintSprite = function () {
            if (this.sprite)
                this.sprite.repaint();
        };
        __proto._drawText = function (tex, x, y, width, height, m, tx, ty, dx, dy) {
            var webGLImg = tex.bitmap;
            this._drawCount++;
            var rid = webGLImg.id + this._shader2D.ALPHA + 10016;
            if (rid != this._renderKey) {
                this._renderKey = rid;
                var curShader = this._curSubmit.shaderValue;
                var shader = this._shader2D;
                shader.glTexture = webGLImg;
                var vb = this._vb;
                var submit = null;
                var submitID = NaN;
                var vbSize = (vb._byteLength / 32) * 3;
                if (AtlasResourceManager.enabled) {
                    submit = SubmitTexture.create(this, this._ib, vb, vbSize, Value2D.create(0x01, 0));
                }
                else {
                    submit = SubmitTexture.create(this, this._ib, vb, vbSize, TextSV.create());
                }
                submit._preIsSameTextureShader = this._curSubmit._renderType === 10016 && shader.ALPHA === curShader.ALPHA;
                this._submits[this._submits._length++] = submit;
                submit.shaderValue.textureHost = tex;
                submit._renderType = 10016;
                this._curSubmit = submit;
            }
            tex.active();
            var finalVB = this._curSubmit._vb || this._vb;
            if (GlUtils.fillRectImgVb(finalVB, this._clipRect, x + tx, y + ty, width || tex.width, height || tex.height, tex.uv, m || this._curMat, this._x, this._y, dx, dy, true)) {
                if (AtlasResourceManager.enabled && !this._isMain) {
                    (this._curSubmit).addTexture(tex, (finalVB._byteLength >> 2) - 16);
                }
                this._curSubmit._numEle += 6;
                this._maxNumEle = Math.max(this._maxNumEle, this._curSubmit._numEle);
            }
        };
        __proto.drawTextureWithTransform = function (tex, x, y, width, height, transform, tx, ty, alpha) {
            if (!transform) {
                this._drawTextureM(tex, x, y, width, height, tx, ty, null, alpha);
                return;
            }
            ;
            var curMat = this._curMat;
            var prex = this._x;
            var prey = this._y;
            (tx !== 0 || ty !== 0) && (this._x = tx * curMat.a + ty * curMat.c, this._y = ty * curMat.d + tx * curMat.b);
            if (transform && curMat.bTransform) {
                Matrix.mul(transform, curMat, WebGLContext2D._tmpMatrix);
                transform = WebGLContext2D._tmpMatrix;
                transform._checkTransform();
            }
            else {
                this._x += curMat.tx;
                this._y += curMat.ty;
            }
            this._drawTextureM(tex, x, y, width, height, 0, 0, transform, alpha);
            this._x = prex;
            this._y = prey;
        };
        __proto.fillQuadrangle = function (tex, x, y, point4, m) {
            var submit = this._curSubmit;
            var vb = this._vb;
            var shader = this._shader2D;
            var curShader = submit.shaderValue;
            this._renderKey = 0;
            if (tex.bitmap) {
                var t_tex = tex.bitmap;
                if (shader.glTexture != t_tex || shader.ALPHA !== curShader.ALPHA) {
                    shader.glTexture = t_tex;
                    submit = this._curSubmit = Submit.createSubmit(this, this._ib, vb, ((vb._byteLength) / 32) * 3, Value2D.create(0x01, 0));
                    submit.shaderValue.glTexture = t_tex;
                    this._submits[this._submits._length++] = submit;
                }
                GlUtils.fillQuadrangleImgVb(vb, x, y, point4, tex.uv, m || this._curMat, this._x, this._y);
            }
            else {
                if (!submit.shaderValue.fillStyle || !submit.shaderValue.fillStyle.equal(tex) || shader.ALPHA !== curShader.ALPHA) {
                    shader.glTexture = null;
                    submit = this._curSubmit = Submit.createSubmit(this, this._ib, vb, ((vb._byteLength) / 32) * 3, Value2D.create(0x02, 0));
                    submit.shaderValue.defines.add(0x02);
                    submit.shaderValue.fillStyle = DrawStyle.create(tex);
                    this._submits[this._submits._length++] = submit;
                }
                GlUtils.fillQuadrangleImgVb(vb, x, y, point4, Texture.DEF_UV, m || this._curMat, this._x, this._y);
            }
            submit._numEle += 6;
        };
        __proto.drawTexture2 = function (x, y, pivotX, pivotY, transform, alpha, blendMode, args) {
            if (alpha == 0)
                return;
            var curMat = this._curMat;
            this._x = x * curMat.a + y * curMat.c;
            this._y = y * curMat.d + x * curMat.b;
            if (transform) {
                if (curMat.bTransform || transform.bTransform) {
                    Matrix.mul(transform, curMat, WebGLContext2D._tmpMatrix);
                    transform = WebGLContext2D._tmpMatrix;
                }
                else {
                    this._x += transform.tx + curMat.tx;
                    this._y += transform.ty + curMat.ty;
                    transform = Matrix.EMPTY;
                }
            }
            if (alpha === 1 && !blendMode)
                this._drawTextureM(args[0], args[1] - pivotX, args[2] - pivotY, args[3], args[4], 0, 0, transform, 1);
            else {
                var preAlpha = this._shader2D.ALPHA;
                var preblendType = this._nBlendType;
                this._shader2D.ALPHA = alpha;
                blendMode && (this._nBlendType = BlendMode.TOINT(blendMode));
                this._drawTextureM(args[0], args[1] - pivotX, args[2] - pivotY, args[3], args[4], 0, 0, transform, 1);
                this._shader2D.ALPHA = preAlpha;
                this._nBlendType = preblendType;
            }
            this._x = this._y = 0;
        };
        __proto.drawCanvas = function (canvas, x, y, width, height) {
            var src = canvas.context;
            this._renderKey = 0;
            if (src._targets) {
                this._submits[this._submits._length++] = SubmitCanvas.create(src, 0, null);
                this._curSubmit = Submit.RENDERBASE;
                src._targets.drawTo(this, x, y, width, height);
            }
            else {
                var submit = this._submits[this._submits._length++] = SubmitCanvas.create(src, this._shader2D.ALPHA, this._shader2D.filters);
                var sx = width / canvas.width;
                var sy = height / canvas.height;
                var mat = submit._matrix;
                this._curMat.copyTo(mat);
                sx != 1 && sy != 1 && mat.scale(sx, sy);
                var tx = mat.tx, ty = mat.ty;
                mat.tx = mat.ty = 0;
                mat.transformPoint(Point.TEMP.setTo(x, y));
                mat.translate(Point.TEMP.x + tx, Point.TEMP.y + ty);
                this._curSubmit = Submit.RENDERBASE;
            }
            if (Config.showCanvasMark) {
                this.save();
                this.lineWidth = 4;
                this.strokeStyle = src._targets ? "yellow" : "green";
                this.strokeRect(x - 1, y - 1, width + 2, height + 2, 1);
                this.strokeRect(x, y, width, height, 1);
                this.restore();
            }
        };
        __proto.drawTarget = function (scope, x, y, width, height, m, proName, shaderValue, uv, blend) {
            (blend === void 0) && (blend = -1);
            var vb = this._vb;
            if (GlUtils.fillRectImgVb(vb, this._clipRect, x, y, width, height, uv || Texture.DEF_UV, m || this._curMat, this._x, this._y, 0, 0)) {
                this._renderKey = 0;
                var shader = this._shader2D;
                shader.glTexture = null;
                var curShader = this._curSubmit.shaderValue;
                var submit = this._curSubmit = SubmitTarget.create(this, this._ib, vb, ((vb._byteLength - 16 * 4) / 32) * 3, shaderValue, proName);
                if (blend == -1) {
                    submit.blendType = this._nBlendType;
                }
                else {
                    submit.blendType = blend;
                }
                submit.scope = scope;
                this._submits[this._submits._length++] = submit;
                this._curSubmit._numEle += 6;
            }
        };
        __proto.mixRGBandAlpha = function (color) {
            return this._mixRGBandAlpha(color, this._shader2D.ALPHA);
        };
        __proto._mixRGBandAlpha = function (color, alpha) {
            var a = ((color & 0xff000000) >>> 24);
            if (a != 0) {
                a *= alpha;
            }
            else {
                a = alpha * 255;
            }
            return (color & 0x00ffffff) | (a << 24);
        };
        __proto.drawTriangles = function (tex, x, y, vertices, uvs, indices, matrix, alpha, color, blendMode) {
            if (!(tex.loaded && tex.source)) {
                if (this.sprite) {
                    Laya.timer.callLater(this, this._repaintSprite);
                }
                return false;
            }
            this._drawCount++;
            var webGLImg = tex.bitmap;
            var rgba = this._mixRGBandAlpha(0xffffffff, alpha);
            var vertNum = vertices.length / 2;
            var eleNum = indices.length;
            this._renderKey = -1;
            var submit = this._curSubmit = SubmitTexture.create(this, this._triangleMesh.getIBR(), this._triangleMesh.getVBR(), this._triangleMesh.indexNum, Value2D.create(0x01, 0));
            submit.shaderValue.textureHost = tex;
            submit._renderType = 10016;
            this._submits[this._submits._length++] = submit;
            if (matrix) {
                WebGLContext2D._tmpMatrix.a = matrix.a;
                WebGLContext2D._tmpMatrix.b = matrix.b;
                WebGLContext2D._tmpMatrix.c = matrix.c;
                WebGLContext2D._tmpMatrix.d = matrix.d;
                WebGLContext2D._tmpMatrix.tx = matrix.tx + x;
                WebGLContext2D._tmpMatrix.ty = matrix.ty + y;
                Matrix.mul(WebGLContext2D._tmpMatrix, this._curMat, WebGLContext2D._tmpMatrix);
            }
            else {
                WebGLContext2D._tmpMatrix.a = this._curMat.a;
                WebGLContext2D._tmpMatrix.b = this._curMat.b;
                WebGLContext2D._tmpMatrix.c = this._curMat.c;
                WebGLContext2D._tmpMatrix.d = this._curMat.d;
                WebGLContext2D._tmpMatrix.tx = this._curMat.tx + x;
                WebGLContext2D._tmpMatrix.ty = this._curMat.ty + y;
            }
            this._triangleMesh.addData(vertices, uvs, indices, WebGLContext2D._tmpMatrix, rgba, this);
            this._curSubmit._numEle += eleNum;
            this._maxNumEle = Math.max(this._maxNumEle, this._curSubmit._numEle);
            return true;
        };
        __proto.transform = function (a, b, c, d, tx, ty) {
            SaveTransform.save(this);
            Matrix.mul(Matrix.TEMP.setTo(a, b, c, d, tx, ty), this._curMat, this._curMat);
            this._curMat._checkTransform();
        };
        __proto.setTransformByMatrix = function (value) {
            value.copyTo(this._curMat);
        };
        __proto.transformByMatrix = function (value) {
            SaveTransform.save(this);
            Matrix.mul(value, this._curMat, this._curMat);
            this._curMat._checkTransform();
        };
        __proto.rotate = function (angle) {
            SaveTransform.save(this);
            this._curMat.rotateEx(angle);
        };
        __proto.scale = function (scaleX, scaleY) {
            SaveTransform.save(this);
            this._curMat.scaleEx(scaleX, scaleY);
        };
        __proto.clipRect = function (x, y, width, height) {
            if (this._curMat.b != 0 || this._curMat.c != 0) {
                this._renderKey = 0;
                var submitStencil0 = SubmitStencil.create(4);
                this.addRenderObject(submitStencil0);
                var vb = this._vb;
                var nPos = (vb._byteLength >> 2);
                if (GlUtils.fillRectImgVb(vb, null, x, y, width, height, Texture.DEF_UV, this._curMat, this._x, this._y, 0, 0)) {
                    var shader = this._shader2D;
                    shader.glTexture = null;
                    var submit = this._curSubmit = Submit.createSubmit(this, this._ib, vb, ((vb._byteLength - 16 * 4) / 32) * 3, Value2D.create(0x02, 0));
                    submit.shaderValue.ALPHA = 1.0;
                    this._submits[this._submits._length++] = submit;
                    this._curSubmit._numEle += 6;
                }
                else {
                    alert("clipRect calc stencil rect error");
                }
                ;
                var submitStencil1 = SubmitStencil.create(5);
                this.addRenderObject(submitStencil1);
                var vbdata = vb.getFloat32Array();
                var minx = Math.min(Math.min(Math.min(vbdata[nPos + 0], vbdata[nPos + 4]), vbdata[nPos + 8]), vbdata[nPos + 12]);
                var maxx = Math.max(Math.max(Math.max(vbdata[nPos + 0], vbdata[nPos + 4]), vbdata[nPos + 8]), vbdata[nPos + 12]);
                var miny = Math.min(Math.min(Math.min(vbdata[nPos + 1], vbdata[nPos + 5]), vbdata[nPos + 9]), vbdata[nPos + 13]);
                var maxy = Math.max(Math.max(Math.max(vbdata[nPos + 1], vbdata[nPos + 5]), vbdata[nPos + 9]), vbdata[nPos + 13]);
                SaveClipRectStencil.save(this, submitStencil1, x, y, width, height, minx, miny, maxx - minx, maxy - miny);
                this._curSubmit = Submit.RENDERBASE;
            }
            else {
                width *= this._curMat.a;
                height *= this._curMat.d;
                var p = Point.TEMP;
                this._curMat.transformPoint(p.setTo(x, y));
                if (width < 0) {
                    p.x = p.x + width;
                    width = -width;
                }
                if (height < 0) {
                    p.y = p.y + height;
                    height = -height;
                }
                this._renderKey = 0;
                var submitSc = this._curSubmit = SubmitScissor.create(this);
                this._submits[this._submits._length++] = submitSc;
                submitSc.submitIndex = this._submits._length;
                submitSc.submitLength = 9999999;
                SaveClipRect.save(this, submitSc);
                var clip = this._clipRect;
                var x1 = clip.x, y1 = clip.y;
                var r = p.x + width, b = p.y + height;
                x1 < p.x && (clip.x = p.x);
                y1 < p.y && (clip.y = p.y);
                clip.width = Math.min(r, x1 + clip.width) - clip.x;
                clip.height = Math.min(b, y1 + clip.height) - clip.y;
                this._shader2D.glTexture = null;
                submitSc.clipRect.copyFrom(clip);
                this._curSubmit = Submit.RENDERBASE;
            }
        };
        __proto.setIBVB = function (x, y, ib, vb, numElement, mat, shader, shaderValues, startIndex, offset, type) {
            (startIndex === void 0) && (startIndex = 0);
            (offset === void 0) && (offset = 0);
            (type === void 0) && (type = 0);
            if (ib === null) {
                if (!Render.isFlash) {
                    ib = this._ib;
                }
                else {
                    var falshVB = vb;
                    (falshVB._selfIB) || (falshVB._selfIB = IndexBuffer2D.create(0x88E4));
                    falshVB._selfIB.clear();
                    ib = falshVB._selfIB;
                }
                GlUtils.expandIBQuadrangle(ib, (vb._byteLength / (4 * vb.vertexStride * 4)));
            }
            if (!shaderValues || !shader)
                throw Error("setIBVB must input:shader shaderValues");
            var submit = SubmitOtherIBVB.create(this, vb, ib, numElement, shader, shaderValues, startIndex, offset, type);
            mat || (mat = Matrix.EMPTY);
            mat.translate(x, y);
            Matrix.mul(mat, this._curMat, submit._mat);
            mat.translate(-x, -y);
            this._submits[this._submits._length++] = submit;
            this._curSubmit = Submit.RENDERBASE;
            this._renderKey = 0;
        };
        __proto.addRenderObject = function (o) {
            this._submits[this._submits._length++] = o;
        };
        __proto.fillTrangles = function (tex, x, y, points, m) {
            var submit = this._curSubmit;
            var vb = this._vb;
            var shader = this._shader2D;
            var curShader = submit.shaderValue;
            var length = points.length >> 4;
            var t_tex = tex.bitmap;
            this._renderKey = 0;
            if (shader.glTexture != t_tex || shader.ALPHA !== curShader.ALPHA) {
                submit = this._curSubmit = Submit.createSubmit(this, this._ib, vb, ((vb._byteLength) / 32) * 3, Value2D.create(0x01, 0));
                submit.shaderValue.textureHost = tex;
                this._submits[this._submits._length++] = submit;
            }
            GlUtils.fillTranglesVB(vb, x, y, points, m || this._curMat, this._x, this._y);
            submit._numEle += length * 6;
        };
        __proto.submitElement = function (start, end) {
            var renderList = this._submits;
            end < 0 && (end = renderList._length);
            while (start < end) {
                start += renderList[start].renderSubmit();
            }
        };
        __proto.finish = function () {
            WebGL.mainContext.finish();
        };
        __proto.flush = function () {
            var maxNum = Math.max(this._vb._byteLength / (4 * 16), this._maxNumEle / 6) + 8;
            if (maxNum > (this._ib.bufferLength / (6 * 2))) {
                GlUtils.expandIBQuadrangle(this._ib, maxNum);
            }
            if (!this._isMain && AtlasResourceManager.enabled && AtlasResourceManager._atlasRestore > this._atlasResourceChange) {
                this._atlasResourceChange = AtlasResourceManager._atlasRestore;
                var renderList = this._submits;
                for (var i = 0, s = renderList._length; i < s; i++) {
                    var submit = renderList[i];
                    if (submit.getRenderType() === 10016)
                        (submit).checkTexture();
                }
            }
            this.submitElement(0, this._submits._length);
            this._path && this._path.reset();
            SkinMeshBuffer.instance && SkinMeshBuffer.getInstance().reset();
            var sz = 0;
            for (i = 0, sz = this.meshlist.length; i < sz; i++) {
                var curm = this.meshlist[i];
                curm.canReuse ? (curm.releaseMesh()) : (curm.destroy());
            }
            this.meshlist.length = 0;
            this._curSubmit = Submit.RENDERBASE;
            this._renderKey = 0;
            this._triangleMesh = MeshTexture.getAMesh();
            this.meshlist.push(this._triangleMesh);
            return this._submits._length;
        };
        __proto.setPathId = function (id) {
            this.mId = id;
            if (this.mId != -1) {
                this.mHaveKey = false;
                var tVGM = VectorGraphManager.getInstance();
                if (tVGM.shapeDic[this.mId]) {
                    this.mHaveKey = true;
                }
                this.mHaveLineKey = false;
                if (tVGM.shapeLineDic[this.mId]) {
                    this.mHaveLineKey = true;
                }
            }
        };
        __proto.movePath = function (x, y) {
            var _x1 = x, _y1 = y;
            x = this._curMat.a * _x1 + this._curMat.c * _y1 + this._curMat.tx;
            y = this._curMat.b * _x1 + this._curMat.d * _y1 + this._curMat.ty;
            this.mX += x;
            this.mY += y;
        };
        __proto.beginPath = function () {
            var tPath = this._getPath();
            tPath.tempArray.length = 0;
            tPath.closePath = false;
            this.mX = 0;
            this.mY = 0;
        };
        __proto.closePath = function () {
            this._path.closePath = true;
        };
        __proto.fill = function (isConvexPolygon) {
            (isConvexPolygon === void 0) && (isConvexPolygon = false);
            var tPath = this._getPath();
            this.drawPoly(0, 0, tPath.tempArray, this.fillStyle._color.numColor, 0, 0, isConvexPolygon);
        };
        __proto.stroke = function () {
            var tPath = this._getPath();
            if (this.lineWidth > 0) {
                if (this.mId == -1) {
                    tPath.drawLine(0, 0, tPath.tempArray, this.lineWidth, this.strokeStyle._color.numColor);
                }
                else {
                    if (this.mHaveLineKey) {
                        var tShapeLine = VectorGraphManager.getInstance().shapeLineDic[this.mId];
                        tShapeLine.rebuild(tPath.tempArray);
                        tPath.setGeomtry(tShapeLine);
                    }
                    else {
                        VectorGraphManager.getInstance().addLine(this.mId, tPath.drawLine(0, 0, tPath.tempArray, this.lineWidth, this.strokeStyle._color.numColor));
                    }
                }
                tPath.update();
                var tPosArray = [this.mX, this.mY];
                var tempSubmit = Submit.createShape(this, tPath.ib, tPath.vb, tPath.count, tPath.offset, Value2D.create(0x04, 0));
                tempSubmit.shaderValue.ALPHA = this._shader2D.ALPHA;
                (tempSubmit.shaderValue).u_pos = tPosArray;
                tempSubmit.shaderValue.u_mmat2 = RenderState2D.TEMPMAT4_ARRAY;
                this._submits[this._submits._length++] = tempSubmit;
            }
        };
        __proto.line = function (fromX, fromY, toX, toY, lineWidth, mat) {
            var submit = this._curSubmit;
            var vb = this._vb;
            if (GlUtils.fillLineVb(vb, this._clipRect, fromX, fromY, toX, toY, lineWidth, mat)) {
                this._renderKey = 0;
                var shader = this._shader2D;
                var curShader = submit.shaderValue;
                if (shader.strokeStyle !== curShader.strokeStyle || shader.ALPHA !== curShader.ALPHA) {
                    shader.glTexture = null;
                    submit = this._curSubmit = Submit.createSubmit(this, this._ib, vb, ((vb._byteLength - 16 * 4) / 32) * 3, Value2D.create(0x02, 0));
                    submit.shaderValue.strokeStyle = shader.strokeStyle;
                    submit.shaderValue.mainID = 0x02;
                    submit.shaderValue.ALPHA = shader.ALPHA;
                    this._submits[this._submits._length++] = submit;
                }
                submit._numEle += 6;
            }
        };
        __proto.moveTo = function (x, y, b) {
            (b === void 0) && (b = true);
            var tPath = this._getPath();
            if (b) {
                var _x1 = x, _y1 = y;
                x = this._curMat.a * _x1 + this._curMat.c * _y1;
                y = this._curMat.b * _x1 + this._curMat.d * _y1;
            }
            tPath.addPoint(x, y);
        };
        __proto.lineTo = function (x, y, b) {
            (b === void 0) && (b = true);
            var tPath = this._getPath();
            if (b) {
                var _x1 = x, _y1 = y;
                x = this._curMat.a * _x1 + this._curMat.c * _y1;
                y = this._curMat.b * _x1 + this._curMat.d * _y1;
            }
            tPath.addPoint(x, y);
        };
        __proto.drawCurves = function (x, y, args) {
            this.setPathId(-1);
            this.beginPath();
            this.strokeStyle = args[3];
            this.lineWidth = args[4];
            var points = args[2];
            x += args[0], y += args[1];
            this.movePath(x, y);
            this.moveTo(points[0], points[1]);
            var i = 2, n = points.length;
            while (i < n) {
                this.quadraticCurveTo(points[i++], points[i++], points[i++], points[i++]);
            }
            this.stroke();
        };
        __proto.arcTo = function (x1, y1, x2, y2, r) {
            if (this.mId != -1) {
                if (this.mHaveKey) {
                    return;
                }
            }
            ;
            var i = 0;
            var x = 0, y = 0;
            var tPath = this._getPath();
            this._curMat.copyTo(WebGLContext2D._tmpMatrix);
            WebGLContext2D._tmpMatrix.tx = WebGLContext2D._tmpMatrix.ty = 0;
            WebGLContext2D._tempPoint.setTo(tPath.getEndPointX(), tPath.getEndPointY());
            WebGLContext2D._tmpMatrix.invertTransformPoint(WebGLContext2D._tempPoint);
            var dx = WebGLContext2D._tempPoint.x - x1;
            var dy = WebGLContext2D._tempPoint.y - y1;
            var len1 = Math.sqrt(dx * dx + dy * dy);
            if (len1 <= 0.000001) {
                return;
            }
            ;
            var ndx = dx / len1;
            var ndy = dy / len1;
            var dx2 = x2 - x1;
            var dy2 = y2 - y1;
            var len22 = dx2 * dx2 + dy2 * dy2;
            var len2 = Math.sqrt(len22);
            if (len2 <= 0.000001) {
                return;
            }
            ;
            var ndx2 = dx2 / len2;
            var ndy2 = dy2 / len2;
            var odx = ndx + ndx2;
            var ody = ndy + ndy2;
            var olen = Math.sqrt(odx * odx + ody * ody);
            if (olen <= 0.000001) {
                return;
            }
            ;
            var nOdx = odx / olen;
            var nOdy = ody / olen;
            var alpha = Math.acos(nOdx * ndx + nOdy * ndy);
            var halfAng = Math.PI / 2 - alpha;
            len1 = r / Math.tan(halfAng);
            var ptx1 = len1 * ndx + x1;
            var pty1 = len1 * ndy + y1;
            var orilen = Math.sqrt(len1 * len1 + r * r);
            var orix = x1 + nOdx * orilen;
            var oriy = y1 + nOdy * orilen;
            var ptx2 = len1 * ndx2 + x1;
            var pty2 = len1 * ndy2 + y1;
            var dir = ndx * ndy2 - ndy * ndx2;
            var fChgAng = 0;
            var sinx = 0.0;
            var cosx = 0.0;
            if (dir >= 0) {
                fChgAng = halfAng * 2;
                var fda = fChgAng / WebGLContext2D.SEGNUM;
                sinx = Math.sin(fda);
                cosx = Math.cos(fda);
            }
            else {
                fChgAng = -halfAng * 2;
                fda = fChgAng / WebGLContext2D.SEGNUM;
                sinx = Math.sin(fda);
                cosx = Math.cos(fda);
            }
            x = this._curMat.a * ptx1 + this._curMat.c * pty1;
            y = this._curMat.b * ptx1 + this._curMat.d * pty1;
            if (x != this._path.getEndPointX() || y != this._path.getEndPointY()) {
                tPath.addPoint(x, y);
            }
            ;
            var cvx = ptx1 - orix;
            var cvy = pty1 - oriy;
            var tx = 0.0;
            var ty = 0.0;
            for (i = 0; i < WebGLContext2D.SEGNUM; i++) {
                var cx = cvx * cosx + cvy * sinx;
                var cy = -cvx * sinx + cvy * cosx;
                x = cx + orix;
                y = cy + oriy;
                x1 = this._curMat.a * x + this._curMat.c * y;
                y1 = this._curMat.b * x + this._curMat.d * y;
                x = x1;
                y = y1;
                if (x != this._path.getEndPointX() || y != this._path.getEndPointY()) {
                    tPath.addPoint(x, y);
                }
                cvx = cx;
                cvy = cy;
            }
        };
        __proto.arc = function (cx, cy, r, startAngle, endAngle, counterclockwise, b) {
            (counterclockwise === void 0) && (counterclockwise = false);
            (b === void 0) && (b = true);
            if (this.mId != -1) {
                var tShape = VectorGraphManager.getInstance().shapeDic[this.mId];
                if (tShape) {
                    if (this.mHaveKey && !tShape.needUpdate(this._curMat))
                        return;
                }
                cx = 0;
                cy = 0;
            }
            ;
            var a = 0, da = 0, hda = 0, kappa = 0;
            var dx = 0, dy = 0, x = 0, y = 0, tanx = 0, tany = 0;
            var px = 0, py = 0, ptanx = 0, ptany = 0;
            var i = 0, ndivs = 0, nvals = 0;
            da = endAngle - startAngle;
            if (!counterclockwise) {
                if (Math.abs(da) >= Math.PI * 2) {
                    da = Math.PI * 2;
                }
                else {
                    while (da < 0.0) {
                        da += Math.PI * 2;
                    }
                }
            }
            else {
                if (Math.abs(da) >= Math.PI * 2) {
                    da = -Math.PI * 2;
                }
                else {
                    while (da > 0.0) {
                        da -= Math.PI * 2;
                    }
                }
            }
            if (r < 101) {
                ndivs = Math.max(10, da * r / 5);
            }
            else if (r < 201) {
                ndivs = Math.max(10, da * r / 20);
            }
            else {
                ndivs = Math.max(10, da * r / 40);
            }
            hda = (da / ndivs) / 2.0;
            kappa = Math.abs(4 / 3 * (1 - Math.cos(hda)) / Math.sin(hda));
            if (counterclockwise)
                kappa = -kappa;
            nvals = 0;
            var tPath = this._getPath();
            var _x1 = NaN, _y1 = NaN;
            for (i = 0; i <= ndivs; i++) {
                a = startAngle + da * (i / ndivs);
                dx = Math.cos(a);
                dy = Math.sin(a);
                x = cx + dx * r;
                y = cy + dy * r;
                if (b) {
                    _x1 = x, _y1 = y;
                    x = this._curMat.a * _x1 + this._curMat.c * _y1;
                    y = this._curMat.b * _x1 + this._curMat.d * _y1;
                }
                if (x != this._path.getEndPointX() || y != this._path.getEndPointY()) {
                    tPath.addPoint(x, y);
                }
            }
            dx = Math.cos(endAngle);
            dy = Math.sin(endAngle);
            x = cx + dx * r;
            y = cy + dy * r;
            if (b) {
                _x1 = x, _y1 = y;
                x = this._curMat.a * _x1 + this._curMat.c * _y1;
                y = this._curMat.b * _x1 + this._curMat.d * _y1;
            }
            if (x != this._path.getEndPointX() || y != this._path.getEndPointY()) {
                tPath.addPoint(x, y);
            }
        };
        __proto.quadraticCurveTo = function (cpx, cpy, x, y) {
            var tBezier = Bezier.I;
            var tResultArray = [];
            var _x1 = x, _y1 = y;
            x = this._curMat.a * _x1 + this._curMat.c * _y1;
            y = this._curMat.b * _x1 + this._curMat.d * _y1;
            _x1 = cpx, _y1 = cpy;
            cpx = this._curMat.a * _x1 + this._curMat.c * _y1;
            cpy = this._curMat.b * _x1 + this._curMat.d * _y1;
            var tArray = tBezier.getBezierPoints([this._path.getEndPointX(), this._path.getEndPointY(), cpx, cpy, x, y], 30, 2);
            for (var i = 0, n = tArray.length / 2; i < n; i++) {
                this.lineTo(tArray[i * 2], tArray[i * 2 + 1], false);
            }
            this.lineTo(x, y, false);
        };
        __proto.rect = function (x, y, width, height) {
            this._other = this._other.make();
            this._other.path || (this._other.path = new Path());
            this._other.path.rect(x, y, width, height);
        };
        __proto.strokeRect = function (x, y, width, height, parameterLineWidth) {
            var tW = parameterLineWidth * 0.5;
            this.line(x - tW, y, x + width + tW, y, parameterLineWidth, this._curMat);
            this.line(x + width, y, x + width, y + height, parameterLineWidth, this._curMat);
            this.line(x, y, x, y + height, parameterLineWidth, this._curMat);
            this.line(x - tW, y + height, x + width + tW, y + height, parameterLineWidth, this._curMat);
        };
        __proto.clip = function () { };
        __proto.drawPoly = function (x, y, points, color, lineWidth, boderColor, isConvexPolygon) {
            (isConvexPolygon === void 0) && (isConvexPolygon = false);
            this._renderKey = 0;
            this._shader2D.glTexture = null;
            var tPath = this._getPath();
            if (this.mId == -1) {
                tPath.polygon(x, y, points, color, lineWidth ? lineWidth : 1, boderColor);
            }
            else {
                if (this.mHaveKey) {
                    var tShape = VectorGraphManager.getInstance().shapeDic[this.mId];
                    tShape.setMatrix(this._curMat);
                    tShape.rebuild(tPath.tempArray);
                    tPath.setGeomtry(tShape);
                }
                else {
                    var t = tPath.polygon(x, y, points, color, lineWidth ? lineWidth : 1, boderColor);
                    VectorGraphManager.getInstance().addShape(this.mId, t);
                    t.setMatrix(this._curMat);
                }
            }
            tPath.update();
            var tPosArray = [this.mX, this.mY];
            var tempSubmit;
            tempSubmit = Submit.createShape(this, tPath.ib, tPath.vb, tPath.count, tPath.offset, Value2D.create(0x04, 0));
            tempSubmit.shaderValue.ALPHA = this._shader2D.ALPHA;
            (tempSubmit.shaderValue).u_pos = tPosArray;
            tempSubmit.shaderValue.u_mmat2 = RenderState2D.EMPTYMAT4_ARRAY;
            this._submits[this._submits._length++] = tempSubmit;
            if (lineWidth > 0) {
                if (this.mHaveLineKey) {
                    var tShapeLine = VectorGraphManager.getInstance().shapeLineDic[this.mId];
                    tShapeLine.rebuild(tPath.tempArray);
                    tPath.setGeomtry(tShapeLine);
                }
                else {
                    VectorGraphManager.getInstance().addShape(this.mId, tPath.drawLine(x, y, points, lineWidth, boderColor));
                }
                tPath.update();
                tempSubmit = Submit.createShape(this, tPath.ib, tPath.vb, tPath.count, tPath.offset, Value2D.create(0x04, 0));
                tempSubmit.shaderValue.ALPHA = this._shader2D.ALPHA;
                tempSubmit.shaderValue.u_mmat2 = RenderState2D.EMPTYMAT4_ARRAY;
                this._submits[this._submits._length++] = tempSubmit;
            }
        };
        __proto.drawParticle = function (x, y, pt) {
            pt.x = x;
            pt.y = y;
            this._submits[this._submits._length++] = pt;
        };
        __proto._getPath = function () {
            return this._path || (this._path = new Path());
        };
        __getset(0, __proto, 'globalCompositeOperation', function () {
            return BlendMode.NAMES[this._nBlendType];
        }, function (value) {
            var n = BlendMode.TOINT[value];
            n == null || (this._nBlendType === n) || (SaveBase.save(this, 0x10000, this, true), this._curSubmit = Submit.RENDERBASE, this._renderKey = 0, this._nBlendType = n);
        });
        __getset(0, __proto, 'strokeStyle', function () {
            return this._shader2D.strokeStyle;
        }, function (value) {
            this._shader2D.strokeStyle.equal(value) || (SaveBase.save(this, 0x200, this._shader2D, false), this._shader2D.strokeStyle = DrawStyle.create(value));
        });
        __getset(0, __proto, 'globalAlpha', function () {
            return this._shader2D.ALPHA;
        }, function (value) {
            value = Math.floor(value * 1000) / 1000;
            if (value != this._shader2D.ALPHA) {
                SaveBase.save(this, 0x1, this._shader2D, true);
                this._shader2D.ALPHA = value;
            }
        });
        __getset(0, __proto, 'asBitmap', null, function (value) {
            if (value) {
                this._targets || (this._targets = new RenderTargetMAX());
                this._targets.repaint = true;
                if (!this._width || !this._height)
                    throw Error("asBitmap no size!");
                this._targets.setSP(this.sprite);
                this._targets.size(this._width, this._height);
            }
            else
                this._targets = null;
        });
        __getset(0, __proto, 'fillStyle', function () {
            return this._shader2D.fillStyle;
        }, function (value) {
            this._shader2D.fillStyle.equal(value) || (SaveBase.save(this, 0x2, this._shader2D, false), this._shader2D.fillStyle = DrawStyle.create(value));
        });
        __getset(0, __proto, 'textAlign', function () {
            return this._other.textAlign;
        }, function (value) {
            (this._other.textAlign === value) || (this._other = this._other.make(), SaveBase.save(this, 0x8000, this._other, false), this._other.textAlign = value);
        });
        __getset(0, __proto, 'lineWidth', function () {
            return this._other.lineWidth;
        }, function (value) {
            (this._other.lineWidth === value) || (this._other = this._other.make(), SaveBase.save(this, 0x100, this._other, false), this._other.lineWidth = value);
        });
        __getset(0, __proto, 'textBaseline', function () {
            return this._other.textBaseline;
        }, function (value) {
            (this._other.textBaseline === value) || (this._other = this._other.make(), SaveBase.save(this, 0x4000, this._other, false), this._other.textBaseline = value);
        });
        __getset(0, __proto, 'font', null, function (str) {
            if (str == this._other.font.toString())
                return;
            this._other = this._other.make();
            SaveBase.save(this, 0x8, this._other, false);
            this._other.font === FontInContext.EMPTY ? (this._other.font = new FontInContext(str)) : (this._other.font.setFont(str));
        });
        WebGLContext2D.__init__ = function () {
            ContextParams.DEFAULT = new ContextParams();
        };
        WebGLContext2D._tempPoint = new Point();
        WebGLContext2D._SUBMITVBSIZE = 32000;
        WebGLContext2D._MAXSIZE = 99999999;
        WebGLContext2D._RECTVBSIZE = 16;
        WebGLContext2D.MAXCLIPRECT = new Rectangle(0, 0, 99999999, 99999999);
        WebGLContext2D._COUNT = 0;
        WebGLContext2D._tmpMatrix = new Matrix();
        WebGLContext2D.SEGNUM = 32;
        WebGLContext2D._contextcount = 0;
        __static(WebGLContext2D, ['_fontTemp', function () { return this._fontTemp = new FontInContext(); }, '_drawStyleTemp', function () { return this._drawStyleTemp = new DrawStyle(null); }
        ]);
        WebGLContext2D.__init$ = function () {
            ContextParams = (function () {
                function ContextParams() {
                    this.lineWidth = 1;
                    this.path = null;
                    this.textAlign = null;
                    this.textBaseline = null;
                    this.font = FontInContext.EMPTY;
                }
                __class(ContextParams, '');
                var __proto = ContextParams.prototype;
                __proto.clear = function () {
                    this.lineWidth = 1;
                    this.path && this.path.clear();
                    this.textAlign = this.textBaseline = null;
                    this.font = FontInContext.EMPTY;
                };
                __proto.make = function () {
                    return this === ContextParams.DEFAULT ? new ContextParams() : this;
                };
                ContextParams.DEFAULT = null;
                return ContextParams;
            })();
        };
        return WebGLContext2D;
    })(Context);
    var Value2D = (function (_super) {
        function Value2D(mainID, subID) {
            this.size = [0, 0];
            this.alpha = 1.0;
            this.ALPHA = 1.0;
            this.subID = 0;
            this._cacheID = 0;
            Value2D.__super.call(this);
            this.defines = new ShaderDefines2D();
            this.position = Value2D._POSITION;
            this.mainID = mainID;
            this.subID = subID;
            this.textureHost = null;
            this.texture = null;
            this.fillStyle = null;
            this.color = null;
            this.strokeStyle = null;
            this.colorAdd = null;
            this.glTexture = null;
            this.u_mmat2 = null;
            this._cacheID = mainID | subID;
            this._inClassCache = Value2D._cache[this._cacheID];
            if (mainID > 0 && !this._inClassCache) {
                this._inClassCache = Value2D._cache[this._cacheID] = [];
                this._inClassCache._length = 0;
            }
            this.clear();
        }
        __class(Value2D, 'laya.webgl.shader.d2.value.Value2D', _super);
        var __proto = Value2D.prototype;
        __proto.setValue = function (value) { };
        __proto.refresh = function () {
            var size = this.size;
            size[0] = RenderState2D.width;
            size[1] = RenderState2D.height;
            this.alpha = this.ALPHA * RenderState2D.worldAlpha;
            this.mmat = RenderState2D.worldMatrix4;
            return this;
        };
        __proto._ShaderWithCompile = function (kdsSetMaterialMacrosID) {
            return Shader.withCompile2D(0, this.mainID, this.defines.toNameDic(this), this.mainID | this.defines._value, Shader2X.create, kdsSetMaterialMacrosID);
        };
        __proto._withWorldShaderDefines = function () {
            var defs = RenderState2D.worldShaderDefines;
            var sd = Shader.sharders[this.mainID | this.defines._value | defs.getValue()];
            if (!sd) {
                var def = {};
                var dic;
                var name;
                dic = this.defines.toNameDic();
                for (name in dic)
                    def[name] = "";
                dic = defs.toNameDic();
                for (name in dic)
                    def[name] = "";
                sd = Shader.withCompile2D(0, this.mainID, def, this.mainID | this.defines._value | defs.getValue(), Shader2X.create);
            }
            ;
            var worldFilters = RenderState2D.worldFilters;
            if (!worldFilters)
                return sd;
            var n = worldFilters.length, f;
            for (var i = 0; i < n; i++) {
                ((f = worldFilters[i])) && f.action.setValue(this);
            }
            return sd;
        };
        __proto.upload = function () {
            var renderstate2d = RenderState2D;
            this.alpha = this.ALPHA * renderstate2d.worldAlpha;
            if (RenderState2D.worldMatrix4 !== RenderState2D.TEMPMAT4_ARRAY)
                this.defines.add(0x80);
            (WebGL.shaderHighPrecision) && (this.defines.add(0x400));
            // 存在使用材质的情况，缓存需要根据材质额外追加计算
            if (this.kdsSetMaterialMacrosID) {
                var mID = (this.mainID | this.defines._value) + "_" + this.kdsSetMaterialMacrosID;
                var sd = ShaderValue.kdsMaterialShaders[mID];
                if (!sd) {
                    // trace("创建使用KDS材质Shader--------------------------------", mID);
                    sd = this._ShaderWithCompile(mID);
                    ShaderValue.kdsMaterialShaders[mID] = sd;
                }
            }
            else {
                var sd = renderstate2d.worldShaderDefines ? this._withWorldShaderDefines() : (Shader.sharders[this.mainID | this.defines._value] || this._ShaderWithCompile());
            }
            var params;
            this.size[0] = renderstate2d.width, this.size[1] = renderstate2d.height;
            this.mmat = renderstate2d.worldMatrix4;
            if (BaseShader.activeShader !== sd) {
                if (sd._shaderValueWidth !== renderstate2d.width || sd._shaderValueHeight !== renderstate2d.height) {
                    sd._shaderValueWidth = renderstate2d.width;
                    sd._shaderValueHeight = renderstate2d.height;
                }
                else {
                    params = sd._params2dQuick2 || sd._make2dQuick2();
                }
                sd.upload(this, params);
            }
            else {
                if (sd._shaderValueWidth !== renderstate2d.width || sd._shaderValueHeight !== renderstate2d.height) {
                    sd._shaderValueWidth = renderstate2d.width;
                    sd._shaderValueHeight = renderstate2d.height;
                }
                else {
                    params = (sd._params2dQuick1) || sd._make2dQuick1();
                }
                sd.upload(this, params);
            }
        };
        __proto.setFilters = function (value) {
            this.filters = value;
            if (!value)
                return;
            var n = value.length, f;
            for (var i = 0; i < n; i++) {
                f = value[i];
                if (f) {
                    this.defines.add(f.type);
                    f.action.setValue(this);
                }
            }
        };
        __proto.clear = function () {
            this.defines.setValue(this.subID);
        };
        __proto.release = function () {
            this._inClassCache[this._inClassCache._length++] = this;
            this.fillStyle = null;
            this.strokeStyle = null;
            this.clear();
        };
        Value2D._initone = function (type, classT) {
            Value2D._typeClass[type] = classT;
            Value2D._cache[type] = [];
            Value2D._cache[type]._length = 0;
        };
        Value2D.__init__ = function () {
            Value2D._POSITION = [2, 0x1406, false, 4 * CONST3D2D.BYTES_PE, 0];
            Value2D._TEXCOORD = [2, 0x1406, false, 4 * CONST3D2D.BYTES_PE, 2 * CONST3D2D.BYTES_PE];
            Value2D._initone(0x02, Color2dSV);
            Value2D._initone(0x04, PrimitiveSV);
            Value2D._initone(0x100, FillTextureSV);
            Value2D._initone(0x200, SkinSV);
            Value2D._initone(0x01, TextureSV);
            Value2D._initone(0x01 | 0x40, TextSV);
            Value2D._initone(0x01 | 0x08, TextureSV);
        };
        Value2D.create = function (mainType, subType) {
            var types = Value2D._cache[mainType | subType];
            if (types._length)
                return types[--types._length];
            else
                return new Value2D._typeClass[mainType | subType](subType);
        };
        Value2D._POSITION = null;
        Value2D._TEXCOORD = null;
        Value2D._cache = [];
        Value2D._typeClass = [];
        Value2D.TEMPMAT4_ARRAY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        return Value2D;
    })(ShaderValue);
    ShaderValue.kdsMaterialShaders = [];
    var RenderSprite3D = (function (_super) {
        function RenderSprite3D(type, next) {
            RenderSprite3D.__super.call(this, type, next);
        }
        __class(RenderSprite3D, 'laya.webgl.utils.RenderSprite3D', _super);
        var __proto = RenderSprite3D.prototype;
        __proto.onCreate = function (type) {
            switch (type) {
                case 0x08:
                    this._fun = this._blend;
                    return;
                case 0x04:
                    this._fun = this._transform;
                    return;
            }
        };
        __proto._mask = function (sprite, context, x, y) {
            var next = this._next;
            var mask = sprite.mask;
            var submitCMD;
            var submitStencil;
            if (mask) {
                context.ctx.save();
                var preBlendMode = (context.ctx).globalCompositeOperation;
                var tRect = new Rectangle();
                tRect.copyFrom(mask.getBounds());
                tRect.width = Math.round(tRect.width);
                tRect.height = Math.round(tRect.height);
                tRect.x = Math.round(tRect.x);
                tRect.y = Math.round(tRect.y);
                if (tRect.width > 0 && tRect.height > 0) {
                    var tf = sprite._style._tf;
                    var scope = SubmitCMDScope.create();
                    scope.addValue("bounds", tRect);
                    submitCMD = SubmitCMD.create([scope, context], laya.webgl.utils.RenderSprite3D.tmpTarget);
                    context.addRenderObject(submitCMD);
                    mask.render(context, -tRect.x, -tRect.y);
                    submitCMD = SubmitCMD.create([scope], laya.webgl.utils.RenderSprite3D.endTmpTarget);
                    context.addRenderObject(submitCMD);
                    context.ctx.save();
                    context.clipRect(x - tf.translateX + tRect.x, y - tf.translateY + tRect.y, tRect.width, tRect.height);
                    next._fun.call(next, sprite, context, x, y);
                    context.ctx.restore();
                    submitStencil = SubmitStencil.create(6);
                    preBlendMode = (context.ctx).globalCompositeOperation;
                    submitStencil.blendMode = "mask";
                    context.addRenderObject(submitStencil);
                    Matrix.TEMP.identity();
                    var shaderValue = Value2D.create(0x01, 0);
                    var uv = Texture.INV_UV;
                    var w = tRect.width;
                    var h = tRect.height;
                    var tempLimit = 32;
                    if (tRect.width < tempLimit || tRect.height < tempLimit) {
                        uv = RenderSprite3D.tempUV;
                        uv[0] = 0;
                        uv[1] = 0;
                        uv[2] = (tRect.width >= 32) ? 1 : tRect.width / tempLimit;
                        uv[3] = 0;
                        uv[4] = (tRect.width >= 32) ? 1 : tRect.width / tempLimit;
                        uv[5] = (tRect.height >= 32) ? 1 : tRect.height / tempLimit;
                        uv[6] = 0;
                        uv[7] = (tRect.height >= 32) ? 1 : tRect.height / tempLimit;
                        tRect.width = (tRect.width >= 32) ? tRect.width : tempLimit;
                        tRect.height = (tRect.height >= 32) ? tRect.height : tempLimit;
                        uv[1] *= -1;
                        uv[3] *= -1;
                        uv[5] *= -1;
                        uv[7] *= -1;
                        uv[1] += 1;
                        uv[3] += 1;
                        uv[5] += 1;
                        uv[7] += 1;
                    }
                    (context.ctx).drawTarget(scope, x + tRect.x - tf.translateX, y + tRect.y - tf.translateY, w, h, Matrix.TEMP, "tmpTarget", shaderValue, uv, 6);
                    submitCMD = SubmitCMD.create([scope], laya.webgl.utils.RenderSprite3D.recycleTarget);
                    context.addRenderObject(submitCMD);
                    submitStencil = SubmitStencil.create(6);
                    submitStencil.blendMode = preBlendMode;
                    context.addRenderObject(submitStencil);
                }
                context.ctx.restore();
            }
            else {
                next._fun.call(next, sprite, context, x, y);
            }
        };
        __proto._blend = function (sprite, context, x, y) {
            var style = sprite._style;
            var next = this._next;
            if (style.blendMode) {
                context.ctx.save();
                context.ctx.globalCompositeOperation = style.blendMode;
                next._fun.call(next, sprite, context, x, y);
                context.ctx.restore();
            }
            else {
                next._fun.call(next, sprite, context, x, y);
            }
        };
        __proto._transform = function (sprite, context, x, y) {
            'use strict';
            var transform = sprite.transform, _next = this._next;
            if (transform && _next != RenderSprite.NORENDER) {
                var ctx = context.ctx;
                var style = sprite._style;
                transform.tx = x;
                transform.ty = y;
                var m2 = ctx._getTransformMatrix();
                var m1 = m2.clone();
                Matrix.mul(transform, m2, m2);
                m2._checkTransform();
                transform.tx = transform.ty = 0;
                _next._fun.call(_next, sprite, context, 0, 0);
                m1.copyTo(m2);
                m1.destroy();
            }
            else {
                _next._fun.call(_next, sprite, context, x, y);
            }
        };
        RenderSprite3D.tmpTarget = function (scope, context) {
            var b = scope.getValue("bounds");
            var tmpTarget = RenderTarget2D.create(b.width, b.height);
            tmpTarget.start();
            tmpTarget.clear(0, 0, 0, 0);
            scope.addValue("tmpTarget", tmpTarget);
        };
        RenderSprite3D.endTmpTarget = function (scope) {
            var tmpTarget = scope.getValue("tmpTarget");
            tmpTarget.end();
        };
        RenderSprite3D.recycleTarget = function (scope) {
            var tmpTarget = scope.getValue("tmpTarget");
            tmpTarget.recycle();
            scope.recycle();
        };
        __static(RenderSprite3D, ['tempUV', function () { return this.tempUV = new Array(8); }
        ]);
        return RenderSprite3D;
    })(RenderSprite);
    var ColorFilterActionGL = (function (_super) {
        function ColorFilterActionGL() {
            this.data = null;
            ColorFilterActionGL.__super.call(this);
        }
        __class(ColorFilterActionGL, 'laya.filters.webgl.ColorFilterActionGL', _super);
        var __proto = ColorFilterActionGL.prototype;
        Laya.imps(__proto, { "laya.filters.IFilterActionGL": true });
        __proto.setValue = function (shader) {
            shader.colorMat = this.data._mat;
            shader.colorAlpha = this.data._alpha;
        };
        __proto.apply3d = function (scope, sprite, context, x, y) {
            var b = scope.getValue("bounds");
            var shaderValue = Value2D.create(0x01, 0);
            shaderValue.setFilters([this.data]);
            var tMatrix = Matrix.TEMP;
            tMatrix.identity();
            context.ctx.drawTarget(scope, 0, 0, b.width, b.height, tMatrix, "src", shaderValue);
        };
        return ColorFilterActionGL;
    })(FilterActionGL);
    var Atlaser = (function (_super) {
        function Atlaser(gridNumX, gridNumY, width, height, atlasID) {
            this._atlasCanvas = null;
            this._inAtlasTextureKey = null;
            this._inAtlasTextureBitmapValue = null;
            this._inAtlasTextureOriUVValue = null;
            this._InAtlasWebGLImagesKey = null;
            this._InAtlasWebGLImagesOffsetValue = null;
            Atlaser.__super.call(this, gridNumX, gridNumY, atlasID);
            this._inAtlasTextureKey = [];
            this._inAtlasTextureBitmapValue = [];
            this._inAtlasTextureOriUVValue = [];
            this._InAtlasWebGLImagesKey = {};
            this._InAtlasWebGLImagesOffsetValue = [];
            this._atlasCanvas = new AtlasWebGLCanvas();
            this._atlasCanvas._atlaser = this;
            this._atlasCanvas.width = width;
            this._atlasCanvas.height = height;
            this._atlasCanvas.activeResource();
            this._atlasCanvas.lock = true;
        }
        __class(Atlaser, 'laya.webgl.atlas.Atlaser', _super);
        var __proto = Atlaser.prototype;
        __proto.computeUVinAtlasTexture = function (texture, oriUV, offsetX, offsetY) {
            var tex = texture;
            var _width = AtlasResourceManager.atlasTextureWidth;
            var _height = AtlasResourceManager.atlasTextureHeight;
            var u1 = offsetX / _width, v1 = offsetY / _height, u2 = (offsetX + texture.bitmap.width) / _width, v2 = (offsetY + texture.bitmap.height) / _height;
            var inAltasUVWidth = texture.bitmap.width / _width, inAltasUVHeight = texture.bitmap.height / _height;
            texture.uv = [u1 + oriUV[0] * inAltasUVWidth, v1 + oriUV[1] * inAltasUVHeight, u2 - (1 - oriUV[2]) * inAltasUVWidth, v1 + oriUV[3] * inAltasUVHeight, u2 - (1 - oriUV[4]) * inAltasUVWidth, v2 - (1 - oriUV[5]) * inAltasUVHeight, u1 + oriUV[6] * inAltasUVWidth, v2 - (1 - oriUV[7]) * inAltasUVHeight];
        };
        __proto.findBitmapIsExist = function (bitmap) {
            if ((bitmap instanceof laya.webgl.resource.WebGLImage)) {
                var webImage = bitmap;
                var sUrl = webImage.url;
                var object = this._InAtlasWebGLImagesKey[sUrl ? sUrl : webImage.id];
                if (object) {
                    return object.offsetInfoID;
                }
            }
            return -1;
        };
        __proto.addToAtlasTexture = function (mergeAtlasBitmap, offsetX, offsetY) {
            if ((mergeAtlasBitmap instanceof laya.webgl.resource.WebGLImage)) {
                var webImage = mergeAtlasBitmap;
                var sUrl = webImage.url;
                this._InAtlasWebGLImagesKey[sUrl ? sUrl : webImage.id] = { bitmap: mergeAtlasBitmap, offsetInfoID: this._InAtlasWebGLImagesOffsetValue.length };
                this._InAtlasWebGLImagesOffsetValue.push([offsetX, offsetY]);
            }
            this._atlasCanvas.texSubImage2D(offsetX, offsetY, mergeAtlasBitmap.atlasSource);
            mergeAtlasBitmap.clearAtlasSource();
        };
        __proto.addToAtlas = function (texture, offsetX, offsetY) {
            texture._atlasID = this._inAtlasTextureKey.length;
            var oriUV = texture.uv.slice();
            var oriBitmap = texture.bitmap;
            this._inAtlasTextureKey.push(texture);
            this._inAtlasTextureOriUVValue.push(oriUV);
            this._inAtlasTextureBitmapValue.push(oriBitmap);
            this.computeUVinAtlasTexture(texture, oriUV, offsetX, offsetY);
            texture.bitmap = this._atlasCanvas;
        };
        __proto.clear = function () {
            for (var i = 0, n = this._inAtlasTextureKey.length; i < n; i++) {
                this._inAtlasTextureKey[i].bitmap = this._inAtlasTextureBitmapValue[i];
                this._inAtlasTextureKey[i].uv = this._inAtlasTextureOriUVValue[i];
                this._inAtlasTextureKey[i]._atlasID = -1;
                this._inAtlasTextureKey[i].bitmap.lock = false;
                this._inAtlasTextureKey[i].bitmap.releaseResource();
            }
            this._inAtlasTextureKey.length = 0;
            this._inAtlasTextureBitmapValue.length = 0;
            this._inAtlasTextureOriUVValue.length = 0;
            this._InAtlasWebGLImagesKey = null;
            this._InAtlasWebGLImagesOffsetValue.length = 0;
        };
        __proto.dispose = function () {
            this.clear();
            this._atlasCanvas.destroy();
        };
        __getset(0, __proto, 'InAtlasWebGLImagesOffsetValue', function () {
            return this._InAtlasWebGLImagesOffsetValue;
        });
        __getset(0, __proto, 'texture', function () {
            return this._atlasCanvas;
        });
        __getset(0, __proto, 'inAtlasWebGLImagesKey', function () {
            return this._InAtlasWebGLImagesKey;
        });
        return Atlaser;
    })(AtlasGrid);
    var ShaderDefines2D = (function (_super) {
        function ShaderDefines2D() {
            ShaderDefines2D.__super.call(this, ShaderDefines2D.__name2int, ShaderDefines2D.__int2name, ShaderDefines2D.__int2nameMap);
        }
        __class(ShaderDefines2D, 'laya.webgl.shader.d2.ShaderDefines2D', _super);
        ShaderDefines2D.__init__ = function () {
            ShaderDefines2D.reg("TEXTURE2D", 0x01);
            ShaderDefines2D.reg("COLOR2D", 0x02);
            ShaderDefines2D.reg("PRIMITIVE", 0x04);
            ShaderDefines2D.reg("GLOW_FILTER", 0x08);
            ShaderDefines2D.reg("BLUR_FILTER", 0x10);
            ShaderDefines2D.reg("COLOR_FILTER", 0x20);
            ShaderDefines2D.reg("COLOR_ADD", 0x40);
            ShaderDefines2D.reg("WORLDMAT", 0x80);
            ShaderDefines2D.reg("FILLTEXTURE", 0x100);
            ShaderDefines2D.reg("FSHIGHPRECISION", 0x400);

        };
        ShaderDefines2D.reg = function (name, value) {
            ShaderDefines._reg(name, value, ShaderDefines2D.__name2int, ShaderDefines2D.__int2name);
        };
        ShaderDefines2D.toText = function (value, int2name, int2nameMap) {
            return ShaderDefines._toText(value, int2name, int2nameMap);
        };
        ShaderDefines2D.toInt = function (names) {
            return ShaderDefines._toInt(names, ShaderDefines2D.__name2int);
        };
        ShaderDefines2D.TEXTURE2D = 0x01;
        ShaderDefines2D.COLOR2D = 0x02;
        ShaderDefines2D.PRIMITIVE = 0x04;
        ShaderDefines2D.FILTERGLOW = 0x08;
        ShaderDefines2D.FILTERBLUR = 0x10;
        ShaderDefines2D.FILTERCOLOR = 0x20;
        ShaderDefines2D.COLORADD = 0x40;
        ShaderDefines2D.WORLDMAT = 0x80;
        ShaderDefines2D.FILLTEXTURE = 0x100;
        ShaderDefines2D.SKINMESH = 0x200;
        ShaderDefines2D.SHADERDEFINE_FSHIGHPRECISION = 0x400;
        ShaderDefines2D.__name2int = {};
        ShaderDefines2D.__int2name = [];
        ShaderDefines2D.__int2nameMap = [];
        return ShaderDefines2D;
    })(ShaderDefines);
    var Ellipse = (function (_super) {
        function Ellipse(x, y, width, height, color, borderWidth, borderColor) {
            Ellipse.__super.call(this, x, y, width, height, 40, color, borderWidth, borderColor);
        }
        __class(Ellipse, 'laya.webgl.shapes.Ellipse', _super);
        return Ellipse;
    })(BasePoly);
    var Line = (function (_super) {
        function Line(x, y, points, borderWidth, color) {
            this._points = [];
            this.rebuild(points);
            Line.__super.call(this, x, y, 0, 0, 0, color, borderWidth, color, 0);
        }
        __class(Line, 'laya.webgl.shapes.Line', _super);
        var __proto = Line.prototype;
        __proto.rebuild = function (points) {
            var len = points.length;
            var preLen = this._points.length;
            if (len != preLen) {
                this.mUint16Array = new Uint16Array((len / 2 - 1) * 6);
                this.mFloat32Array = new Float32Array(len * 5);
            }
            this._points.length = 0;
            var tCurrX = NaN;
            var tCurrY = NaN;
            var tLastX = -1;
            var tLastY = -1;
            var tLen = points.length / 2;
            for (var i = 0; i < tLen; i++) {
                tCurrX = points[i * 2];
                tCurrY = points[i * 2 + 1];
                if (Math.abs(tLastX - tCurrX) > 0.01 || Math.abs(tLastY - tCurrY) > 0.01) {
                    this._points.push(tCurrX, tCurrY);
                }
                tLastX = tCurrX;
                tLastY = tCurrY;
            }
        };
        __proto.getData = function (ib, vb, start) {
            var indices = [];
            var verts = [];
            (this.borderWidth > 0) && this.createLine2(this._points, indices, this.borderWidth, start, verts, this._points.length / 2);
            this.mUint16Array.set(indices, 0);
            this.mFloat32Array.set(verts, 0);
            ib.append(this.mUint16Array);
            vb.append(this.mFloat32Array);
        };
        return Line;
    })(BasePoly);
    var LoopLine = (function (_super) {
        function LoopLine(x, y, points, width, color) {
            this._points = [];
            var tCurrX = NaN;
            var tCurrY = NaN;
            var tLastX = -1;
            var tLastY = -1;
            var tLen = points.length / 2 - 1;
            for (var i = 0; i < tLen; i++) {
                tCurrX = points[i * 2];
                tCurrY = points[i * 2 + 1];
                if (Math.abs(tLastX - tCurrX) > 0.01 || Math.abs(tLastY - tCurrY) > 0.01) {
                    this._points.push(tCurrX, tCurrY);
                }
                tLastX = tCurrX;
                tLastY = tCurrY;
            }
            tCurrX = points[tLen * 2];
            tCurrY = points[tLen * 2 + 1];
            tLastX = this._points[0];
            tLastY = this._points[1];
            if (Math.abs(tLastX - tCurrX) > 0.01 || Math.abs(tLastY - tCurrY) > 0.01) {
                this._points.push(tCurrX, tCurrY);
            }
            LoopLine.__super.call(this, x, y, 0, 0, this._points.length / 2, 0, width, color);
        }
        __class(LoopLine, 'laya.webgl.shapes.LoopLine', _super);
        var __proto = LoopLine.prototype;
        __proto.getData = function (ib, vb, start) {
            if (this.borderWidth > 0) {
                var color = this.color;
                var r = ((color >> 16) & 0x0000ff) / 255, g = ((color >> 8) & 0xff) / 255, b = (color & 0x0000ff) / 255;
                var verts = [];
                var tLastX = -1, tLastY = -1;
                var tCurrX = 0, tCurrY = 0;
                var indices = [];
                var tLen = Math.floor(this._points.length / 2);
                for (var i = 0; i < tLen; i++) {
                    tCurrX = this._points[i * 2];
                    tCurrY = this._points[i * 2 + 1];
                    verts.push(this.x + tCurrX, this.y + tCurrY, r, g, b);
                }
                this.createLoopLine(verts, indices, this.borderWidth, start + verts.length / 5);
                ib.append(new Uint16Array(indices));
                vb.append(new Float32Array(verts));
            }
        };
        __proto.createLoopLine = function (p, indices, lineWidth, len, outVertex, outIndex) {
            var tLen = p.length / 5;
            var points = p.concat();
            var result = outVertex ? outVertex : p;
            var color = this.borderColor;
            var r = ((color >> 16) & 0x0000ff) / 255, g = ((color >> 8) & 0xff) / 255, b = (color & 0x0000ff) / 255;
            var firstPoint = [points[0], points[1]];
            var lastPoint = [points[points.length - 5], points[points.length - 4]];
            var midPointX = lastPoint[0] + (firstPoint[0] - lastPoint[0]) * 0.5;
            var midPointY = lastPoint[1] + (firstPoint[1] - lastPoint[1]) * 0.5;
            points.unshift(midPointX, midPointY, 0, 0, 0);
            points.push(midPointX, midPointY, 0, 0, 0);
            var length = points.length / 5;
            var iStart = len, w = lineWidth / 2;
            var px, py, p1x, p1y, p2x, p2y, p3x, p3y;
            var perpx, perpy, perp2x, perp2y, perp3x, perp3y;
            var a1, b1, c1, a2, b2, c2;
            var denom, pdist, dist;
            p1x = points[0];
            p1y = points[1];
            p2x = points[5];
            p2y = points[6];
            perpx = -(p1y - p2y);
            perpy = p1x - p2x;
            dist = Math.sqrt(perpx * perpx + perpy * perpy);
            perpx = perpx / dist * w;
            perpy = perpy / dist * w;
            result.push(p1x - perpx, p1y - perpy, r, g, b, p1x + perpx, p1y + perpy, r, g, b);
            for (var i = 1; i < length - 1; i++) {
                p1x = points[(i - 1) * 5];
                p1y = points[(i - 1) * 5 + 1];
                p2x = points[(i) * 5];
                p2y = points[(i) * 5 + 1];
                p3x = points[(i + 1) * 5];
                p3y = points[(i + 1) * 5 + 1];
                perpx = -(p1y - p2y);
                perpy = p1x - p2x;
                dist = Math.sqrt(perpx * perpx + perpy * perpy);
                perpx = perpx / dist * w;
                perpy = perpy / dist * w;
                perp2x = -(p2y - p3y);
                perp2y = p2x - p3x;
                dist = Math.sqrt(perp2x * perp2x + perp2y * perp2y);
                perp2x = perp2x / dist * w;
                perp2y = perp2y / dist * w;
                a1 = (-perpy + p1y) - (-perpy + p2y);
                b1 = (-perpx + p2x) - (-perpx + p1x);
                c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);
                a2 = (-perp2y + p3y) - (-perp2y + p2y);
                b2 = (-perp2x + p2x) - (-perp2x + p3x);
                c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);
                denom = a1 * b2 - a2 * b1;
                if (Math.abs(denom) < 0.1) {
                    denom += 10.1;
                    result.push(p2x - perpx, p2y - perpy, r, g, b, p2x + perpx, p2y + perpy, r, g, b);
                    continue;
                }
                px = (b1 * c2 - b2 * c1) / denom;
                py = (a2 * c1 - a1 * c2) / denom;
                pdist = (px - p2x) * (px - p2x) + (py - p2y) + (py - p2y);
                result.push(px, py, r, g, b, p2x - (px - p2x), p2y - (py - p2y), r, g, b);
            }
            if (outIndex) {
                indices = outIndex;
            }
            ;
            var groupLen = this.edges + 1;
            for (i = 1; i < groupLen; i++) {
                indices.push(iStart + (i - 1) * 2, iStart + (i - 1) * 2 + 1, iStart + i * 2 + 1, iStart + i * 2 + 1, iStart + i * 2, iStart + (i - 1) * 2);
            }
            indices.push(iStart + (i - 1) * 2, iStart + (i - 1) * 2 + 1, iStart + 1, iStart + 1, iStart, iStart + (i - 1) * 2);
            return result;
        };
        return LoopLine;
    })(BasePoly);
    var Polygon = (function (_super) {
        function Polygon(x, y, points, color, borderWidth, borderColor) {
            this._points = null;
            this._start = -1;
            this._repaint = false;
            this.earcutTriangles = null;
            this._mat = Matrix.create();
            this._points = points.slice(0, points.length);
            Polygon.__super.call(this, x, y, 0, 0, this._points.length / 2, color, borderWidth, borderColor);
        }
        __class(Polygon, 'laya.webgl.shapes.Polygon', _super);
        var __proto = Polygon.prototype;
        __proto.rebuild = function (point) {
            if (!this._repaint) {
                this._points.length = 0;
                this._points = this._points.concat(point);
            }
        };
        __proto.setMatrix = function (mat) {
            mat.copyTo(this._mat);
        };
        __proto.needUpdate = function (mat) {
            this._repaint = (this._mat.a == mat.a && this._mat.b == mat.b && this._mat.c == mat.c && this._mat.d == mat.d && this._mat.tx == mat.tx && this._mat.ty == mat.ty);
            return !this._repaint;
        };
        __proto.getData = function (ib, vb, start) {
            var indices, i = 0;
            var tArray = this._points;
            var tLen = 0;
            if (this.mUint16Array && this.mFloat32Array && this._repaint) {
                if (this._start != start) {
                    this._start = start;
                    indices = [];
                    tLen = this.earcutTriangles.length;
                    for (i = 0; i < tLen; i++) {
                        indices.push(this.earcutTriangles[i] + start);
                    }
                    this.mUint16Array = new Uint16Array(indices);
                }
            }
            else {
                this._start = start;
                indices = [];
                var verts = [];
                var vertsEarcut = [];
                var color = this.color;
                var r = ((color >> 16) & 0x0000ff) / 255, g = ((color >> 8) & 0xff) / 255, b = (color & 0x0000ff) / 255;
                tLen = Math.floor(tArray.length / 2);
                for (i = 0; i < tLen; i++) {
                    verts.push(this.x + tArray[i * 2], this.y + tArray[i * 2 + 1], r, g, b);
                    vertsEarcut.push(this.x + tArray[i * 2], this.y + tArray[i * 2 + 1]);
                }
                this.earcutTriangles = Earcut.earcut(vertsEarcut, null, 2);
                tLen = this.earcutTriangles.length;
                for (i = 0; i < tLen; i++) {
                    indices.push(this.earcutTriangles[i] + start);
                }
                this.mUint16Array = new Uint16Array(indices);
                this.mFloat32Array = new Float32Array(verts);
            }
            ib.append(this.mUint16Array);
            vb.append(this.mFloat32Array);
        };
        return Polygon;
    })(BasePoly);
    var SubmitCanvas = (function (_super) {
        function SubmitCanvas() {
            this._matrix = new Matrix();
            this._matrix4 = CONST3D2D.defaultMatrix4.concat();
            SubmitCanvas.__super.call(this, 10000);
            this.shaderValue = new Value2D(0, 0);
        }
        __class(SubmitCanvas, 'laya.webgl.submit.SubmitCanvas', _super);
        var __proto = SubmitCanvas.prototype;
        __proto.renderSubmit = function () {
            if (this._ctx_src._targets) {
                this._ctx_src._targets.flush(this._ctx_src);
                return 1;
            }
            ;
            var preAlpha = RenderState2D.worldAlpha;
            var preMatrix4 = RenderState2D.worldMatrix4;
            var preMatrix = RenderState2D.worldMatrix;
            var preFilters = RenderState2D.worldFilters;
            var preWorldShaderDefines = RenderState2D.worldShaderDefines;
            var v = this.shaderValue;
            var m = this._matrix;
            var m4 = this._matrix4;
            var mout = Matrix.TEMP;
            Matrix.mul(m, preMatrix, mout);
            m4[0] = mout.a;
            m4[1] = mout.b;
            m4[4] = mout.c;
            m4[5] = mout.d;
            m4[12] = mout.tx;
            m4[13] = mout.ty;
            RenderState2D.worldMatrix = mout.clone();
            RenderState2D.worldMatrix4 = m4;
            RenderState2D.worldAlpha = RenderState2D.worldAlpha * v.alpha;
            if (v.filters && v.filters.length) {
                RenderState2D.worldFilters = v.filters;
                RenderState2D.worldShaderDefines = v.defines;
            }
            this._ctx_src.flush();
            RenderState2D.worldAlpha = preAlpha;
            RenderState2D.worldMatrix4 = preMatrix4;
            RenderState2D.worldMatrix.destroy();
            RenderState2D.worldMatrix = preMatrix;
            RenderState2D.worldFilters = preFilters;
            RenderState2D.worldShaderDefines = preWorldShaderDefines;
            return 1;
        };
        __proto.releaseRender = function () {
            var cache = SubmitCanvas._cache;
            this._ctx_src = null;
            cache[cache._length++] = this;
        };
        __proto.getRenderType = function () {
            return 10003;
        };
        SubmitCanvas.create = function (ctx_src, alpha, filters) {
            var o = (!SubmitCanvas._cache._length) ? (new SubmitCanvas()) : SubmitCanvas._cache[--SubmitCanvas._cache._length];
            o._ctx_src = ctx_src;
            var v = o.shaderValue;
            v.alpha = alpha;
            v.defines.setValue(0);
            filters && filters.length && v.setFilters(filters);
            return o;
        };
        SubmitCanvas._cache = (SubmitCanvas._cache = [], SubmitCanvas._cache._length = 0, SubmitCanvas._cache);
        return SubmitCanvas;
    })(Submit);
    var SubmitTexture = (function (_super) {
        function SubmitTexture(renderType) {
            this._preIsSameTextureShader = false;
            this._isSameTexture = true;
            this._texs = new Array;
            this._texsID = new Array;
            this._vbPos = new Array;
            (renderType === void 0) && (renderType = 10000);
            SubmitTexture.__super.call(this, renderType);
        }
        __class(SubmitTexture, 'laya.webgl.submit.SubmitTexture', _super);
        var __proto = SubmitTexture.prototype;
        __proto.releaseRender = function () {
            var cache = SubmitTexture._cache;
            cache[cache._length++] = this;
            this.shaderValue.release();
            this._preIsSameTextureShader = false;
            this._vb = null;
            this._texs.length = 0;
            this._vbPos.length = 0;
            this._isSameTexture = true;
        };
        __proto.addTexture = function (tex, vbpos) {
            this._texsID[this._texs.length] = tex._uvID;
            this._texs.push(tex);
            this._vbPos.push(vbpos);
        };
        __proto.checkTexture = function () {
            if (this._texs.length < 1) {
                this._isSameTexture = true;
                return;
            }
            ;
            var _tex = this.shaderValue.textureHost;
            var webGLImg = _tex.bitmap;
            if (webGLImg === null)
                return;
            var vbdata = this._vb.getFloat32Array();
            for (var i = 0, s = this._texs.length; i < s; i++) {
                var tex = this._texs[i];
                tex.active();
                var newUV = tex.uv;
                if (this._texsID[i] !== tex._uvID) {
                    this._texsID[i] = tex._uvID;
                    var vbPos = this._vbPos[i];
                    vbdata[vbPos + 2] = newUV[0];
                    vbdata[vbPos + 3] = newUV[1];
                    vbdata[vbPos + 6] = newUV[2];
                    vbdata[vbPos + 7] = newUV[3];
                    vbdata[vbPos + 10] = newUV[4];
                    vbdata[vbPos + 11] = newUV[5];
                    vbdata[vbPos + 14] = newUV[6];
                    vbdata[vbPos + 15] = newUV[7];
                    this._vb.setNeedUpload();
                }
                if (tex.bitmap !== webGLImg) {
                    this._isSameTexture = false;
                }
            }
        };
        __proto.renderSubmit = function () {
            if (this._numEle === 0) {
                SubmitTexture._shaderSet = false;
                return 1;
            }
            ;
            var _tex = this.shaderValue.textureHost;
            if (_tex) {
                var source = _tex.source;
                if (!_tex.bitmap || !source) {
                    SubmitTexture._shaderSet = false;
                    return 1;
                }
                this.shaderValue.texture = source;
            }
            this._vb.bind_upload(this._ib);
            var gl = WebGL.mainContext;
            if (BlendMode.activeBlendFunction !== this._blendFn) {
                gl.enable(0x0BE2);
                this._blendFn(gl);
                BlendMode.activeBlendFunction = this._blendFn;
            }
            Stat.drawCall++;
            Stat.trianglesFaces += this._numEle / 3;
            if (this._preIsSameTextureShader && BaseShader.activeShader && SubmitTexture._shaderSet)
                (BaseShader.activeShader).uploadTexture2D(this.shaderValue.texture);
            else
                this.shaderValue.upload();
            SubmitTexture._shaderSet = true;
            if (this._texs.length > 1 && !this._isSameTexture) {
                var webGLImg = _tex.bitmap;
                var index = 0;
                var shader = BaseShader.activeShader;
                for (var i = 0, s = this._texs.length; i < s; i++) {
                    var tex2 = this._texs[i];
                    if (tex2.bitmap !== webGLImg || (i + 1) === s) {
                        shader.uploadTexture2D(tex2.source);
                        gl.drawElements(0x0004, (i - index + 1) * 6, 0x1403, this._startIdx + index * 6 * CONST3D2D.BYTES_PIDX);
                        webGLImg = tex2.bitmap;
                        index = i;
                    }
                }
            }
            else {
                gl.drawElements(0x0004, this._numEle, 0x1403, this._startIdx);
            }
            return 1;
        };
        SubmitTexture.create = function (context, ib, vb, pos, sv) {
            var o = SubmitTexture._cache._length ? SubmitTexture._cache[--SubmitTexture._cache._length] : new SubmitTexture();
            if (vb == null) {
                vb = o._selfVb || (o._selfVb = VertexBuffer2D.create(-1));
                vb.clear();
                pos = 0;
            }
            o._ib = ib;
            o._vb = vb;
            o._startIdx = pos * CONST3D2D.BYTES_PIDX;
            o._numEle = 0;
            var blendType = context._nBlendType;
            o._blendFn = context._targets ? BlendMode.targetFns[blendType] : BlendMode.fns[blendType];
            o.shaderValue = sv;
            o.shaderValue.setValue(context._shader2D);
            var filters = context._shader2D.filters;
            filters && o.shaderValue.setFilters(filters);
            return o;
        };
        SubmitTexture._cache = (SubmitTexture._cache = [], SubmitTexture._cache._length = 0, SubmitTexture._cache);
        SubmitTexture._shaderSet = true;
        return SubmitTexture;
    })(Submit);
    var MeshTexture = (function (_super) {
        function MeshTexture() {
            MeshTexture.__super.call(this, laya.webgl.utils.MeshTexture.const_stride, 0, 0);
            this.canReuse = true;
            this.setAttributes(laya.webgl.utils.MeshTexture._fixattriInfo);
        }
        __class(MeshTexture, 'laya.webgl.utils.MeshTexture', _super);
        var __proto = MeshTexture.prototype;
        __proto.addData = function (vertices, uvs, idx, matrix, rgba, ctx) {
            var sz = vertices.length / 2;
            var startpos = this._vb.needSize(sz * MeshTexture.const_stride);
            var f32pos = startpos >> 2;
            var vbdata = this._vb.getFloat32Array();
            var ci = 0;
            for (var i = 0; i < sz; i++) {
                var x = vertices[ci], y = vertices[ci + 1];
                var x1 = x * matrix.a + y * matrix.c + matrix.tx;
                var y1 = x * matrix.b + y * matrix.d + matrix.ty;
                vbdata[f32pos++] = x1;
                vbdata[f32pos++] = y1;
                vbdata[f32pos++] = uvs[ci];
                vbdata[f32pos++] = uvs[ci + 1];
                ci += 2;
            }
            this._vb.setNeedUpload();
            var vertN = this.vertNum;
            if (vertN > 0) {
                sz = idx.length;
                if (sz > MeshTexture.tmpIdx.length)
                    MeshTexture.tmpIdx = new Uint16Array(sz);
                for (var ii = 0; ii < sz; ii++) {
                    MeshTexture.tmpIdx[ii] = idx[ii] + vertN;
                }
                this._ib.appendU16Array(MeshTexture.tmpIdx, idx.length);
            }
            else {
                this._ib.append(idx);
            }
            this._ib.setNeedUpload();
            this.vertNum += sz;
            this.indexNum += idx.length;
        };
        __proto.releaseMesh = function () {
            this._vb._byteLength = 0;
            this._ib._byteLength = 0;
            this.vertNum = 0;
            this.indexNum = 0;
            laya.webgl.utils.MeshTexture._POOL.push(this);
        };
        __proto.destroy = function () {
            this._ib.destroy();
            this._vb.destroy();
        };
        MeshTexture.getAMesh = function () {
            if (laya.webgl.utils.MeshTexture._POOL.length) {
                return laya.webgl.utils.MeshTexture._POOL.pop();
            }
            return new MeshTexture();
        };
        MeshTexture.const_stride = 16;
        MeshTexture._POOL = [];
        __static(MeshTexture, ['_fixattriInfo', function () {
            return this._fixattriInfo = [
                0x1406, 2, 0,
                0x1406, 2, 8];
        }, 'tmpIdx', function () { return this.tmpIdx = new Uint16Array(4); }
        ]);
        return MeshTexture;
    })(Mesh2D);
    var BaseShader = (function (_super) {
        function BaseShader() {
            BaseShader.__super.call(this);
            this.lock = true;
        }
        __class(BaseShader, 'laya.webgl.shader.BaseShader', _super);
        BaseShader.activeShader = null;
        BaseShader.bindShader = null;
        return BaseShader;
    })(Resource);
    var RenderTarget2D = (function (_super) {
        function RenderTarget2D(width, height, surfaceFormat, surfaceType, depthStencilFormat, mipMap, repeat, minFifter, magFifter) {
            this._type = 0;
            this._svWidth = NaN;
            this._svHeight = NaN;
            this._preRenderTarget = null;
            this._alreadyResolved = false;
            this._looked = false;
            this._surfaceFormat = 0;
            this._surfaceType = 0;
            this._depthStencilFormat = 0;
            this._mipMap = false;
            this._repeat = false;
            this._minFifter = 0;
            this._magFifter = 0;
            this._destroy = false;
            (surfaceFormat === void 0) && (surfaceFormat = 0x1908);
            (surfaceType === void 0) && (surfaceType = 0x1401);
            (depthStencilFormat === void 0) && (depthStencilFormat = 0x84F9);
            (mipMap === void 0) && (mipMap = false);
            (repeat === void 0) && (repeat = false);
            (minFifter === void 0) && (minFifter = -1);
            (magFifter === void 0) && (magFifter = -1);
            this._type = 1;
            this._w = width;
            this._h = height;
            this._surfaceFormat = surfaceFormat;
            this._surfaceType = surfaceType;
            this._depthStencilFormat = depthStencilFormat;
            this._mipMap = mipMap;
            this._repeat = repeat;
            this._minFifter = minFifter;
            this._magFifter = magFifter;
            this._createWebGLRenderTarget();
            this.bitmap.lock = true;
            RenderTarget2D.__super.call(this, this.bitmap, Texture.INV_UV);
        }
        __class(RenderTarget2D, 'laya.webgl.resource.RenderTarget2D', _super);
        var __proto = RenderTarget2D.prototype;
        Laya.imps(__proto, { "laya.resource.IDispose": true });
        __proto.getType = function () {
            return this._type;
        };
        __proto.getTexture = function () {
            return this;
        };
        __proto.size = function (w, h) {
            if (this._w == w && this._h == h)
                return;
            this._w = w;
            this._h = h;
            this.release();
            if (this._w != 0 && this._h != 0)
                this._createWebGLRenderTarget();
        };
        __proto.release = function () {
            this.destroy();
        };
        __proto.recycle = function () {
            RenderTarget2D.POOL.push(this);
        };
        __proto.start = function () {
            var gl = WebGL.mainContext;
            this._preRenderTarget = RenderState2D.curRenderTarget;
            RenderState2D.curRenderTarget = this;
            gl.bindFramebuffer(0x8D40, this.bitmap.frameBuffer);
            this._alreadyResolved = false;
            if (this._type == 1) {
                gl.viewport(0, 0, this._w, this._h);
                this._svWidth = RenderState2D.width;
                this._svHeight = RenderState2D.height;
                RenderState2D.width = this._w;
                RenderState2D.height = this._h;
                BaseShader.activeShader = null;
            }
            return this;
        };
        __proto.clear = function (r, g, b, a) {
            (r === void 0) && (r = 0.0);
            (g === void 0) && (g = 0.0);
            (b === void 0) && (b = 0.0);
            (a === void 0) && (a = 1.0);
            var gl = WebGL.mainContext;
            gl.clearColor(r, g, b, a);
            var clearFlag = 0x00004000;
            switch (this._depthStencilFormat) {
                case 0x81A5:
                    clearFlag |= 0x00000100;
                    break;
                case 0x8D48:
                    clearFlag |= 0x00000400;
                    break;
                case 0x84F9:
                    clearFlag |= 0x00000100;
                    clearFlag |= 0x00000400;
                    break;
            }
            gl.clear(clearFlag);
        };
        __proto.end = function () {
            var gl = WebGL.mainContext;
            gl.bindFramebuffer(0x8D40, this._preRenderTarget ? this._preRenderTarget.bitmap.frameBuffer : null);
            this._alreadyResolved = true;
            RenderState2D.curRenderTarget = this._preRenderTarget;
            if (this._type == 1) {
                gl.viewport(0, 0, this._svWidth, this._svHeight);
                RenderState2D.width = this._svWidth;
                RenderState2D.height = this._svHeight;
                BaseShader.activeShader = null;
            }
            else
                gl.viewport(0, 0, Laya.stage.width, Laya.stage.height);
        };
        __proto.getData = function (x, y, width, height) {
            var gl = WebGL.mainContext;
            gl.bindFramebuffer(0x8D40, (this.bitmap).frameBuffer);
            var canRead = (gl.checkFramebufferStatus(0x8D40) === 0x8CD5);
            if (!canRead) {
                gl.bindFramebuffer(0x8D40, null);
                return null;
            }
            ;
            var pixels = new Uint8Array(this._w * this._h * 4);
            gl.readPixels(x, y, width, height, this._surfaceFormat, this._surfaceType, pixels);
            gl.bindFramebuffer(0x8D40, null);
            return pixels;
        };
        __proto.destroy = function (foreDiposeTexture) {
            (foreDiposeTexture === void 0) && (foreDiposeTexture = false);
            if (!this._destroy) {
                this._loaded = false;
                this.bitmap.offAll();
                this.bitmap.disposeResource();
                this.bitmap.dispose();
                this.offAll();
                this.bitmap = null;
                this._alreadyResolved = false;
                this._destroy = true;
                _super.prototype.destroy.call(this);
            }
        };
        __proto.dispose = function () { };
        __proto._createWebGLRenderTarget = function () {
            this.bitmap = new WebGLRenderTarget(this.width, this.height, this._surfaceFormat, this._surfaceType, this._depthStencilFormat, this._mipMap, this._repeat, this._minFifter, this._magFifter);
            this.bitmap.activeResource();
            this._alreadyResolved = true;
            this._destroy = false;
            this._loaded = true;
            this.bitmap.on("recovered", this, function (e) {
                this.event("recovered");
            });
        };
        __getset(0, __proto, 'surfaceFormat', function () {
            return this._surfaceFormat;
        });
        __getset(0, __proto, 'magFifter', function () {
            return this._magFifter;
        });
        __getset(0, __proto, 'surfaceType', function () {
            return this._surfaceType;
        });
        __getset(0, __proto, 'mipMap', function () {
            return this._mipMap;
        });
        __getset(0, __proto, 'depthStencilFormat', function () {
            return this._depthStencilFormat;
        });
        __getset(0, __proto, 'minFifter', function () {
            return this._minFifter;
        });
        __getset(0, __proto, 'source', function () {
            if (this._alreadyResolved)
                return Laya.superGet(Texture, this, 'source');
            return null;
        });
        RenderTarget2D.create = function (w, h, surfaceFormat, surfaceType, depthStencilFormat, mipMap, repeat, minFifter, magFifter) {
            (surfaceFormat === void 0) && (surfaceFormat = 0x1908);
            (surfaceType === void 0) && (surfaceType = 0x1401);
            (depthStencilFormat === void 0) && (depthStencilFormat = 0x84F9);
            (mipMap === void 0) && (mipMap = false);
            (repeat === void 0) && (repeat = false);
            (minFifter === void 0) && (minFifter = -1);
            (magFifter === void 0) && (magFifter = -1);
            var t = RenderTarget2D.POOL.pop();
            t || (t = new RenderTarget2D(w, h));
            if (!t.bitmap || t._w != w || t._h != h || t._surfaceFormat != surfaceFormat || t._surfaceType != surfaceType || t._depthStencilFormat != depthStencilFormat || t._mipMap != mipMap || t._repeat != repeat || t._minFifter != minFifter || t._magFifter != magFifter) {
                t._w = w;
                t._h = h;
                t._surfaceFormat = surfaceFormat;
                t._surfaceType = surfaceType;
                t._depthStencilFormat = depthStencilFormat;
                t._mipMap = mipMap;
                t._repeat = repeat;
                t._minFifter = minFifter;
                t._magFifter = magFifter;
                t.release();
                t._createWebGLRenderTarget();
            }
            return t;
        };
        RenderTarget2D.TYPE2D = 1;
        RenderTarget2D.TYPE3D = 2;
        RenderTarget2D.POOL = [];
        return RenderTarget2D;
    })(Texture);
    var Buffer = (function (_super) {
        function Buffer() {
            this._glBuffer = null;
            this._buffer = null;
            this._bufferType = 0;
            this._bufferUsage = 0;
            this._byteLength = 0;
            Buffer.__super.call(this);
            Buffer._gl = WebGL.mainContext;
        }
        __class(Buffer, 'laya.webgl.utils.Buffer', _super);
        var __proto = Buffer.prototype;
        __proto._bind = function () {
            this.activeResource();
            if (Buffer._bindActive[this._bufferType] !== this._glBuffer) {
                (this._bufferType === 0x8892) && (Buffer._bindVertexBuffer = this._glBuffer);
                Buffer._gl.bindBuffer(this._bufferType, Buffer._bindActive[this._bufferType] = this._glBuffer);
                BaseShader.activeShader = null;
            }
        };
        __proto.recreateResource = function () {
            this._glBuffer || (this._glBuffer = Buffer._gl.createBuffer());
            this.completeCreate();
        };
        __proto.disposeResource = function () {
            if (this._glBuffer) {
                WebGL.mainContext.deleteBuffer(this._glBuffer);
                this._glBuffer = null;
            }
            this.memorySize = 0;
        };
        __getset(0, __proto, 'bufferUsage', function () {
            return this._bufferUsage;
        });
        Buffer._gl = null;
        Buffer._bindActive = {};
        Buffer._bindVertexBuffer = null;
        Buffer._enableAtributes = [];
        return Buffer;
    })(Resource);
    var SkinSV = (function (_super) {
        function SkinSV(type) {
            this.texcoord = null;
            this.offsetX = 300;
            this.offsetY = 0;
            SkinSV.__super.call(this, 0x200, 0);
            var _vlen = 8 * CONST3D2D.BYTES_PE;
            this.position = [2, 0x1406, false, _vlen, 0];
            this.texcoord = [2, 0x1406, false, _vlen, 2 * CONST3D2D.BYTES_PE];
            this.color = [4, 0x1406, false, _vlen, 4 * CONST3D2D.BYTES_PE];
        }
        __class(SkinSV, 'laya.webgl.shader.d2.skinAnishader.SkinSV', _super);
        return SkinSV;
    })(Value2D);
    var Color2dSV = (function (_super) {
        function Color2dSV(args) {
            Color2dSV.__super.call(this, 0x02, 0);
            this.color = [];
        }
        __class(Color2dSV, 'laya.webgl.shader.d2.value.Color2dSV', _super);
        var __proto = Color2dSV.prototype;
        __proto.setValue = function (value) {
            value.fillStyle && (this.color = value.fillStyle._color._color);
            value.strokeStyle && (this.color = value.strokeStyle._color._color);
        };
        return Color2dSV;
    })(Value2D);
    var FillTextureSV = (function (_super) {
        function FillTextureSV(type) {
            this.u_colorMatrix = null;
            this.strength = 0;
            this.colorMat = null;
            this.colorAlpha = null;
            this.u_TexRange = [0, 1, 0, 1];
            this.u_offset = [0, 0];
            this.texcoord = Value2D._TEXCOORD;
            FillTextureSV.__super.call(this, 0x100, 0);
        }
        __class(FillTextureSV, 'laya.webgl.shader.d2.value.FillTextureSV', _super);
        var __proto = FillTextureSV.prototype;
        __proto.setValue = function (vo) {
            this.ALPHA = vo.ALPHA;
            vo.filters && this.setFilters(vo.filters);
        };
        __proto.clear = function () {
            this.texture = null;
            this.shader = null;
            this.defines.setValue(0);
        };
        return FillTextureSV;
    })(Value2D);
    var TextureSV = (function (_super) {
        function TextureSV(subID) {
            this.u_colorMatrix = null;
            this.strength = 0;
            this.blurInfo = null;
            this.colorMat = null;
            this.colorAlpha = null;
            this.texcoord = Value2D._TEXCOORD;
            (subID === void 0) && (subID = 0);
            TextureSV.__super.call(this, 0x01, subID);
        }
        __class(TextureSV, 'laya.webgl.shader.d2.value.TextureSV', _super);
        var __proto = TextureSV.prototype;
        __proto.setValue = function (vo) {
            this.ALPHA = vo.ALPHA;
            vo.filters && this.setFilters(vo.filters);
        };
        __proto.clear = function () {
            this.texture = null;
            this.shader = null;
            this.defines.setValue(0);
        };
        return TextureSV;
    })(Value2D);
    var PrimitiveSV = (function (_super) {
        function PrimitiveSV(args) {
            this.a_color = null;
            this.u_pos = [0, 0];
            PrimitiveSV.__super.call(this, 0x04, 0);
            this.position = [2, 0x1406, false, 5 * CONST3D2D.BYTES_PE, 0];
            this.a_color = [3, 0x1406, false, 5 * CONST3D2D.BYTES_PE, 2 * CONST3D2D.BYTES_PE];
        }
        __class(PrimitiveSV, 'laya.webgl.shader.d2.value.PrimitiveSV', _super);
        return PrimitiveSV;
    })(Value2D);
    var AtlasWebGLCanvas = (function (_super) {
        function AtlasWebGLCanvas() {
            this._atlaser = null;
            this._flashCacheImage = null;
            this._flashCacheImageNeedFlush = false;
            AtlasWebGLCanvas.__super.call(this);
        }
        __class(AtlasWebGLCanvas, 'laya.webgl.atlas.AtlasWebGLCanvas', _super);
        var __proto = AtlasWebGLCanvas.prototype;
        __proto.recreateResource = function () {
            var gl = WebGL.mainContext;
            var glTex = this._source = gl.createTexture();
            var preTarget = WebGLContext.curBindTexTarget;
            var preTexture = WebGLContext.curBindTexValue;
            WebGLContext.bindTexture(gl, 0x0DE1, glTex);
            gl.texImage2D(0x0DE1, 0, 0x1908, this._w, this._h, 0, 0x1908, 0x1401, null);
            gl.texParameteri(0x0DE1, 0x2801, 0x2601);
            gl.texParameteri(0x0DE1, 0x2800, 0x2601);
            gl.texParameteri(0x0DE1, 0x2802, 0x812F);
            gl.texParameteri(0x0DE1, 0x2803, 0x812F);
            (preTarget && preTexture) && (WebGLContext.bindTexture(gl, preTarget, preTexture));
            this.memorySize = this._w * this._h * 4;
            this.completeCreate();
        };
        __proto.disposeResource = function () {
            if (this._source) {
                WebGL.mainContext.deleteTexture(this._source);
                this._source = null;
                this.memorySize = 0;
            }
        };
        __proto.texSubImage2D = function (xoffset, yoffset, bitmap) {
            if (!Render.isFlash) {
                var gl = WebGL.mainContext;
                var preTarget = WebGLContext.curBindTexTarget;
                var preTexture = WebGLContext.curBindTexValue;
                WebGLContext.bindTexture(gl, 0x0DE1, this._source);
                gl.pixelStorei(0x9241, true);
                (xoffset - 1 >= 0) && (gl.texSubImage2D(0x0DE1, 0, xoffset - 1, yoffset, 0x1908, 0x1401, bitmap));
                (xoffset + 1 <= this._w) && (gl.texSubImage2D(0x0DE1, 0, xoffset + 1, yoffset, 0x1908, 0x1401, bitmap));
                (yoffset - 1 >= 0) && (gl.texSubImage2D(0x0DE1, 0, xoffset, yoffset - 1, 0x1908, 0x1401, bitmap));
                (yoffset + 1 <= this._h) && (gl.texSubImage2D(0x0DE1, 0, xoffset, yoffset + 1, 0x1908, 0x1401, bitmap));
                gl.texSubImage2D(0x0DE1, 0, xoffset, yoffset, 0x1908, 0x1401, bitmap);
                gl.pixelStorei(0x9241, false);
                (preTarget && preTexture) && (WebGLContext.bindTexture(gl, preTarget, preTexture));
            }
            else {
                if (!this._flashCacheImage) {
                    this._flashCacheImage = HTMLImage.create("");
                    this._flashCacheImage._image.createCanvas(this._w, this._h);
                }
                ;
                var bmData = bitmap.bitmapdata;
                this._flashCacheImage._image.copyPixels(bmData, 0, 0, bmData.width, bmData.height, xoffset, yoffset);
                (this._flashCacheImageNeedFlush) || (this._flashCacheImageNeedFlush = true);
            }
        };
        __proto.texSubImage2DPixel = function (xoffset, yoffset, width, height, pixel) {
            var gl = WebGL.mainContext;
            var preTarget = WebGLContext.curBindTexTarget;
            var preTexture = WebGLContext.curBindTexValue;
            WebGLContext.bindTexture(gl, 0x0DE1, this._source);
            var pixels = new Uint8Array(pixel.data);
            gl.pixelStorei(0x9241, true);
            gl.texSubImage2D(0x0DE1, 0, xoffset, yoffset, width, height, 0x1908, 0x1401, pixels);
            gl.pixelStorei(0x9241, false);
            (preTarget && preTexture) && (WebGLContext.bindTexture(gl, preTarget, preTexture));
        };
        __getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
            this._w = value;
        });
        __getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
            this._h = value;
        });
        return AtlasWebGLCanvas;
    })(Bitmap);
    var WebGLCanvas = (function (_super) {
        function WebGLCanvas() {
            this.flipY = true;
            this.premulAlpha = false;
            this.alwaysChange = false;
            WebGLCanvas.__super.call(this);
        }
        __class(WebGLCanvas, 'laya.webgl.resource.WebGLCanvas', _super);
        var __proto = WebGLCanvas.prototype;
        __proto.getCanvas = function () {
            return this._canvas;
        };
        __proto.clear = function () {
            this._ctx && this._ctx.clear();
        };
        __proto.destroy = function () {
            this._ctx && this._ctx.destroy();
            this._ctx = null;
            _super.prototype.destroy.call(this);
        };
        __proto._setContext = function (context) {
            this._ctx = context;
        };
        __proto.getContext = function (contextID, other) {
            return this._ctx ? this._ctx : (this._ctx = WebGLCanvas._createContext(this));
        };
        __proto.size = function (w, h) {
            if (this._w != w || this._h != h) {
                this._w = w;
                this._h = h;
                this._ctx && this._ctx.size(w, h);
                this._canvas && (this._canvas.height = h, this._canvas.width = w);
            }
        };
        __proto.activeResource = function (force) {
            (force === void 0) && (force = false);
            if (!this._source) {
                this.recreateResource();
            }
        };
        __proto.recreateResource = function () {
            this.createWebGlTexture();
            this.completeCreate();
        };
        __proto.disposeResource = function () {
            if (this._source && !this.iscpuSource) {
                WebGL.mainContext.deleteTexture(this._source);
                this._source = null;
                this.memorySize = 0;
            }
        };
        __proto.createWebGlTexture = function () {
            var gl = WebGL.mainContext;
            var glTex = this._source = gl.createTexture();
            this.iscpuSource = false;
            var preTarget = WebGLContext.curBindTexTarget;
            var preTexture = WebGLContext.curBindTexValue;
            WebGLContext.bindTexture(gl, 0x0DE1, glTex);
            gl.pixelStorei(0x9240, this.flipY ? 1 : 0);
            this.premulAlpha && gl.pixelStorei(0x9241, true);
            if (this._imgData.width || this._imgData.height || this._imgData.videoWidth || this._imgData.videoHeight) {
                gl.texImage2D(0x0DE1, 0, 0x1908, 0x1908, 0x1401, this._imgData);
            } else {
                if (!window['defaultImageData']) {
                    window['defaultImageData'] = new ImageData(1, 1)
                }
                gl.texImage2D(0x0DE1, 0, 0x1908, 0x1908, 0x1401, window['defaultImageData']);
            }
            this.premulAlpha && gl.pixelStorei(0x9241, false);
            gl.texParameteri(0x0DE1, 0x2800, 0x2601);
            gl.texParameteri(0x0DE1, 0x2801, 0x2601);
            gl.texParameteri(0x0DE1, 0x2802, 0x812F);
            gl.texParameteri(0x0DE1, 0x2803, 0x812F);
            gl.pixelStorei(0x9240, 0);
            this.memorySize = this._w * this._h * 4;
            (preTarget && preTexture) && (WebGLContext.bindTexture(gl, preTarget, preTexture));
        };
        __proto.reloadCanvasData = function () {
            var gl = WebGL.mainContext;
            if (!this._source) {
                console.error("reloadCanvasData error, gl texture not created!");
                return;
            }
            var preTarget = WebGLContext.curBindTexTarget;
            var preTexture = WebGLContext.curBindTexValue;
            WebGLContext.bindTexture(gl, 0x0DE1, this._source);
            this.premulAlpha && gl.pixelStorei(0x9241, true);
            if (this._imgData.width || this._imgData.height || this._imgData.videoWidth || this._imgData.videoHeight) {
                gl.texImage2D(0x0DE1, 0, 0x1908, 0x1908, 0x1401, this._imgData);
            } else {
                if (!window['defaultImageData']) {
                    window['defaultImageData'] = new ImageData(1, 1)
                }
                gl.texImage2D(0x0DE1, 0, 0x1908, 0x1908, 0x1401, window['defaultImageData']);
            }
            this.premulAlpha && gl.pixelStorei(0x9241, false);
            gl.pixelStorei(0x9240, 0);
            (preTarget && preTexture) && (WebGLContext.bindTexture(gl, preTarget, preTexture));
        };
        __proto.texSubImage2D = function (webglCanvas, xoffset, yoffset) {
            var gl = WebGL.mainContext;
            var preTarget = WebGLContext.curBindTexTarget;
            var preTexture = WebGLContext.curBindTexValue;
            WebGLContext.bindTexture(gl, 0x0DE1, this._source);
            gl.pixelStorei(0x9241, true);
            gl.texSubImage2D(0x0DE1, 0, xoffset, yoffset, 0x1908, 0x1401, webglCanvas._source);
            gl.pixelStorei(0x9241, false);
            (preTarget && preTexture) && (WebGLContext.bindTexture(gl, preTarget, preTexture));
        };
        __proto.toBase64 = function (type, encoderOptions, callBack) {
            var base64Data = null;
            if (this._canvas) {
                base64Data = this._canvas.toDataURL(type, encoderOptions);
            }
            callBack.call(this, base64Data);
        };
        __getset(0, __proto, 'context', function () {
            return this._ctx;
        });
        __getset(0, __proto, 'source', function () {
            if (this.alwaysChange)
                this.reloadCanvasData();
            return this._source;
        });
        __getset(0, __proto, 'asBitmap', null, function (value) {
            this._ctx && (this._ctx.asBitmap = value);
        });
        WebGLCanvas._createContext = null;
        return WebGLCanvas;
    })(Bitmap);
    var WebGLCharImage = (function (_super) {
        function WebGLCharImage(content, drawValue) {
            this.CborderSize = 12;
            WebGLCharImage.__super.call(this);
            this.char = content;
            this.isSpace = content === ' ';
            this.xs = drawValue.scaleX;
            this.ys = drawValue.scaleY;
            this.font = drawValue.font.toString();
            this.fontSize = drawValue.font.size;
            this.fillColor = drawValue.fillColor;
            this.borderColor = drawValue.borderColor;
            this.lineWidth = drawValue.lineWidth;
            this.underLine = drawValue.underLine;
            var bIsConchApp = Render.isConchApp;
            var pCanvas;
            if (bIsConchApp) {
                pCanvas = ConchTextCanvas;
                pCanvas._source = ConchTextCanvas;
                pCanvas._source.canvas = ConchTextCanvas;
            }
            else {
                pCanvas = Browser.canvas.source;
            }
            this.canvas = pCanvas;
            this._enableMerageInAtlas = true;
            if (bIsConchApp) {
                this._ctx = pCanvas;
            }
            else {
                this._ctx = this.canvas.getContext('2d', undefined);
            }
            ;
            var t = Utils.measureText(this.char, this.font);
            this.cw = t.width * this.xs;
            this.ch = (t.height || this.fontSize) * this.ys;
            this.onresize(this.cw + this.CborderSize * 2, this.ch + this.CborderSize * 2);
            this.texture = new Texture(this);
        }
        __class(WebGLCharImage, 'laya.webgl.resource.WebGLCharImage', _super);
        var __proto = WebGLCharImage.prototype;
        Laya.imps(__proto, { "laya.webgl.resource.IMergeAtlasBitmap": true });
        __proto.active = function () {
            this.texture.active();
        };
        __proto.recreateResource = function () {
            var bIsConchApp = Render.isConchApp;
            this.onresize(this.cw + this.CborderSize * 2, this.ch + this.CborderSize * 2);
            this.canvas && (this.canvas.height = this._h, this.canvas.width = this._w);
            if (bIsConchApp) {
                var nFontSize = this.fontSize;
                if (this.xs != 1 || this.ys != 1) {
                    nFontSize = parseInt(nFontSize * ((this.xs > this.ys) ? this.xs : this.ys) + "");
                }
                ;
                var sFont = "normal 100 " + nFontSize + "px Arial";
                if (this.borderColor) {
                    sFont += " 1 " + this.borderColor;
                }
                this._ctx.font = sFont;
                this._ctx.textBaseline = "top";
                this._ctx.fillStyle = this.fillColor;
                this._ctx.fillText(this.char, this.CborderSize, this.CborderSize, null, null, null);
            }
            else {
                this._ctx.save();
                (this._ctx).clearRect(0, 0, this.cw + this.CborderSize * 2, this.ch + this.CborderSize * 2);
                this._ctx.font = this.font;
                if (Text.RightToLeft) {
                    this._ctx.textAlign = "end";
                }
                this._ctx.textBaseline = "top";
                this._ctx.translate(this.CborderSize, this.CborderSize);
                if (this.xs != 1 || this.ys != 1) {
                    this._ctx.scale(this.xs, this.ys);
                }
                if (this.fillColor && this.borderColor) {
                    this._ctx.strokeStyle = this.borderColor;
                    this._ctx.lineWidth = this.lineWidth;
                    this._ctx.strokeText(this.char, 0, 0, null, null, 0, null);
                    this._ctx.fillStyle = this.fillColor;
                    this._ctx.fillText(this.char, 0, 0, null, null, null);
                }
                else {
                    if (this.lineWidth === -1) {
                        this._ctx.fillStyle = this.fillColor ? this.fillColor : "white";
                        this._ctx.fillText(this.char, 0, 0, null, null, null);
                    }
                    else {
                        this._ctx.strokeStyle = this.borderColor ? this.borderColor : 'white';
                        this._ctx.lineWidth = this.lineWidth;
                        this._ctx.strokeText(this.char, 0, 0, null, null, 0, null);
                    }
                }
                if (this.underLine) {
                    this._ctx.lineWidth = 1;
                    this._ctx.strokeStyle = this.fillColor;
                    this._ctx.beginPath();
                    this._ctx.moveTo(0, this.fontSize + 1);
                    var nW = this._ctx.measureText(this.char).width + 1;
                    this._ctx.lineTo(nW, this.fontSize + 1);
                    this._ctx.stroke();
                }
                this._ctx.restore();
            }
            this.borderSize = this.CborderSize;
            this.completeCreate();
        };
        __proto.onresize = function (w, h) {
            this._w = w;
            this._h = h;
            this._allowMerageInAtlas = true;
        };
        __proto.clearAtlasSource = function () { };
        __getset(0, __proto, 'allowMerageInAtlas', function () {
            return this._allowMerageInAtlas;
        });
        __getset(0, __proto, 'atlasSource', function () {
            return this.canvas;
        });
        __getset(0, __proto, 'enableMerageInAtlas', function () {
            return this._enableMerageInAtlas;
        }, function (value) {
            this._enableMerageInAtlas = value;
        });
        WebGLCharImage.createOneChar = function (content, drawValue) {
            var char = new WebGLCharImage(content, drawValue);
            return char;
        };
        return WebGLCharImage;
    })(Bitmap);
    var WebGLRenderTarget = (function (_super) {
        function WebGLRenderTarget(width, height, surfaceFormat, surfaceType, depthStencilFormat, mipMap, repeat, minFifter, magFifter) {
            (surfaceFormat === void 0) && (surfaceFormat = 0x1908);
            (surfaceType === void 0) && (surfaceType = 0x1401);
            (depthStencilFormat === void 0) && (depthStencilFormat = 0x84F9);
            (mipMap === void 0) && (mipMap = false);
            (repeat === void 0) && (repeat = false);
            (minFifter === void 0) && (minFifter = -1);
            (magFifter === void 0) && (magFifter = 1);
            WebGLRenderTarget.__super.call(this);
            this._w = width;
            this._h = height;
            this._surfaceFormat = surfaceFormat;
            this._surfaceType = surfaceType;
            this._depthStencilFormat = depthStencilFormat;
            this._mipMap = mipMap;
            this._repeat = repeat;
            this._minFifter = minFifter;
            this._magFifter = magFifter;
        }
        __class(WebGLRenderTarget, 'laya.webgl.resource.WebGLRenderTarget', _super);
        var __proto = WebGLRenderTarget.prototype;
        __proto.recreateResource = function () {
            var gl = WebGL.mainContext;
            this._frameBuffer || (this._frameBuffer = gl.createFramebuffer());
            this._source || (this._source = gl.createTexture());
            var preTarget = WebGLContext.curBindTexTarget;
            var preTexture = WebGLContext.curBindTexValue;
            WebGLContext.bindTexture(gl, 0x0DE1, this._source);
            gl.texImage2D(0x0DE1, 0, 0x1908, this._w, this._h, 0, this._surfaceFormat, this._surfaceType, null);
            var minFifter = this._minFifter;
            var magFifter = this._magFifter;
            var repeat = this._repeat ? 0x2901 : 0x812F;
            var isPot = Arith.isPOT(this._w, this._h);
            if (isPot) {
                if (this._mipMap)
                    (minFifter !== -1) || (minFifter = 0x2703);
                else
                    (minFifter !== -1) || (minFifter = 0x2601);
                (magFifter !== -1) || (magFifter = 0x2601);
                gl.texParameteri(0x0DE1, 0x2801, minFifter);
                gl.texParameteri(0x0DE1, 0x2800, magFifter);
                gl.texParameteri(0x0DE1, 0x2802, repeat);
                gl.texParameteri(0x0DE1, 0x2803, repeat);
                this._mipMap && gl.generateMipmap(0x0DE1);
            }
            else {
                (minFifter !== -1) || (minFifter = 0x2601);
                (magFifter !== -1) || (magFifter = 0x2601);
                gl.texParameteri(0x0DE1, 0x2801, minFifter);
                gl.texParameteri(0x0DE1, 0x2800, magFifter);
                gl.texParameteri(0x0DE1, 0x2802, 0x812F);
                gl.texParameteri(0x0DE1, 0x2803, 0x812F);
            }
            gl.bindFramebuffer(0x8D40, this._frameBuffer);
            gl.framebufferTexture2D(0x8D40, 0x8CE0, 0x0DE1, this._source, 0);
            if (this._depthStencilFormat) {
                this._depthStencilBuffer || (this._depthStencilBuffer = gl.createRenderbuffer());
                gl.bindRenderbuffer(0x8D41, this._depthStencilBuffer);
                gl.renderbufferStorage(0x8D41, this._depthStencilFormat, this._w, this._h);
                switch (this._depthStencilFormat) {
                    case 0x81A5:
                        gl.framebufferRenderbuffer(0x8D40, 0x8D00, 0x8D41, this._depthStencilBuffer);
                        break;
                    case 0x8D48:
                        gl.framebufferRenderbuffer(0x8D40, 0x8D20, 0x8D41, this._depthStencilBuffer);
                        break;
                    case 0x84F9:
                        gl.framebufferRenderbuffer(0x8D40, 0x821A, 0x8D41, this._depthStencilBuffer);
                        break;
                }
            }
            gl.bindFramebuffer(0x8D40, null);
            (preTarget && preTexture) && (WebGLContext.bindTexture(gl, preTarget, preTexture));
            gl.bindRenderbuffer(0x8D41, null);
            if (isPot && this._mipMap)
                this.memorySize = this._w * this._h * 4 * (1 + 1 / 3);
            else
                this.memorySize = this._w * this._h * 4;
            this.completeCreate();
        };
        __proto.disposeResource = function () {
            if (this._frameBuffer) {
                WebGL.mainContext.deleteTexture(this._source);
                WebGL.mainContext.deleteFramebuffer(this._frameBuffer);
                WebGL.mainContext.deleteRenderbuffer(this._depthStencilBuffer);
                this._source = null;
                this._frameBuffer = null;
                this._depthStencilBuffer = null;
                this.memorySize = 0;
            }
        };
        __getset(0, __proto, 'depthStencilBuffer', function () {
            return this._depthStencilBuffer;
        });
        __getset(0, __proto, 'frameBuffer', function () {
            return this._frameBuffer;
        });
        return WebGLRenderTarget;
    })(Bitmap);
    var WebGLSubImage = (function (_super) {
        function WebGLSubImage(canvas, offsetX, offsetY, width, height, atlasImage, src) {
            this.offsetX = 0;
            this.offsetY = 0;
            WebGLSubImage.__super.call(this);
            this.repeat = true;
            this.mipmap = false;
            this.minFifter = -1;
            this.magFifter = -1;
            this.atlasImage = atlasImage;
            this.canvas = canvas;
            this._ctx = canvas.getContext('2d', undefined);
            this._w = width;
            this._h = height;
            this.offsetX = offsetX;
            this.offsetY = offsetY;
            this.src = src;
            this._enableMerageInAtlas = true;
            (AtlasResourceManager.enabled) && (this._w < AtlasResourceManager.atlasLimitWidth && this._h < AtlasResourceManager.atlasLimitHeight) ? this._allowMerageInAtlas = true : this._allowMerageInAtlas = false;
        }
        __class(WebGLSubImage, 'laya.webgl.resource.WebGLSubImage', _super);
        var __proto = WebGLSubImage.prototype;
        Laya.imps(__proto, { "laya.webgl.resource.IMergeAtlasBitmap": true });
        __proto.size = function (w, h) {
            this._w = w;
            this._h = h;
            this._ctx && this._ctx.size(w, h);
            this.canvas && (this.canvas.height = h, this.canvas.width = w);
        };
        __proto.recreateResource = function () {
            this.size(this._w, this._h);
            this._ctx.drawImage(this.atlasImage, this.offsetX, this.offsetY, this._w, this._h, 0, 0, this._w, this._h);
            (!(this._allowMerageInAtlas && this._enableMerageInAtlas)) ? (this.createWebGlTexture()) : (this.memorySize = 0);
            this.completeCreate();
        };
        __proto.createWebGlTexture = function () {
            var gl = WebGL.mainContext;
            if (!this.canvas) {
                throw "create GLTextur err:no data:" + this.canvas;
            }
            var glTex = this._source = gl.createTexture();
            var preTarget = WebGLContext.curBindTexTarget;
            var preTexture = WebGLContext.curBindTexValue;
            WebGLContext.bindTexture(gl, 0x0DE1, glTex);
            gl.pixelStorei(0x9241, true);
            gl.texImage2D(0x0DE1, 0, 0x1908, 0x1908, 0x1401, this.canvas);
            gl.pixelStorei(0x9241, false);
            var minFifter = this.minFifter;
            var magFifter = this.magFifter;
            var repeat = this.repeat ? 0x2901 : 0x812F;
            var isPOT = Arith.isPOT(this.width, this.height);
            if (isPOT) {
                if (this.mipmap)
                    (minFifter !== -1) || (minFifter = 0x2703);
                else
                    (minFifter !== -1) || (minFifter = 0x2601);
                (magFifter !== -1) || (magFifter = 0x2601);
                gl.texParameteri(0x0DE1, 0x2800, magFifter);
                gl.texParameteri(0x0DE1, 0x2801, minFifter);
                gl.texParameteri(0x0DE1, 0x2802, repeat);
                gl.texParameteri(0x0DE1, 0x2803, repeat);
                this.mipmap && gl.generateMipmap(0x0DE1);
            }
            else {
                (minFifter !== -1) || (minFifter = 0x2601);
                (magFifter !== -1) || (magFifter = 0x2601);
                gl.texParameteri(0x0DE1, 0x2801, minFifter);
                gl.texParameteri(0x0DE1, 0x2800, magFifter);
                gl.texParameteri(0x0DE1, 0x2802, 0x812F);
                gl.texParameteri(0x0DE1, 0x2803, 0x812F);
            }
            (preTarget && preTexture) && (WebGLContext.bindTexture(gl, preTarget, preTexture));
            this.canvas = null;
            if (isPOT && this.mipmap)
                this.memorySize = this._w * this._h * 4 * (1 + 1 / 3);
            else
                this.memorySize = this._w * this._h * 4;
        };
        __proto.disposeResource = function () {
            if (!(AtlasResourceManager.enabled && this._allowMerageInAtlas) && this._source) {
                WebGL.mainContext.deleteTexture(this._source);
                this._source = null;
                this.memorySize = 0;
            }
        };
        __proto.clearAtlasSource = function () { };
        __getset(0, __proto, 'allowMerageInAtlas', function () {
            return this._allowMerageInAtlas;
        });
        __getset(0, __proto, 'atlasSource', function () {
            return this.canvas;
        });
        __getset(0, __proto, 'enableMerageInAtlas', function () {
            return this._allowMerageInAtlas;
        }, function (value) {
            this._allowMerageInAtlas = value;
        });
        return WebGLSubImage;
    })(Bitmap);
    var Shader = (function (_super) {
        function Shader(vs, ps, saveName, nameMap) {
            this.customCompile = false;
            this._curActTexIndex = 0;
            this.tag = {};
            this._program = null;
            this._params = null;
            this._paramsMap = {};
            this._offset = 0;
            Shader.__super.call(this);
            if ((!vs) || (!ps))
                throw "Shader Error";
            if (Render.isConchApp || Render.isFlash) {
                this.customCompile = true;
            }
            this._id = ++Shader._count;
            this._vs = vs;
            this._ps = ps;
            this._nameMap = nameMap ? nameMap : {};
            saveName != null && (Shader.sharders[saveName] = this);
        }
        __class(Shader, 'laya.webgl.shader.Shader', _super);
        var __proto = Shader.prototype;
        __proto.recreateResource = function () {
            this._compile();
            this.completeCreate();
            this.memorySize = 0;
        };
        __proto.disposeResource = function () {
            WebGL.mainContext.deleteShader(this._vshader);
            WebGL.mainContext.deleteShader(this._pshader);
            WebGL.mainContext.deleteProgram(this._program);
            this._vshader = this._pshader = this._program = null;
            this._params = null;
            this._paramsMap = {};
            this.memorySize = 0;
            this._curActTexIndex = 0;
        };
        __proto._compile = function () {
            if (!this._vs || !this._ps || this._params)
                return;
            this._reCompile = true;
            this._params = [];
            var text = [this._vs, this._ps];
            var result;
            if (this.customCompile)
                result = ShaderCompile.preGetParams(this._vs, this._ps);
            var gl = WebGL.mainContext;
            this._program = gl.createProgram();
            this._vshader = Shader._createShader(gl, text[0], 0x8B31);
            this._pshader = Shader._createShader(gl, text[1], 0x8B30);
            gl.attachShader(this._program, this._vshader);
            gl.attachShader(this._program, this._pshader);
            gl.linkProgram(this._program);
            if (!this.customCompile && !gl.getProgramParameter(this._program, 0x8B82)) {
                // throw gl.getProgramInfoLog(this._program);
                console.log("shader error", gl.getProgramInfoLog(this._program));
                return;

            }
            ;
            var one, i = 0, j = 0, n = 0, location;
            var attribNum = this.customCompile ? result.attributes.length : gl.getProgramParameter(this._program, 0x8B89);
            for (i = 0; i < attribNum; i++) {
                var attrib = this.customCompile ? result.attributes[i] : gl.getActiveAttrib(this._program, i);
                location = gl.getAttribLocation(this._program, attrib.name);
                one = { vartype: "attribute", glfun: null, ivartype: 0, attrib: attrib, location: location, name: attrib.name, type: attrib.type, isArray: false, isSame: false, preValue: null, indexOfParams: 0 };
                this._params.push(one);
            }
            ;
            var nUniformNum = this.customCompile ? result.uniforms.length : gl.getProgramParameter(this._program, 0x8B86);
            for (i = 0; i < nUniformNum; i++) {
                var uniform = this.customCompile ? result.uniforms[i] : gl.getActiveUniform(this._program, i);
                location = gl.getUniformLocation(this._program, uniform.name);
                one = { vartype: "uniform", glfun: null, ivartype: 1, attrib: attrib, location: location, name: uniform.name, type: uniform.type, isArray: false, isSame: false, preValue: null, indexOfParams: 0 };
                if (one.name.indexOf('[0]') > 0) {
                    one.name = one.name.substr(0, one.name.length - 3);
                    one.isArray = true;
                    one.location = gl.getUniformLocation(this._program, one.name);
                }
                this._params.push(one);
            }
            for (i = 0, n = this._params.length; i < n; i++) {
                one = this._params[i];
                one.indexOfParams = i;
                one.index = 1;
                one.value = [one.location, null];
                one.codename = one.name;
                one.name = this._nameMap[one.codename] ? this._nameMap[one.codename] : one.codename;
                this._paramsMap[one.name] = one;
                one._this = this;
                one.uploadedValue = [];
                if (one.vartype === "attribute") {
                    one.fun = this._attribute;
                    continue;
                }
                switch (one.type) {
                    case 0x1404:
                        one.fun = one.isArray ? this._uniform1iv : this._uniform1i;
                        break;
                    case 0x1406:
                        one.fun = one.isArray ? this._uniform1fv : this._uniform1f;
                        break;
                    case 0x8B50:
                        one.fun = one.isArray ? this._uniform_vec2v : this._uniform_vec2;
                        break;
                    case 0x8B51:
                        one.fun = one.isArray ? this._uniform_vec3v : this._uniform_vec3;
                        break;
                    case 0x8B52:
                        one.fun = one.isArray ? this._uniform_vec4v : this._uniform_vec4;
                        break;
                    case 0x8B5E:
                        one.fun = this._uniform_sampler2D;
                        break;
                    case 0x8B60:
                        one.fun = this._uniform_samplerCube;
                        break;
                    case 0x8B5C:
                        one.glfun = gl.uniformMatrix4fv;
                        one.fun = this._uniformMatrix4fv;
                        break;
                    case 0x8B56:
                        one.fun = this._uniform1i;
                        break;
                    case 0x8B5A:
                    case 0x8B5B:
                        throw new Error("compile shader err!");
                        break;
                    default:
                        throw new Error("compile shader err!");
                        break;
                }
            }
        };
        __proto.getUniform = function (name) {
            return this._paramsMap[name];
        };
        __proto._attribute = function (one, value) {
            if (value == null) return 1;
            var gl = WebGL.mainContext;
            var enableAtributes = Buffer._enableAtributes;
            var location = one.location;
            (enableAtributes[location]) || (gl.enableVertexAttribArray(location));
            gl.vertexAttribPointer(location, value[0], value[1], value[2], value[3], value[4] + this._offset);
            enableAtributes[location] = Buffer._bindVertexBuffer;
            return 1;
        };
        __proto._uniform1f = function (one, value) {
            if (value == null) return 0;
            var uploadedValue = one.uploadedValue;
            if (uploadedValue[0] !== value) {
                WebGL.mainContext.uniform1f(one.location, uploadedValue[0] = value);
                return 1;
            }
            return 0;
        };
        __proto._uniform1fv = function (one, value) {
            if (value == null) return 0;
            if (value.length < 4) {
                var uploadedValue = one.uploadedValue;
                if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2] || uploadedValue[3] !== value[3]) {
                    WebGL.mainContext.uniform1fv(one.location, value);
                    uploadedValue[0] = value[0];
                    uploadedValue[1] = value[1];
                    uploadedValue[2] = value[2];
                    uploadedValue[3] = value[3];
                    return 1;
                }
                return 0;
            }
            else {
                WebGL.mainContext.uniform1fv(one.location, value);
                return 1;
            }
        };
        __proto._uniform_vec2 = function (one, value) {
            var uploadedValue = one.uploadedValue;
            if (uploadedValue && value && (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1])) {
                WebGL.mainContext.uniform2f(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1]);
                return 1;
            }
            return 0;
        };
        __proto._uniform_vec2v = function (one, value) {
            if (value == null) return 0;
            if (value.length < 2) {
                var uploadedValue = one.uploadedValue;
                if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2] || uploadedValue[3] !== value[3]) {
                    WebGL.mainContext.uniform2fv(one.location, value);
                    uploadedValue[0] = value[0];
                    uploadedValue[1] = value[1];
                    uploadedValue[2] = value[2];
                    uploadedValue[3] = value[3];
                    return 1;
                }
                return 0;
            }
            else {
                WebGL.mainContext.uniform2fv(one.location, value);
                return 1;
            }
        };
        __proto._uniform_vec3 = function (one, value) {
            if (value != null) {
                var uploadedValue = one.uploadedValue;
                if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2]) {
                    WebGL.mainContext.uniform3f(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1], uploadedValue[2] = value[2]);
                    return 1;
                }
            }
            return 0;
        };
        __proto._uniform_vec3v = function (one, value) {
            if (value != null) WebGL.mainContext.uniform3fv(one.location, value);
            return 1;
        };
        __proto._uniform_vec4 = function (one, value) {
            if (value != null) {
                var uploadedValue = one.uploadedValue;
                if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2] || uploadedValue[3] !== value[3]) {
                    WebGL.mainContext.uniform4f(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1], uploadedValue[2] = value[2], uploadedValue[3] = value[3]);
                    return 1;
                }
            }
            return 0;
        };
        __proto._uniform_vec4v = function (one, value) {
            if (value != null) WebGL.mainContext.uniform4fv(one.location, value);
            return 1;
        };
        __proto._uniformMatrix2fv = function (one, value) {
            if (value != null) WebGL.mainContext.uniformMatrix2fv(one.location, false, value);
            return 1;
        };
        __proto._uniformMatrix3fv = function (one, value) {
            if (value != null) WebGL.mainContext.uniformMatrix3fv(one.location, false, value);
            return 1;
        };
        __proto._uniformMatrix4fv = function (one, value) {
            if (value != null) WebGL.mainContext.uniformMatrix4fv(one.location, false, value);
            return 1;
        };
        __proto._uniform1i = function (one, value) {
            var uploadedValue = one.uploadedValue;
            if (uploadedValue[0] !== value) {
                WebGL.mainContext.uniform1i(one.location, uploadedValue[0] = value);
                return 1;
            }
            return 0;
        };
        __proto._uniform1iv = function (one, value) {
            WebGL.mainContext.uniform1iv(one.location, value);
            return 1;
        };
        __proto._uniform_ivec2 = function (one, value) {
            var uploadedValue = one.uploadedValue;
            if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1]) {
                WebGL.mainContext.uniform2i(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1]);
                return 1;
            }
            return 0;
        };
        __proto._uniform_ivec2v = function (one, value) {
            WebGL.mainContext.uniform2iv(one.location, value);
            return 1;
        };
        __proto._uniform_vec3i = function (one, value) {
            var uploadedValue = one.uploadedValue;
            if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2]) {
                WebGL.mainContext.uniform3i(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1], uploadedValue[2] = value[2]);
                return 1;
            }
            return 0;
        };
        __proto._uniform_vec3vi = function (one, value) {
            WebGL.mainContext.uniform3iv(one.location, value);
            return 1;
        };
        __proto._uniform_vec4i = function (one, value) {
            var uploadedValue = one.uploadedValue;
            if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2] || uploadedValue[3] !== value[3]) {
                WebGL.mainContext.uniform4i(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1], uploadedValue[2] = value[2], uploadedValue[3] = value[3]);
                return 1;
            }
            return 0;
        };
        __proto._uniform_vec4vi = function (one, value) {
            WebGL.mainContext.uniform4iv(one.location, value);
            return 1;
        };
        __proto._uniform_sampler2D = function (one, value) {
            var gl = WebGL.mainContext;
            var uploadedValue = one.uploadedValue;
            if (uploadedValue[0] == null) {
                uploadedValue[0] = this._curActTexIndex;
                gl.uniform1i(one.location, this._curActTexIndex);
                gl.activeTexture(Shader._TEXTURES[this._curActTexIndex]);
                WebGLContext.bindTexture(gl, 0x0DE1, value);
                this._curActTexIndex++;
                return 1;
            }
            else {
                gl.activeTexture(Shader._TEXTURES[uploadedValue[0]]);
                WebGLContext.bindTexture(gl, 0x0DE1, value);
                return 0;
            }
        };
        __proto._uniform_samplerCube = function (one, value) {
            var gl = WebGL.mainContext;
            var uploadedValue = one.uploadedValue;
            if (uploadedValue[0] == null) {
                uploadedValue[0] = this._curActTexIndex;
                gl.uniform1i(one.location, this._curActTexIndex);
                gl.activeTexture(Shader._TEXTURES[this._curActTexIndex]);
                WebGLContext.bindTexture(gl, 0x8513, value);
                this._curActTexIndex++;
                return 1;
            }
            else {
                gl.activeTexture(Shader._TEXTURES[uploadedValue[0]]);
                WebGLContext.bindTexture(gl, 0x8513, value);
                return 0;
            }
        };
        __proto._noSetValue = function (one) {
            console_log("no....:" + one.name);
        };
        __proto.uploadOne = function (name, value) {
            this.activeResource();
            WebGLContext.UseProgram(this._program);
            var one = this._paramsMap[name];
            one.fun.call(this, one, value);
        };
        __proto.uploadTexture2D = function (value) {
            Stat.shaderCall++;
            var gl = WebGL.mainContext;
            gl.activeTexture(0x84C0);
            WebGLContext.bindTexture(gl, 0x0DE1, value);
        };
        __proto.upload = function (shaderValue, params) {
            BaseShader.activeShader = BaseShader.bindShader = this;
            this._lastUseFrameCount === Stat.loopCount || this.activeResource();
            WebGLContext.UseProgram(this._program);
            if (this._reCompile) {
                params = this._params;
                this._reCompile = false;
            }
            else {
                params = params || this._params;
            }
            ;
            var gl = WebGL.mainContext;
            var one, value, n = params.length, shaderCall = 0;
            for (var i = 0; i < n; i++) {
                one = params[i];
                if ((value = shaderValue[one.name]) !== null)
                    shaderCall += one.fun.call(this, one, value);
            }
            Stat.shaderCall += shaderCall;
        };
        __proto.uploadArray = function (shaderValue, length, _bufferUsage) {
            BaseShader.activeShader = this;
            BaseShader.bindShader = this;
            this.activeResource();
            WebGLContext.UseProgram(this._program);
            var params = this._params, value;
            var one, shaderCall = 0;
            for (var i = length - 2; i >= 0; i -= 2) {
                one = this._paramsMap[shaderValue[i]];
                if (!one)
                    continue;
                value = shaderValue[i + 1];
                if (value != null) {
                    _bufferUsage && _bufferUsage[one.name] && _bufferUsage[one.name].bind();
                    shaderCall += one.fun.call(this, one, value);
                }
            }
            Stat.shaderCall += shaderCall;
        };
        __proto.getParams = function () {
            return this._params;
        };
        Shader.getShader = function (name) {
            return Shader.sharders[name];
        };
        Shader.create = function (vs, ps, saveName, nameMap) {
            return new Shader(vs, ps, saveName, nameMap);
        };
        Shader.withCompile = function (nameID, define, shaderName, createShader) {
            if (shaderName && Shader.sharders[shaderName])
                return Shader.sharders[shaderName];
            var pre = Shader._preCompileShader[0.0002 * nameID];
            if (!pre)
                throw new Error("withCompile shader err!" + nameID);
            return pre.createShader(define, shaderName, createShader);
        };
        Shader.withCompile2D = function (nameID, mainID, define, shaderName, createShader, kdsSetMaterialMacrosID) {

            // 创建
            // var sd = ShaderValue.kdsMaterialShaders[kdsSetMaterialMacrosID]
            // if(sd)return sd;
            // if(ShaderValue){}
            // return 

            if (!kdsSetMaterialMacrosID && shaderName && Shader.sharders[shaderName])
                return Shader.sharders[shaderName];
            var pre = Shader._preCompileShader[0.0002 * nameID + mainID];
            if (!pre)
                throw new Error("withCompile shader err!" + nameID + " " + mainID);
            return pre.createShader(define, shaderName, createShader);
        };
        Shader.addInclude = function (fileName, txt, force) {
            ShaderCompile.addInclude(fileName, txt, force);
        };
        Shader.preCompile = function (nameID, vs, ps, nameMap) {
            var id = 0.0002 * nameID;
            Shader._preCompileShader[id] = new ShaderCompile(id, vs, ps, nameMap);
        };
        Shader.preCompile2D = function (nameID, mainID, vs, ps, nameMap) {
            var id = 0.0002 * nameID + mainID;
            Shader._preCompileShader[id] = new ShaderCompile(id, vs, ps, nameMap);
        };
        Shader._createShader = function (gl, str, type) {
            var shader = gl.createShader(type);
            gl.shaderSource(shader, str);
            gl.compileShader(shader);
            return shader;
        };
        Shader._TEXTURES = [0x84C0, 0x84C1, 0x84C2, 0x84C3, 0x84C4, 0x84C5, 0x84C6, , 0x84C7, 0x84C8];
        Shader._count = 0;
        Shader._preCompileShader = {};
        Shader.SHADERNAME2ID = 0.0002;
        Shader.sharders = (Shader.sharders = [], Shader.sharders.length = 0x20, Shader.sharders);
        __static(Shader, ['nameKey', function () { return this.nameKey = new StringKey(); }
        ]);
        return Shader;
    })(BaseShader);
    var Buffer2D = (function (_super) {
        function Buffer2D() {
            this._maxsize = 0;
            this._upload = true;
            this._uploadSize = 0;
            Buffer2D.__super.call(this);
            this.lock = true;
        }
        __class(Buffer2D, 'laya.webgl.utils.Buffer2D', _super);
        var __proto = Buffer2D.prototype;
        __proto.needSize = function (sz) {
            var old = this._byteLength;
            if (sz) {
                var needsz = this._byteLength + sz;
                needsz <= this._buffer.byteLength || (this._resizeBuffer(needsz << 1, true));
                this._byteLength = needsz;
            }
            return old;
        };
        __proto._bufferData = function () {
            this._maxsize = Math.max(this._maxsize, this._byteLength);
            if (Stat.loopCount % 30 == 0) {
                if (this._buffer.byteLength > (this._maxsize + 64)) {
                    this.memorySize = this._buffer.byteLength;
                    this._buffer = this._buffer.slice(0, this._maxsize + 64);
                    this._checkArrayUse();
                }
                this._maxsize = this._byteLength;
            }
            if (this._uploadSize < this._buffer.byteLength) {
                this._uploadSize = this._buffer.byteLength;
                Buffer._gl.bufferData(this._bufferType, this._uploadSize, this._bufferUsage);
                this.memorySize = this._uploadSize;
            }
            Buffer._gl.bufferSubData(this._bufferType, 0, this._buffer);
        };
        __proto._bufferSubData = function (offset, dataStart, dataLength) {
            (offset === void 0) && (offset = 0);
            (dataStart === void 0) && (dataStart = 0);
            (dataLength === void 0) && (dataLength = 0);
            this._maxsize = Math.max(this._maxsize, this._byteLength);
            if (Stat.loopCount % 30 == 0) {
                if (this._buffer.byteLength > (this._maxsize + 64)) {
                    this.memorySize = this._buffer.byteLength;
                    this._buffer = this._buffer.slice(0, this._maxsize + 64);
                    this._checkArrayUse();
                }
                this._maxsize = this._byteLength;
            }
            if (this._uploadSize < this._buffer.byteLength) {
                this._uploadSize = this._buffer.byteLength;
                Buffer._gl.bufferData(this._bufferType, this._uploadSize, this._bufferUsage);
                this.memorySize = this._uploadSize;
            }
            if (dataStart || dataLength) {
                var subBuffer = this._buffer.slice(dataStart, dataLength);
                Buffer._gl.bufferSubData(this._bufferType, offset, subBuffer);
            }
            else {
                Buffer._gl.bufferSubData(this._bufferType, offset, this._buffer);
            }
        };
        __proto._checkArrayUse = function () { };
        __proto._bind_upload = function () {
            if (!this._upload)
                return false;
            this._upload = false;
            this._bind();
            this._bufferData();
            return true;
        };
        __proto._bind_subUpload = function (offset, dataStart, dataLength) {
            (offset === void 0) && (offset = 0);
            (dataStart === void 0) && (dataStart = 0);
            (dataLength === void 0) && (dataLength = 0);
            if (!this._upload)
                return false;
            this._upload = false;
            this._bind();
            this._bufferSubData(offset, dataStart, dataLength);
            return true;
        };
        __proto._resizeBuffer = function (nsz, copy) {
            if (nsz < this._buffer.byteLength)
                return this;
            this.memorySize = nsz;
            if (copy && this._buffer && this._buffer.byteLength > 0) {
                var newbuffer = new ArrayBuffer(nsz);
                var n = new Uint8Array(newbuffer);
                n.set(new Uint8Array(this._buffer), 0);
                this._buffer = newbuffer;
            }
            else
                this._buffer = new ArrayBuffer(nsz);
            this._checkArrayUse();
            this._upload = true;
            return this;
        };
        __proto.append = function (data) {
            this._upload = true;
            var byteLen = 0, n;
            byteLen = data.byteLength;
            if ((data instanceof Uint8Array)) {
                this._resizeBuffer(this._byteLength + byteLen, true);
                n = new Uint8Array(this._buffer, this._byteLength);
            }
            else if ((data instanceof Uint16Array)) {
                this._resizeBuffer(this._byteLength + byteLen, true);
                n = new Uint16Array(this._buffer, this._byteLength);
            }
            else if ((data instanceof Float32Array)) {
                this._resizeBuffer(this._byteLength + byteLen, true);
                n = new Float32Array(this._buffer, this._byteLength);
            }
            n.set(data, 0);
            this._byteLength += byteLen;
            this._checkArrayUse();
        };
        __proto.appendU16Array = function (data, len) {
            this._resizeBuffer(this._byteLength + len * 2, true);
            var u = new Uint16Array(this._buffer, this._byteLength, len);
            for (var i = 0; i < len; i++) {
                u[i] = data[i];
            }
            this._byteLength += len * 2;
            this._checkArrayUse();
        };
        __proto.appendEx = function (data, type) {
            this._upload = true;
            var byteLen = 0, n;
            byteLen = data.byteLength;
            this._resizeBuffer(this._byteLength + byteLen, true);
            n = new type(this._buffer, this._byteLength);
            n.set(data, 0);
            this._byteLength += byteLen;
            this._checkArrayUse();
        };
        __proto.appendEx2 = function (data, type, dataLen, perDataLen) {
            (perDataLen === void 0) && (perDataLen = 1);
            this._upload = true;
            var byteLen = 0, n;
            byteLen = dataLen * perDataLen;
            this._resizeBuffer(this._byteLength + byteLen, true);
            n = new type(this._buffer, this._byteLength);
            var i = 0;
            for (i = 0; i < dataLen; i++) {
                n[i] = data[i];
            }
            this._byteLength += byteLen;
            this._checkArrayUse();
        };
        __proto.getBuffer = function () {
            return this._buffer;
        };
        __proto.setNeedUpload = function () {
            this._upload = true;
        };
        __proto.getNeedUpload = function () {
            return this._upload;
        };
        __proto.upload = function () {
            var scuess = this._bind_upload();
            Buffer._gl.bindBuffer(this._bufferType, null);
            Buffer._bindActive[this._bufferType] = null;
            BaseShader.activeShader = null;
            return scuess;
        };
        __proto.subUpload = function (offset, dataStart, dataLength) {
            (offset === void 0) && (offset = 0);
            (dataStart === void 0) && (dataStart = 0);
            (dataLength === void 0) && (dataLength = 0);
            var scuess = this._bind_subUpload();
            Buffer._gl.bindBuffer(this._bufferType, null);
            Buffer._bindActive[this._bufferType] = null;
            BaseShader.activeShader = null;
            return scuess;
        };
        __proto.disposeResource = function () {
            _super.prototype.disposeResource.call(this);
            this._upload = true;
            this._uploadSize = 0;
        };
        __proto.clear = function () {
            this._byteLength = 0;
            this._upload = true;
        };
        __getset(0, __proto, 'bufferLength', function () {
            return this._buffer.byteLength;
        });
        __getset(0, __proto, 'byteLength', null, function (value) {
            if (this._byteLength === value)
                return;
            value <= this._buffer.byteLength || (this._resizeBuffer(value * 2 + 256, true));
            this._byteLength = value;
        });
        Buffer2D.__int__ = function (gl) {
            IndexBuffer2D.QuadrangleIB = IndexBuffer2D.create(0x88E4);
            GlUtils.fillIBQuadrangle(IndexBuffer2D.QuadrangleIB, 16);
        };
        Buffer2D.FLOAT32 = 4;
        Buffer2D.SHORT = 2;
        return Buffer2D;
    })(Buffer);
    var GlowSV = (function (_super) {
        function GlowSV(args) {
            this.u_blurX = false;
            this.u_color = null;
            this.u_offset = null;
            this.u_strength = NaN;
            this.u_texW = 0;
            this.u_texH = 0;
            GlowSV.__super.call(this, 0x08 | 0x01);
        }
        __class(GlowSV, 'laya.webgl.shader.d2.value.GlowSV', _super);
        var __proto = GlowSV.prototype;
        __proto.setValue = function (vo) {
            _super.prototype.setValue.call(this, vo);
        };
        __proto.clear = function () {
            _super.prototype.clear.call(this);
        };
        return GlowSV;
    })(TextureSV);
    var TextSV = (function (_super) {
        function TextSV(args) {
            TextSV.__super.call(this, 0x40);
            this.defines.add(0x40);
        }
        __class(TextSV, 'laya.webgl.shader.d2.value.TextSV', _super);
        var __proto = TextSV.prototype;
        __proto.release = function () {
            TextSV.pool[TextSV._length++] = this;
            this.clear();
        };
        __proto.clear = function () {
            _super.prototype.clear.call(this);
        };
        TextSV.create = function () {
            if (TextSV._length)
                return TextSV.pool[--TextSV._length];
            else
                return new TextSV(null);
        };
        TextSV.pool = [];
        TextSV._length = 0;
        return TextSV;
    })(TextureSV);
    var Shader2X = (function (_super) {
        function Shader2X(vs, ps, saveName, nameMap) {
            this._params2dQuick1 = null;
            this._params2dQuick2 = null;
            this._shaderValueWidth = NaN;
            this._shaderValueHeight = NaN;
            Shader2X.__super.call(this, vs, ps, saveName, nameMap);
        }
        __class(Shader2X, 'laya.webgl.shader.d2.Shader2X', _super);
        var __proto = Shader2X.prototype;
        __proto.upload2dQuick1 = function (shaderValue) {
            this.upload(shaderValue, this._params2dQuick1 || this._make2dQuick1());
        };
        __proto._make2dQuick1 = function () {
            if (!this._params2dQuick1) {
                this.activeResource();
                this._params2dQuick1 = [];
                var params = this._params, one;
                for (var i = 0, n = params.length; i < n; i++) {
                    one = params[i];
                    if (!Render.isFlash && (one.name === "size" || one.name === "position" || one.name === "texcoord"))
                        continue;
                    this._params2dQuick1.push(one);
                }
            }
            return this._params2dQuick1;
        };
        __proto.disposeResource = function () {
            _super.prototype.disposeResource.call(this);
            this._params2dQuick1 = null;
            this._params2dQuick2 = null;
        };
        __proto.upload2dQuick2 = function (shaderValue) {
            this.upload(shaderValue, this._params2dQuick2 || this._make2dQuick2());
        };
        __proto._make2dQuick2 = function () {
            if (!this._params2dQuick2) {
                this.activeResource();
                this._params2dQuick2 = [];
                var params = this._params, one;
                for (var i = 0, n = params.length; i < n; i++) {
                    one = params[i];
                    if (!Render.isFlash && (one.name === "size"))
                        continue;
                    this._params2dQuick2.push(one);
                }
            }
            return this._params2dQuick2;
        };
        Shader2X.create = function (vs, ps, saveName, nameMap) {
            return new Shader2X(vs, ps, saveName, nameMap);
        };
        return Shader2X;
    })(Shader);
    var IndexBuffer2D = (function (_super) {
        function IndexBuffer2D(bufferUsage) {
            this._uint8Array = null;
            this._uint16Array = null;
            (bufferUsage === void 0) && (bufferUsage = 0x88E4);
            IndexBuffer2D.__super.call(this);
            this._bufferUsage = bufferUsage;
            this._bufferType = 0x8893;
            Render.isFlash || (this._buffer = new ArrayBuffer(8));
        }
        __class(IndexBuffer2D, 'laya.webgl.utils.IndexBuffer2D', _super);
        var __proto = IndexBuffer2D.prototype;
        __proto._checkArrayUse = function () {
            this._uint8Array && (this._uint8Array = new Uint8Array(this._buffer));
            this._uint16Array && (this._uint16Array = new Uint16Array(this._buffer));
        };
        __proto.getUint8Array = function () {
            return this._uint8Array || (this._uint8Array = new Uint8Array(this._buffer));
        };
        __proto.getUint16Array = function () {
            return this._uint16Array || (this._uint16Array = new Uint16Array(this._buffer));
        };
        __proto.destory = function () {
            this._uint16Array = null;
            this._uint8Array = null;
            this._buffer = null;
        };
        IndexBuffer2D.QuadrangleIB = null;
        IndexBuffer2D.create = function (bufferUsage) {
            (bufferUsage === void 0) && (bufferUsage = 0x88E4);
            return new IndexBuffer2D(bufferUsage);
        };
        return IndexBuffer2D;
    })(Buffer2D);
    var VertexBuffer2D = (function (_super) {
        function VertexBuffer2D(vertexStride, bufferUsage) {
            this._floatArray32 = null;
            this._vertexStride = 0;
            VertexBuffer2D.__super.call(this);
            this._vertexStride = vertexStride;
            this._bufferUsage = bufferUsage;
            this._bufferType = 0x8892;
            Render.isFlash || (this._buffer = new ArrayBuffer(8));
            this.getFloat32Array();
        }
        __class(VertexBuffer2D, 'laya.webgl.utils.VertexBuffer2D', _super);
        var __proto = VertexBuffer2D.prototype;
        __proto.getFloat32Array = function () {
            return this._floatArray32 || (this._floatArray32 = new Float32Array(this._buffer));
        };
        __proto.bind = function (ibBuffer) {
            (ibBuffer) && (ibBuffer._bind());
            this._bind();
        };
        __proto.insertData = function (data, pos) {
            var vbdata = this.getFloat32Array();
            vbdata.set(data, pos);
            this._upload = true;
        };
        __proto.bind_upload = function (ibBuffer) {
            (ibBuffer._bind_upload()) || (ibBuffer._bind());
            (this._bind_upload()) || (this._bind());
        };
        __proto._checkArrayUse = function () {
            this._floatArray32 && (this._floatArray32 = new Float32Array(this._buffer));
        };
        __proto.disposeResource = function () {
            _super.prototype.disposeResource.call(this);
            var enableAtributes = Buffer._enableAtributes;
            for (var i = 0; i < 10; i++) {
                WebGL.mainContext.disableVertexAttribArray(i);
                enableAtributes[i] = null;
            }
        };
        __proto.destory = function () {
            this._byteLength = 0;
            this._upload = true;
            this._buffer = null;
            this._floatArray32 = null;
        };
        __getset(0, __proto, 'vertexStride', function () {
            return this._vertexStride;
        });
        VertexBuffer2D.create = function (vertexStride, bufferUsage) {
            (bufferUsage === void 0) && (bufferUsage = 0x88E8);
            return new VertexBuffer2D(vertexStride, bufferUsage);
        };
        return VertexBuffer2D;
    })(Buffer2D);
    var WebGLImage = (function (_super) {
        function WebGLImage(data, def, format, mipmap) {
            this._format = 0;
            this._mipmap = false;
            this._allowMerageInAtlas = false;
            this._enableMerageInAtlas = false;
            this.repeat = false;
            this._image = null;
            this.minFifter = 0;
            this.magFifter = 0;
            (format === void 0) && (format = 0x1908);
            (mipmap === void 0) && (mipmap = true);
            WebGLImage.__super.call(this, data, def);
            this._format = format;
            this._mipmap = mipmap;
            this.repeat = false;
            this.minFifter = -1;
            this.magFifter = -1;
            if ((typeof data == 'string')) {
                this._url = data;
                this._src = data;
                this._image = new Browser.window.Image();
                if (def) {
                    def.onload && (this.onload = def.onload);
                    def.onerror && (this.onerror = def.onerror);
                    def.onCreate && def.onCreate(this);
                }
                this._image.crossOrigin = (data && (data.indexOf("data:") == 0)) ? null : "";
                (data) && (this._image.src = data);
            }
            else if ((data instanceof ArrayBuffer)) {
                this._src = def;
                this._url = this._src;
                var readData = new Byte(data);
                var magicNumber = readData.readUTFBytes(4);
                var version = readData.readUTFBytes(2);
                var dataType = readData.getInt16();
                readData.endian = "bigEndian";
                this._w = readData.getInt16();
                this._h = readData.getInt16();
                var originalWidth = readData.getInt16();
                var originalHeight = readData.getInt16();
                this._image = new Uint8Array(data, readData.pos);
                this._format = WebGL.compressEtc1.COMPRESSED_RGB_ETC1_WEBGL;
                (AtlasResourceManager.enabled) && (this._w < AtlasResourceManager.atlasLimitWidth && this._h < AtlasResourceManager.atlasLimitHeight) ? this._allowMerageInAtlas = true : this._allowMerageInAtlas = false;
            }
            else {
                this._src = def;
                this._url = this._src;
                this._image = data["source"] || data;
                this.onresize();
            }
            this._$5__enableMerageInAtlas = true;
        }
        __class(WebGLImage, 'laya.webgl.resource.WebGLImage', _super);
        var __proto = WebGLImage.prototype;
        Laya.imps(__proto, { "laya.webgl.resource.IMergeAtlasBitmap": true });
        __proto._init_ = function (src, def) { };
        __proto._createWebGlTexture = function () {
            if (!this._image) {
                throw "create GLTextur err:no data:" + this._image;
            }
            var gl = WebGL.mainContext;
            var glTex = this._source = gl.createTexture();
            var preTarget = WebGLContext.curBindTexTarget;
            var preTexture = WebGLContext.curBindTexValue;
            WebGLContext.bindTexture(gl, 0x0DE1, glTex);
            gl.pixelStorei(0x9241, true);
            switch (this._format) {
                case 0x1908:
                    gl.texImage2D(0x0DE1, 0, this._format, 0x1908, 0x1401, this._image);
                    break;
                case WebGL.compressEtc1.COMPRESSED_RGB_ETC1_WEBGL:
                    gl.compressedTexImage2D(0x0DE1, 0, this._format, this._w, this._h, 0, this._image);
                    break;
            }
            gl.pixelStorei(0x9241, false);
            var minFifter = this.minFifter;
            var magFifter = this.magFifter;
            var repeat = this.repeat ? 0x2901 : 0x812F;
            var isPot = Arith.isPOT(this._w, this._h);
            if (isPot) {
                if (this.mipmap)
                    (minFifter !== -1) || (minFifter = 0x2703);
                else
                    (minFifter !== -1) || (minFifter = 0x2601);
                (magFifter !== -1) || (magFifter = 0x2601);
                gl.texParameteri(0x0DE1, 0x2801, minFifter);
                gl.texParameteri(0x0DE1, 0x2800, magFifter);
                gl.texParameteri(0x0DE1, 0x2802, repeat);
                gl.texParameteri(0x0DE1, 0x2803, repeat);
                this.mipmap && gl.generateMipmap(0x0DE1);
            }
            else {
                (minFifter !== -1) || (minFifter = 0x2601);
                (magFifter !== -1) || (magFifter = 0x2601);
                gl.texParameteri(0x0DE1, 0x2801, minFifter);
                gl.texParameteri(0x0DE1, 0x2800, magFifter);
                gl.texParameteri(0x0DE1, 0x2802, 0x812F);
                gl.texParameteri(0x0DE1, 0x2803, 0x812F);
            }
            (preTarget && preTexture) && (WebGLContext.bindTexture(gl, preTarget, preTexture));
            this._image.onload = null;
            this._image = null;
            if (isPot && this.mipmap)
                this.memorySize = this._w * this._h * 4 * (1 + 1 / 3);
            else
                this.memorySize = this._w * this._h * 4;
            this._recreateLock = false;
        };
        __proto.recreateResource = function () {
            var _$this = this;
            if (this._src == null || this._src === "")
                return;
            this._needReleaseAgain = false;
            if (!this._image) {
                this._recreateLock = true;
                var _this = this;
                this._image = new Browser.window.Image();
                this._image.crossOrigin = this._src.indexOf("data:") == 0 ? null : "";
                this._image.onload = function () {
                    if (_this._needReleaseAgain) {
                        _this._needReleaseAgain = false;
                        _this._image.onload = null;
                        _this._image = null;
                        return;
                    }
                    (!(_this._allowMerageInAtlas && _this._enableMerageInAtlas)) ? (_this._createWebGlTexture()) : (_$this.memorySize = 0, _$this._recreateLock = false);
                    _this.completeCreate();
                };
                this._image.src = this._src;
            }
            else {
                if (this._recreateLock) {
                    return;
                }
                (!(this._allowMerageInAtlas && this._$5__enableMerageInAtlas)) ? (this._createWebGlTexture()) : (this.memorySize = 0, this._recreateLock = false);
                this.completeCreate();
            }
        };
        __proto.disposeResource = function () {
            if (this._recreateLock) {
                this._needReleaseAgain = true;
            }
            if (this._source) {
                WebGL.mainContext.deleteTexture(this._source);
                this._source = null;
                this._image = null;
                this.memorySize = 0;
            }
        };
        __proto.onresize = function () {
            this._w = this._image.width;
            this._h = this._image.height;
            (AtlasResourceManager.enabled) && (this._w < AtlasResourceManager.atlasLimitWidth && this._h < AtlasResourceManager.atlasLimitHeight) ? this._allowMerageInAtlas = true : this._allowMerageInAtlas = false;
        };
        __proto.clearAtlasSource = function () {
            this._image.onload = null;
            this._image = null;
        };
        __getset(0, __proto, 'format', function () {
            return this._format;
        });
        __getset(0, __proto, 'enableMerageInAtlas', function () {
            return this._$5__enableMerageInAtlas;
        }, function (value) {
            this._$5__enableMerageInAtlas = value;
        });
        __getset(0, __proto, 'mipmap', function () {
            return this._mipmap;
        });
        __getset(0, __proto, 'allowMerageInAtlas', function () {
            return this._allowMerageInAtlas;
        });
        __getset(0, __proto, 'atlasSource', function () {
            return this._image;
        });
        __getset(0, __proto, 'onload', null, function (value) {
            var _$this = this;
            this._onload = value;
            this._image && (this._image.onload = this._onload != null ? (function () {
                _$this.onresize();
                _$this._onload();
            }) : null);
        });
        __getset(0, __proto, 'onerror', null, function (value) {
            var _$this = this;
            this._onerror = value;
            this._image && (this._image.onerror = this._onerror != null ? (function () {
                _$this._onerror();
            }) : null);
        });
        return WebGLImage;
    })(HTMLImage);
    Laya.__init([DrawText, AtlasGrid, WebGLContext2D, ShaderCompile]);
})(window, document, Laya);
if (typeof define === 'function' && define.amd) {
    define('laya.core', ['require', "exports"], function (require, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        for (var i in Laya) {
            var o = Laya[i];
            o && o.__isclass && (exports[i] = o);
        }
    });
}
(function (window, document, Laya) {
    var __un = Laya.un, __uns = Laya.uns, __static = Laya.static, __class = Laya.class, __getset = Laya.getset, __newvec = Laya.__newvec;
    var Animation = laya.display.Animation, Browser = laya.utils.Browser, ClassUtils = laya.utils.ClassUtils, ColorFilter = laya.filters.ColorFilter;
    var Ease = laya.utils.Ease, Event = laya.events.Event, EventDispatcher = laya.events.EventDispatcher, Font = laya.display.css.Font;
    var FrameAnimation = laya.display.FrameAnimation, Graphics = laya.display.Graphics, Handler = laya.utils.Handler;
    var Input = laya.display.Input, Loader = laya.net.Loader, Node = laya.display.Node, Point = laya.maths.Point, Rectangle = laya.maths.Rectangle;
    var Render = laya.renders.Render, Sprite = laya.display.Sprite, Text = laya.display.Text, Texture = laya.resource.Texture;
    var Tween = laya.utils.Tween, Utils = laya.utils.Utils, WeakObject = laya.utils.WeakObject;
    Laya.interface('laya.ui.IItem');
    Laya.interface('laya.ui.ISelect');
    Laya.interface('laya.ui.IRender');
    Laya.interface('laya.ui.IComponent');
    Laya.interface('laya.ui.IBox', 'IComponent');
    var LayoutStyle = (function () {
        function LayoutStyle() {
            this.enable = false;
            this.top = NaN;
            this.bottom = NaN;
            this.left = NaN;
            this.right = NaN;
            this.centerX = NaN;
            this.centerY = NaN;
            this.anchorX = NaN;
            this.anchorY = NaN;
        }
        __class(LayoutStyle, 'laya.ui.LayoutStyle');
        __static(LayoutStyle, ['EMPTY', function () { return this.EMPTY = new LayoutStyle(); }
        ]);
        return LayoutStyle;
    })();
    var Styles = (function () {
        function Styles() { }
        __class(Styles, 'laya.ui.Styles');
        Styles.labelColor = "#000000";
        Styles.buttonStateNum = 3;
        Styles.scrollBarMinNum = 15;
        Styles.scrollBarDelayTime = 500;
        __static(Styles, ['defaultSizeGrid', function () { return this.defaultSizeGrid = [4, 4, 4, 4, 0]; }, 'labelPadding', function () { return this.labelPadding = [2, 2, 2, 2]; }, 'inputLabelPadding', function () { return this.inputLabelPadding = [1, 1, 1, 3]; }, 'buttonLabelColors', function () { return this.buttonLabelColors = ["#32556b", "#32cc6b", "#ff0000", "#C0C0C0"]; }, 'comboBoxItemColors', function () { return this.comboBoxItemColors = ["#5e95b6", "#ffffff", "#000000", "#8fa4b1", "#ffffff"]; }
        ]);
        return Styles;
    })();
    var UIUtils = (function () {
        function UIUtils() { }
        __class(UIUtils, 'laya.ui.UIUtils');
        UIUtils.fillArray = function (arr, str, type) {
            var temp = arr.concat();
            if (str) {
                var a = str.split(",");
                for (var i = 0, n = Math.min(temp.length, a.length); i < n; i++) {
                    var value = a[i];
                    temp[i] = (value == "true" ? true : (value == "false" ? false : value));
                    if (type != null)
                        temp[i] = type(value);
                }
            }
            return temp;
        };
        UIUtils.toColor = function (color) {
            return Utils.toHexColor(color);
        };
        UIUtils.gray = function (traget, isGray) {
            (isGray === void 0) && (isGray = true);
            if (isGray) {
                UIUtils.addFilter(traget, UIUtils.grayFilter);
            }
            else {
                UIUtils.clearFilter(traget, ColorFilter);
            }
        };
        UIUtils.addFilter = function (target, filter) {
            var filters = target.filters || [];
            filters.push(filter);
            target.filters = filters;
        };
        UIUtils.clearFilter = function (target, filterType) {
            var filters = target.filters;
            if (filters != null && filters.length > 0) {
                for (var i = filters.length - 1; i > -1; i--) {
                    var filter = filters[i];
                    if (Laya.__typeof(filter, filterType))
                        filters.splice(i, 1);
                }
                target.filters = filters;
            }
        };
        UIUtils._getReplaceStr = function (word) {
            return UIUtils.escapeSequence[word] ? UIUtils.escapeSequence[word] : word;
        };
        UIUtils.adptString = function (str) {
            return str.replace(/\\(\w)/g, UIUtils._getReplaceStr);
        };
        UIUtils.getBindFun = function (value) {
            var fun = UIUtils._funMap.get(value);
            if (fun == null) {
                var temp = "\"" + value + "\"";
                temp = temp.replace(/^"\${|}"$/g, "").replace(/\${/g, "\"+").replace(/}/g, "+\"");
                var str = "(function(data){if(data==null)return;with(data){try{\nreturn " + temp + "\n}catch(e){}}})";
                fun = Browser.window.eval(str);
                UIUtils._funMap.set(value, fun);
            }
            return fun;
        };
        __static(UIUtils, ['grayFilter', function () { return this.grayFilter = new ColorFilter([0.3086, 0.6094, 0.082, 0, 0, 0.3086, 0.6094, 0.082, 0, 0, 0.3086, 0.6094, 0.082, 0, 0, 0, 0, 0, 1, 0]); }, 'escapeSequence', function () { return this.escapeSequence = { "\\n": "\n", "\\t": "\t" }; }, '_funMap', function () { return this._funMap = new WeakObject(); }
        ]);
        return UIUtils;
    })();
    var UIConfig = (function () {
        function UIConfig() { }
        __class(UIConfig, 'UIConfig');
        UIConfig.touchScrollEnable = true;
        UIConfig.mouseWheelEnable = true;
        UIConfig.showButtons = true;
        UIConfig.popupBgColor = "#000000";
        UIConfig.popupBgAlpha = 0.5;
        UIConfig.closeDialogOnSide = true;
        return UIConfig;
    })();
    var AutoBitmap = (function (_super) {
        function AutoBitmap() {
            this.autoCacheCmd = true;
            this._width = 0;
            this._height = 0;
            this._source = null;
            this._sizeGrid = null;
            this._isChanged = false;
            this._offset = null;
            AutoBitmap.__super.call(this);
        }
        __class(AutoBitmap, 'laya.ui.AutoBitmap', _super);
        var __proto = AutoBitmap.prototype;
        __proto.destroy = function () {
            _super.prototype.destroy.call(this);
            this._source = null;
            this._sizeGrid = null;
            this._offset = null;
        };
        __proto._setChanged = function () {
            if (!this._isChanged) {
                this._isChanged = true;
                Laya.timer.callLater(this, this.changeSource);
            }
        };
        __proto.changeSource = function () {
            this._isChanged = false;
            var source = this._source;
            if (!source || !source.bitmap)
                return;
            var width = this.width;
            var height = this.height;
            var sizeGrid = this._sizeGrid;
            var sw = source.sourceWidth;
            var sh = source.sourceHeight;
            if (!sizeGrid || (sw === width && sh === height)) {
                this.cleanByTexture(source, this._offset ? this._offset[0] : 0, this._offset ? this._offset[1] : 0, width, height);
            }
            else {
                source.$_GID || (source.$_GID = Utils.getGID());
                var key = source.$_GID + "." + width + "." + height + "." + sizeGrid.join(".");
                if (Utils.isOKCmdList(WeakObject.I.get(key))) {
                    this.cmds = WeakObject.I.get(key);
                    return;
                }
                this.clear();
                var top = sizeGrid[0];
                var right = sizeGrid[1];
                var bottom = sizeGrid[2];
                var left = sizeGrid[3];
                var repeat = sizeGrid[4];
                var needClip = false;
                if (width == sw) {
                    left = right = 0;
                }
                if (height == sh) {
                    top = bottom = 0;
                }
                if (left + right > width) {
                    var clipWidth = width;
                    needClip = true;
                    width = left + right;
                    this.save();
                    this.clipRect(0, 0, clipWidth, height);
                }
                left && top && this.drawTexture(AutoBitmap.getTexture(source, 0, 0, left, top), 0, 0, left, top);
                right && top && this.drawTexture(AutoBitmap.getTexture(source, sw - right, 0, right, top), width - right, 0, right, top);
                left && bottom && this.drawTexture(AutoBitmap.getTexture(source, 0, sh - bottom, left, bottom), 0, height - bottom, left, bottom);
                right && bottom && this.drawTexture(AutoBitmap.getTexture(source, sw - right, sh - bottom, right, bottom), width - right, height - bottom, right, bottom);
                top && this.drawBitmap(repeat, AutoBitmap.getTexture(source, left, 0, sw - left - right, top), left, 0, width - left - right, top);
                bottom && this.drawBitmap(repeat, AutoBitmap.getTexture(source, left, sh - bottom, sw - left - right, bottom), left, height - bottom, width - left - right, bottom);
                left && this.drawBitmap(repeat, AutoBitmap.getTexture(source, 0, top, left, sh - top - bottom), 0, top, left, height - top - bottom);
                right && this.drawBitmap(repeat, AutoBitmap.getTexture(source, sw - right, top, right, sh - top - bottom), width - right, top, right, height - top - bottom);
                this.drawBitmap(repeat, AutoBitmap.getTexture(source, left, top, sw - left - right, sh - top - bottom), left, top, width - left - right, height - top - bottom);
                if (needClip)
                    this.restore();
                if (this.autoCacheCmd && !Render.isConchApp)
                    WeakObject.I.set(key, this.cmds);
            }
            this._repaint();
        };
        __proto.drawBitmap = function (repeat, tex, x, y, width, height) {
            (width === void 0) && (width = 0);
            (height === void 0) && (height = 0);
            if (!tex)
                return;
            if (width < 0.1 || height < 0.1)
                return;
            if (repeat && (tex.width != width || tex.height != height))
                this.fillTexture(tex, x, y, width, height);
            else
                this.drawTexture(tex, x, y, width, height);
        };
        __proto.clear = function (recoverCmds) {
            (recoverCmds === void 0) && (recoverCmds = true);
            _super.prototype.clear.call(this, false);
        };
        __getset(0, __proto, 'sizeGrid', function () {
            return this._sizeGrid;
        }, function (value) {
            this._sizeGrid = value;
            this._setChanged();
        });
        __getset(0, __proto, 'width', function () {
            if (this._width)
                return this._width;
            if (this._source)
                return this._source.sourceWidth;
            return 0;
        }, function (value) {
            if (this._width != value) {
                this._width = value;
                this._setChanged();
            }
        });
        __getset(0, __proto, 'height', function () {
            if (this._height)
                return this._height;
            if (this._source)
                return this._source.sourceHeight;
            return 0;
        }, function (value) {
            if (this._height != value) {
                this._height = value;
                this._setChanged();
            }
        });
        __getset(0, __proto, 'source', function () {
            return this._source;
        }, function (value) {
            if (value) {
                this._source = value;
                this._setChanged();
            }
            else {
                this._source = null;
                this.clear();
            }
        });
        AutoBitmap.getTexture = function (tex, x, y, width, height) {
            if (width <= 0)
                width = 1;
            if (height <= 0)
                height = 1;
            tex.$_GID || (tex.$_GID = Utils.getGID());
            var key = tex.$_GID + "." + x + "." + y + "." + width + "." + height;
            var texture = WeakObject.I.get(key);
            if (!texture || !texture.source) {
                texture = Texture.createFromTexture(tex, x, y, width, height);
                WeakObject.I.set(key, texture);
            }
            return texture;
        };
        return AutoBitmap;
    })(Graphics);
    var UIEvent = (function (_super) {
        function UIEvent() {
            UIEvent.__super.call(this);
            ;
        }
        __class(UIEvent, 'laya.ui.UIEvent', _super);
        UIEvent.SHOW_TIP = "showtip";
        UIEvent.HIDE_TIP = "hidetip";
        return UIEvent;
    })(Event);
    var Component = (function (_super) {
        function Component() {
            this._comXml = null;
            this._dataSource = null;
            this._toolTip = null;
            this._tag = null;
            this._disabled = false;
            this._gray = false;
            this.layoutEnabled = true;
            Component.__super.call(this);
            this._layout = LayoutStyle.EMPTY;
            this.preinitialize();
            this.createChildren();
            this.initialize();
        }
        __class(Component, 'laya.ui.Component', _super);
        var __proto = Component.prototype;
        Laya.imps(__proto, { "laya.ui.IComponent": true });
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            _super.prototype.destroy.call(this, destroyChild);
            this._dataSource = this._layout = null;
            this._tag = null;
            this._toolTip = null;
        };
        __proto.preinitialize = function () { };
        __proto.createChildren = function () { };
        __proto.initialize = function () { };
        __proto.callLater = function (method, args) {
            Laya.timer.callLater(this, method, args);
        };
        __proto.runCallLater = function (method) {
            Laya.timer.runCallLater(this, method);
        };
        __proto.commitMeasure = function () { };
        __proto.changeSize = function () {
            this.event("resize");
        };
        __proto.getLayout = function () {
            this._layout === LayoutStyle.EMPTY && (this._layout = new LayoutStyle());
            return this._layout;
        };
        __proto._setLayoutEnabled = function (value) {
            if (this._layout && this._layout.enable != value) {
                this._layout.enable = value;
                this.on("added", this, this.onAdded);
                this.on("removed", this, this.onRemoved);
                if (this.parent) {
                    this.onAdded();
                }
            }
        };
        __proto.onRemoved = function () {
            this.parent.off("resize", this, this.onCompResize);
        };
        __proto.onAdded = function () {
            this.parent.on("resize", this, this.onCompResize);
            this.resetLayoutX();
            this.resetLayoutY();
        };
        __proto.onCompResize = function () {
            if (this._layout && this._layout.enable) {
                this.resetLayoutX();
                this.resetLayoutY();
            }
        };
        __proto.resetLayoutX = function () {
            var layout = this._layout;
            if (!isNaN(layout.anchorX))
                this.pivotX = layout.anchorX * this.width;
            if (!this.layoutEnabled)
                return;
            var parent = this.parent;
            if (parent) {
                if (!isNaN(layout.centerX)) {
                    this.x = Math.round((parent.width - this.displayWidth) * 0.5 + layout.centerX + this.pivotX * this.scaleX);
                }
                else if (!isNaN(layout.left)) {
                    this.x = Math.round(layout.left + this.pivotX * this.scaleX);
                    if (!isNaN(layout.right)) {
                        this.width = (parent._width - layout.left - layout.right) / (this.scaleX || 0.01);
                    }
                }
                else if (!isNaN(layout.right)) {
                    this.x = Math.round(parent.width - this.displayWidth - layout.right + this.pivotX * this.scaleX);
                }
            }
        };
        __proto.resetLayoutY = function () {
            var layout = this._layout;
            if (!isNaN(layout.anchorY))
                this.pivotY = layout.anchorY * this.height;
            if (!this.layoutEnabled)
                return;
            var parent = this.parent;
            if (parent) {
                if (!isNaN(layout.centerY)) {
                    this.y = Math.round((parent.height - this.displayHeight) * 0.5 + layout.centerY + this.pivotY * this.scaleY);
                }
                else if (!isNaN(layout.top)) {
                    this.y = Math.round(layout.top + this.pivotY * this.scaleY);
                    if (!isNaN(layout.bottom)) {
                        this.height = (parent._height - layout.top - layout.bottom) / (this.scaleY || 0.01);
                    }
                }
                else if (!isNaN(layout.bottom)) {
                    this.y = Math.round(parent.height - this.displayHeight - layout.bottom + this.pivotY * this.scaleY);
                }
            }
        };
        __proto.onMouseOver = function (e) {
            Laya.stage.event("showtip", this._toolTip);
        };
        __proto.onMouseOut = function (e) {
            Laya.stage.event("hidetip", this._toolTip);
        };
        __getset(0, __proto, 'displayWidth', function () {
            return this.width * this.scaleX;
        });
        __getset(0, __proto, 'width', function () {
            if (this._width)
                return this._width;
            return this.measureWidth;
        }, function (value) {
            if (this._width != value) {
                this._width = value;
                this.conchModel && this.conchModel.size(this._width, this._height);
                this.callLater(this.changeSize);
                if (this._layout.enable && (!isNaN(this._layout.centerX) || !isNaN(this._layout.right) || !isNaN(this._layout.anchorX)))
                    this.resetLayoutX();
            }
        });
        __getset(0, __proto, 'measureWidth', function () {
            var max = 0;
            this.commitMeasure();
            for (var i = this.numChildren - 1; i > -1; i--) {
                var comp = this.getChildAt(i);
                if (comp.visible) {
                    max = Math.max(comp.x + comp.width * comp.scaleX, max);
                }
            }
            return max;
        });
        __getset(0, __proto, 'displayHeight', function () {
            return this.height * this.scaleY;
        });
        __getset(0, __proto, 'height', function () {
            if (this._height)
                return this._height;
            return this.measureHeight;
        }, function (value) {
            if (this._height != value) {
                this._height = value;
                this.conchModel && this.conchModel.size(this._width, this._height);
                this.callLater(this.changeSize);
                if (this._layout.enable && (!isNaN(this._layout.centerY) || !isNaN(this._layout.bottom) || !isNaN(this._layout.anchorY)))
                    this.resetLayoutY();
            }
        });
        __getset(0, __proto, 'dataSource', function () {
            return this._dataSource;
        }, function (value) {
            this._dataSource = value;
            for (var prop in this._dataSource) {
                if (this.hasOwnProperty(prop) && !((typeof (this[prop]) == 'function'))) {
                    this[prop] = this._dataSource[prop];
                }
            }
        });
        __getset(0, __proto, 'scaleY', _super.prototype._$get_scaleY, function (value) {
            if (Laya.superGet(Sprite, this, 'scaleY') != value) {
                Laya.superSet(Sprite, this, 'scaleY', value);
                this.callLater(this.changeSize);
                this._layout.enable && this.resetLayoutY();
            }
        });
        __getset(0, __proto, 'measureHeight', function () {
            var max = 0;
            this.commitMeasure();
            for (var i = this.numChildren - 1; i > -1; i--) {
                var comp = this.getChildAt(i);
                if (comp.visible) {
                    max = Math.max(comp.y + comp.height * comp.scaleY, max);
                }
            }
            return max;
        });
        __getset(0, __proto, 'scaleX', _super.prototype._$get_scaleX, function (value) {
            if (Laya.superGet(Sprite, this, 'scaleX') != value) {
                Laya.superSet(Sprite, this, 'scaleX', value);
                this.callLater(this.changeSize);
                this._layout.enable && this.resetLayoutX();
            }
        });
        __getset(0, __proto, 'top', function () {
            return this._layout.top;
        }, function (value) {
            if (value != this._layout.top) {
                this.getLayout().top = value;
                this._setLayoutEnabled(true);
            }
            this.resetLayoutY();
        });
        __getset(0, __proto, 'bottom', function () {
            return this._layout.bottom;
        }, function (value) {
            if (value != this._layout.bottom) {
                this.getLayout().bottom = value;
                this._setLayoutEnabled(true);
            }
            this.resetLayoutY();
        });
        __getset(0, __proto, 'left', function () {
            return this._layout.left;
        }, function (value) {
            if (value != this._layout.left) {
                this.getLayout().left = value;
                this._setLayoutEnabled(true);
            }
            this.resetLayoutX();
        });
        __getset(0, __proto, 'right', function () {
            return this._layout.right;
        }, function (value) {
            if (value != this._layout.right) {
                this.getLayout().right = value;
                this._setLayoutEnabled(true);
            }
            this.resetLayoutX();
        });
        __getset(0, __proto, 'centerX', function () {
            return this._layout.centerX;
        }, function (value) {
            if (value != this._layout.centerX) {
                this.getLayout().centerX = value;
                this._setLayoutEnabled(true);
            }
            this.resetLayoutX();
        });
        __getset(0, __proto, 'centerY', function () {
            return this._layout.centerY;
        }, function (value) {
            if (value != this._layout.centerY) {
                this.getLayout().centerY = value;
                this._setLayoutEnabled(true);
            }
            this.resetLayoutY();
        });
        __getset(0, __proto, 'anchorX', function () {
            return this._layout.anchorX;
        }, function (value) {
            if (value != this._layout.anchorX) {
                this.getLayout().anchorX = value;
                this._setLayoutEnabled(true);
            }
            this.resetLayoutX();
        });
        __getset(0, __proto, 'anchorY', function () {
            return this._layout.anchorY;
        }, function (value) {
            if (value != this._layout.anchorY) {
                this.getLayout().anchorY = value;
                this._setLayoutEnabled(true);
            }
            this.resetLayoutY();
        });
        __getset(0, __proto, 'tag', function () {
            return this._tag;
        }, function (value) {
            this._tag = value;
        });
        __getset(0, __proto, 'toolTip', function () {
            return this._toolTip;
        }, function (value) {
            if (this._toolTip != value) {
                this._toolTip = value;
                if (value != null) {
                    this.on("mouseover", this, this.onMouseOver);
                    this.on("mouseout", this, this.onMouseOut);
                }
                else {
                    this.off("mouseover", this, this.onMouseOver);
                    this.off("mouseout", this, this.onMouseOut);
                }
            }
        });
        __getset(0, __proto, 'comXml', function () {
            return this._comXml;
        }, function (value) {
            this._comXml = value;
        });
        __getset(0, __proto, 'gray', function () {
            return this._gray;
        }, function (value) {
            if (value !== this._gray) {
                this._gray = value;
                UIUtils.gray(this, value);
            }
        });
        __getset(0, __proto, 'disabled', function () {
            return this._disabled;
        }, function (value) {
            if (value !== this._disabled) {
                this.gray = this._disabled = value;
                this.mouseEnabled = !value;
            }
        });
        return Component;
    })(Sprite);
    var DialogManager = (function (_super) {
        function DialogManager() {
            this.lockLayer = null;
            this.popupEffect = function (dialog) {
                dialog.scale(1, 1);
                Tween.from(dialog, { x: Laya.stage.width / 2, y: Laya.stage.height / 2, scaleX: 0, scaleY: 0 }, 300, Ease.backOut, Handler.create(this, this.doOpen, [dialog]));
            };
            this.closeEffect = function (dialog, type) {
                Tween.to(dialog, { x: Laya.stage.width / 2, y: Laya.stage.height / 2, scaleX: 0, scaleY: 0 }, 300, Ease.strongOut, Handler.create(this, this.doClose, [dialog, type]));
            };
            DialogManager.__super.call(this);
            this.maskLayer = new Sprite();
            this.popupEffectHandler = new Handler(this, this.popupEffect);
            this.closeEffectHandler = new Handler(this, this.closeEffect);
            this.mouseEnabled = this.maskLayer.mouseEnabled = true;
            this.zOrder = 1000;
            Laya.stage.addChild(this);
            Laya.stage.on("resize", this, this._onResize);
            if (UIConfig.closeDialogOnSide)
                this.maskLayer.on("click", this, this._closeOnSide);
            this._onResize(null);
        }
        __class(DialogManager, 'laya.ui.DialogManager', _super);
        var __proto = DialogManager.prototype;
        __proto._closeOnSide = function () {
            var dialog = this.getChildAt(this.numChildren - 1);
            if ((dialog instanceof laya.ui.Dialog))
                dialog.close("side");
        };
        __proto.setLockView = function (value) {
            if (!this.lockLayer) {
                this.lockLayer = new Box();
                this.lockLayer.mouseEnabled = true;
                this.lockLayer.size(Laya.stage.width, Laya.stage.height);
            }
            this.lockLayer.removeChildren();
            if (value) {
                value.centerX = value.centerY = 0;
                this.lockLayer.addChild(value);
            }
        };
        __proto._onResize = function (e) {
            var width = this.maskLayer.width = Laya.stage.width;
            var height = this.maskLayer.height = Laya.stage.height;
            if (this.lockLayer)
                this.lockLayer.size(width, height);
            this.maskLayer.graphics.clear();
            this.maskLayer.graphics.drawRect(0, 0, width, height, UIConfig.popupBgColor);
            this.maskLayer.alpha = UIConfig.popupBgAlpha;
            for (var i = this.numChildren - 1; i > -1; i--) {
                var item = this.getChildAt(i);
                if (item.popupCenter)
                    this._centerDialog(item);
            }
        };
        __proto._centerDialog = function (dialog) {
            dialog.x = Math.round(((Laya.stage.width - dialog.width) >> 1) + dialog.pivotX);
            dialog.y = Math.round(((Laya.stage.height - dialog.height) >> 1) + dialog.pivotY);
        };
        __proto.open = function (dialog, closeOther, showEffect) {
            (closeOther === void 0) && (closeOther = false);
            (showEffect === void 0) && (showEffect = false);
            if (closeOther)
                this._closeAll();
            if (dialog.popupCenter)
                this._centerDialog(dialog);
            this.addChild(dialog);
            if (dialog.isModal || this._$P["hasZorder"])
                this.timer.callLater(this, this._checkMask);
            if (showEffect && dialog.popupEffect != null)
                dialog.popupEffect.runWith(dialog);
            else
                this.doOpen(dialog);
            this.event("open");
        };
        __proto.doOpen = function (dialog) {
            dialog.onOpened();
        };
        __proto.lock = function (value) {
            if (this.lockLayer) {
                if (value)
                    this.addChild(this.lockLayer);
                else
                    this.lockLayer.removeSelf();
            }
        };
        __proto.close = function (dialog, type, showEffect) {
            (showEffect === void 0) && (showEffect = false);
            if (showEffect && dialog.closeEffect != null)
                dialog.closeEffect.runWith([dialog, type]);
            else
                this.doClose(dialog, type);
            this.event("close");
        };
        __proto.doClose = function (dialog, type) {
            dialog.removeSelf();
            dialog.isModal && this._checkMask();
            dialog.closeHandler && dialog.closeHandler.runWith(type);
            dialog.onClosed(type);
        };
        __proto.closeAll = function () {
            this._closeAll();
            this.event("close");
        };
        __proto._closeAll = function () {
            for (var i = this.numChildren - 1; i > -1; i--) {
                var item = this.getChildAt(i);
                if (item && item.close != null) {
                    this.doClose(item);
                }
            }
        };
        __proto.getDialogsByGroup = function (group) {
            var arr = [];
            for (var i = this.numChildren - 1; i > -1; i--) {
                var item = this.getChildAt(i);
                if (item && item.group === group) {
                    arr.push(item);
                }
            }
            return arr;
        };
        __proto.closeByGroup = function (group) {
            var arr = [];
            for (var i = this.numChildren - 1; i > -1; i--) {
                var item = this.getChildAt(i);
                if (item && item.group === group) {
                    item.close();
                    arr.push(item);
                }
            }
            return arr;
        };
        __proto._checkMask = function () {
            this.maskLayer.removeSelf();
            for (var i = this.numChildren - 1; i > -1; i--) {
                var dialog = this.getChildAt(i);
                if (dialog && dialog.isModal) {
                    this.addChildAt(this.maskLayer, i);
                    return;
                }
            }
        };
        return DialogManager;
    })(Sprite);
    var Box = (function (_super) {
        function Box() {
            Box.__super.call(this);
            ;
        }
        __class(Box, 'laya.ui.Box', _super);
        var __proto = Box.prototype;
        Laya.imps(__proto, { "laya.ui.IBox": true });
        __getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
            this._dataSource = value;
            for (var name in value) {
                var comp = this.getChildByName(name);
                if (comp)
                    comp.dataSource = value[name];
                else if (this.hasOwnProperty(name) && !((typeof (this[name]) == 'function')))
                    this[name] = value[name];
            }
        });
        return Box;
    })(Component);
    var Button = (function (_super) {
        function Button(skin, label) {
            this.toggle = false;
            this._bitmap = null;
            this._text = null;
            this._strokeColors = null;
            this._state = 0;
            this._selected = false;
            this._skin = null;
            this._autoSize = true;
            this._sources = null;
            this._clickHandler = null;
            this._stateChanged = false;
            Button.__super.call(this);
            this._labelColors = Styles.buttonLabelColors;
            this._stateNum = Styles.buttonStateNum;
            (label === void 0) && (label = "");
            this.skin = skin;
            this.label = label;
        }
        __class(Button, 'laya.ui.Button', _super);
        var __proto = Button.prototype;
        Laya.imps(__proto, { "laya.ui.ISelect": true });
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            _super.prototype.destroy.call(this, destroyChild);
            this._bitmap && this._bitmap.destroy();
            this._text && this._text.destroy(destroyChild);
            this._bitmap = null;
            this._text = null;
            this._clickHandler = null;
            this._labelColors = this._sources = this._strokeColors = null;
        };
        __proto.createChildren = function () {
            this.graphics = this._bitmap = new AutoBitmap();
        };
        __proto.createText = function () {
            if (!this._text) {
                this._text = new Text();
                this._text.overflow = Text.HIDDEN;
                this._text.align = "center";
                this._text.valign = "middle";
                this._text.width = this._width;
                this._text.height = this._height;
            }
        };
        __proto.initialize = function () {
            if (this._mouseEnableState !== 1) {
                this.mouseEnabled = true;
                this._setBit(0x2, true);
            }
            this._createListener("mouseover", this, this.onMouse, null, false, false);
            this._createListener("mouseout", this, this.onMouse, null, false, false);
            this._createListener("mousedown", this, this.onMouse, null, false, false);
            this._createListener("mouseup", this, this.onMouse, null, false, false);
            this._createListener("click", this, this.onMouse, null, false, false);
        };
        __proto.onMouse = function (e) {
            if (this.toggle === false && this._selected)
                return;
            if (e.type === "click") {
                this.toggle && (this.selected = !this._selected);
                this._clickHandler && this._clickHandler.run();
                return;
            }
            !this._selected && (this.state = Button.stateMap[e.type]);
        };
        __proto.changeClips = function () {
            var img = Loader.getRes(this._skin);
            if (!img) {
                return;
            }
            ;
            var width = img.sourceWidth;
            var height = img.sourceHeight / this._stateNum;
            img.$_GID || (img.$_GID = Utils.getGID());
            var key = img.$_GID + "-" + this._stateNum;
            var clips = WeakObject.I.get(key);
            if (!Utils.isOkTextureList(clips)) {
                clips = null;
            }
            if (clips)
                this._sources = clips;
            else {
                this._sources = [];
                if (this._stateNum === 1) {
                    this._sources.push(img);
                }
                else {
                    for (var i = 0; i < this._stateNum; i++) {
                        this._sources.push(Texture.createFromTexture(img, 0, height * i, width, height));
                    }
                }
                WeakObject.I.set(key, this._sources);
            }
            if (this._autoSize) {
                this._bitmap.width = this._width || width;
                this._bitmap.height = this._height || height;
                if (this._text) {
                    this._text.width = this._bitmap.width;
                    this._text.height = this._bitmap.height;
                }
            }
            else {
                this._text && (this._text.x = width);
            }
        };
        __proto.changeState = function () {
            this._stateChanged = false;
            this.runCallLater(this.changeClips);
            var index = this._state < this._stateNum ? this._state : this._stateNum - 1;
            this._sources && (this._bitmap.source = this._sources[index]);
            if (this.label) {
                this._text.color = this._labelColors[index];
                if (this._strokeColors)
                    this._text.strokeColor = this._strokeColors[index];
            }
        };
        __proto._setStateChanged = function () {
            if (!this._stateChanged) {
                this._stateChanged = true;
                this.callLater(this.changeState);
            }
        };
        __getset(0, __proto, 'labelStrokeColor', function () {
            this.createText();
            return this._text.strokeColor;
        }, function (value) {
            this.createText();
            this._text.strokeColor = value;
        });
        __getset(0, __proto, 'measureHeight', function () {
            this.runCallLater(this.changeClips);
            return this._text ? Math.max(this._bitmap.height, this._text.height) : this._bitmap.height;
        });
        __getset(0, __proto, 'skin', function () {
            return this._skin;
        }, function (value) {
            if (this._skin != value) {
                this._skin = value;
                this.callLater(this.changeClips);
                this._setStateChanged();
            }
        });
        __getset(0, __proto, 'state', function () {
            return this._state;
        }, function (value) {
            if (this._state != value) {
                this._state = value;
                this._setStateChanged();
            }
        });
        __getset(0, __proto, 'text', function () {
            this.createText();
            return this._text;
        });
        __getset(0, __proto, 'stateNum', function () {
            return this._stateNum;
        }, function (value) {
            if ((typeof value == 'string')) {
                value = parseInt(value);
            }
            if (this._stateNum != value) {
                this._stateNum = value < 1 ? 1 : value > 3 ? 3 : value;
                this.callLater(this.changeClips);
            }
        });
        __getset(0, __proto, 'strokeColors', function () {
            return this._strokeColors ? this._strokeColors.join(",") : "";
        }, function (value) {
            this._strokeColors = UIUtils.fillArray(Styles.buttonLabelColors, value, String);
            this._setStateChanged();
        });
        __getset(0, __proto, 'labelColors', function () {
            return this._labelColors.join(",");
        }, function (value) {
            this._labelColors = UIUtils.fillArray(Styles.buttonLabelColors, value, String);
            this._setStateChanged();
        });
        __getset(0, __proto, 'measureWidth', function () {
            this.runCallLater(this.changeClips);
            if (this._autoSize)
                return this._bitmap.width;
            this.runCallLater(this.changeState);
            return this._bitmap.width + (this._text ? this._text.width : 0);
        });
        __getset(0, __proto, 'label', function () {
            return this._text ? this._text.text : null;
        }, function (value) {
            if (!this._text && !value)
                return;
            this.createText();
            if (this._text.text != value) {
                value && !this._text.parent && this.addChild(this._text);
                this._text.text = (value + "").replace(/\\n/g, "\n");
                this._setStateChanged();
            }
        });
        __getset(0, __proto, 'selected', function () {
            return this._selected;
        }, function (value) {
            if (this._selected != value) {
                this._selected = value;
                this.state = this._selected ? 2 : 0;
                this.event("change");
            }
        });
        __getset(0, __proto, 'labelPadding', function () {
            this.createText();
            return this._text.padding.join(",");
        }, function (value) {
            this.createText();
            this._text.padding = UIUtils.fillArray(Styles.labelPadding, value, Number);
        });
        __getset(0, __proto, 'labelSize', function () {
            this.createText();
            return this._text.fontSize;
        }, function (value) {
            this.createText();
            this._text.fontSize = value;
        });
        __getset(0, __proto, 'labelStroke', function () {
            this.createText();
            return this._text.stroke;
        }, function (value) {
            this.createText();
            this._text.stroke = value;
        });
        __getset(0, __proto, 'labelBold', function () {
            this.createText();
            return this._text.bold;
        }, function (value) {
            this.createText();
            this._text.bold = value;
        });
        __getset(0, __proto, 'labelFont', function () {
            this.createText();
            return this._text.font;
        }, function (value) {
            this.createText();
            this._text.font = value;
        });
        __getset(0, __proto, 'labelAlign', function () {
            this.createText();
            return this._text.align;
        }, function (value) {
            this.createText();
            this._text.align = value;
        });
        __getset(0, __proto, 'clickHandler', function () {
            return this._clickHandler;
        }, function (value) {
            this._clickHandler = value;
        });
        __getset(0, __proto, 'sizeGrid', function () {
            if (this._bitmap.sizeGrid)
                return this._bitmap.sizeGrid.join(",");
            return null;
        }, function (value) {
            this._bitmap.sizeGrid = UIUtils.fillArray(Styles.defaultSizeGrid, value, Number);
        });
        __getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
            Laya.superSet(Component, this, 'width', value);
            if (this._autoSize) {
                this._bitmap.width = value;
                this._text && (this._text.width = value);
            }
        });
        __getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
            Laya.superSet(Component, this, 'height', value);
            if (this._autoSize) {
                this._bitmap.height = value;
                this._text && (this._text.height = value);
            }
        });
        __getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
            this._dataSource = value;
            if ((typeof value == 'number') || (typeof value == 'string'))
                this.label = value + "";
            else
                Laya.superSet(Component, this, 'dataSource', value);
        });
        __getset(0, __proto, 'iconOffset', function () {
            return this._bitmap._offset ? this._bitmap._offset.join(",") : null;
        }, function (value) {
            if (value)
                this._bitmap._offset = UIUtils.fillArray([1, 1], value, Number);
            else
                this._bitmap._offset = [];
        });
        __static(Button, ['stateMap', function () { return this.stateMap = { "mouseup": 0, "mouseover": 1, "mousedown": 2, "mouseout": 0 }; }
        ]);
        return Button;
    })(Component);
    var Clip = (function (_super) {
        function Clip(url, clipX, clipY) {
            this._sources = null;
            this._bitmap = null;
            this._skin = null;
            this._clipX = 1;
            this._clipY = 1;
            this._clipWidth = 0;
            this._clipHeight = 0;
            this._autoPlay = false;
            this._interval = 50;
            this._complete = null;
            this._isPlaying = false;
            this._index = 0;
            this._clipChanged = false;
            this._group = null;
            this._toIndex = -1;
            Clip.__super.call(this);
            (clipX === void 0) && (clipX = 1);
            (clipY === void 0) && (clipY = 1);
            this._clipX = clipX;
            this._clipY = clipY;
            this.skin = url;
        }
        __class(Clip, 'laya.ui.Clip', _super);
        var __proto = Clip.prototype;
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            _super.prototype.destroy.call(this, true);
            this._bitmap && this._bitmap.destroy();
            this._bitmap = null;
            this._sources = null;
        };
        __proto.dispose = function () {
            this.destroy(true);
            Laya.loader.clearRes(this._skin);
        };
        __proto.createChildren = function () {
            this.graphics = this._bitmap = new AutoBitmap();
        };
        __proto._onDisplay = function (e) {
            if (this._isPlaying) {
                if (this._displayedInStage)
                    this.play();
                else
                    this.stop();
            }
            else if (this._autoPlay) {
                this.play();
            }
        };
        __proto.changeClip = function () {
            this._clipChanged = false;
            if (!this._skin)
                return;
            var img = Loader.getRes(this._skin);
            if (img) {
                this.loadComplete(this._skin, img);
            }
            else {
                Laya.loader.load(this._skin, Handler.create(this, this.loadComplete, [this._skin]));
            }
        };
        __proto.loadComplete = function (url, img) {
            if (url === this._skin && img) {
                var w = this._clipWidth || Math.ceil(img.sourceWidth / this._clipX);
                var h = this._clipHeight || Math.ceil(img.sourceHeight / this._clipY);
                var key = this._skin + w + h;
                var clips = WeakObject.I.get(key);
                if (!Utils.isOkTextureList(clips)) {
                    clips = null;
                }
                if (clips)
                    this._sources = clips;
                else {
                    this._sources = [];
                    for (var i = 0; i < this._clipY; i++) {
                        for (var j = 0; j < this._clipX; j++) {
                            this._sources.push(Texture.createFromTexture(img, w * j, h * i, w, h));
                        }
                    }
                    WeakObject.I.set(key, this._sources);
                }
                this.index = this._index;
                this.event("loaded");
                this.onCompResize();
            }
        };
        __proto.play = function (from, to) {
            (from === void 0) && (from = 0);
            (to === void 0) && (to = -1);
            this._isPlaying = true;
            this.index = from;
            this._toIndex = to;
            this._index++;
            Laya.timer.loop(this.interval, this, this._loop);
            this.on("display", this, this._onDisplay);
            this.on("undisplay", this, this._onDisplay);
        };
        __proto._loop = function () {
            if (this._style.visible && this._sources) {
                this._index++;
                if (this._toIndex > -1 && this._index >= this._toIndex)
                    this.stop();
                else if (this._index >= this._sources.length)
                    this._index = 0;
                this.index = this._index;
            }
        };
        __proto.stop = function () {
            this._isPlaying = false;
            Laya.timer.clear(this, this._loop);
            this.event("complete");
        };
        __proto._setClipChanged = function () {
            if (!this._clipChanged) {
                this._clipChanged = true;
                this.callLater(this.changeClip);
            }
        };
        __getset(0, __proto, 'interval', function () {
            return this._interval;
        }, function (value) {
            if (this._interval != value) {
                this._interval = value;
                if (this._isPlaying)
                    this.play();
            }
        });
        __getset(0, __proto, 'skin', function () {
            return this._skin;
        }, function (value) {
            if (this._skin != value) {
                this._skin = value;
                if (value) {
                    this._setClipChanged();
                }
                else {
                    this._bitmap.source = null;
                }
            }
        });
        __getset(0, __proto, 'sources', function () {
            return this._sources;
        }, function (value) {
            this._sources = value;
            this.index = this._index;
            this.event("loaded");
        });
        __getset(0, __proto, 'clipX', function () {
            return this._clipX;
        }, function (value) {
            this._clipX = value || 1;
            this._setClipChanged();
        });
        __getset(0, __proto, 'clipY', function () {
            return this._clipY;
        }, function (value) {
            this._clipY = value || 1;
            this._setClipChanged();
        });
        __getset(0, __proto, 'total', function () {
            this.runCallLater(this.changeClip);
            return this._sources ? this._sources.length : 0;
        });
        __getset(0, __proto, 'clipWidth', function () {
            return this._clipWidth;
        }, function (value) {
            this._clipWidth = value;
            this._setClipChanged();
        });
        __getset(0, __proto, 'sizeGrid', function () {
            if (this._bitmap.sizeGrid)
                return this._bitmap.sizeGrid.join(",");
            return null;
        }, function (value) {
            this._bitmap.sizeGrid = UIUtils.fillArray(Styles.defaultSizeGrid, value, Number);
        });
        __getset(0, __proto, 'group', function () {
            return this._group;
        }, function (value) {
            if (value && this._skin)
                Loader.setGroup(this._skin, value);
            this._group = value;
        });
        __getset(0, __proto, 'clipHeight', function () {
            return this._clipHeight;
        }, function (value) {
            this._clipHeight = value;
            this._setClipChanged();
        });
        __getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
            Laya.superSet(Component, this, 'width', value);
            this._bitmap.width = value;
        });
        __getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
            Laya.superSet(Component, this, 'height', value);
            this._bitmap.height = value;
        });
        __getset(0, __proto, 'measureWidth', function () {
            this.runCallLater(this.changeClip);
            return this._bitmap.width;
        });
        __getset(0, __proto, 'measureHeight', function () {
            this.runCallLater(this.changeClip);
            return this._bitmap.height;
        });
        __getset(0, __proto, 'index', function () {
            return this._index;
        }, function (value) {
            this._index = value;
            this._bitmap && this._sources && (this._bitmap.source = this._sources[value]);
            this.event("change");
        });
        __getset(0, __proto, 'autoPlay', function () {
            return this._autoPlay;
        }, function (value) {
            if (this._autoPlay != value) {
                this._autoPlay = value;
                value ? this.play() : this.stop();
            }
        });
        __getset(0, __proto, 'isPlaying', function () {
            return this._isPlaying;
        }, function (value) {
            this._isPlaying = value;
        });
        __getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
            this._dataSource = value;
            if (((typeof value == 'number') && Math.floor(value) == value) || (typeof value == 'string'))
                this.index = parseInt(value);
            else
                Laya.superSet(Component, this, 'dataSource', value);
        });
        __getset(0, __proto, 'bitmap', function () {
            return this._bitmap;
        });
        return Clip;
    })(Component);
    var ColorPicker = (function (_super) {
        function ColorPicker() {
            this.changeHandler = null;
            this._gridSize = 11;
            this._bgColor = "#ffffff";
            this._borderColor = "#000000";
            this._inputColor = "#000000";
            this._inputBgColor = "#efefef";
            this._colorPanel = null;
            this._colorTiles = null;
            this._colorBlock = null;
            this._colorInput = null;
            this._colorButton = null;
            this._colors = [];
            this._selectedColor = "#000000";
            this._panelChanged = false;
            ColorPicker.__super.call(this);
        }
        __class(ColorPicker, 'laya.ui.ColorPicker', _super);
        var __proto = ColorPicker.prototype;
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            _super.prototype.destroy.call(this, destroyChild);
            this._colorPanel && this._colorPanel.destroy(destroyChild);
            this._colorButton && this._colorButton.destroy(destroyChild);
            this._colorPanel = null;
            this._colorTiles = null;
            this._colorBlock = null;
            this._colorInput = null;
            this._colorButton = null;
            this._colors = null;
            this.changeHandler = null;
        };
        __proto.createChildren = function () {
            this.addChild(this._colorButton = new Button());
            this._colorPanel = new Box();
            this._colorPanel.size(230, 166);
            this._colorPanel.addChild(this._colorTiles = new Sprite());
            this._colorPanel.addChild(this._colorBlock = new Sprite());
            this._colorPanel.addChild(this._colorInput = new Input());
        };
        __proto.initialize = function () {
            this._colorButton.on("click", this, this.onColorButtonClick);
            this._colorBlock.pos(5, 5);
            this._colorInput.pos(60, 5);
            this._colorInput.size(60, 20);
            this._colorInput.on("change", this, this.onColorInputChange);
            this._colorInput.on("keydown", this, this.onColorFieldKeyDown);
            this._colorTiles.pos(5, 30);
            this._colorTiles.on("mousemove", this, this.onColorTilesMouseMove);
            this._colorTiles.on("click", this, this.onColorTilesClick);
            this._colorTiles.size(20 * this._gridSize, 12 * this._gridSize);
            this._colorPanel.on("mousedown", this, this.onPanelMouseDown);
            this.bgColor = this._bgColor;
        };
        __proto.onPanelMouseDown = function (e) {
            e.stopPropagation();
        };
        __proto.changePanel = function () {
            this._panelChanged = false;
            var g = this._colorPanel.graphics;
            g.clear();
            g.drawRect(0, 0, 230, 166, this._bgColor, this._borderColor);
            this.drawBlock(this._selectedColor);
            this._colorInput.borderColor = this._borderColor;
            this._colorInput.bgColor = this._inputBgColor;
            this._colorInput.color = this._inputColor;
            g = this._colorTiles.graphics;
            g.clear();
            var mainColors = [0x000000, 0x333333, 0x666666, 0x999999, 0xCCCCCC, 0xFFFFFF, 0xFF0000, 0x00FF00, 0x0000FF, 0xFFFF00, 0x00FFFF, 0xFF00FF];
            for (var i = 0; i < 12; i++) {
                for (var j = 0; j < 20; j++) {
                    var color = 0;
                    if (j === 0)
                        color = mainColors[i];
                    else if (j === 1)
                        color = 0x000000;
                    else
                        color = (((i * 3 + j / 6) % 3 << 0) + ((i / 6) << 0) * 3) * 0x33 << 16 | j % 6 * 0x33 << 8 | (i << 0) % 6 * 0x33;
                    var strColor = UIUtils.toColor(color);
                    this._colors.push(strColor);
                    var x = j * this._gridSize;
                    var y = i * this._gridSize;
                    g.drawRect(x, y, this._gridSize, this._gridSize, strColor, "#000000");
                }
            }
        };
        __proto.onColorButtonClick = function (e) {
            if (this._colorPanel.parent)
                this.close();
            else
                this.open();
        };
        __proto.open = function () {
            var p = this.localToGlobal(new Point());
            var px = p.x + this._colorPanel.width <= Laya.stage.width ? p.x : Laya.stage.width - this._colorPanel.width;
            var py = p.y + this._colorButton.height;
            py = py + this._colorPanel.height <= Laya.stage.height ? py : p.y - this._colorPanel.height;
            this._colorPanel.pos(px, py);
            this._colorPanel.zOrder = 1001;
            Laya._currentStage.addChild(this._colorPanel);
            Laya.stage.on("mousedown", this, this.removeColorBox);
        };
        __proto.close = function () {
            Laya.stage.off("mousedown", this, this.removeColorBox);
            this._colorPanel.removeSelf();
        };
        __proto.removeColorBox = function (e) {
            this.close();
        };
        __proto.onColorFieldKeyDown = function (e) {
            if (e.keyCode == 13) {
                if (this._colorInput.text)
                    this.selectedColor = this._colorInput.text;
                else
                    this.selectedColor = null;
                this.close();
                e.stopPropagation();
            }
        };
        __proto.onColorInputChange = function (e) {
            if (this._colorInput.text)
                this.drawBlock(this._colorInput.text);
            else
                this.drawBlock("#FFFFFF");
        };
        __proto.onColorTilesClick = function (e) {
            this.selectedColor = this.getColorByMouse();
            this.close();
        };
        __proto.onColorTilesMouseMove = function (e) {
            this._colorInput.focus = false;
            var color = this.getColorByMouse();
            this._colorInput.text = color;
            this.drawBlock(color);
        };
        __proto.getColorByMouse = function () {
            var point = this._colorTiles.getMousePoint();
            var x = Math.floor(point.x / this._gridSize);
            var y = Math.floor(point.y / this._gridSize);
            return this._colors[y * 20 + x];
        };
        __proto.drawBlock = function (color) {
            var g = this._colorBlock.graphics;
            g.clear();
            var showColor = color ? color : "#ffffff";
            g.drawRect(0, 0, 50, 20, showColor, this._borderColor);
            color || g.drawLine(0, 0, 50, 20, "#ff0000");
        };
        __proto.changeColor = function () {
            var g = this.graphics;
            g.clear();
            var showColor = this._selectedColor || "#000000";
            g.drawRect(0, 0, this._colorButton.width, this._colorButton.height, showColor);
        };
        __proto._setPanelChanged = function () {
            if (!this._panelChanged) {
                this._panelChanged = true;
                this.callLater(this.changePanel);
            }
        };
        __getset(0, __proto, 'inputBgColor', function () {
            return this._inputBgColor;
        }, function (value) {
            this._inputBgColor = value;
            this._setPanelChanged();
        });
        __getset(0, __proto, 'selectedColor', function () {
            return this._selectedColor;
        }, function (value) {
            if (this._selectedColor != value) {
                this._selectedColor = this._colorInput.text = value;
                this.drawBlock(value);
                this.changeColor();
                this.changeHandler && this.changeHandler.runWith(this._selectedColor);
                this.event("change", Event.EMPTY.setTo("change", this, this));
            }
        });
        __getset(0, __proto, 'skin', function () {
            return this._colorButton.skin;
        }, function (value) {
            this._colorButton.skin = value;
            this.changeColor();
        });
        __getset(0, __proto, 'bgColor', function () {
            return this._bgColor;
        }, function (value) {
            this._bgColor = value;
            this._setPanelChanged();
        });
        __getset(0, __proto, 'borderColor', function () {
            return this._borderColor;
        }, function (value) {
            this._borderColor = value;
            this._setPanelChanged();
        });
        __getset(0, __proto, 'inputColor', function () {
            return this._inputColor;
        }, function (value) {
            this._inputColor = value;
            this._setPanelChanged();
        });
        return ColorPicker;
    })(Component);
    var ComboBox = (function (_super) {
        function ComboBox(skin, labels) {
            this._visibleNum = 6;
            this._button = null;
            this._list = null;
            this._isOpen = false;
            this._itemSize = 12;
            this._labels = [];
            this._selectedIndex = -1;
            this._selectHandler = null;
            this._itemHeight = NaN;
            this._listHeight = NaN;
            this._listChanged = false;
            this._itemChanged = false;
            this._scrollBarSkin = null;
            this._isCustomList = false;
            this.itemRender = null;
            ComboBox.__super.call(this);
            this._itemColors = Styles.comboBoxItemColors;
            this.skin = skin;
            this.labels = labels;
        }
        __class(ComboBox, 'laya.ui.ComboBox', _super);
        var __proto = ComboBox.prototype;
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            _super.prototype.destroy.call(this, destroyChild);
            this._button && this._button.destroy(destroyChild);
            this._list && this._list.destroy(destroyChild);
            this._button = null;
            this._list = null;
            this._itemColors = null;
            this._labels = null;
            this._selectHandler = null;
        };
        __proto.createChildren = function () {
            this.addChild(this._button = new Button());
            this._button.text.align = "left";
            this._button.labelPadding = "0,0,0,5";
            this._button.on("mousedown", this, this.onButtonMouseDown);
        };
        __proto._createList = function () {
            this._list = new List();
            if (this._scrollBarSkin)
                this._list.vScrollBarSkin = this._scrollBarSkin;
            this._setListEvent(this._list);
        };
        __proto._setListEvent = function (list) {
            this._list.selectEnable = true;
            this._list.on("mousedown", this, this.onListDown);
            this._list.mouseHandler = Handler.create(this, this.onlistItemMouse, null, false);
            if (this._list.scrollBar)
                this._list.scrollBar.on("mousedown", this, this.onScrollBarDown);
        };
        __proto.onListDown = function (e) {
            e.stopPropagation();
        };
        __proto.onScrollBarDown = function (e) {
            e.stopPropagation();
        };
        __proto.onButtonMouseDown = function (e) {
            this.callLater(this.switchTo, [!this._isOpen]);
        };
        __proto.changeList = function () {
            this._listChanged = false;
            var labelWidth = this.width - 2;
            var labelColor = this._itemColors[2];
            this._itemHeight = this._itemSize + 6;
            this._list.itemRender = this.itemRender || { type: "Box", child: [{ type: "Label", props: { name: "label", x: 1, padding: "3,3,3,3", width: labelWidth, height: this._itemHeight, fontSize: this._itemSize, color: labelColor } }] };
            this._list.repeatY = this._visibleNum;
            this._list.refresh();
        };
        __proto.onlistItemMouse = function (e, index) {
            var type = e.type;
            if (type === "mouseover" || type === "mouseout") {
                if (this._isCustomList)
                    return;
                var box = this._list.getCell(index);
                if (!box)
                    return;
                var label = box.getChildByName("label");
                if (label) {
                    if (type === "mouseover") {
                        label.bgColor = this._itemColors[0];
                        label.color = this._itemColors[1];
                    }
                    else {
                        label.bgColor = null;
                        label.color = this._itemColors[2];
                    }
                }
            }
            else if (type === "click") {
                this.selectedIndex = index;
                this.isOpen = false;
            }
        };
        __proto.switchTo = function (value) {
            this.isOpen = value;
        };
        __proto.changeOpen = function () {
            this.isOpen = !this._isOpen;
        };
        __proto.changeItem = function () {
            this._itemChanged = false;
            this._listHeight = this._labels.length > 0 ? Math.min(this._visibleNum, this._labels.length) * this._itemHeight : this._itemHeight;
            if (!this._isCustomList) {
                var g = this._list.graphics;
                g.clear();
                g.drawRect(0, 0, this.width - 1, this._listHeight, this._itemColors[4], this._itemColors[3]);
            }
            var a = this._list.array || [];
            a.length = 0;
            for (var i = 0, n = this._labels.length; i < n; i++) {
                a.push({ label: this._labels[i] });
            }
            this._list.width = this.width;
            this._list.height = this._listHeight;
            this._list.array = a;
        };
        __proto.changeSelected = function () {
            this._button.label = this.selectedLabel;
        };
        __proto._onStageMouseWheel = function (e) {
            if (!this._list || this._list.contains(e.target))
                return;
            this.removeList(null);
        };
        __proto.removeList = function (e) {
            Laya.stage.off("mousedown", this, this.removeList);
            Laya.stage.off("mousewheel", this, this._onStageMouseWheel);
            this.isOpen = false;
        };
        __getset(0, __proto, 'selectedIndex', function () {
            return this._selectedIndex;
        }, function (value) {
            if (this._selectedIndex != value) {
                this._selectedIndex = value;
                if (this._labels.length > 0)
                    this.changeSelected();
                else
                    this.callLater(this.changeSelected);
                this.event("change", [Event.EMPTY.setTo("change", this, this)]);
                this._selectHandler && this._selectHandler.runWith(this._selectedIndex);
            }
        });
        __getset(0, __proto, 'measureHeight', function () {
            return this._button.height;
        });
        __getset(0, __proto, 'skin', function () {
            return this._button.skin;
        }, function (value) {
            if (this._button.skin != value) {
                this._button.skin = value;
                this._listChanged = true;
            }
        });
        __getset(0, __proto, 'measureWidth', function () {
            return this._button.width;
        });
        __getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
            Laya.superSet(Component, this, 'width', value);
            this._button.width = this._width;
            this._itemChanged = true;
            this._listChanged = true;
        });
        __getset(0, __proto, 'selectedLabel', function () {
            return this._selectedIndex > -1 && this._selectedIndex < this._labels.length ? this._labels[this._selectedIndex] : "";
        }, function (value) {
            this.selectedIndex = this._labels.indexOf(value);
        });
        __getset(0, __proto, 'labels', function () {
            return this._labels.join(",");
        }, function (value) {
            if (this._labels.length > 0)
                this.selectedIndex = -1;
            if (value)
                this._labels = value.split(",");
            else
                this._labels.length = 0;
            this._itemChanged = true;
        });
        __getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
            Laya.superSet(Component, this, 'height', value);
            this._button.height = this._height;
        });
        __getset(0, __proto, 'selectHandler', function () {
            return this._selectHandler;
        }, function (value) {
            this._selectHandler = value;
        });
        __getset(0, __proto, 'visibleNum', function () {
            return this._visibleNum;
        }, function (value) {
            this._visibleNum = value;
            this._listChanged = true;
        });
        __getset(0, __proto, 'labelBold', function () {
            return this._button.text.bold;
        }, function (value) {
            this._button.text.bold = value;
        });
        __getset(0, __proto, 'itemColors', function () {
            return String(this._itemColors);
        }, function (value) {
            this._itemColors = UIUtils.fillArray(this._itemColors, value, String);
            this._listChanged = true;
        });
        __getset(0, __proto, 'itemSize', function () {
            return this._itemSize;
        }, function (value) {
            this._itemSize = value;
            this._listChanged = true;
        });
        __getset(0, __proto, 'scrollBar', function () {
            return this.list.scrollBar;
        });
        __getset(0, __proto, 'isOpen', function () {
            return this._isOpen;
        }, function (value) {
            if (this._isOpen != value) {
                this._isOpen = value;
                if (!this._button) return;
                this._button.selected = this._isOpen;
                if (this._isOpen) {
                    this._list || this._createList();
                    this._listChanged && !this._isCustomList && this.changeList();
                    this._itemChanged && this.changeItem();
                    var p = this.localToGlobal(Point.TEMP.setTo(0, 0));
                    var py = p.y + this._button.height;
                    py = py + this._listHeight <= Laya.stage.height ? py : p.y - this._listHeight;
                    this._list.pos(p.x, py);
                    this._list.zOrder = 1001;
                    Laya._currentStage.addChild(this._list);
                    Laya.stage.once("mousedown", this, this.removeList);
                    Laya.stage.on("mousewheel", this, this._onStageMouseWheel);
                    this._list.selectedIndex = this._selectedIndex;
                }
                else {
                    this._list && this._list.removeSelf();
                }
                ComboBox.isOpen = value;
            }
        });
        __getset(0, __proto, 'scrollBarSkin', function () {
            return this._scrollBarSkin;
        }, function (value) {
            this._scrollBarSkin = value;
        });
        __getset(0, __proto, 'sizeGrid', function () {
            return this._button.sizeGrid;
        }, function (value) {
            this._button.sizeGrid = value;
        });
        __getset(0, __proto, 'button', function () {
            return this._button;
        });
        __getset(0, __proto, 'list', function () {
            this._list || this._createList();
            return this._list;
        }, function (value) {
            if (value) {
                value.removeSelf();
                this._isCustomList = true;
                this._list = value;
                this._setListEvent(value);
                this._itemHeight = value.getCell(0).height + value.spaceY;
            }
        });
        __getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
            this._dataSource = value;
            if (((typeof value == 'number') && Math.floor(value) == value) || (typeof value == 'string'))
                this.selectedIndex = parseInt(value);
            else if ((value instanceof Array))
                this.labels = (value).join(",");
            else
                Laya.superSet(Component, this, 'dataSource', value);
        });
        __getset(0, __proto, 'labelColors', function () {
            return this._button.labelColors;
        }, function (value) {
            if (this._button.labelColors != value) {
                this._button.labelColors = value;
            }
        });
        __getset(0, __proto, 'labelPadding', function () {
            return this._button.text.padding.join(",");
        }, function (value) {
            this._button.text.padding = UIUtils.fillArray(Styles.labelPadding, value, Number);
        });
        __getset(0, __proto, 'labelSize', function () {
            return this._button.text.fontSize;
        }, function (value) {
            this._button.text.fontSize = value;
        });
        __getset(0, __proto, 'labelFont', function () {
            return this._button.text.font;
        }, function (value) {
            this._button.text.font = value;
        });
        __getset(0, __proto, 'stateNum', function () {
            return this._button.stateNum;
        }, function (value) {
            this._button.stateNum = value;
        });
        return ComboBox;
    })(Component);
    var ScrollBar = (function (_super) {
        function ScrollBar(skin) {
            this.rollRatio = 0.95;
            this.changeHandler = null;
            this.scaleBar = true;
            this.autoHide = false;
            this.elasticDistance = 0;
            this.elasticBackTime = 500;
            this.upButton = null;
            this.downButton = null;
            this.slider = null;
            this._scrollSize = 1;
            this._skin = null;
            this._thumbPercent = 1;
            this._target = null;
            this._lastPoint = null;
            this._lastOffset = 0;
            this._checkElastic = false;
            this._isElastic = false;
            this._value = NaN;
            this._hide = false;
            this._clickOnly = true;
            this._offsets = null;
            ScrollBar.__super.call(this);
            this._showButtons = UIConfig.showButtons;
            this._touchScrollEnable = UIConfig.touchScrollEnable;
            this._mouseWheelEnable = UIConfig.mouseWheelEnable;
            this.skin = skin;
            this.max = 1;
        }
        __class(ScrollBar, 'laya.ui.ScrollBar', _super);
        var __proto = ScrollBar.prototype;
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            this.stopScroll();
            this.target = null;
            _super.prototype.destroy.call(this, destroyChild);
            this.upButton && this.upButton.destroy(destroyChild);
            this.downButton && this.downButton.destroy(destroyChild);
            this.slider && this.slider.destroy(destroyChild);
            this.upButton = this.downButton = null;
            this.slider = null;
            this.changeHandler = null;
            this._offsets = null;
        };
        __proto.createChildren = function () {
            this.addChild(this.slider = new Slider());
            this.addChild(this.upButton = new Button());
            this.addChild(this.downButton = new Button());
        };
        __proto.initialize = function () {
            this.slider.showLabel = false;
            this.slider.on("change", this, this.onSliderChange);
            this.slider.setSlider(0, 0, 0);
            this.upButton.on("mousedown", this, this.onButtonMouseDown);
            this.downButton.on("mousedown", this, this.onButtonMouseDown);
        };
        __proto.onSliderChange = function () {
            if (this._value != this.slider.value)
                this.value = this.slider.value;
        };
        __proto.onButtonMouseDown = function (e) {
            var isUp = e.currentTarget === this.upButton;
            this.slide(isUp);
            Laya.timer.once(Styles.scrollBarDelayTime, this, this.startLoop, [isUp]);
            Laya.stage.once("mouseup", this, this.onStageMouseUp);
        };
        __proto.startLoop = function (isUp) {
            Laya.timer.frameLoop(1, this, this.slide, [isUp]);
        };
        __proto.slide = function (isUp) {
            if (isUp)
                this.value -= this._scrollSize;
            else
                this.value += this._scrollSize;
        };
        __proto.onStageMouseUp = function (e) {
            Laya.timer.clear(this, this.startLoop);
            Laya.timer.clear(this, this.slide);
        };
        __proto.changeScrollBar = function () {
            this.upButton.visible = this._showButtons;
            this.downButton.visible = this._showButtons;
            if (this._showButtons) {
                this.upButton.skin = this._skin.replace(".png", "$up.png");
                this.downButton.skin = this._skin.replace(".png", "$down.png");
            }
            if (this.slider.isVertical)
                this.slider.y = this._showButtons ? this.upButton.height : 0;
            else
                this.slider.x = this._showButtons ? this.upButton.width : 0;
            this.resetPositions();
            this.repaint();
        };
        __proto.changeSize = function () {
            _super.prototype.changeSize.call(this);
            this.repaint();
            this.resetPositions();
            this.event("change");
            this.changeHandler && this.changeHandler.runWith(this.value);
        };
        __proto.resetPositions = function () {
            if (this.slider.isVertical)
                this.slider.height = this.height - (this._showButtons ? (this.upButton.height + this.downButton.height) : 0);
            else
                this.slider.width = this.width - (this._showButtons ? (this.upButton.width + this.downButton.width) : 0);
            this.resetButtonPosition();
        };
        __proto.resetButtonPosition = function () {
            if (this.slider.isVertical)
                this.downButton.y = this.slider.y + this.slider.height;
            else
                this.downButton.x = this.slider.x + this.slider.width;
        };
        __proto.setScroll = function (min, max, value) {
            this.runCallLater(this.changeSize);
            this.slider.setSlider(min, max, value);
            this.slider.bar.visible = max > 0;
            if (!this._hide && this.autoHide)
                this.visible = false;
        };
        __proto.onTargetMouseWheel = function (e) {
            this.value -= e.delta * this._scrollSize;
            this.target = this._target;
        };
        __proto.onTargetMouseDown = function (e) {
            this._clickOnly = true;
            this._lastOffset = 0;
            this._checkElastic = false;
            this._lastPoint || (this._lastPoint = new Point());
            this._lastPoint.setTo(Laya.stage.mouseX, Laya.stage.mouseY);
            Laya.timer.clear(this, this.tweenMove);
            Tween.clearTween(this);
            Laya.stage.once("mouseup", this, this.onStageMouseUp2);
            Laya.stage.once("mouseout", this, this.onStageMouseUp2);
            Laya.timer.frameLoop(1, this, this.loop);
        };
        __proto.loop = function () {
            var mouseY = Laya.stage.mouseY;
            var mouseX = Laya.stage.mouseX;
            this._lastOffset = this.isVertical ? (mouseY - this._lastPoint.y) : (mouseX - this._lastPoint.x);
            if (this._clickOnly) {
                if (Math.abs(this._lastOffset * (this.isVertical ? Laya.stage._canvasTransform.getScaleY() : Laya.stage._canvasTransform.getScaleX())) > 1) {
                    this._clickOnly = false;
                    this._offsets || (this._offsets = []);
                    this._offsets.length = 0;
                    this._target.mouseEnabled = false;
                    if (!this.hide && this.autoHide) {
                        this.alpha = 1;
                        this.visible = true;
                    }
                    this.event("start");
                }
                else
                    return;
            }
            this._offsets.push(this._lastOffset);
            this._lastPoint.x = mouseX;
            this._lastPoint.y = mouseY;
            if (this._lastOffset === 0)
                return;
            if (!this._checkElastic) {
                if (this.elasticDistance > 0) {
                    if (!this._checkElastic && this._lastOffset != 0) {
                        if ((this._lastOffset > 0 && this._value <= this.min) || (this._lastOffset < 0 && this._value >= this.max)) {
                            this._isElastic = true;
                            this._checkElastic = true;
                        }
                        else {
                            this._isElastic = false;
                        }
                    }
                }
                else {
                    this._checkElastic = true;
                }
            }
            if (this._isElastic) {
                if (this._value <= this.min) {
                    this.value -= this._lastOffset * Math.max(0, (1 - ((this.min - this._value) / this.elasticDistance)));
                }
                else if (this._value >= this.max) {
                    this.value -= this._lastOffset * Math.max(0, (1 - ((this._value - this.max) / this.elasticDistance)));
                }
            }
            else {
                this.value -= this._lastOffset;
            }
        };
        __proto.onStageMouseUp2 = function (e) {
            Laya.stage.off("mouseup", this, this.onStageMouseUp2);
            Laya.stage.off("mouseout", this, this.onStageMouseUp2);
            Laya.timer.clear(this, this.loop);
            if (this._clickOnly) {
                if (this._value >= this.min && this._value <= this.max)
                    return;
            }
            this._target.mouseEnabled = true;
            if (this._isElastic) {
                if (this._value < this.min) {
                    Tween.to(this, { value: this.min }, this.elasticBackTime, Ease.sineOut, Handler.create(this, this.elasticOver));
                }
                else if (this._value > this.max) {
                    Tween.to(this, { value: this.max }, this.elasticBackTime, Ease.sineOut, Handler.create(this, this.elasticOver));
                }
            }
            else {
                if (!this._offsets)
                    return;
                if (this._offsets.length < 1) {
                    this._offsets[0] = this.isVertical ? Laya.stage.mouseY - this._lastPoint.y : Laya.stage.mouseX - this._lastPoint.x;
                }
                ;
                var offset = 0;
                var n = Math.min(this._offsets.length, 3);
                for (var i = 0; i < n; i++) {
                    offset += this._offsets[this._offsets.length - 1 - i];
                }
                this._lastOffset = offset / n;
                offset = Math.abs(this._lastOffset);
                if (offset < 2) {
                    this.event("end");
                    return;
                }
                if (offset > 60)
                    this._lastOffset = this._lastOffset > 0 ? 60 : -60;
                var dis = Math.round(Math.abs(this.elasticDistance * (this._lastOffset / 240)));
                Laya.timer.frameLoop(1, this, this.tweenMove, [dis]);
            }
        };
        __proto.elasticOver = function () {
            this._isElastic = false;
            if (!this.hide && this.autoHide) {
                Tween.to(this, { alpha: 0 }, 500);
            }
            this.event("end");
        };
        __proto.tweenMove = function (maxDistance) {
            this._lastOffset *= this.rollRatio;
            var tarSpeed = NaN;
            if (maxDistance > 0) {
                if (this._lastOffset > 0 && this.value <= this.min) {
                    this._isElastic = true;
                    tarSpeed = -(this.min - maxDistance - this.value) * 0.5;
                    if (this._lastOffset > tarSpeed)
                        this._lastOffset = tarSpeed;
                }
                else if (this._lastOffset < 0 && this.value >= this.max) {
                    this._isElastic = true;
                    tarSpeed = -(this.max + maxDistance - this.value) * 0.5;
                    if (this._lastOffset < tarSpeed)
                        this._lastOffset = tarSpeed;
                }
            }
            this.value -= this._lastOffset;
            if (Math.abs(this._lastOffset) < 1) {
                Laya.timer.clear(this, this.tweenMove);
                if (this._isElastic) {
                    if (this._value < this.min) {
                        Tween.to(this, { value: this.min }, this.elasticBackTime, Ease.sineOut, Handler.create(this, this.elasticOver));
                    }
                    else if (this._value > this.max) {
                        Tween.to(this, { value: this.max }, this.elasticBackTime, Ease.sineOut, Handler.create(this, this.elasticOver));
                    }
                    else {
                        this.elasticOver();
                    }
                    return;
                }
                this.event("end");
                if (!this.hide && this.autoHide) {
                    Tween.to(this, { alpha: 0 }, 500);
                }
            }
        };
        __proto.stopScroll = function () {
            this.onStageMouseUp2(null);
            Laya.timer.clear(this, this.tweenMove);
            Tween.clearTween(this);
        };
        __getset(0, __proto, 'measureHeight', function () {
            if (this.slider.isVertical)
                return 100;
            return this.slider.height;
        });
        __getset(0, __proto, 'skin', function () {
            return this._skin;
        }, function (value) {
            if (this._skin != value) {
                this._skin = value;
                this.slider.skin = this._skin;
                this.callLater(this.changeScrollBar);
            }
        });
        __getset(0, __proto, 'max', function () {
            return this.slider.max;
        }, function (value) {
            this.slider.max = value;
        });
        __getset(0, __proto, 'showButtons', function () {
            return this._showButtons;
        }, function (value) {
            this._showButtons = value;
            this.callLater(this.changeScrollBar);
        });
        __getset(0, __proto, 'measureWidth', function () {
            if (this.slider.isVertical)
                return this.slider.width;
            return 100;
        });
        __getset(0, __proto, 'min', function () {
            return this.slider.min;
        }, function (value) {
            this.slider.min = value;
        });
        __getset(0, __proto, 'value', function () {
            return this._value;
        }, function (v) {
            if (v !== this._value) {
                this._value = v;
                if (!this._isElastic) {
                    if (this.slider._value != v) {
                        this.slider._value = v;
                        this.slider.changeValue();
                    }
                    this._value = this.slider._value;
                }
                this.event("change");
                this.changeHandler && this.changeHandler.runWith(this._value);
            }
        });
        __getset(0, __proto, 'isVertical', function () {
            return this.slider.isVertical;
        }, function (value) {
            this.slider.isVertical = value;
        });
        __getset(0, __proto, 'sizeGrid', function () {
            return this.slider.sizeGrid;
        }, function (value) {
            this.slider.sizeGrid = value;
        });
        __getset(0, __proto, 'scrollSize', function () {
            return this._scrollSize;
        }, function (value) {
            this._scrollSize = value;
        });
        __getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
            this._dataSource = value;
            if ((typeof value == 'number') || (typeof value == 'string'))
                this.value = Number(value);
            else
                Laya.superSet(Component, this, 'dataSource', value);
        });
        __getset(0, __proto, 'thumbPercent', function () {
            return this._thumbPercent;
        }, function (value) {
            this.runCallLater(this.changeScrollBar);
            this.runCallLater(this.changeSize);
            value = value >= 1 ? 0.99 : value;
            this._thumbPercent = value;
            if (this.scaleBar) {
                if (this.slider.isVertical) {
                    this.slider.bar.height = Math.max(this.slider.height * value, Styles.scrollBarMinNum);
                    this.slider.bar.height = Math.min(this.slider.bar.height, this.slider.height);
                }
                else {
                    this.slider.bar.width = Math.max(this.slider.width * value, Styles.scrollBarMinNum);
                    this.slider.bar.width = Math.min(this.slider.bar.width, this.slider.width);
                }
            }
        });
        __getset(0, __proto, 'target', function () {
            return this._target;
        }, function (value) {
            if (this._target) {
                this._target.off("mousewheel", this, this.onTargetMouseWheel);
                this._target.off("mousedown", this, this.onTargetMouseDown);
            }
            this._target = value;
            if (value) {
                this._mouseWheelEnable && this._target.on("mousewheel", this, this.onTargetMouseWheel);
                this._touchScrollEnable && this._target.on("mousedown", this, this.onTargetMouseDown);
            }
        });
        __getset(0, __proto, 'hide', function () {
            return this._hide;
        }, function (value) {
            this._hide = value;
            this.visible = !value;
        });
        __getset(0, __proto, 'touchScrollEnable', function () {
            return this._touchScrollEnable;
        }, function (value) {
            this._touchScrollEnable = value;
            this.target = this._target;
        });
        __getset(0, __proto, 'mouseWheelEnable', function () {
            return this._mouseWheelEnable;
        }, function (value) {
            this._mouseWheelEnable = value;
        });
        __getset(0, __proto, 'tick', function () {
            return this.slider.tick;
        }, function (value) {
            this.slider.tick = value;
        });
        return ScrollBar;
    })(Component);
    var Slider = (function (_super) {
        function Slider(skin) {
            this.changeHandler = null;
            this.isVertical = true;
            this.showLabel = true;
            this._allowClickBack = false;
            this._max = 100;
            this._min = 0;
            this._tick = 1;
            this._value = 0;
            this._skin = null;
            this._bg = null;
            this._progress = null;
            this._bar = null;
            this._tx = NaN;
            this._ty = NaN;
            this._maxMove = NaN;
            this._globalSacle = null;
            Slider.__super.call(this);
            this.skin = skin;
        }
        __class(Slider, 'laya.ui.Slider', _super);
        var __proto = Slider.prototype;
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            _super.prototype.destroy.call(this, destroyChild);
            this._bg && this._bg.destroy(destroyChild);
            this._bar && this._bar.destroy(destroyChild);
            this._progress && this._progress.destroy(destroyChild);
            this._bg = null;
            this._bar = null;
            this._progress = null;
            this.changeHandler = null;
        };
        __proto.createChildren = function () {
            this.addChild(this._bg = new Image());
            this.addChild(this._bar = new Button());
        };
        __proto.initialize = function () {
            this._bar.on("mousedown", this, this.onBarMouseDown);
            // this._bg.sizeGrid = this._bar.sizeGrid = "4,4,4,4,0";
            this._bg.sizeGrid = this._bar.sizeGrid = "0,0,0,0,0";
            if (this._progress)
                this._progress.sizeGrid = this._bar.sizeGrid;
            this.allowClickBack = true;
        };
        __proto.onBarMouseDown = function (e) {
            this._globalSacle || (this._globalSacle = new Point());
            this._globalSacle.setTo(this.globalScaleX || 0.01, this.globalScaleY || 0.01);
            this._maxMove = this.isVertical ? (this.height - this._bar.height) : (this.width - this._bar.width);
            this._tx = Laya.stage.mouseX;
            this._ty = Laya.stage.mouseY;
            Laya.stage.on("mousemove", this, this.mouseMove);
            Laya.stage.once("mouseup", this, this.mouseUp);
            Laya.stage.once("mouseout", this, this.mouseUp);
            this.showValueText();
        };
        __proto.showValueText = function () {
            if (this.showLabel) {
                var label = laya.ui.Slider.label;
                this.addChild(label);
                label.textField.changeText(this._value + "");
                if (this.isVertical) {
                    label.x = this._bar.x + 20;
                    label.y = (this._bar.height - label.height) * 0.5 + this._bar.y;
                }
                else {
                    label.y = this._bar.y - 20;
                    label.x = (this._bar.width - label.width) * 0.5 + this._bar.x;
                }
            }
        };
        __proto.hideValueText = function () {
            laya.ui.Slider.label && laya.ui.Slider.label.removeSelf();
        };
        __proto.mouseUp = function (e) {
            Laya.stage.off("mousemove", this, this.mouseMove);
            Laya.stage.off("mouseup", this, this.mouseUp);
            Laya.stage.off("mouseout", this, this.mouseUp);
            this.sendChangeEvent("changed");
            this.hideValueText();
        };
        __proto.mouseMove = function (e) {
            var oldValue = this._value;
            if (this.isVertical) {
                this._bar.y += (Laya.stage.mouseY - this._ty) / this._globalSacle.y;
                if (this._bar.y > this._maxMove)
                    this._bar.y = this._maxMove;
                else if (this._bar.y < 0)
                    this._bar.y = 0;
                this._value = this._bar.y / this._maxMove * (this._max - this._min) + this._min;
                if (this._progress)
                    this._progress.height = this._bar.y + 0.5 * this._bar.height;
            }
            else {
                this._bar.x += (Laya.stage.mouseX - this._tx) / this._globalSacle.x;
                if (this._bar.x > this._maxMove)
                    this._bar.x = this._maxMove;
                else if (this._bar.x < 0)
                    this._bar.x = 0;
                this._value = this._bar.x / this._maxMove * (this._max - this._min) + this._min;
                if (this._progress)
                    this._progress.width = this._bar.x + 0.5 * this._bar.width;
            }
            this._tx = Laya.stage.mouseX;
            this._ty = Laya.stage.mouseY;
            var pow = Math.pow(10, (this._tick + "").length - 1);
            this._value = Math.round(Math.round(this._value / this._tick) * this._tick * pow) / pow;
            if (this._value != oldValue) {
                this.sendChangeEvent();
            }
            this.showValueText();
        };
        __proto.sendChangeEvent = function (type) {
            (type === void 0) && (type = "change");
            this.event(type);
            this.changeHandler && this.changeHandler.runWith(this._value);
        };
        __proto.setBarPoint = function () {
            if (this.isVertical)
                this._bar.x = Math.round((this._bg.width - this._bar.width) * 0.5);
            else
                this._bar.y = Math.round((this._bg.height - this._bar.height) * 0.5);
        };
        __proto.changeSize = function () {
            _super.prototype.changeSize.call(this);
            if (this.isVertical)
                this._bg.height = this.height;
            else
                this._bg.width = this.width;
            this.setBarPoint();
            this.changeValue();
        };
        __proto.setSlider = function (min, max, value) {
            this._value = -1;
            this._min = min;
            this._max = max > min ? max : min;
            this.value = value < min ? min : value > max ? max : value;
        };
        __proto.changeValue = function () {
            if (os.platform != 4 && os.platform != 3) {
                var pow = Math.pow(10, (this._tick + "").length - 1);
                this._value = Math.round(Math.round(this._value / this._tick) * this._tick * pow) / pow;
            }
            this._value = this._value > this._max ? this._max : this._value < this._min ? this._min : this._value;
            var num = this._max - this._min;
            if (num === 0)
                num = 1;
            if (this.isVertical) {
                this._bar.y = (this._value - this._min) / num * (this.height - this._bar.height);
                if (this._progress)
                    this._progress.height = this._bar.y + 0.5 * this._bar.height;
            }
            else {
                this._bar.x = (this._value - this._min) / num * (this.width - this._bar.width);
                if (this._progress)
                    this._progress.width = this._bar.x + 0.5 * this._bar.width;
            }
        };
        __proto.onBgMouseDown = function (e) {
            var point = this._bg.getMousePoint();
            if (this.isVertical)
                this.value = point.y / (this.height - this._bar.height) * (this._max - this._min) + this._min;
            else
                this.value = point.x / (this.width - this._bar.width) * (this._max - this._min) + this._min;
        };
        __getset(0, __proto, 'measureHeight', function () {
            return Math.max(this._bg.height, this._bar.height);
        });
        __getset(0, __proto, 'skin', function () {
            return this._skin;
        }, function (value) {
            if (this._skin != value) {
                this._skin = value;
                this._bg.skin = this._skin;
                this._bar.skin = this._skin.replace(".png", "$bar.png");
                var progressSkin = this._skin.replace(".png", "$progress.png");
                if (Loader.getRes(progressSkin)) {
                    if (!this._progress) {
                        this.addChild(this._progress = new Image());
                        this._progress.sizeGrid = this._bar.sizeGrid;
                        this.setChildIndex(this._progress, 1);
                    }
                    this._progress.skin = progressSkin;
                }
                this.setBarPoint();
                this.callLater(this.changeValue);
            }
        });
        __getset(0, __proto, 'allowClickBack', function () {
            return this._allowClickBack;
        }, function (value) {
            if (this._allowClickBack != value) {
                this._allowClickBack = value;
                if (value)
                    this._bg.on("mousedown", this, this.onBgMouseDown);
                else
                    this._bg.off("mousedown", this, this.onBgMouseDown);
            }
        });
        __getset(0, __proto, 'max', function () {
            return this._max;
        }, function (value) {
            if (this._max != value) {
                this._max = value;
                this.callLater(this.changeValue);
            }
        });
        __getset(0, __proto, 'measureWidth', function () {
            return Math.max(this._bg.width, this._bar.width);
        });
        __getset(0, __proto, 'tick', function () {
            return this._tick;
        }, function (value) {
            if (this._tick != value) {
                this._tick = value;
                this.callLater(this.changeValue);
            }
        });
        __getset(0, __proto, 'sizeGrid', function () {
            return this._bg.sizeGrid;
        }, function (value) {
            this._bg.sizeGrid = value;
            this._bar.sizeGrid = value;
            if (this._progress)
                this._progress.sizeGrid = this._bar.sizeGrid;
        });
        __getset(0, __proto, 'min', function () {
            return this._min;
        }, function (value) {
            if (this._min != value) {
                this._min = value;
                this.callLater(this.changeValue);
            }
        });
        __getset(0, __proto, 'value', function () {
            return this._value;
        }, function (num) {
            if (this._value != num) {
                var oldValue = this._value;
                this._value = num;
                this.changeValue();
                if (this._value != oldValue) {
                    this.sendChangeEvent();
                }
            }
        });
        __getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
            this._dataSource = value;
            if ((typeof value == 'number') || (typeof value == 'string'))
                this.value = Number(value);
            else
                Laya.superSet(Component, this, 'dataSource', value);
        });
        __getset(0, __proto, 'bar', function () {
            return this._bar;
        });
        __static(Slider, ['label', function () { return this.label = new Label(); }
        ]);
        return Slider;
    })(Component);
    var Image = (function (_super) {
        function Image(skin) {
            this._bitmap = null;
            this._skin = null;
            this._group = null;
            Image.__super.call(this);
            this.skin = skin;
        }
        __class(Image, 'laya.ui.Image', _super);
        var __proto = Image.prototype;
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            _super.prototype.destroy.call(this, true);
            this._bitmap && this._bitmap.destroy();
            this._bitmap = null;
        };
        __proto.dispose = function () {
            this.destroy(true);
            Laya.loader.clearRes(this._skin);
        };
        __proto.createChildren = function () {
            this.graphics = this._bitmap = new AutoBitmap();
            this._bitmap.autoCacheCmd = false;
        };
        __proto.setSource = function (url, img) {
            if (url === this._skin && img) {
                this.source = img;
                this.onCompResize();
            }
        };
        __getset(0, __proto, 'source', function () {
            return this._bitmap.source;
        }, function (value) {
            if (!this._bitmap)
                return;
            this._bitmap.source = value;
            this.event("loaded");
            this.repaint();
        });
        __getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
            this._dataSource = value;
            if ((typeof value == 'string'))
                this.skin = value;
            else
                Laya.superSet(Component, this, 'dataSource', value);
        });
        __getset(0, __proto, 'measureHeight', function () {
            return this._bitmap.height;
        });
        __getset(0, __proto, 'skin', function () {
            return this._skin;
        }, function (value) {
            if (this._skin != value) {
                this._skin = value;
                if (value) {
                    var source = Loader.getRes(value);
                    if (source) {
                        this.source = source;
                        this.onCompResize();
                    }
                    else
                        Laya.loader.load(this._skin, Handler.create(this, this.setSource, [this._skin]), null, "image", 1, true, this._group);
                }
                else {
                    this.source = null;
                }
            }
        });
        __getset(0, __proto, 'group', function () {
            return this._group;
        }, function (value) {
            if (value && this._skin)
                Loader.setGroup(this._skin, value);
            this._group = value;
        });
        __getset(0, __proto, 'sizeGrid', function () {
            if (this._bitmap.sizeGrid)
                return this._bitmap.sizeGrid.join(",");
            return null;
        }, function (value) {
            this._bitmap.sizeGrid = UIUtils.fillArray(Styles.defaultSizeGrid, value, Number);
        });
        __getset(0, __proto, 'measureWidth', function () {
            return this._bitmap.width;
        });
        __getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
            Laya.superSet(Component, this, 'width', value);
            this._bitmap.width = value == 0 ? 0.0000001 : value;
        });
        __getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
            Laya.superSet(Component, this, 'height', value);
            this._bitmap.height = value == 0 ? 0.0000001 : value;
        });
        return Image;
    })(Component);
    var Label = (function (_super) {
        function Label(text) {
            this._tf = null;
            Label.__super.call(this);
            (text === void 0) && (text = "");
            Font.defaultColor = Styles.labelColor;
            this.text = text;
        }
        __class(Label, 'laya.ui.Label', _super);
        var __proto = Label.prototype;
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            _super.prototype.destroy.call(this, destroyChild);
            this._tf = null;
        };
        __proto.createChildren = function () {
            this.addChild(this._tf = new Text());
        };
        __proto.changeText = function (text) {
            this._tf.changeText(text);
        };
        __getset(0, __proto, 'padding', function () {
            return this._tf.padding.join(",");
        }, function (value) {
            this._tf.padding = UIUtils.fillArray(Styles.labelPadding, value, Number);
        });
        __getset(0, __proto, 'bold', function () {
            return this._tf.bold;
        }, function (value) {
            this._tf.bold = value;
        });
        __getset(0, __proto, 'align', function () {
            return this._tf.align;
        }, function (value) {
            this._tf.align = value;
        });
        __getset(0, __proto, 'text', function () {
            return this._tf.text;
        }, function (value) {
            if (this._tf.text != value) {
                if (value)
                    value = UIUtils.adptString(value + "");
                this._tf.text = value;
                this.event("change");
                if (!this._width || !this._height)
                    this.onCompResize();
            }
        });
        __getset(0, __proto, 'italic', function () {
            return this._tf.italic;
        }, function (value) {
            this._tf.italic = value;
        });
        __getset(0, __proto, 'wordWrap', function () {
            return this._tf.wordWrap;
        }, function (value) {
            this._tf.wordWrap = value;
        });
        __getset(0, __proto, 'font', function () {
            return this._tf.font;
        }, function (value) {
            this._tf.font = value;
        });
        __getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
            this._dataSource = value;
            if ((typeof value == 'number') || (typeof value == 'string'))
                this.text = value + "";
            else
                Laya.superSet(Component, this, 'dataSource', value);
        });
        __getset(0, __proto, 'color', function () {
            return this._tf.color;
        }, function (value) {
            this._tf.color = value;
        });
        __getset(0, __proto, 'valign', function () {
            return this._tf.valign;
        }, function (value) {
            this._tf.valign = value;
        });
        __getset(0, __proto, 'leading', function () {
            return this._tf.leading;
        }, function (value) {
            this._tf.leading = value;
        });
        __getset(0, __proto, 'letterSpacing', function () {
            return this._tf.letterSpacing;
        }, function (value) {
            this._tf.letterSpacing = value;
        });
        __getset(0, __proto, 'fontSize', function () {
            return this._tf.fontSize;
        }, function (value) {
            this._tf.fontSize = value;
        });
        __getset(0, __proto, 'bgColor', function () {
            return this._tf.bgColor;
        }, function (value) {
            this._tf.bgColor = value;
        });
        __getset(0, __proto, 'borderColor', function () {
            return this._tf.borderColor;
        }, function (value) {
            this._tf.borderColor = value;
        });
        __getset(0, __proto, 'stroke', function () {
            return this._tf.stroke;
        }, function (value) {
            this._tf.stroke = value;
        });
        __getset(0, __proto, 'strokeColor', function () {
            return this._tf.strokeColor;
        }, function (value) {
            this._tf.strokeColor = value;
        });
        __getset(0, __proto, 'textField', function () {
            return this._tf;
        });
        __getset(0, __proto, 'measureWidth', function () {
            return this._tf.width;
        });
        __getset(0, __proto, 'measureHeight', function () {
            return this._tf.height;
        });
        __getset(0, __proto, 'width', function () {
            if (this._width || this._tf.text) {
                return Laya.superGet(Component, this, 'width');
            }
            return 0;
        }, function (value) {
            Laya.superSet(Component, this, 'width', value);
            this._tf.width = value;
        });
        __getset(0, __proto, 'height', function () {
            if (this._height || this._tf.text) {
                return Laya.superGet(Component, this, 'height');
            }
            return 0;
        }, function (value) {
            Laya.superSet(Component, this, 'height', value);
            this._tf.height = value;
        });
        __getset(0, __proto, 'overflow', function () {
            return this._tf.overflow;
        }, function (value) {
            this._tf.overflow = value;
        });
        __getset(0, __proto, 'underline', function () {
            return this._tf.underline;
        }, function (value) {
            this._tf.underline = value;
        });
        __getset(0, __proto, 'underlineColor', function () {
            return this._tf.underlineColor;
        }, function (value) {
            this._tf.underlineColor = value;
        });
        return Label;
    })(Component);
    var ProgressBar = (function (_super) {
        function ProgressBar(skin) {
            this.changeHandler = null;
            this._bg = null;
            this._bar = null;
            this._skin = null;
            this._value = 0.5;
            ProgressBar.__super.call(this);
            this.skin = skin;
        }
        __class(ProgressBar, 'laya.ui.ProgressBar', _super);
        var __proto = ProgressBar.prototype;
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            _super.prototype.destroy.call(this, destroyChild);
            this._bg && this._bg.destroy(destroyChild);
            this._bar && this._bar.destroy(destroyChild);
            this._bg = this._bar = null;
            this.changeHandler = null;
        };
        __proto.createChildren = function () {
            this.addChild(this._bg = new Image());
            this.addChild(this._bar = new Image());
            this._bar._bitmap.autoCacheCmd = false;
        };
        __proto.changeValue = function () {
            if (this.sizeGrid) {
                var grid = this.sizeGrid.split(",");
                var left = Number(grid[3]);
                var right = Number(grid[1]);
                var max = this.width - left - right;
                var sw = max * this._value;
                this._bar.width = left + right + sw;
                this._bar.visible = this._bar.width > left + right;
            }
            else {
                this._bar.width = this.width * this._value;
            }
        };
        __getset(0, __proto, 'measureHeight', function () {
            return this._bg.height;
        });
        __getset(0, __proto, 'skin', function () {
            return this._skin;
        }, function (value) {
            if (this._skin != value) {
                this._skin = value;
                this._bg.skin = this._skin;
                this._bar.skin = this._skin.replace(".png", "$bar.png");
                this.callLater(this.changeValue);
            }
        });
        __getset(0, __proto, 'measureWidth', function () {
            return this._bg.width;
        });
        __getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
            Laya.superSet(Component, this, 'height', value);
            this._bg.height = this._height;
            this._bar.height = this._height;
        });
        __getset(0, __proto, 'bar', function () {
            return this._bar;
        });
        __getset(0, __proto, 'value', function () {
            return this._value;
        }, function (num) {
            if (this._value != num) {
                num = num > 1 ? 1 : num < 0 ? 0 : num;
                this._value = num;
                this.callLater(this.changeValue);
                this.event("change");
                this.changeHandler && this.changeHandler.runWith(num);
            }
        });
        __getset(0, __proto, 'bg', function () {
            return this._bg;
        });
        __getset(0, __proto, 'sizeGrid', function () {
            return this._bg.sizeGrid;
        }, function (value) {
            this._bg.sizeGrid = this._bar.sizeGrid = value;
        });
        __getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
            Laya.superSet(Component, this, 'width', value);
            this._bg.width = this._width;
            this.callLater(this.changeValue);
        });
        __getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
            this._dataSource = value;
            if ((typeof value == 'number') || (typeof value == 'string'))
                this.value = Number(value);
            else
                Laya.superSet(Component, this, 'dataSource', value);
        });
        return ProgressBar;
    })(Component);
    var TipManager = (function (_super) {
        function TipManager() {
            this._tipBox = null;
            this._tipText = null;
            this._defaultTipHandler = null;
            TipManager.__super.call(this);
            this._tipBox = new Component();
            this._tipBox.addChild(this._tipText = new Text());
            this._tipText.x = this._tipText.y = 5;
            this._tipText.color = TipManager.tipTextColor;
            this._defaultTipHandler = this._showDefaultTip;
            Laya.stage.on("showtip", this, this._onStageShowTip);
            Laya.stage.on("hidetip", this, this._onStageHideTip);
            this.zOrder = 1100;
        }
        __class(TipManager, 'laya.ui.TipManager', _super);
        var __proto = TipManager.prototype;
        __proto._onStageHideTip = function (e) {
            Laya.timer.clear(this, this._showTip);
            this.closeAll();
            this.removeSelf();
        };
        __proto._onStageShowTip = function (data) {
            Laya.timer.once(TipManager.tipDelay, this, this._showTip, [data], true);
        };
        __proto._showTip = function (tip) {
            if ((typeof tip == 'string')) {
                var text = String(tip);
                if (Boolean(text)) {
                    this._defaultTipHandler(text);
                }
            }
            else if ((tip instanceof laya.utils.Handler)) {
                (tip).run();
            }
            else if ((typeof tip == 'function')) {
                (tip).apply();
            }
            if (true) {
                Laya.stage.on("mousemove", this, this._onStageMouseMove);
                Laya.stage.on("mousedown", this, this._onStageMouseDown);
            }
            this._onStageMouseMove(null);
        };
        __proto._onStageMouseDown = function (e) {
            this.closeAll();
        };
        __proto._onStageMouseMove = function (e) {
            this._showToStage(this, TipManager.offsetX, TipManager.offsetY);
        };
        __proto._showToStage = function (dis, offX, offY) {
            (offX === void 0) && (offX = 0);
            (offY === void 0) && (offY = 0);
            var rec = dis.getBounds();
            dis.x = Laya.stage.mouseX + offX;
            dis.y = Laya.stage.mouseY + offY;
            if (dis.x + rec.width > Laya.stage.width) {
                dis.x -= rec.width + offX;
            }
            if (dis.y + rec.height > Laya.stage.height) {
                dis.y -= rec.height + offY;
            }
        };
        __proto.closeAll = function () {
            Laya.timer.clear(this, this._showTip);
            Laya.stage.off("mousemove", this, this._onStageMouseMove);
            Laya.stage.off("mousedown", this, this._onStageMouseDown);
            this.removeChildren();
        };
        __proto.showDislayTip = function (tip) {
            this.addChild(tip);
            this._showToStage(this);
            Laya._currentStage.addChild(this);
        };
        __proto._showDefaultTip = function (text) {
            this._tipText.text = text;
            var g = this._tipBox.graphics;
            g.clear();
            g.drawRect(0, 0, this._tipText.width + 10, this._tipText.height + 10, TipManager.tipBackColor);
            this.addChild(this._tipBox);
            this._showToStage(this);
            Laya._currentStage.addChild(this);
        };
        __getset(0, __proto, 'defaultTipHandler', function () {
            return this._defaultTipHandler;
        }, function (value) {
            this._defaultTipHandler = value;
        });
        TipManager.offsetX = 10;
        TipManager.offsetY = 15;
        TipManager.tipTextColor = "#ffffff";
        TipManager.tipBackColor = "#111111";
        TipManager.tipDelay = 200;
        return TipManager;
    })(Component);
    var View = (function (_super) {
        var DataWatcher;
        function View() {
            this._idMap = null;
            this._aniList = null;
            this._watchMap = {};
            View.__super.call(this);
        }
        __class(View, 'laya.ui.View', _super);
        var __proto = View.prototype;
        __proto.createView = function (uiView) {
            if (uiView.animations && !this._idMap)
                this._idMap = {};
            View.createComp(uiView, this, this);
            if (uiView.animations) {
                var anilist = [];
                var animations = uiView.animations;
                var i = 0, len = animations.length;
                var tAni;
                var tAniO;
                for (i = 0; i < len; i++) {
                    tAni = new FrameAnimation();
                    tAniO = animations[i];
                    tAni._setUp(this._idMap, tAniO);
                    this[tAniO.name] = tAni;
                    tAni._setControlNode(this);
                    switch (tAniO.action) {
                        case 1:
                            tAni.play(0, false);
                            break;
                        case 2:
                            tAni.play(0, true);
                            break;
                    }
                    anilist.push(tAni);
                }
                this._aniList = anilist;
            }
            if (this._width > 0 && uiView.props.hitTestPrior == null && !this.mouseThrough)
                this.hitTestPrior = true;
        };
        __proto.onEvent = function (type, event) { };
        __proto.loadUI = function (path) {
            var uiView = View.uiMap[path];
            uiView && this.createView(uiView);
        };
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            if (this._aniList)
                this._aniList.length = 0;
            this._idMap = null;
            this._aniList = null;
            this._watchMap = null;
            laya.ui.Component.prototype.destroy.call(this, destroyChild);
        };
        __proto.changeData = function (key) {
            var arr = this._watchMap[key];
            if (!arr)
                return;
            console_log("change", key);
            for (var i = 0, n = arr.length; i < n; i++) {
                var watcher = arr[i];
                watcher.exe(this);
            }
        };
        View._regs = function () {
            for (var key in View.uiClassMap) {
                ClassUtils.regClass(key, View.uiClassMap[key]);
            }
        };
        View.createComp = function (uiView, comp, view, dataMap) {
            comp = comp || View.getCompInstance(uiView);
            if (!comp) {
                console_warn("can not create:" + uiView.type);
                return null;
            }
            ;
            var child = uiView.child;
            if (child) {
                var isList = (comp instanceof laya.ui.List);
                for (var i = 0, n = child.length; i < n; i++) {
                    var node = child[i];
                    if (comp.hasOwnProperty("itemRender") && (node.props.name == "render" || node.props.renderType === "render")) {
                        (comp).itemRender = node;
                    }
                    else if (node.type == "Graphic") {
                        ClassUtils.addGraphicsToSprite(node, comp);
                    }
                    else if (ClassUtils.isDrawType(node.type)) {
                        ClassUtils.addGraphicToSprite(node, comp, true);
                    }
                    else {
                        if (isList) {
                            var arr = [];
                            var tChild = View.createComp(node, null, view, arr);
                            if (arr.length)
                                tChild["_$bindData"] = arr;
                        }
                        else {
                            tChild = View.createComp(node, null, view, dataMap);
                        }
                        if (node.type == "Script") {
                            if ("owner" in tChild) {
                                tChild["owner"] = comp;
                            }
                            else if ("target" in tChild) {
                                tChild["target"] = comp;
                            }
                        }
                        else if (node.props.renderType == "mask" || node.props.name == "mask") {
                            comp.mask = tChild;
                        }
                        else {
                            (tChild instanceof laya.display.Sprite) && comp.addChild(tChild);
                        }
                    }
                }
            }
            ;
            var props = uiView.props;
            for (var prop in props) {
                var value = props[prop];
                if (View.eventDic[prop]) {
                    if (value && view) {
                        (comp).on(prop, view, view.onEvent, [value]);
                    }
                }
                else
                    View.setCompValue(comp, prop, value, view, dataMap);
            }
            if (Laya.__typeof(comp, 'laya.ui.IItem'))
                (comp).initItems();
            if (uiView.compId && view && view._idMap) {
                view._idMap[uiView.compId] = comp;
            }
            return comp;
        };
        View.setCompValue = function (comp, prop, value, view, dataMap) {
            if ((typeof value == 'string') && value.indexOf("${") > -1) {
                View._sheet || (View._sheet = ClassUtils.getClass("laya.data.Table"));
                if (!View._sheet) {
                    console_warn("Can not find class Sheet");
                    return;
                }
                if (dataMap) {
                    dataMap.push(comp, prop, value);
                }
                else if (view) {
                    if (value.indexOf("].") == -1) {
                        value = value.replace(".", "[0].");
                    }
                    ;
                    var watcher = new DataWatcher(comp, prop, value);
                    watcher.exe(view);
                    var one, temp;
                    var str = value.replace(/\[.*?\]\./g, ".");
                    while ((one = View._parseWatchData.exec(str)) != null) {
                        var key1 = one[1];
                        while ((temp = View._parseKeyWord.exec(key1)) != null) {
                            var key2 = temp[0];
                            var arr = (view._watchMap[key2] || (view._watchMap[key2] = []));
                            arr.push(watcher);
                            View._sheet.I.notifer.on(key2, view, view.changeData, [key2]);
                        }
                        arr = (view._watchMap[key1] || (view._watchMap[key1] = []));
                        arr.push(watcher);
                        View._sheet.I.notifer.on(key1, view, view.changeData, [key1]);
                    }
                }
                return;
            }
            if (prop === "var" && view) {
                view[value] = comp;
            }
            else if (prop == "onClick") {
                var fun = Browser.window.eval("(function(){" + value + "})");
                comp.on("click", view, fun);
            }
            else {
                comp[prop] = (value === "true" ? true : (value === "false" ? false : value));
            }
        };
        View.getCompInstance = function (json) {
            var runtime = json.props ? json.props.runtime : null;
            var compClass;
            compClass = runtime ? (View.viewClassMap[runtime] || View.uiClassMap[runtime] || Laya["__classmap"][runtime]) : View.uiClassMap[json.type];
            if (json.props && json.props.hasOwnProperty("renderType") && json.props["renderType"] == "instance")
                return compClass["instance"];
            return compClass ? new compClass() : null;
        };
        View.regComponent = function (key, compClass) {
            View.uiClassMap[key] = compClass;
            ClassUtils.regClass(key, compClass);
        };
        View.regViewRuntime = function (key, compClass) {
            View.viewClassMap[key] = compClass;
        };
        View.uiMap = {};
        View.viewClassMap = {};
        View._sheet = null;
        __static(View, ['uiClassMap', function () { return this.uiClassMap = { "ViewStack": ViewStack, "LinkButton": Button, "TextArea": TextArea, "ColorPicker": ColorPicker, "Box": Box, "Button": Button, "CheckBox": CheckBox, "Clip": Clip, "ComboBox": ComboBox, "Component": Component, "HScrollBar": HScrollBar, "HSlider": HSlider, "Image": Image, "Label": Label, "List": List, "Panel": Panel, "ProgressBar": ProgressBar, "Radio": Radio, "RadioGroup": RadioGroup, "ScrollBar": ScrollBar, "Slider": Slider, "Tab": Tab, "TextInput": TextInput, "View": View, "VScrollBar": VScrollBar, "VSlider": VSlider, "Tree": Tree, "HBox": HBox, "VBox": VBox, "Sprite": Sprite, "Animation": Animation, "Text": Text, "FontClip": FontClip }; }, 'eventDic', function () { return this.eventDic = { "mousedown": true, "mouseup": true, "mousemove": true, "mouseover": true, "mouseout": true, "click": true, "doubleclick": true, "rightmousedown": true, "rightmouseup": true, "rightclick": true }; }, '_parseWatchData', function () { return this._parseWatchData = /\${(.*?)}/g; }, '_parseKeyWord', function () { return this._parseKeyWord = /[a-zA-Z_][a-zA-Z0-9_]*(?:(?:\.[a-zA-Z_][a-zA-Z0-9_]*)+)/g; }
        ]);
        View.__init$ = function () {
            View._regs();
            DataWatcher = (function () {
                function DataWatcher(comp, prop, value) {
                    this.comp = null;
                    this.prop = null;
                    this.value = null;
                    this.comp = comp;
                    this.prop = prop;
                    this.value = value;
                }
                __class(DataWatcher, '');
                var __proto = DataWatcher.prototype;
                __proto.exe = function (view) {
                    var fun = UIUtils.getBindFun(this.value);
                    this.comp[this.prop] = fun.call(this, view);
                };
                return DataWatcher;
            })();
        };
        return View;
    })(Box);
    var CheckBox = (function (_super) {
        function CheckBox(skin, label) {
            (label === void 0) && (label = "");
            CheckBox.__super.call(this, skin, label);
        }
        __class(CheckBox, 'laya.ui.CheckBox', _super);
        var __proto = CheckBox.prototype;
        __proto.preinitialize = function () {
            laya.ui.Component.prototype.preinitialize.call(this);
            this.toggle = true;
            this._autoSize = false;
        };
        __proto.initialize = function () {
            _super.prototype.initialize.call(this);
            this.createText();
            this._text.align = "left";
            this._text.valign = "top";
            this._text.width = 0;
        };
        __getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
            this._dataSource = value;
            if ((typeof value == 'boolean'))
                this.selected = value;
            else if ((typeof value == 'string'))
                this.selected = value === "true";
            else
                Laya.superSet(Button, this, 'dataSource', value);
        });
        return CheckBox;
    })(Button);
    var LayoutBox = (function (_super) {
        function LayoutBox() {
            this._space = 0;
            this._align = "none";
            this._itemChanged = false;
            LayoutBox.__super.call(this);
        }
        __class(LayoutBox, 'laya.ui.LayoutBox', _super);
        var __proto = LayoutBox.prototype;
        __proto.addChild = function (child) {
            child.on("resize", this, this.onResize);
            this._setItemChanged();
            return laya.display.Node.prototype.addChild.call(this, child);
        };
        __proto.onResize = function (e) {
            this._setItemChanged();
        };
        __proto.addChildAt = function (child, index) {
            child.on("resize", this, this.onResize);
            this._setItemChanged();
            return laya.display.Node.prototype.addChildAt.call(this, child, index);
        };
        __proto.removeChild = function (child) {
            child.off("resize", this, this.onResize);
            this._setItemChanged();
            return laya.display.Node.prototype.removeChild.call(this, child);
        };
        __proto.removeChildAt = function (index) {
            this.getChildAt(index).off("resize", this, this.onResize);
            this._setItemChanged();
            return laya.display.Node.prototype.removeChildAt.call(this, index);
        };
        __proto.refresh = function () {
            this._setItemChanged();
        };
        __proto.changeItems = function () {
            this._itemChanged = false;
        };
        __proto.sortItem = function (items) {
            if (items)
                items.sort(function (a, b) { return a.y - b.y; });
        };
        __proto._setItemChanged = function () {
            if (!this._itemChanged) {
                this._itemChanged = true;
                this.callLater(this.changeItems);
            }
        };
        __getset(0, __proto, 'space', function () {
            return this._space;
        }, function (value) {
            this._space = value;
            this._setItemChanged();
        });
        __getset(0, __proto, 'align', function () {
            return this._align;
        }, function (value) {
            this._align = value;
            this._setItemChanged();
        });
        return LayoutBox;
    })(Box);
    var FontClip = (function (_super) {
        function FontClip(skin, sheet) {
            this._valueArr = null;
            this._indexMap = null;
            this._sheet = null;
            this._direction = "horizontal";
            this._spaceX = 0;
            this._spaceY = 0;
            this._align = "left";
            this._wordsW = 0;
            this._wordsH = 0;
            FontClip.__super.call(this);
            if (skin)
                this.skin = skin;
            if (sheet)
                this.sheet = sheet;
        }
        __class(FontClip, 'laya.ui.FontClip', _super);
        var __proto = FontClip.prototype;
        __proto.createChildren = function () {
            this._bitmap = new AutoBitmap();
            this.on("loaded", this, this._onClipLoaded);
        };
        __proto._onClipLoaded = function () {
            this.callLater(this.changeValue);
        };
        __proto.changeValue = function () {
            if (!this._sources)
                return;
            if (!this._valueArr)
                return;
            this.graphics.clear(true);
            var texture;
            texture = this._sources[0];
            if (!texture)
                return;
            var isHorizontal = (this._direction === "horizontal");
            if (isHorizontal) {
                this._wordsW = this._valueArr.length * (texture.sourceWidth + this.spaceX);
                this._wordsH = texture.sourceHeight;
            }
            else {
                this._wordsW = texture.sourceWidth;
                this._wordsH = (texture.sourceHeight + this.spaceY) * this._valueArr.length;
            }
            ;
            var dX = 0;
            if (this._width) {
                switch (this._align) {
                    case "center":
                        dX = 0.5 * (this._width - this._wordsW);
                        break;
                    case "right":
                        dX = this._width - this._wordsW;
                        break;
                    default:
                        dX = 0;
                }
            }
            for (var i = 0, sz = this._valueArr.length; i < sz; i++) {
                var index = this._indexMap[this._valueArr.charAt(i)];
                if (!this.sources[index])
                    continue;
                texture = this.sources[index];
                if (isHorizontal)
                    this.graphics.drawTexture(texture, dX + i * (texture.sourceWidth + this.spaceX), 0, texture.sourceWidth, texture.sourceHeight);
                else
                    this.graphics.drawTexture(texture, 0 + dX, i * (texture.sourceHeight + this.spaceY), texture.sourceWidth, texture.sourceHeight);
            }
            if (!this._width) {
                this.resetLayoutX();
                this.callLater(this.changeSize);
            }
            if (!this._height) {
                this.resetLayoutY();
                this.callLater(this.changeSize);
            }
        };
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            this._valueArr = null;
            this._indexMap = null;
            this.graphics.clear(true);
            this.removeSelf();
            this.off("loaded", this, this._onClipLoaded);
            _super.prototype.destroy.call(this, destroyChild);
        };
        __getset(0, __proto, 'sheet', function () {
            return this._sheet;
        }, function (value) {
            value += "";
            this._sheet = value;
            var arr = value.split(" ");
            this._clipX = String(arr[0]).length;
            this.clipY = arr.length;
            this._indexMap = {};
            for (var i = 0; i < this._clipY; i++) {
                var line = arr[i].split("");
                for (var j = 0, n = line.length; j < n; j++) {
                    this._indexMap[line[j]] = i * this._clipX + j;
                }
            }
        });
        __getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
            Laya.superSet(Clip, this, 'height', value);
            this.callLater(this.changeValue);
        });
        __getset(0, __proto, 'direction', function () {
            return this._direction;
        }, function (value) {
            this._direction = value;
            this.callLater(this.changeValue);
        });
        __getset(0, __proto, 'value', function () {
            if (!this._valueArr)
                return "";
            return this._valueArr;
        }, function (value) {
            value += "";
            this._valueArr = value;
            this.callLater(this.changeValue);
        });
        __getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
            Laya.superSet(Clip, this, 'width', value);
            this.callLater(this.changeValue);
        });
        __getset(0, __proto, 'spaceX', function () {
            return this._spaceX;
        }, function (value) {
            this._spaceX = value;
            if (this._direction === "horizontal")
                this.callLater(this.changeValue);
        });
        __getset(0, __proto, 'spaceY', function () {
            return this._spaceY;
        }, function (value) {
            this._spaceY = value;
            if (!(this._direction === "horizontal"))
                this.callLater(this.changeValue);
        });
        __getset(0, __proto, 'align', function () {
            return this._align;
        }, function (v) {
            this._align = v;
            this.callLater(this.changeValue);
        });
        __getset(0, __proto, 'measureWidth', function () {
            return this._wordsW;
        });
        __getset(0, __proto, 'measureHeight', function () {
            return this._wordsH;
        });
        return FontClip;
    })(Clip);
    var List = (function (_super) {
        function List() {
            this.selectHandler = null;
            this.renderHandler = null;
            this.mouseHandler = null;
            this.selectEnable = false;
            this.totalPage = 0;
            this._content = null;
            this._scrollBar = null;
            this._itemRender = null;
            this._repeatX = 0;
            this._repeatY = 0;
            this._repeatX2 = 0;
            this._repeatY2 = 0;
            this._spaceX = 0;
            this._spaceY = 0;
            this._array = null;
            this._startIndex = 0;
            this._selectedIndex = -1;
            this._page = 0;
            this._isVertical = true;
            this._cellSize = 20;
            this._cellOffset = 0;
            this._isMoved = false;
            this.cacheContent = false;
            this._createdLine = 0;
            this._cellChanged = false;
            List.__super.call(this);
            this._cells = [];
            this._offset = new Point();
        }
        __class(List, 'laya.ui.List', _super);
        var __proto = List.prototype;
        Laya.imps(__proto, { "laya.ui.IRender": true, "laya.ui.IItem": true });
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            this._content && this._content.destroy(destroyChild);
            this._scrollBar && this._scrollBar.destroy(destroyChild);
            laya.ui.Component.prototype.destroy.call(this, destroyChild);
            this._content = null;
            this._scrollBar = null;
            this._itemRender = null;
            this._cells = null;
            this._array = null;
            this.selectHandler = this.renderHandler = this.mouseHandler = null;
        };
        __proto.createChildren = function () {
            this.addChild(this._content = new Box());
        };
        __proto.onScrollStart = function () {
            this._$P.cacheAs || (this._$P.cacheAs = Laya.superGet(Box, this, 'cacheAs'));
            Laya.superSet(Box, this, 'cacheAs', "none");
            this._scrollBar.once("end", this, this.onScrollEnd);
        };
        __proto.onScrollEnd = function () {
            Laya.superSet(Box, this, 'cacheAs', this._$P.cacheAs);
        };
        __proto._removePreScrollBar = function () {
            var preNode = this.removeChildByName("scrollBar");
            if (preNode)
                preNode.destroy(true);
        };
        __proto.changeCells = function () {
            this._cellChanged = false;
            if (this._itemRender) {
                this.scrollBar = this.getChildByName("scrollBar");
                var cell = this._getOneCell();
                var cellWidth = (cell.width + this._spaceX) || 1;
                var cellHeight = (cell.height + this._spaceY) || 1;
                if (this._width > 0)
                    this._repeatX2 = this._isVertical ? Math.round(this._width / cellWidth) : Math.ceil(this._width / cellWidth);
                if (this._height > 0)
                    this._repeatY2 = this._isVertical ? Math.ceil(this._height / cellHeight) : Math.round(this._height / cellHeight);
                var listWidth = this._width ? this._width : (cellWidth * this.repeatX - this._spaceX);
                var listHeight = this._height ? this._height : (cellHeight * this.repeatY - this._spaceY);
                this._cellSize = this._isVertical ? cellHeight : cellWidth;
                this._cellOffset = this._isVertical ? (cellHeight * Math.max(this._repeatY2, this._repeatY) - listHeight - this._spaceY + this._offset.y) : (cellWidth * Math.max(this._repeatX2, this._repeatX) - listWidth - this._spaceX + this._offset.x);
                if (this._isVertical && this._scrollBar)
                    this._scrollBar.height = listHeight;
                else if (!this._isVertical && this._scrollBar)
                    this._scrollBar.width = listWidth;
                if (this._scrollBar) this._scrollBar.thumbPercent = 1;
                this.setContentSize(listWidth, listHeight);
                var numX = this._isVertical ? this.repeatX : this.repeatY;
                var numY = (this._isVertical ? this.repeatY : this.repeatX) + (this._scrollBar ? 1 : 0);
                this._createItems(0, numX, numY);
                this._createdLine = numY;
                if (this._array) {
                    this.array = this._array;
                    this.runCallLater(this.renderItems);
                }
                if (this._scrollBar) this._scrollBar.right = 0;
            }

        };
        __proto._getOneCell = function () {
            if (this._cells.length === 0) {
                var item = this.createItem();
                this._offset.setTo(item.x, item.y);
                if (this.cacheContent)
                    return item;
                this._cells.push(item);
            }
            return this._cells[0];
        };
        __proto._createItems = function (startY, numX, numY) {
            var box = this._content;
            var cell = this._getOneCell();
            var cellWidth = cell.width + this._spaceX;
            var cellHeight = cell.height + this._spaceY;
            if (this.cacheContent) {
                var cacheBox = new Box();
                cacheBox.cacheAsBitmap = true;
                cacheBox.pos((this._isVertical ? 0 : startY) * cellWidth, (this._isVertical ? startY : 0) * cellHeight);
                this._content.addChild(cacheBox);
                this._content.optimizeScrollRect = true;
                box = cacheBox;
            }
            else {
                var arr = [];
                for (var i = this._cells.length - 1; i > -1; i--) {
                    var item = this._cells[i];
                    item.removeSelf();
                    arr.push(item);
                }
                this._cells.length = 0;
            }
            for (var k = startY; k < numY; k++) {
                for (var l = 0; l < numX; l++) {
                    if (arr && arr.length) {
                        cell = arr.pop();
                    }
                    else {
                        cell = this.createItem();
                    }
                    cell.x = (this._isVertical ? l : k) * cellWidth - box.x;
                    cell.y = (this._isVertical ? k : l) * cellHeight - box.y;
                    cell.name = "item" + (k * numX + l);
                    box.addChild(cell);
                    this.addCell(cell);
                }
            }
        };
        __proto.createItem = function () {
            var arr = [];
            if ((typeof this._itemRender == 'function')) {
                var box = new this._itemRender();
            }
            else {
                box = View.createComp(this._itemRender, null, null, arr);
            }
            if (arr.length == 0 && box._watchMap) {
                var watchMap = box._watchMap;
                for (var name in watchMap) {
                    var a = watchMap[name];
                    for (var i = 0; i < a.length; i++) {
                        var watcher = a[i];
                        arr.push(watcher.comp, watcher.prop, watcher.value);
                    }
                }
            }
            if (arr.length)
                box["_$bindData"] = arr;
            return box;
        };
        __proto.addCell = function (cell) {
            cell.on("click", this, this.onCellMouse);
            cell.on("rightclick", this, this.onCellMouse);
            cell.on("mouseover", this, this.onCellMouse);
            cell.on("mouseout", this, this.onCellMouse);
            cell.on("mousedown", this, this.onCellMouse);
            cell.on("mouseup", this, this.onCellMouse);
            this._cells.push(cell);
        };
        __proto.initItems = function () {
            if (!this._itemRender && this.getChildByName("item0") != null) {
                this.repeatX = 1;
                var count = 0;
                count = 0;
                for (var i = 0; i < 10000; i++) {
                    var cell = this.getChildByName("item" + i);
                    if (cell) {
                        this.addCell(cell);
                        count++;
                        continue;
                    }
                    break;
                }
                this.repeatY = count;
            }
        };
        __proto.setContentSize = function (width, height) {
            this._content.width = width;
            this._content.height = height;
            if (this._scrollBar || this._offset.x != 0 || this._offset.y != 0) {
                this._content.scrollRect || (this._content.scrollRect = new Rectangle());
                var scrollValue = this._scrollBar.value ? this._scrollBar.value : 0;
                if (this._isVertical) {
                    this._content.scrollRect.setTo(-this._offset.x, scrollValue - this._offset.y, width, height);
                }
                else {
                    this._content.scrollRect.setTo(scrollValue - this._offset.x, scrollValue - this._offset.y, width, height);
                }
                this._content.scrollRect = this._content.scrollRect;
            }
            this.event("resize");
        };
        __proto.onCellMouse = function (e) {
            if (e.type === "mousedown")
                this._isMoved = false;
            var cell = e.currentTarget;
            var index = this._startIndex + this._cells.indexOf(cell);
            if (index < 0)
                return;
            if (e.type === "click" || e.type === "rightclick") {
                if (this.selectEnable && !this._isMoved)
                    this.selectedIndex = index;
                else
                    this.changeCellState(cell, true, 0);
            }
            else if ((e.type === "mouseover" || e.type === "mouseout") && this._selectedIndex !== index) {
                this.changeCellState(cell, e.type === "mouseover", 0);
            }
            this.mouseHandler && this.mouseHandler.runWith([e, index]);
        };
        __proto.changeCellState = function (cell, visable, index) {
            var selectBox = cell.getChildByName("selectBox");
            if (selectBox) {
                this.selectEnable = true;
                selectBox.visible = visable;
                selectBox.index = index;
            }
        };
        __proto.changeSize = function () {
            laya.ui.Component.prototype.changeSize.call(this);
            this.setContentSize(this.width, this.height);
            if (this._scrollBar)
                this.callLater(this.onScrollBarChange);
        };
        __proto.onScrollBarChange = function (e) {
            this.runCallLater(this.changeCells);
            var scrollValue = this._scrollBar.value;
            var lineX = (this._isVertical ? this.repeatX : this.repeatY);
            var lineY = (this._isVertical ? this.repeatY : this.repeatX);
            var scrollLine = Math.floor(scrollValue / this._cellSize);
            if (!this.cacheContent) {
                var index = scrollLine * lineX;
                var num = 0;
                if (index > this._startIndex) {
                    num = index - this._startIndex;
                    var down = true;
                    var toIndex = this._startIndex + lineX * (lineY + 1);
                    this._isMoved = true;
                }
                else if (index < this._startIndex) {
                    num = this._startIndex - index;
                    down = false;
                    toIndex = this._startIndex - 1;
                    this._isMoved = true;
                }
                for (var i = 0; i < num; i++) {
                    if (down) {
                        var cell = this._cells.shift();
                        this._cells[this._cells.length] = cell;
                        var cellIndex = toIndex + i;
                    }
                    else {
                        cell = this._cells.pop();
                        this._cells.unshift(cell);
                        cellIndex = toIndex - i;
                    }
                    var pos = Math.floor(cellIndex / lineX) * this._cellSize;
                    this._isVertical ? cell.y = pos : cell.x = pos;
                    this.renderItem(cell, cellIndex);
                }
                this._startIndex = index;
                this.changeSelectStatus();
            }
            else {
                num = (lineY + 1);
                if (this._createdLine - scrollLine < num) {
                    this._createItems(this._createdLine, lineX, this._createdLine + num);
                    this.renderItems(this._createdLine * lineX, 0);
                    this._createdLine += num;
                }
            }
            var r = this._content.scrollRect;
            if (!r) return;
            if (this._isVertical) {
                r.y = scrollValue - this._offset.y;
                r.x = -this._offset.x;
            }
            else {
                r.y = -this._offset.y;
                r.x = scrollValue - this._offset.x;
            }
            this._content.scrollRect = r;
        };
        __proto.posCell = function (cell, cellIndex) {
            if (!this._scrollBar)
                return;
            var lineX = (this._isVertical ? this.repeatX : this.repeatY);
            var lineY = (this._isVertical ? this.repeatY : this.repeatX);
            var pos = Math.floor(cellIndex / lineX) * this._cellSize;
            this._isVertical ? cell.y = pos : cell.x = pos;
        };
        __proto.changeSelectStatus = function () {
            for (var i = 0, n = this._cells.length; i < n; i++) {
                this.changeCellState(this._cells[i], this._selectedIndex === this._startIndex + i, 1);
            }
        };
        __proto.renderItems = function (from, to) {
            (from === void 0) && (from = 0);
            (to === void 0) && (to = 0);
            for (var i = from, n = to || this._cells.length; i < n; i++) {
                this.renderItem(this._cells[i], this._startIndex + i);
            }
            this.changeSelectStatus();
        };
        __proto.renderItem = function (cell, index) {
            if (this._array && index >= 0 && index < this._array.length) {
                cell.visible = true;
                if (cell._$bindData) {
                    cell._dataSource = this._array[index];
                    this._bindData(cell, this._array[index]);
                }
                else
                    cell.dataSource = this._array[index];
                if (!this.cacheContent) {
                    this.posCell(cell, index);
                }
                if (this.hasListener("render"))
                    this.event("render", [cell, index]);
                if (this.renderHandler)
                    this.renderHandler.runWith([cell, index]);
            }
            else {
                cell.visible = false;
                cell.dataSource = null;
            }
        };
        __proto._bindData = function (cell, data) {
            var arr = cell._$bindData;
            for (var i = 0, n = arr.length; i < n; i++) {
                var ele = arr[i++];
                var prop = arr[i++];
                var value = arr[i];
                var fun = UIUtils.getBindFun(value);
                ele[prop] = fun.call(this, data);
            }
        };
        __proto.refresh = function () {
            this.array = this._array;
        };
        __proto.getItem = function (index) {
            if (index > -1 && index < this._array.length) {
                return this._array[index];
            }
            return null;
        };
        __proto.changeItem = function (index, source) {
            if (index > -1 && index < this._array.length) {
                this._array[index] = source;
                if (index >= this._startIndex && index < this._startIndex + this._cells.length) {
                    this.renderItem(this.getCell(index), index);
                }
            }
        };
        __proto.setItem = function (index, source) {
            this.changeItem(index, source);
        };
        __proto.addItem = function (souce) {
            this._array.push(souce);
            this.array = this._array;
        };
        __proto.addItemAt = function (souce, index) {
            this._array.splice(index, 0, souce);
            this.array = this._array;
        };
        __proto.deleteItem = function (index) {
            this._array.splice(index, 1);
            this.array = this._array;
        };
        __proto.getCell = function (index) {
            this.runCallLater(this.changeCells);
            if (index > -1 && this._cells) {
                return this._cells[(index - this._startIndex) % this._cells.length];
            }
            return null;
        };
        __proto.scrollTo = function (index) {
            if (this._scrollBar) {
                var numX = this._isVertical ? this.repeatX : this.repeatY;
                this._scrollBar.value = Math.floor(index / numX) * this._cellSize;
            }
            else {
                this.startIndex = index;
            }
        };
        __proto.tweenTo = function (index, time, complete) {
            (time === void 0) && (time = 200);
            if (this._scrollBar) {
                var numX = this._isVertical ? this.repeatX : this.repeatY;
                Tween.to(this._scrollBar, { value: Math.floor(index / numX) * this._cellSize }, time, null, complete, 0, true);
            }
            else {
                this.startIndex = index;
                if (complete)
                    complete.run();
            }
        };
        __proto._setCellChanged = function () {
            if (!this._cellChanged) {
                this._cellChanged = true;
                this.callLater(this.changeCells);
            }
        };
        __proto.commitMeasure = function () {
            this.runCallLater(this.changeCells);
        };
        __getset(0, __proto, 'cacheAs', _super.prototype._$get_cacheAs, function (value) {
            Laya.superSet(Box, this, 'cacheAs', value);
            if (this._scrollBar) {
                this._$P.cacheAs = null;
                if (value !== "none")
                    this._scrollBar.on("start", this, this.onScrollStart);
                else
                    this._scrollBar.off("start", this, this.onScrollStart);
            }
        });
        __getset(0, __proto, 'content', function () {
            return this._content;
        });
        __getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
            if (value != this._height) {
                Laya.superSet(Box, this, 'height', value);
                this._setCellChanged();
            }
        });
        __getset(0, __proto, 'itemRender', function () {
            return this._itemRender;
        }, function (value) {
            if (this._itemRender != value) {
                this._itemRender = value;
                for (var i = this._cells.length - 1; i > -1; i--) {
                    this._cells[i].destroy();
                }
                this._cells.length = 0;
                this._setCellChanged();
            }
        });
        __getset(0, __proto, 'vScrollBarSkin', function () {
            return this._scrollBar ? this._scrollBar.skin : null;
        }, function (value) {
            this._removePreScrollBar();
            var scrollBar = new VScrollBar();
            scrollBar.name = "scrollBar";
            scrollBar.right = 0;
            if (value && value != " ")
                scrollBar.skin = value;
            this.scrollBar = scrollBar;
            this.addChild(scrollBar);
            this._setCellChanged();
        });
        __getset(0, __proto, 'page', function () {
            return this._page;
        }, function (value) {
            this._page = value;
            if (this._array) {
                this._page = value > 0 ? value : 0;
                this._page = this._page < this.totalPage ? this._page : this.totalPage - 1;
                this.startIndex = this._page * this.repeatX * this.repeatY;
            }
        });
        __getset(0, __proto, 'hScrollBarSkin', function () {
            return this._scrollBar ? this._scrollBar.skin : null;
        }, function (value) {
            this._removePreScrollBar();
            var scrollBar = new HScrollBar();
            scrollBar.name = "scrollBar";
            scrollBar.bottom = 0;
            if (value && value != " ")
                scrollBar.skin = value;
            this.scrollBar = scrollBar;
            this.addChild(scrollBar);
            this._setCellChanged();
        });
        __getset(0, __proto, 'repeatX', function () {
            return this._repeatX > 0 ? this._repeatX : this._repeatX2 > 0 ? this._repeatX2 : 1;
        }, function (value) {
            this._repeatX = value;
            this._setCellChanged();
        });
        __getset(0, __proto, 'scrollBar', function () {
            return this._scrollBar;
        }, function (value) {
            if (this._scrollBar != value) {
                this._scrollBar = value;
                if (value) {
                    this._isVertical = this._scrollBar.isVertical;
                    this.addChild(this._scrollBar);
                    this._scrollBar.on("change", this, this.onScrollBarChange);
                }
            }
        });
        __getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
            if (value != this._width) {
                Laya.superSet(Box, this, 'width', value);
                this._setCellChanged();
            }
        });
        __getset(0, __proto, 'repeatY', function () {
            return this._repeatY > 0 ? this._repeatY : this._repeatY2 > 0 ? this._repeatY2 : 1;
        }, function (value) {
            this._repeatY = value;
            this._setCellChanged();
        });
        __getset(0, __proto, 'spaceX', function () {
            return this._spaceX;
        }, function (value) {
            this._spaceX = value;
            this._setCellChanged();
        });
        __getset(0, __proto, 'spaceY', function () {
            return this._spaceY;
        }, function (value) {
            this._spaceY = value;
            this._setCellChanged();
        });
        __getset(0, __proto, 'selectedIndex', function () {
            return this._selectedIndex;
        }, function (value) {
            if (this._selectedIndex != value) {
                this._selectedIndex = value;
                this.changeSelectStatus();
                this.event("change");
                this.selectHandler && this.selectHandler.runWith(value);
                this.startIndex = this._startIndex;
            }
        });
        __getset(0, __proto, 'selectedItem', function () {
            return this._selectedIndex != -1 ? this._array[this._selectedIndex] : null;
        }, function (value) {
            this.selectedIndex = this._array.indexOf(value);
        });
        __getset(0, __proto, 'length', function () {
            return this._array ? this._array.length : 0;
        });
        __getset(0, __proto, 'selection', function () {
            return this.getCell(this._selectedIndex);
        }, function (value) {
            this.selectedIndex = this._startIndex + this._cells.indexOf(value);
        });
        __getset(0, __proto, 'startIndex', function () {
            return this._startIndex;
        }, function (value) {
            this._startIndex = value > 0 ? value : 0;
            this.callLater(this.renderItems);
        });
        __getset(0, __proto, 'array', function () {
            return this._array;
        }, function (value) {
            this.runCallLater(this.changeCells);
            this._array = value || [];
            var length = this._array.length;
            this.totalPage = Math.ceil(length / (this.repeatX * this.repeatY));
            this._selectedIndex = this._selectedIndex < length ? this._selectedIndex : length - 1;
            this.startIndex = this._startIndex;
            if (this._scrollBar) {
                this._scrollBar.stopScroll();
                var numX = this._isVertical ? this.repeatX : this.repeatY;
                var numY = this._isVertical ? this.repeatY : this.repeatX;
                var lineCount = Math.ceil(length / numX);
                var total = this._cellOffset > 0 ? this.totalPage + 1 : this.totalPage;
                if (total > 1) {
                    this._scrollBar.scrollSize = this._cellSize;
                    this._scrollBar.thumbPercent = numY / lineCount;
                    this._scrollBar.setScroll(0, (lineCount - numY) * this._cellSize + this._cellOffset + 1, this._scrollBar.value);
                    this._scrollBar.target = this._content;
                }
                else {
                    this._scrollBar.setScroll(0, 0, 0);
                    this._scrollBar.target = this._content;
                }
            }
        });
        __getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
            this._dataSource = value;
            if (((typeof value == 'number') && Math.floor(value) == value) || (typeof value == 'string'))
                this.selectedIndex = parseInt(value);
            else if ((value instanceof Array))
                this.array = value;
            else
                Laya.superSet(Box, this, 'dataSource', value);
        });
        __getset(0, __proto, 'cells', function () {
            this.runCallLater(this.changeCells);
            return this._cells;
        });
        return List;
    })(Box);
    var HScrollBar = (function (_super) {
        function HScrollBar() {
            HScrollBar.__super.call(this);
            ;
        }
        __class(HScrollBar, 'laya.ui.HScrollBar', _super);
        var __proto = HScrollBar.prototype;
        __proto.initialize = function () {
            _super.prototype.initialize.call(this);
            this.slider.isVertical = false;
        };
        return HScrollBar;
    })(ScrollBar);
    var Panel = (function (_super) {
        function Panel() {
            this._content = null;
            this._vScrollBar = null;
            this._hScrollBar = null;
            this._scrollChanged = false;
            Panel.__super.call(this);
            this.width = this.height = 100;
        }
        __class(Panel, 'laya.ui.Panel', _super);
        var __proto = Panel.prototype;
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            laya.ui.Component.prototype.destroy.call(this, destroyChild);
            this._content && this._content.destroy(destroyChild);
            this._vScrollBar && this._vScrollBar.destroy(destroyChild);
            this._hScrollBar && this._hScrollBar.destroy(destroyChild);
            this._vScrollBar = null;
            this._hScrollBar = null;
            this._content = null;
        };
        __proto.destroyChildren = function () {
            this._content.destroyChildren();
        };
        __proto.createChildren = function () {
            laya.display.Node.prototype.addChild.call(this, this._content = new Box());
        };
        __proto.addChild = function (child) {
            child.on("resize", this, this.onResize);
            this._setScrollChanged();
            return this._content.addChild(child);
        };
        __proto.onResize = function () {
            this._setScrollChanged();
        };
        __proto.addChildAt = function (child, index) {
            child.on("resize", this, this.onResize);
            this._setScrollChanged();
            return this._content.addChildAt(child, index);
        };
        __proto.removeChild = function (child) {
            child.off("resize", this, this.onResize);
            this._setScrollChanged();
            return this._content.removeChild(child);
        };
        __proto.removeChildAt = function (index) {
            this.getChildAt(index).off("resize", this, this.onResize);
            this._setScrollChanged();
            return this._content.removeChildAt(index);
        };
        __proto.removeChildren = function (beginIndex, endIndex) {
            (beginIndex === void 0) && (beginIndex = 0);
            (endIndex === void 0) && (endIndex = 0x7fffffff);
            for (var i = this._content.numChildren - 1; i > -1; i--) {
                this._content.removeChildAt(i);
            }
            this._setScrollChanged();
            return this;
        };
        __proto.getChildAt = function (index) {
            return this._content.getChildAt(index);
        };
        __proto.getChildByName = function (name) {
            return this._content.getChildByName(name);
        };
        __proto.getChildIndex = function (child) {
            return this._content.getChildIndex(child);
        };
        __proto.changeScroll = function () {
            this._scrollChanged = false;
            var vscroll = this._vScrollBar;
            var hscroll = this._hScrollBar;
            if (this._width <= 0 || this._height <= 0) {
                if (vscroll) vscroll.visible = false
                if (hscroll) hscroll.visible = false;
                return;
            }
            if (vscroll) vscroll.visible = true
            if (hscroll) hscroll.visible = true;
            var contentW = this.contentWidth || 1;
            var contentH = this.contentHeight || 1;
            var vShow = vscroll && contentH > this._height;
            var hShow = hscroll && contentW > this._width;
            var showWidth = vShow ? this._width - vscroll.width : this._width;
            var showHeight = hShow ? this._height - hscroll.height : this._height;
            if (vscroll) {
                vscroll.x = this._width - vscroll.width;
                vscroll.y = 0;
                vscroll.height = this._height - (hShow ? hscroll.height : 0);
                vscroll.scrollSize = Math.max(this._height * 0.033, 1);
                vscroll.thumbPercent = showHeight / contentH;
                vscroll.setScroll(0, contentH - showHeight, vscroll.value);
            }
            if (hscroll) {
                hscroll.x = 0;
                hscroll.y = this._height - hscroll.height;
                hscroll.width = this._width - (vShow ? vscroll.width : 0);
                hscroll.scrollSize = Math.max(this._width * 0.033, 1);
                hscroll.thumbPercent = showWidth / contentW;
                hscroll.setScroll(0, contentW - showWidth, hscroll.value);
            }
        };
        __proto.changeSize = function () {
            laya.ui.Component.prototype.changeSize.call(this);
            this.setContentSize(this._width, this._height);
        };
        __proto.setContentSize = function (width, height) {
            var content = this._content;
            content.width = width;
            content.height = height;
            content.scrollRect || (content.scrollRect = new Rectangle());
            content.scrollRect.width = width;
            content.scrollRect.height = height;
            var contentW = this.contentWidth || 1;
            var contentH = this.contentHeight || 1;
            var vscroll = this._vScrollBar;
            var hscroll = this._hScrollBar;
            var vShow = vscroll && contentH > this._height;
            var hShow = hscroll && contentW > this._width;
            var showWidth = vShow ? this._width - vscroll.width : this._width;
            var showHeight = hShow ? this._height - hscroll.height : this._height;
            if (vscroll && vShow) {
                if (contentH - showHeight >= vscroll.value) return;
            }
            if (hscroll && hShow) {
                if (contentW - showWidth >= hscroll.value) return;
            }
            content.scrollRect.x = 0;
            content.scrollRect.y = 0;
            content.scrollRect = content.scrollRect;
        };
        __proto.onScrollBarChange = function (scrollBar) {
            var rect = this._content.scrollRect;
            if (rect) {
                var start = Math.round(scrollBar.value);
                scrollBar.isVertical ? rect.y = start : rect.x = start;
                this._content.scrollRect = rect;
            }
        };
        __proto.scrollTo = function (x, y) {
            (x === void 0) && (x = 0);
            (y === void 0) && (y = 0);
            if (this.vScrollBar)
                this.vScrollBar.value = y;
            if (this.hScrollBar)
                this.hScrollBar.value = x;
        };
        __proto.refresh = function () {
            this.changeScroll();
        };
        __proto.onScrollStart = function () {
            this._$P.cacheAs || (this._$P.cacheAs = Laya.superGet(Box, this, 'cacheAs'));
            Laya.superSet(Box, this, 'cacheAs', "none");
            this._hScrollBar && this._hScrollBar.once("end", this, this.onScrollEnd);
            this._vScrollBar && this._vScrollBar.once("end", this, this.onScrollEnd);
        };
        __proto.onScrollEnd = function () {
            Laya.superSet(Box, this, 'cacheAs', this._$P.cacheAs);
        };
        __proto._setScrollChanged = function () {
            if (!this._scrollChanged) {
                this._scrollChanged = true;
                this.callLater(this.changeScroll);
            }
        };
        __getset(0, __proto, 'numChildren', function () {
            return this._content.numChildren;
        });
        __getset(0, __proto, 'hScrollBarSkin', function () {
            return this._hScrollBar ? this._hScrollBar.skin : null;
        }, function (value) {
            if (this._hScrollBar == null) {
                laya.display.Node.prototype.addChild.call(this, this._hScrollBar = new HScrollBar());
                this._hScrollBar.on("change", this, this.onScrollBarChange, [this._hScrollBar]);
                this._hScrollBar.target = this._content;
                this._setScrollChanged();
            }
            this._hScrollBar.skin = value;
        });
        __getset(0, __proto, 'contentWidth', function () {
            var max = 0;
            for (var i = this._content.numChildren - 1; i > -1; i--) {
                var comp = this._content.getChildAt(i);
                if (!comp.visible) continue;
                max = Math.max(comp.x + comp.width * comp.scaleX, max);
            }
            return max;
        });
        __getset(0, __proto, 'contentHeight', function () {
            var max = 0;
            for (var i = this._content.numChildren - 1; i > -1; i--) {
                var comp = this._content.getChildAt(i);
                if (!comp.visible) continue;
                max = Math.max(comp.y + comp.height * comp.scaleY, max);
            }
            return max;
        });
        __getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
            Laya.superSet(Box, this, 'width', value);
            this._setScrollChanged();
        });
        __getset(0, __proto, 'hScrollBar', function () {
            return this._hScrollBar;
        });
        __getset(0, __proto, 'content', function () {
            return this._content;
        });
        __getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
            Laya.superSet(Box, this, 'height', value);
            this._setScrollChanged();
        });
        __getset(0, __proto, 'vScrollBarSkin', function () {
            return this._vScrollBar ? this._vScrollBar.skin : null;
        }, function (value) {
            if (this._vScrollBar == null) {
                laya.display.Node.prototype.addChild.call(this, this._vScrollBar = new VScrollBar());
                this._vScrollBar.on("change", this, this.onScrollBarChange, [this._vScrollBar]);
                this._vScrollBar.target = this._content;
                this._setScrollChanged();
            }
            this._vScrollBar.skin = value;
        });
        __getset(0, __proto, 'vScrollBar', function () {
            return this._vScrollBar;
        });
        __getset(0, __proto, 'cacheAs', _super.prototype._$get_cacheAs, function (value) {
            Laya.superSet(Box, this, 'cacheAs', value);
            this._$P.cacheAs = null;
            if (value !== "none") {
                this._hScrollBar && this._hScrollBar.on("start", this, this.onScrollStart);
                this._vScrollBar && this._vScrollBar.on("start", this, this.onScrollStart);
            }
            else {
                this._hScrollBar && this._hScrollBar.off("start", this, this.onScrollStart);
                this._vScrollBar && this._vScrollBar.off("start", this, this.onScrollStart);
            }
        });
        return Panel;
    })(Box);
    var UIGroup = (function (_super) {
        function UIGroup(labels, skin) {
            this.selectHandler = null;
            this._items = null;
            this._selectedIndex = -1;
            this._skin = null;
            this._direction = "horizontal";
            this._space = 0;
            this._labels = null;
            this._labelColors = null;
            this._labelFont = null;
            this._labelStrokeColor = null;
            this._strokeColors = null;
            this._labelStroke = NaN;
            this._labelSize = 0;
            this._labelBold = false;
            this._labelPadding = null;
            this._labelAlign = null;
            this._stateNum = 0;
            this._labelChanged = false;
            UIGroup.__super.call(this);
            this.skin = skin;
            this.labels = labels;
        }
        __class(UIGroup, 'laya.ui.UIGroup', _super);
        var __proto = UIGroup.prototype;
        Laya.imps(__proto, { "laya.ui.IItem": true });
        __proto.preinitialize = function () {
            this.mouseEnabled = true;
        };
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            laya.ui.Component.prototype.destroy.call(this, destroyChild);
            this._items && (this._items.length = 0);
            this._items = null;
            this.selectHandler = null;
        };
        __proto.addItem = function (item, autoLayOut) {
            (autoLayOut === void 0) && (autoLayOut = true);
            var display = item;
            var index = this._items.length;
            display.name = "item" + index;
            this.addChild(display);
            this.initItems();
            if (autoLayOut && index > 0) {
                var preItem = this._items[index - 1];
                if (this._direction == "horizontal") {
                    display.x = preItem.x + preItem.width + this._space;
                }
                else {
                    display.y = preItem.y + preItem.height + this._space;
                }
            }
            else {
                if (autoLayOut) {
                    display.x = 0;
                    display.y = 0;
                }
            }
            return index;
        };
        __proto.delItem = function (item, autoLayOut) {
            (autoLayOut === void 0) && (autoLayOut = true);
            var index = this._items.indexOf(item);
            if (index != -1) {
                var display = item;
                this.removeChild(display);
                for (var i = index + 1, n = this._items.length; i < n; i++) {
                    var child = this._items[i];
                    child.name = "item" + (i - 1);
                    if (autoLayOut) {
                        if (this._direction == "horizontal") {
                            child.x -= display.width + this._space;
                        }
                        else {
                            child.y -= display.height + this._space;
                        }
                    }
                }
                this.initItems();
                if (this._selectedIndex > -1) {
                    var newIndex = 0;
                    newIndex = this._selectedIndex < this._items.length ? this._selectedIndex : (this._selectedIndex - 1);
                    this._selectedIndex = -1;
                    this.selectedIndex = newIndex;
                }
            }
        };
        __proto.initItems = function () {
            this._items || (this._items = []);
            this._items.length = 0;
            for (var i = 0; i < 10000; i++) {
                var item = this.getChildByName("item" + i);
                if (item == null)
                    break;
                this._items.push(item);
                item.selected = (i === this._selectedIndex);
                item.clickHandler = Handler.create(this, this.itemClick, [i], false);
            }
        };
        __proto.itemClick = function (index) {
            this.selectedIndex = index;
        };
        __proto.setSelect = function (index, selected) {
            if (this._items && index > -1 && index < this._items.length)
                this._items[index].selected = selected;
        };
        __proto.createItem = function (skin, label) {
            return null;
        };
        __proto.changeLabels = function () {
            this._labelChanged = false;
            if (this._items) {
                var left = 0;
                for (var i = 0, n = this._items.length; i < n; i++) {
                    var btn = this._items[i];
                    this._skin && (btn.skin = this._skin);
                    this._labelColors && (btn.labelColors = this._labelColors);
                    this._labelSize && (btn.labelSize = this._labelSize);
                    this._labelStroke && (btn.labelStroke = this._labelStroke);
                    this._labelStrokeColor && (btn.labelStrokeColor = this._labelStrokeColor);
                    this._strokeColors && (btn.strokeColors = this._strokeColors);
                    this._labelBold && (btn.labelBold = this._labelBold);
                    this._labelPadding && (btn.labelPadding = this._labelPadding);
                    this._labelAlign && (btn.labelAlign = this._labelAlign);
                    this._stateNum && (btn.stateNum = this._stateNum);
                    this._labelFont && (btn.labelFont = this._labelFont);
                    if (this._direction === "horizontal") {
                        btn.y = 0;
                        btn.x = left;
                        left += btn.width + this._space;
                    }
                    else {
                        btn.x = 0;
                        btn.y = left;
                        left += btn.height + this._space;
                    }
                }
            }
            this.changeSize();
        };
        __proto.commitMeasure = function () {
            this.runCallLater(this.changeLabels);
        };
        __proto._setLabelChanged = function () {
            if (!this._labelChanged) {
                this._labelChanged = true;
                this.callLater(this.changeLabels);
            }
        };
        __getset(0, __proto, 'labelStrokeColor', function () {
            return this._labelStrokeColor;
        }, function (value) {
            if (this._labelStrokeColor != value) {
                this._labelStrokeColor = value;
                this._setLabelChanged();
            }
        });
        __getset(0, __proto, 'skin', function () {
            return this._skin;
        }, function (value) {
            if (this._skin != value) {
                this._skin = value;
                this._setLabelChanged();
            }
        });
        __getset(0, __proto, 'selectedIndex', function () {
            return this._selectedIndex;
        }, function (value) {
            if (this._selectedIndex != value) {
                this.setSelect(this._selectedIndex, false);
                this._selectedIndex = value;
                this.setSelect(value, true);
                this.event("change");
                this.selectHandler && this.selectHandler.runWith(this._selectedIndex);
            }
        });
        __getset(0, __proto, 'labels', function () {
            return this._labels;
        }, function (value) {
            if (this._labels != value) {
                this._labels = value;
                this.removeChildren();
                this._setLabelChanged();
                if (this._labels) {
                    var a = this._labels.split(",");
                    for (var i = 0, n = a.length; i < n; i++) {
                        var item = this.createItem(this._skin, a[i]);
                        item.name = "item" + i;
                        this.addChild(item);
                    }
                }
                this.initItems();
            }
        });
        __getset(0, __proto, 'strokeColors', function () {
            return this._strokeColors;
        }, function (value) {
            if (this._strokeColors != value) {
                this._strokeColors = value;
                this._setLabelChanged();
            }
        });
        __getset(0, __proto, 'labelColors', function () {
            return this._labelColors;
        }, function (value) {
            if (this._labelColors != value) {
                this._labelColors = value;
                this._setLabelChanged();
            }
        });
        __getset(0, __proto, 'labelStroke', function () {
            return this._labelStroke;
        }, function (value) {
            if (this._labelStroke != value) {
                this._labelStroke = value;
                this._setLabelChanged();
            }
        });
        __getset(0, __proto, 'labelSize', function () {
            return this._labelSize;
        }, function (value) {
            if (this._labelSize != value) {
                this._labelSize = value;
                this._setLabelChanged();
            }
        });
        __getset(0, __proto, 'stateNum', function () {
            return this._stateNum;
        }, function (value) {
            if (this._stateNum != value) {
                this._stateNum = value;
                this._setLabelChanged();
            }
        });
        __getset(0, __proto, 'labelBold', function () {
            return this._labelBold;
        }, function (value) {
            if (this._labelBold != value) {
                this._labelBold = value;
                this._setLabelChanged();
            }
        });
        __getset(0, __proto, 'labelFont', function () {
            return this._labelFont;
        }, function (value) {
            if (this._labelFont != value) {
                this._labelFont = value;
                this._setLabelChanged();
            }
        });
        __getset(0, __proto, 'labelPadding', function () {
            return this._labelPadding;
        }, function (value) {
            if (this._labelPadding != value) {
                this._labelPadding = value;
                this._setLabelChanged();
            }
        });
        __getset(0, __proto, 'direction', function () {
            return this._direction;
        }, function (value) {
            this._direction = value;
            this._setLabelChanged();
        });
        __getset(0, __proto, 'space', function () {
            return this._space;
        }, function (value) {
            this._space = value;
            this._setLabelChanged();
        });
        __getset(0, __proto, 'items', function () {
            return this._items;
        });
        __getset(0, __proto, 'selection', function () {
            return this._selectedIndex > -1 && this._selectedIndex < this._items.length ? this._items[this._selectedIndex] : null;
        }, function (value) {
            this.selectedIndex = this._items.indexOf(value);
        });
        __getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
            this._dataSource = value;
            if (((typeof value == 'number') && Math.floor(value) == value) || (typeof value == 'string'))
                this.selectedIndex = parseInt(value);
            else if ((value instanceof Array))
                this.labels = (value).join(",");
            else
                Laya.superSet(Box, this, 'dataSource', value);
        });
        return UIGroup;
    })(Box);
    var HSlider = (function (_super) {
        function HSlider(skin) {
            HSlider.__super.call(this, skin);
            this.isVertical = false;
        }
        __class(HSlider, 'laya.ui.HSlider', _super);
        return HSlider;
    })(Slider);
    var Radio = (function (_super) {
        function Radio(skin, label) {
            this._value = null;
            (label === void 0) && (label = "");
            Radio.__super.call(this, skin, label);
        }
        __class(Radio, 'laya.ui.Radio', _super);
        var __proto = Radio.prototype;
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            _super.prototype.destroy.call(this, destroyChild);
            this._value = null;
        };
        __proto.preinitialize = function () {
            laya.ui.Component.prototype.preinitialize.call(this);
            this.toggle = false;
            this._autoSize = false;
        };
        __proto.initialize = function () {
            _super.prototype.initialize.call(this);
            this.createText();
            this._text.align = "left";
            this._text.valign = "top";
            this._text.width = 0;
            this.on("click", this, this.onClick);
        };
        __proto.onClick = function (e) {
            this.selected = true;
        };
        __getset(0, __proto, 'value', function () {
            return this._value != null ? this._value : this.label;
        }, function (obj) {
            this._value = obj;
        });
        return Radio;
    })(Button);
    var Tree = (function (_super) {
        function Tree() {
            this._list = null;
            this._source = null;
            this._renderHandler = null;
            this._spaceLeft = 10;
            this._spaceBottom = 0;
            this._keepStatus = true;
            Tree.__super.call(this);
            this.width = this.height = 200;
        }
        __class(Tree, 'laya.ui.Tree', _super);
        var __proto = Tree.prototype;
        Laya.imps(__proto, { "laya.ui.IRender": true });
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            laya.ui.Component.prototype.destroy.call(this, destroyChild);
            this._list && this._list.destroy(destroyChild);
            this._list = null;
            this._source = null;
            this._renderHandler = null;
        };
        __proto.createChildren = function () {
            this.addChild(this._list = new List());
            this._list.renderHandler = Handler.create(this, this.renderItem, null, false);
            this._list.repeatX = 1;
            this._list.on("change", this, this.onListChange);
        };
        __proto.onListChange = function (e) {
            this.event("change");
        };
        __proto.getArray = function () {
            var arr = [];
            var item;
            for (var $each_item in this._source) {
                item = this._source[$each_item];
                if (this.getParentOpenStatus(item)) {
                    item.x = this._spaceLeft * this.getDepth(item);
                    arr.push(item);
                }
            }
            return arr;
        };
        __proto.getDepth = function (item, num) {
            (num === void 0) && (num = 0);
            if (item.nodeParent == null)
                return num;
            else
                return this.getDepth(item.nodeParent, num + 1);
        };
        __proto.getParentOpenStatus = function (item) {
            var parent = item.nodeParent;
            if (parent == null) {
                return true;
            }
            else {
                if (parent.isOpen) {
                    if (parent.nodeParent != null)
                        return this.getParentOpenStatus(parent);
                    else
                        return true;
                }
                else {
                    return false;
                }
            }
        };
        __proto.renderItem = function (cell, index) {
            var item = cell.dataSource;
            if (item) {
                cell.left = item.x;
                var arrow = cell.getChildByName("arrow");
                if (arrow) {
                    if (item.hasChild) {
                        arrow.visible = true;
                        arrow.index = item.isOpen ? 1 : 0;
                        arrow.tag = index;
                        arrow.off("click", this, this.onArrowClick);
                        arrow.on("click", this, this.onArrowClick);
                    }
                    else {
                        arrow.visible = false;
                    }
                }
                ;
                var folder = cell.getChildByName("folder");
                if (folder) {
                    if (folder.clipY == 2) {
                        folder.index = item.isDirectory ? 0 : 1;
                    }
                    else {
                        folder.index = item.isDirectory ? item.isOpen ? 1 : 0 : 2;
                    }
                }
                this._renderHandler && this._renderHandler.runWith([cell, index]);
            }
        };
        __proto.onArrowClick = function (e) {
            var arrow = e.currentTarget;
            var index = arrow.tag;
            this._list.array[index].isOpen = !this._list.array[index].isOpen;
            this.event("open");
            this._list.array = this.getArray();
        };
        __proto.setItemState = function (index, isOpen) {
            if (!this._list.array[index])
                return;
            this._list.array[index].isOpen = isOpen;
            this._list.array = this.getArray();
        };
        __proto.fresh = function () {
            this._list.array = this.getArray();
            this.repaint();
        };
        __proto.parseXml = function (xml, source, nodeParent, isRoot) {
            var obj;
            var list = xml.childNodes;
            var childCount = list.length;
            if (!isRoot) {
                obj = {};
                var list2 = xml.attributes;
                var attrs;
                for (var $each_attrs in list2) {
                    attrs = list2[$each_attrs];
                    var prop = attrs.nodeName;
                    var value = attrs.nodeValue;
                    obj[prop] = value == "true" ? true : value == "false" ? false : value;
                }
                obj.nodeParent = nodeParent;
                if (childCount > 0)
                    obj.isDirectory = true;
                obj.hasChild = childCount > 0;
                source.push(obj);
            }
            for (var i = 0; i < childCount; i++) {
                var node = list[i];
                this.parseXml(node, source, obj, false);
            }
        };
        __proto.parseOpenStatus = function (oldSource, newSource) {
            for (var i = 0, n = newSource.length; i < n; i++) {
                var newItem = newSource[i];
                if (newItem.isDirectory) {
                    for (var j = 0, m = oldSource.length; j < m; j++) {
                        var oldItem = oldSource[j];
                        if (oldItem.isDirectory && this.isSameParent(oldItem, newItem) && newItem.label == oldItem.label) {
                            if (!newItem.isOpen) newItem.isOpen = oldItem.isOpen;
                            break;
                        }
                    }
                }
            }
        };
        __proto.isSameParent = function (item1, item2) {
            if (item1.nodeParent == null && item2.nodeParent == null)
                return true;
            else if (item1.nodeParent == null || item2.nodeParent == null)
                return false;
            else {
                if (item1.nodeParent.label == item2.nodeParent.label)
                    return this.isSameParent(item1.nodeParent, item2.nodeParent);
                else
                    return false;
            }
        };
        __proto.filter = function (key) {
            if (Boolean(key)) {
                var result = [];
                this.getFilterSource(this._source, result, key);
                this._list.array = result;
            }
            else {
                this._list.array = this.getArray();
            }
        };
        __proto.getFilterSource = function (array, result, key) {
            key = key.toLocaleLowerCase();
            var item;
            for (var $each_item in array) {
                item = array[$each_item];
                if (!item.isDirectory && String(item.label).toLowerCase().indexOf(key) > -1) {
                    item.x = 0;
                    result.push(item);
                }
                if (item.child && item.child.length > 0) {
                    this.getFilterSource(item.child, result, key);
                }
            }
        };
        __getset(0, __proto, 'spaceBottom', function () {
            return this._list.spaceY;
        }, function (value) {
            this._list.spaceY = value;
        });
        __getset(0, __proto, 'keepStatus', function () {
            return this._keepStatus;
        }, function (value) {
            this._keepStatus = value;
        });
        __getset(0, __proto, 'itemRender', function () {
            return this._list.itemRender;
        }, function (value) {
            this._list.itemRender = value;
        });
        __getset(0, __proto, 'array', function () {
            return this._list.array;
        }, function (value) {
            if (this._keepStatus && this._list.array && value) {
                this.parseOpenStatus(this._list.array, value);
            }
            this._source = value;
            this._list.array = this.getArray();
        });
        __getset(0, __proto, 'mouseHandler', function () {
            return this._list.mouseHandler;
        }, function (value) {
            this._list.mouseHandler = value;
        });
        __getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
            this._dataSource = value;
            Laya.superSet(Box, this, 'dataSource', value);
        });
        __getset(0, __proto, 'source', function () {
            return this._source;
        });
        __getset(0, __proto, 'scrollBar', function () {
            return this._list.scrollBar;
        });
        __getset(0, __proto, 'list', function () {
            return this._list;
        });
        __getset(0, __proto, 'scrollBarSkin', function () {
            return this._list.vScrollBarSkin;
        }, function (value) {
            this._list.vScrollBarSkin = value;
        });
        __getset(0, __proto, 'renderHandler', function () {
            return this._renderHandler;
        }, function (value) {
            this._renderHandler = value;
        });
        __getset(0, __proto, 'selectedIndex', function () {
            return this._list.selectedIndex;
        }, function (value) {
            this._list.selectedIndex = value;
        });
        __getset(0, __proto, 'spaceLeft', function () {
            return this._spaceLeft;
        }, function (value) {
            this._spaceLeft = value;
        });
        __getset(0, __proto, 'selectedItem', function () {
            return this._list.selectedItem;
        }, function (value) {
            this._list.selectedItem = value;
        });
        __getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
            Laya.superSet(Box, this, 'width', value);
            this._list.width = value;
        });
        __getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
            Laya.superSet(Box, this, 'height', value);
            this._list.height = value;
        });
        __getset(0, __proto, 'xml', null, function (value) {
            var arr = [];
            this.parseXml(value.childNodes[0], arr, null, true);
            this.array = arr;
        });
        __getset(0, __proto, 'selectedPath', function () {
            if (this._list.selectedItem) {
                return this._list.selectedItem.path;
            }
            return null;
        });
        return Tree;
    })(Box);
    var ViewStack = (function (_super) {
        function ViewStack() {
            this._items = null;
            this._selectedIndex = 0;
            ViewStack.__super.call(this);
            this._setIndexHandler = Handler.create(this, this.setIndex, null, false);
        }
        __class(ViewStack, 'laya.ui.ViewStack', _super);
        var __proto = ViewStack.prototype;
        Laya.imps(__proto, { "laya.ui.IItem": true });
        __proto.setItems = function (views) {
            this.removeChildren();
            var index = 0;
            for (var i = 0, n = views.length; i < n; i++) {
                var item = views[i];
                if (item) {
                    item.name = "item" + index;
                    this.addChild(item);
                    index++;
                }
            }
            this.initItems();
        };
        __proto.addItem = function (view) {
            view.name = "item" + this._items.length;
            this.addChild(view);
            this.initItems();
        };
        __proto.initItems = function () {
            this._items = [];
            for (var i = 0; i < 10000; i++) {
                var item = this.getChildByName("item" + i);
                if (item == null) {
                    break;
                }
                this._items.push(item);
                item.visible = (i == this._selectedIndex);
            }
        };
        __proto.setSelect = function (index, selected) {
            if (this._items && index > -1 && index < this._items.length) {
                this._items[index].visible = selected;
            }
        };
        __proto.setIndex = function (index) {
            this.selectedIndex = index;
        };
        __getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
            this._dataSource = value;
            if (((typeof value == 'number') && Math.floor(value) == value) || (typeof value == 'string')) {
                this.selectedIndex = parseInt(value);
            }
            else {
                for (var prop in this._dataSource) {
                    if (this.hasOwnProperty(prop)) {
                        this[prop] = this._dataSource[prop];
                    }
                }
            }
        });
        __getset(0, __proto, 'selectedIndex', function () {
            return this._selectedIndex;
        }, function (value) {
            if (this._selectedIndex != value) {
                this.setSelect(this._selectedIndex, false);
                this._selectedIndex = value;
                this.setSelect(this._selectedIndex, true);
            }
        });
        __getset(0, __proto, 'selection', function () {
            return this._selectedIndex > -1 && this._selectedIndex < this._items.length ? this._items[this._selectedIndex] : null;
        }, function (value) {
            this.selectedIndex = this._items.indexOf(value);
        });
        __getset(0, __proto, 'items', function () {
            return this._items;
        });
        __getset(0, __proto, 'setIndexHandler', function () {
            return this._setIndexHandler;
        }, function (value) {
            this._setIndexHandler = value;
        });
        return ViewStack;
    })(Box);
    var VScrollBar = (function (_super) {
        function VScrollBar() {
            VScrollBar.__super.call(this);
            ;
        }
        __class(VScrollBar, 'laya.ui.VScrollBar', _super);
        return VScrollBar;
    })(ScrollBar);
    var TextInput = (function (_super) {
        function TextInput(text) {
            this._bg = null;
            this._skin = null;
            TextInput.__super.call(this);
            (text === void 0) && (text = "");
            this.text = text;
            this.skin = this.skin;
        }
        __class(TextInput, 'laya.ui.TextInput', _super);
        var __proto = TextInput.prototype;
        __proto.preinitialize = function () {
            this.mouseEnabled = true;
        };
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            _super.prototype.destroy.call(this, destroyChild);
            this._bg && this._bg.destroy();
            this._bg = null;
        };
        __proto.createChildren = function () {
            this.addChild(this._tf = new Input());
            this._tf.padding = Styles.inputLabelPadding;
            this._tf.on("input", this, this._onInput);
            this._tf.on("enter", this, this._onEnter);
            this._tf.on("blur", this, this._onBlur);
            this._tf.on("focus", this, this._onFocus);
        };
        __proto._onFocus = function () {
            this.event("focus", this);
        };
        __proto._onBlur = function () {
            this.event("blur", this);
        };
        __proto._onInput = function () {
            this.event("input", this);
        };
        __proto._onEnter = function () {
            this.event("enter", this);
        };
        __proto.initialize = function () {
            this.width = 128;
            this.height = 22;
        };
        __proto.select = function () {
            (this._tf).select();
        };
        __proto.setSelection = function (startIndex, endIndex) {
            (this._tf).setSelection(startIndex, endIndex);
        };
        __getset(0, __proto, 'text', _super.prototype._$get_text, function (value) {
            if (this._tf.text != value) {
                value = value + "";
                this._tf.text = value;
                this.event("change");
            }
        });
        __getset(0, __proto, 'bg', function () {
            return this._bg;
        }, function (value) {
            this.graphics = this._bg = value;
        });
        __getset(0, __proto, 'inputElementYAdjuster', function () {
            return (this._tf).inputElementYAdjuster;
        }, function (value) {
            (this._tf).inputElementYAdjuster = value;
        });
        __getset(0, __proto, 'multiline', function () {
            return (this._tf).multiline;
        }, function (value) {
            (this._tf).multiline = value;
        });
        __getset(0, __proto, 'skin', function () {
            return this._skin;
        }, function (value) {
            if (this._skin != value) {
                this._skin = value;
                this._bg || (this.graphics = this._bg = new AutoBitmap());
                this._bg.source = Loader.getRes(this._skin);
                this._width && (this._bg.width = this._width);
                this._height && (this._bg.height = this._height);
            }
        });
        __getset(0, __proto, 'sizeGrid', function () {
            return this._bg && this._bg.sizeGrid ? this._bg.sizeGrid.join(",") : null;
        }, function (value) {
            this._bg || (this.graphics = this._bg = new AutoBitmap());
            this._bg.sizeGrid = UIUtils.fillArray(Styles.defaultSizeGrid, value, Number);
        });
        __getset(0, __proto, 'inputElementXAdjuster', function () {
            return (this._tf).inputElementXAdjuster;
        }, function (value) {
            (this._tf).inputElementXAdjuster = value;
        });
        __getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
            Laya.superSet(Label, this, 'width', value);
            this._bg && (this._bg.width = value);
        });
        __getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
            Laya.superSet(Label, this, 'height', value);
            this._bg && (this._bg.height = value);
        });
        __getset(0, __proto, 'editable', function () {
            return (this._tf).editable;
        }, function (value) {
            (this._tf).editable = value;
        });
        __getset(0, __proto, 'restrict', function () {
            return (this._tf).restrict;
        }, function (pattern) {
            (this._tf).restrict = pattern;
        });
        __getset(0, __proto, 'prompt', function () {
            return (this._tf).prompt;
        }, function (value) {
            (this._tf).prompt = value;
        });
        __getset(0, __proto, 'promptColor', function () {
            return (this._tf).promptColor;
        }, function (value) {
            (this._tf).promptColor = value;
        });
        __getset(0, __proto, 'maxChars', function () {
            return (this._tf).maxChars;
        }, function (value) {
            (this._tf).maxChars = value;
        });
        __getset(0, __proto, 'focus', function () {
            return (this._tf).focus;
        }, function (value) {
            (this._tf).focus = value;
        });
        __getset(0, __proto, 'type', function () {
            return (this._tf).type;
        }, function (value) {
            (this._tf).type = value;
        });
        __getset(0, __proto, 'asPassword', function () {
            return (this._tf).asPassword;
        }, function (value) {
            (this._tf).asPassword = value;
        });
        return TextInput;
    })(Label);
    var VSlider = (function (_super) {
        function VSlider() {
            VSlider.__super.call(this);
            ;
        }
        __class(VSlider, 'laya.ui.VSlider', _super);
        return VSlider;
    })(Slider);
    var Dialog = (function (_super) {
        function Dialog() {
            this.popupCenter = true;
            this.closeHandler = null;
            this.popupEffect = null;
            this.closeEffect = null;
            this.group = null;
            this.isModal = false;
            this._dragArea = null;
            Dialog.__super.call(this);
        }
        __class(Dialog, 'laya.ui.Dialog', _super);
        var __proto = Dialog.prototype;
        __proto.initialize = function () {
            this.popupEffect = Dialog.manager.popupEffectHandler;
            this.closeEffect = Dialog.manager.closeEffectHandler;
            this._dealDragArea();
            this.on("click", this, this._onClick);
        };
        __proto._dealDragArea = function () {
            var dragTarget = this.getChildByName("drag");
            if (dragTarget) {
                this.dragArea = dragTarget.x + "," + dragTarget.y + "," + dragTarget.width + "," + dragTarget.height;
                dragTarget.removeSelf();
            }
        };
        __proto._onClick = function (e) {
            var btn = e.target;
            if (btn) {
                switch (btn.name) {
                    case "close":
                    case "cancel":
                    case "sure":
                    case "no":
                    case "ok":
                    case "yes":
                        this.close(btn.name);
                        break;
                }
            }
        };
        __proto.show = function (closeOther, showEffect) {
            (closeOther === void 0) && (closeOther = false);
            (showEffect === void 0) && (showEffect = true);
            this._open(false, closeOther, showEffect);
        };
        __proto.popup = function (closeOther, showEffect) {
            (closeOther === void 0) && (closeOther = false);
            (showEffect === void 0) && (showEffect = true);
            this._open(true, closeOther, showEffect);
        };
        __proto._open = function (modal, closeOther, showEffect) {
            Dialog.manager.lock(false);
            this.isModal = modal;
            Dialog.manager.open(this, closeOther, showEffect);
        };
        __proto.onOpened = function () { };
        __proto.close = function (type, showEffect) {
            (showEffect === void 0) && (showEffect = true);
            Dialog.manager.close(this, type, showEffect);
        };
        __proto.onClosed = function (type) { };
        __proto._onMouseDown = function (e) {
            var point = this.getMousePoint();
            if (this._dragArea.contains(point.x, point.y))
                this.startDrag();
            else
                this.stopDrag();
        };
        __getset(0, __proto, 'dragArea', function () {
            if (this._dragArea)
                return this._dragArea.toString();
            return null;
        }, function (value) {
            if (value) {
                var a = UIUtils.fillArray([0, 0, 0, 0], value, Number);
                this._dragArea = new Rectangle(a[0], a[1], a[2], a[3]);
                this.on("mousedown", this, this._onMouseDown);
            }
            else {
                this._dragArea = null;
                this.off("mousedown", this, this._onMouseDown);
            }
        });
        __getset(0, __proto, 'isPopup', function () {
            return this.parent != null;
        });
        __getset(0, __proto, 'zOrder', _super.prototype._$get_zOrder, function (value) {
            Laya.superSet(View, this, 'zOrder', value);
            Dialog.manager._checkMask();
        });
        __getset(1, Dialog, 'manager', function () {
            return Dialog._manager = Dialog._manager || new DialogManager();
        }, function (value) {
            Dialog._manager = value;
        });
        Dialog.setLockView = function (view) {
            Dialog.manager.setLockView(view);
        };
        Dialog.lock = function (value) {
            Dialog.manager.lock(value);
        };
        Dialog.closeAll = function () {
            Dialog.manager.closeAll();
        };
        Dialog.getDialogsByGroup = function (group) {
            return Dialog.manager.getDialogsByGroup(group);
        };
        Dialog.closeByGroup = function (group) {
            return Dialog.manager.closeByGroup(group);
        };
        Dialog.CLOSE = "close";
        Dialog.CANCEL = "cancel";
        Dialog.SURE = "sure";
        Dialog.NO = "no";
        Dialog.OK = "ok";
        Dialog.YES = "yes";
        Dialog._manager = null;
        return Dialog;
    })(View);
    var HBox = (function (_super) {
        function HBox() {
            HBox.__super.call(this);
            ;
        }
        __class(HBox, 'laya.ui.HBox', _super);
        var __proto = HBox.prototype;
        __proto.sortItem = function (items) {
            if (items)
                items.sort(function (a, b) { return a.x - b.x; });
        };
        __proto.changeItems = function () {
            this._itemChanged = false;
            var items = [];
            var maxHeight = 0;
            for (var i = 0, n = this.numChildren; i < n; i++) {
                var item = this.getChildAt(i);
                if (item && item.layoutEnabled) {
                    items.push(item);
                    maxHeight = this._height ? this._height : Math.max(maxHeight, item.height * item.scaleY);
                }
            }
            this.sortItem(items);
            var left = 0;
            for (i = 0, n = items.length; i < n; i++) {
                item = items[i];
                item.x = left;
                left += item.width * item.scaleX + this._space;
                if (this._align == "top") {
                    item.y = 0;
                }
                else if (this._align == "middle") {
                    item.y = (maxHeight - item.height * item.scaleY) * 0.5;
                }
                else if (this._align == "bottom") {
                    item.y = maxHeight - item.height * item.scaleY;
                }
            }
            this.changeSize();
        };
        __getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
            if (this._height != value) {
                Laya.superSet(LayoutBox, this, 'height', value);
                this.callLater(this.changeItems);
            }
        });
        HBox.NONE = "none";
        HBox.TOP = "top";
        HBox.MIDDLE = "middle";
        HBox.BOTTOM = "bottom";
        return HBox;
    })(LayoutBox);
    var VBox = (function (_super) {
        function VBox() {
            VBox.__super.call(this);
            ;
        }
        __class(VBox, 'laya.ui.VBox', _super);
        var __proto = VBox.prototype;
        __proto.changeItems = function () {
            this._itemChanged = false;
            var items = [];
            var maxWidth = 0;
            for (var i = 0, n = this.numChildren; i < n; i++) {
                var item = this.getChildAt(i);
                if (item && item.layoutEnabled) {
                    items.push(item);
                    maxWidth = this._width ? this._width : Math.max(maxWidth, item.width * item.scaleX);
                }
            }
            this.sortItem(items);
            var top = 0;
            for (i = 0, n = items.length; i < n; i++) {
                item = items[i];
                item.y = top;
                top += item.height * item.scaleY + this._space;
                if (this._align == "left") {
                    item.x = 0;
                }
                else if (this._align == "center") {
                    item.x = (maxWidth - item.width * item.scaleX) * 0.5;
                }
                else if (this._align == "right") {
                    item.x = maxWidth - item.width * item.scaleX;
                }
            }
            this.changeSize();
        };
        __getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
            if (this._width != value) {
                Laya.superSet(LayoutBox, this, 'width', value);
                this.callLater(this.changeItems);
            }
        });
        VBox.NONE = "none";
        VBox.LEFT = "left";
        VBox.CENTER = "center";
        VBox.RIGHT = "right";
        return VBox;
    })(LayoutBox);
    var RadioGroup = (function (_super) {
        function RadioGroup() {
            RadioGroup.__super.call(this);
            ;
        }
        __class(RadioGroup, 'laya.ui.RadioGroup', _super);
        var __proto = RadioGroup.prototype;
        __proto.createItem = function (skin, label) {
            return new Radio(skin, label);
        };
        return RadioGroup;
    })(UIGroup);
    var Tab = (function (_super) {
        function Tab() {
            Tab.__super.call(this);
            ;
        }
        __class(Tab, 'laya.ui.Tab', _super);
        var __proto = Tab.prototype;
        __proto.createItem = function (skin, label) {
            return new Button(skin, label);
        };
        return Tab;
    })(UIGroup);
    var TextArea = (function (_super) {
        function TextArea(text) {
            this._vScrollBar = null;
            this._hScrollBar = null;
            (text === void 0) && (text = "");
            TextArea.__super.call(this, text);
        }
        __class(TextArea, 'laya.ui.TextArea', _super);
        var __proto = TextArea.prototype;
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            _super.prototype.destroy.call(this, destroyChild);
            this._vScrollBar && this._vScrollBar.destroy();
            this._hScrollBar && this._hScrollBar.destroy();
            this._vScrollBar = null;
            this._hScrollBar = null;
        };
        __proto.initialize = function () {
            this.width = 180;
            this.height = 150;
            this._tf.wordWrap = true;
            this.multiline = true;
        };
        __proto.onVBarChanged = function (e) {
            if (this._tf.scrollY != this._vScrollBar.value) {
                this._tf.scrollY = this._vScrollBar.value;
            }
        };
        __proto.onHBarChanged = function (e) {
            if (this._tf.scrollX != this._hScrollBar.value) {
                this._tf.scrollX = this._hScrollBar.value;
            }
        };
        __proto.changeScroll = function () {
            var vShow = this._vScrollBar && this._tf.maxScrollY > 0;
            var hShow = this._hScrollBar && this._tf.maxScrollX > 0;
            var showWidth = vShow ? this._width - this._vScrollBar.width : this._width;
            var showHeight = hShow ? this._height - this._hScrollBar.height : this._height;
            var padding = this._tf.padding || Styles.labelPadding;
            this._tf.width = showWidth;
            this._tf.height = showHeight;
            if (this._vScrollBar) {
                this._vScrollBar.x = this._width - this._vScrollBar.width - padding[2];
                this._vScrollBar.y = padding[1];
                this._vScrollBar.height = this._height - (hShow ? this._hScrollBar.height : 0) - padding[1] - padding[3];
                this._vScrollBar.scrollSize = 1;
                this._vScrollBar.thumbPercent = showHeight / Math.max(this._tf.textHeight, showHeight);
                this._vScrollBar.setScroll(1, this._tf.maxScrollY, this._tf.scrollY);
                this._vScrollBar.visible = vShow;
            }
            if (this._hScrollBar) {
                this._hScrollBar.x = padding[0];
                this._hScrollBar.y = this._height - this._hScrollBar.height - padding[3];
                this._hScrollBar.width = this._width - (vShow ? this._vScrollBar.width : 0) - padding[0] - padding[2];
                this._hScrollBar.scrollSize = Math.max(showWidth * 0.033, 1);
                this._hScrollBar.thumbPercent = showWidth / Math.max(this._tf.textWidth, showWidth);
                this._hScrollBar.setScroll(0, this.maxScrollX, this.scrollX);
                this._hScrollBar.visible = hShow;
            }
        };
        __proto.scrollTo = function (y) {
            this.commitMeasure();
            this._tf.scrollY = y;
        };
        __getset(0, __proto, 'scrollY', function () {
            return this._tf.scrollY;
        });
        __getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
            Laya.superSet(TextInput, this, 'width', value);
            this.callLater(this.changeScroll);
        });
        __getset(0, __proto, 'hScrollBar', function () {
            return this._hScrollBar;
        });
        __getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
            Laya.superSet(TextInput, this, 'height', value);
            this.callLater(this.changeScroll);
        });
        __getset(0, __proto, 'maxScrollX', function () {
            return this._tf.maxScrollX;
        });
        __getset(0, __proto, 'vScrollBarSkin', function () {
            return this._vScrollBar ? this._vScrollBar.skin : null;
        }, function (value) {
            if (this._vScrollBar == null) {
                this.addChild(this._vScrollBar = new VScrollBar());
                this._vScrollBar.on("change", this, this.onVBarChanged);
                this._vScrollBar.target = this._tf;
                this.callLater(this.changeScroll);
            }
            this._vScrollBar.skin = value;
        });
        __getset(0, __proto, 'hScrollBarSkin', function () {
            return this._hScrollBar ? this._hScrollBar.skin : null;
        }, function (value) {
            if (this._hScrollBar == null) {
                this.addChild(this._hScrollBar = new HScrollBar());
                this._hScrollBar.on("change", this, this.onHBarChanged);
                this._hScrollBar.mouseWheelEnable = false;
                this._hScrollBar.target = this._tf;
                this.callLater(this.changeScroll);
            }
            this._hScrollBar.skin = value;
        });
        __getset(0, __proto, 'vScrollBar', function () {
            return this._vScrollBar;
        });
        __getset(0, __proto, 'maxScrollY', function () {
            return this._tf.maxScrollY;
        });
        __getset(0, __proto, 'scrollX', function () {
            return this._tf.scrollX;
        });
        return TextArea;
    })(TextInput);
    var AsynDialog = (function (_super) {
        function AsynDialog() {
            this._uiView = null;
            this.isCloseOther = false;
            AsynDialog.__super.call(this);
        }
        __class(AsynDialog, 'laya.ui.AsynDialog', _super);
        var __proto = AsynDialog.prototype;
        __proto.createView = function (uiView) {
            this._uiView = uiView;
        };
        __proto._open = function (modal, closeOther, showEffect) {
            this.isModal = modal;
            this.isCloseOther = closeOther;
            Dialog.manager.lock(true);
            if (this._uiView)
                this.onCreated();
            else
                this.onOpen();
        };
        __proto.onCreated = function () {
            this.createUI();
            this.onOpen();
        };
        __proto.createUI = function () {
            laya.ui.View.prototype.createView.call(this, this._uiView);
            this._uiView = null;
            this._dealDragArea();
        };
        __proto.onOpen = function () {
            Dialog.manager.open(this, this.isCloseOther);
            Dialog.manager.lock(false);
        };
        __proto.close = function (type, showEffect) {
            (showEffect === void 0) && (showEffect = true);
            Dialog.manager.close(this);
            this.onClose();
        };
        __proto.onClose = function () { };
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            laya.ui.View.prototype.destroy.call(this, destroyChild);
            this._uiView = null;
            this.onDestroy();
        };
        __proto.onDestroy = function () { };
        return AsynDialog;
    })(Dialog);
    Laya.__init([View]);
})(window, document, Laya);
if (typeof define === 'function' && define.amd) {
    define('laya.core', ['require', "exports"], function (require, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        for (var i in Laya) {
            var o = Laya[i];
            o && o.__isclass && (exports[i] = o);
        }
    });
}
(function (window, document, Laya) {
    var __un = Laya.un, __uns = Laya.uns, __static = Laya.static, __class = Laya.class, __getset = Laya.getset, __newvec = Laya.__newvec;
    var Browser = laya.utils.Browser, Color = laya.utils.Color, ColorFilterAction = laya.filters.ColorFilterAction;
    var ColorFilterActionGL = laya.filters.webgl.ColorFilterActionGL, Filter = laya.filters.Filter, FilterActionGL = laya.filters.webgl.FilterActionGL;
    var Matrix = laya.maths.Matrix, Rectangle = laya.maths.Rectangle, Render = laya.renders.Render, RenderContext = laya.renders.RenderContext;
    var RenderTarget2D = laya.webgl.resource.RenderTarget2D, RunDriver = laya.utils.RunDriver, ShaderDefines2D = laya.webgl.shader.d2.ShaderDefines2D;
    var Sprite = laya.display.Sprite, Texture = laya.resource.Texture, Value2D = laya.webgl.shader.d2.value.Value2D;
    var FilterAction = (function () {
        function FilterAction() {
            this.data = null;
        }
        __class(FilterAction, 'laya.filters.FilterAction');
        var __proto = FilterAction.prototype;
        Laya.imps(__proto, { "laya.filters.IFilterAction": true });
        __proto.apply = function (data) {
            return null;
        };
        return FilterAction;
    })();
    var WebGLFilter = (function () {
        function WebGLFilter() { }
        __class(WebGLFilter, 'laya.filters.WebGLFilter');
        WebGLFilter.enable = function () {
            if (WebGLFilter.isInit)
                return;
            WebGLFilter.isInit = true;
            if (!Render.isWebGL)
                return;
            RunDriver.createFilterAction = function (type) {
                var action;
                switch (type) {
                    case 0x20:
                        action = new ColorFilterActionGL();
                        break;
                    case 0x10:
                        action = new BlurFilterActionGL();
                        break;
                    // case 0x800:
                    //     action = new BlurFilterActionGL2();
                    //     break;
                    case 0x08:
                        action = new GlowFilterActionGL();
                        break;
                }
                return action;
            };
        };
        WebGLFilter.isInit = false;
        WebGLFilter.__init$ = function () {
            BlurFilterActionGL;
            // BlurFilterActionGL2;
            ColorFilterActionGL;
            GlowFilterActionGL;
            Render;
            RunDriver;
            {
                RunDriver.createFilterAction = function (type) {
                    var action;
                    switch (type) {
                        case 0x10:
                            action = new FilterAction();
                            break;
                        // case 0x800:
                        // action = new FilterAction();
                        // break;
                        case 0x08:
                            action = new FilterAction();
                            break;
                        case 0x20:
                            action = new ColorFilterAction();
                            break;
                    }
                    return action;
                };
            }
        };
        return WebGLFilter;
    })();
    var BlurFilter = (function (_super) {
        function BlurFilter(strength) {
            this.strength = NaN;
            this.strength_sig2_2sig2_gauss1 = [];
            BlurFilter.__super.call(this);
            (strength === void 0) && (strength = 4);
            if (Render.isWebGL)
                WebGLFilter.enable();
            this.strength = strength;
            this._action = RunDriver.createFilterAction(0x10);
            this._action.data = this;
        }
        __class(BlurFilter, 'laya.filters.BlurFilter', _super);
        var __proto = BlurFilter.prototype;
        __proto.callNative = function (sp) {
            sp.conchModel && sp.conchModel.blurFilter && sp.conchModel.blurFilter(this.strength);
        };
        __getset(0, __proto, 'action', function () {
            return this._action;
        });
        __getset(0, __proto, 'type', function () {
            return 0x10;
        });
        return BlurFilter;
    })(Filter);
    var GlowFilter = (function (_super) {
        function GlowFilter(color, blur, offX, offY) {
            this._color = null;
            GlowFilter.__super.call(this);
            this._elements = new Float32Array(9);
            (blur === void 0) && (blur = 4);
            (offX === void 0) && (offX = 6);
            (offY === void 0) && (offY = 6);
            if (Render.isWebGL) {
                WebGLFilter.enable();
            }
            this._color = new Color(color);
            this.blur = Math.min(blur, 20);
            this.offX = offX;
            this.offY = offY;
            this._action = RunDriver.createFilterAction(0x08);
            this._action.data = this;
        }
        __class(GlowFilter, 'laya.filters.GlowFilter', _super);
        var __proto = GlowFilter.prototype;
        __proto.getColor = function () {
            return this._color._color;
        };
        __proto.callNative = function (sp) {
            sp.conchModel && sp.conchModel.glowFilter && sp.conchModel.glowFilter(this._color.strColor, this._elements[4], this._elements[5], this._elements[6]);
        };
        __getset(0, __proto, 'type', function () {
            return 0x08;
        });
        __getset(0, __proto, 'action', function () {
            return this._action;
        });
        __getset(0, __proto, 'offY', function () {
            return this._elements[6];
        }, function (value) {
            this._elements[6] = value;
        });
        __getset(0, __proto, 'offX', function () {
            return this._elements[5];
        }, function (value) {
            this._elements[5] = value;
        });
        __getset(0, __proto, 'blur', function () {
            return this._elements[4];
        }, function (value) {
            this._elements[4] = value;
        });
        return GlowFilter;
    })(Filter);
    var BlurFilterActionGL = (function (_super) {
        function BlurFilterActionGL() {
            this.data = null;
            BlurFilterActionGL.__super.call(this);
        }
        __class(BlurFilterActionGL, 'laya.filters.webgl.BlurFilterActionGL', _super);
        var __proto = BlurFilterActionGL.prototype;
        __proto.setValueMix = function (shader) {
            shader.defines.add(this.data.type);
            var o = shader;
        };
        __proto.apply3d = function (scope, sprite, context, x, y) {
            var b = scope.getValue("bounds");
            var shaderValue = Value2D.create(0x01, 0);
            shaderValue.setFilters([this.data]);
            var tMatrix = Matrix.EMPTY;
            tMatrix.identity();
            context.ctx.drawTarget(scope, 0, 0, b.width, b.height, Matrix.EMPTY, "src", shaderValue);
            shaderValue.setFilters(null);
        };
        __proto.setValue = function (shader) {
            shader.strength = this.data.strength;
            var sigma = this.data.strength / 3.0;
            var sigma2 = sigma * sigma;
            this.data.strength_sig2_2sig2_gauss1[0] = this.data.strength;
            this.data.strength_sig2_2sig2_gauss1[1] = sigma2;
            this.data.strength_sig2_2sig2_gauss1[2] = 2.0 * sigma2;
            this.data.strength_sig2_2sig2_gauss1[3] = 1.0 / (2.0 * Math.PI * sigma2);
            shader.strength_sig2_2sig2_gauss1 = this.data.strength_sig2_2sig2_gauss1;
        };
        __getset(0, __proto, 'typeMix', function () { return 0x10; });
        return BlurFilterActionGL;
    })(FilterActionGL);






    var GlowFilterActionGL = (function (_super) {
        function GlowFilterActionGL() {
            this.data = null;
            this._initKey = false;
            this._textureWidth = 0;
            this._textureHeight = 0;
            GlowFilterActionGL.__super.call(this);
        }
        __class(GlowFilterActionGL, 'laya.filters.webgl.GlowFilterActionGL', _super);
        var __proto = GlowFilterActionGL.prototype;
        Laya.imps(__proto, { "laya.filters.IFilterActionGL": true });
        __proto.setValueMix = function (shader) { };
        __proto.apply3d = function (scope, sprite, context, x, y) {
            var b = scope.getValue("bounds");
            scope.addValue("color", this.data.getColor());
            var w = b.width, h = b.height;
            this._textureWidth = w;
            this._textureHeight = h;
            var shaderValue;
            var mat = Matrix.TEMP;
            mat.identity();
            shaderValue = Value2D.create(0x01, 0);
            shaderValue.setFilters([this.data]);
            context.ctx.drawTarget(scope, 0, 0, this._textureWidth, this._textureHeight, mat, "src", shaderValue, null);
            shaderValue = Value2D.create(0x01, 0);
            context.ctx.drawTarget(scope, 0, 0, this._textureWidth, this._textureHeight, mat, "src", shaderValue);
            return null;
        };
        __proto.setSpriteWH = function (sprite) {
            this._textureWidth = sprite.width;
            this._textureHeight = sprite.height;
        };
        __proto.setValue = function (shader) {
            shader.u_offsetX = this.data.offX;
            shader.u_offsetY = -this.data.offY;
            shader.u_strength = 1.0;
            shader.u_blurX = this.data.blur;
            shader.u_blurY = this.data.blur;
            shader.u_textW = this._textureWidth;
            shader.u_textH = this._textureHeight;
            shader.u_color = this.data.getColor();
        };
        __getset(0, __proto, 'typeMix', function () { return 0x08; });
        GlowFilterActionGL.tmpTarget = function (scope, sprite, context, x, y) {
            var b = scope.getValue("bounds");
            var out = scope.getValue("out");
            out.end();
            var tmpTarget = RenderTarget2D.create(b.width, b.height);
            tmpTarget.start();
            var color = scope.getValue("color");
            if (color) {
                tmpTarget.clear(color[0], color[1], color[2], 0);
            }
            scope.addValue("tmpTarget", tmpTarget);
        };
        GlowFilterActionGL.startOut = function (scope, sprite, context, x, y) {
            var tmpTarget = scope.getValue("tmpTarget");
            tmpTarget.end();
            var out = scope.getValue("out");
            out.start();
            var color = scope.getValue("color");
            if (color) {
                out.clear(color[0], color[1], color[2], 0);
            }
        };
        GlowFilterActionGL.recycleTarget = function (scope, sprite, context, x, y) {
            var src = scope.getValue("src");
            var tmpTarget = scope.getValue("tmpTarget");
            tmpTarget.recycle();
        };
        return GlowFilterActionGL;
    })(FilterActionGL);
    Laya.__init([WebGLFilter]);
})(window, document, Laya);
if (typeof define === 'function' && define.amd) {
    define('laya.core', ['require', "exports"], function (require, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        for (var i in Laya) {
            var o = Laya[i];
            o && o.__isclass && (exports[i] = o);
        }
    });
}
(function (window, document, Laya) {
    var __un = Laya.un, __uns = Laya.uns, __static = Laya.static, __class = Laya.class, __getset = Laya.getset, __newvec = Laya.__newvec;
    var Browser = laya.utils.Browser, CSSStyle = laya.display.css.CSSStyle, ClassUtils = laya.utils.ClassUtils;
    var Event = laya.events.Event, HTMLChar = laya.utils.HTMLChar, Loader = laya.net.Loader, Node = laya.display.Node, Rectangle = laya.maths.Rectangle;
    var Render = laya.renders.Render, RenderContext = laya.renders.RenderContext, RenderSprite = laya.renders.RenderSprite;
    var Sprite = laya.display.Sprite, Stat = laya.utils.Stat, Text = laya.display.Text, Texture = laya.resource.Texture;
    var URL = laya.net.URL, Utils = laya.utils.Utils;
    var HTMLParse = (function () {
        function HTMLParse() { }
        __class(HTMLParse, 'laya.html.utils.HTMLParse');
        HTMLParse.parse = function (ower, xmlString, url) {
            xmlString = xmlString.replace(/<br>/g, "<br/>");
            xmlString = "<root>" + xmlString + "</root>";
            xmlString = xmlString.replace(HTMLParse.spacePattern, HTMLParse.char255);
            var xml = Utils.parseXMLFromString(xmlString);
            HTMLParse._parseXML(ower, xml.childNodes[0].childNodes, url);
        };
        HTMLParse._parseXML = function (parent, xml, url, href) {
            var i = 0, n = 0;
            if (xml.join || xml.item) {
                for (i = 0, n = xml.length; i < n; ++i) {
                    HTMLParse._parseXML(parent, xml[i], url, href);
                }
            }
            else {
                var node;
                var nodeName;
                if (xml.nodeType == 3) {
                    var txt;
                    if ((parent instanceof laya.html.dom.HTMLDivElement)) {
                        if (xml.nodeName == null) {
                            xml.nodeName = "#text";
                        }
                        nodeName = xml.nodeName.toLowerCase();
                        txt = xml.textContent.replace(/^\s+|\s+$/g, '');
                        if (txt.length > 0) {
                            node = ClassUtils.getInstance(nodeName);
                            if (node) {
                                parent.addChild(node);
                                ((node).innerTEXT = txt.replace(HTMLParse.char255AndOneSpacePattern, " "));
                            }
                        }
                    }
                    else {
                        txt = xml.textContent.replace(/^\s+|\s+$/g, '');
                        if (txt.length > 0) {
                            ((parent).innerTEXT = txt.replace(HTMLParse.char255AndOneSpacePattern, " "));
                        }
                    }
                    return;
                }
                else {
                    nodeName = xml.nodeName.toLowerCase();
                    if (nodeName == "#comment")
                        return;
                    node = ClassUtils.getInstance(nodeName);
                    if (node) {
                        node = parent.addChild(node);
                        (node).URI = url;
                        (node).href = href;
                        var attributes = xml.attributes;
                        if (attributes && attributes.length > 0) {
                            for (i = 0, n = attributes.length; i < n; ++i) {
                                var attribute = attributes[i];
                                var attrName = attribute.nodeName;
                                var value = attribute.value;
                                node._setAttributes(attrName, value);
                            }
                        }
                        HTMLParse._parseXML(node, xml.childNodes, url, (node).href);
                    }
                    else {
                        HTMLParse._parseXML(parent, xml.childNodes, url, href);
                    }
                }
            }
        };
        HTMLParse.char255 = String.fromCharCode(255);
        HTMLParse.spacePattern = /&nbsp;|&#160;/g;
        HTMLParse.char255AndOneSpacePattern = new RegExp(String.fromCharCode(255) + "|(\\s+)", "g");
        return HTMLParse;
    })();
    var Layout = (function () {
        function Layout() { }
        __class(Layout, 'laya.html.utils.Layout');
        Layout.later = function (element) {
            if (Layout._will == null) {
                Layout._will = [];
                Laya.stage.frameLoop(1, null, function () {
                    if (Layout._will.length < 1)
                        return;
                    for (var i = 0; i < Layout._will.length; i++) {
                        laya.html.utils.Layout.layout(Layout._will[i]);
                    }
                    Layout._will.length = 0;
                });
            }
            Layout._will.push(element);
        };
        Layout.layout = function (element) {
            if (!element || !element._style)
                return null;
            if ((element._style._type & 0x200) === 0)
                return null;
            element.getStyle()._type &= ~0x200;
            var arr = Layout._multiLineLayout(element);
            if (Render.isConchApp && element["the3outCallNative"]) {
                (element).the3outCallNative();
            }
            return arr;
        };
        Layout._multiLineLayout = function (element) {
            if (Text.RightToLeft)
                return Layout._multiLineLayout2(element);
            var elements = new Array;
            element._addChildsToLayout(elements);
            var i = 0, n = elements.length, j = 0;
            var style = element._getCSSStyle();
            var letterSpacing = style.letterSpacing;
            var leading = style.leading;
            var lineHeight = style.lineHeight;
            var widthAuto = style._widthAuto() || !style.wordWrap;
            var width = widthAuto ? 999999 : element.width;
            var height = element.height;
            var maxWidth = 0;
            var exWidth = style.italic ? style.fontSize / 3 : 0;
            var align = style._getAlign();
            var valign = style._getValign();
            var endAdjust = valign !== 0 || align !== 0 || lineHeight != 0;
            var oneLayout;
            var x = 0;
            var y = 0;
            var w = 0;
            var h = 0;
            var tBottom = 0;
            var lines = new Array;
            var curStyle;
            var curPadding;
            var curLine = lines[0] = new LayoutLine();
            var newLine = false, nextNewline = false;
            var htmlWord;
            var sprite;
            curLine.h = 0;
            if (style.italic)
                width -= style.fontSize / 3;
            var tWordWidth = 0;
            var tLineFirstKey = true;
            function addLine() {
                curLine.y = y;
                y += curLine.h + leading;
                if (curLine.h == 0)
                    y += lineHeight;
                curLine.mWidth = tWordWidth;
                tWordWidth = 0;
                curLine = new LayoutLine();
                lines.push(curLine);
                curLine.h = 0;
                x = 0;
                tLineFirstKey = true;
                newLine = false;
            }
            for (i = 0; i < n; i++) {
                oneLayout = elements[i];
                if (oneLayout == null) {
                    if (!tLineFirstKey) {
                        x += Layout.DIV_ELEMENT_PADDING;
                    }
                    curLine.wordStartIndex = curLine.elements.length;
                    continue;
                }
                tLineFirstKey = false;
                if ((oneLayout instanceof laya.html.dom.HTMLBrElement)) {
                    addLine();
                    curLine.y = y;
                    continue;
                }
                else if (oneLayout._isChar()) {
                    htmlWord = oneLayout;
                    if (!htmlWord.isWord) {
                        if (lines.length > 0 && (x + w) > width && curLine.wordStartIndex > 0) {
                            var tLineWord = 0;
                            tLineWord = curLine.elements.length - curLine.wordStartIndex + 1;
                            curLine.elements.length = curLine.wordStartIndex;
                            i -= tLineWord;
                            addLine();
                            continue;
                        }
                        newLine = false;
                        tWordWidth += htmlWord.width;
                    }
                    else {
                        newLine = nextNewline || (htmlWord.char === '\n');
                        curLine.wordStartIndex = curLine.elements.length;
                    }
                    w = htmlWord.width + letterSpacing;
                    h = htmlWord.height;
                    nextNewline = false;
                    newLine = newLine || ((x + w) > width);
                    newLine && addLine();
                    curLine.minTextHeight = Math.min(curLine.minTextHeight, oneLayout.height);
                }
                else {
                    curStyle = oneLayout._getCSSStyle();
                    sprite = oneLayout;
                    curPadding = curStyle.padding;
                    curStyle._getCssFloat() === 0 || (endAdjust = true);
                    newLine = nextNewline || curStyle.lineElement;
                    w = sprite.width * sprite._style._tf.scaleX + curPadding[1] + curPadding[3] + letterSpacing;
                    h = sprite.height * sprite._style._tf.scaleY + curPadding[0] + curPadding[2];
                    nextNewline = curStyle.lineElement;
                    newLine = newLine || ((x + w) > width && curStyle.wordWrap);
                    newLine && addLine();
                }
                curLine.elements.push(oneLayout);
                curLine.h = Math.max(curLine.h, h);
                oneLayout.x = x;
                oneLayout.y = y;
                x += w;
                curLine.w = x - letterSpacing;
                curLine.y = y;
                maxWidth = Math.max(x + exWidth, maxWidth);
            }
            y = curLine.y + curLine.h;
            if (endAdjust) {
                var tY = 0;
                var tWidth = width;
                if (widthAuto && element.width > 0) {
                    tWidth = element.width;
                }
                for (i = 0, n = lines.length; i < n; i++) {
                    lines[i].updatePos(0, tWidth, i, tY, align, valign, lineHeight);
                    tY += Math.max(lineHeight, lines[i].h + leading);
                }
                y = tY;
            }
            widthAuto && (element.width = maxWidth);
            (y > element.height) && (element.height = y);
            return [maxWidth, y];
        };
        Layout._multiLineLayout2 = function (element) {
            var elements = new Array;
            element._addChildsToLayout(elements);
            var i = 0, n = elements.length, j = 0;
            var style = element._getCSSStyle();
            var letterSpacing = style.letterSpacing;
            var leading = style.leading;
            var lineHeight = style.lineHeight;
            var widthAuto = style._widthAuto() || !style.wordWrap;
            var width = widthAuto ? 999999 : element.width;
            var height = element.height;
            var maxWidth = 0;
            var exWidth = style.italic ? style.fontSize / 3 : 0;
            var align = 2 - style._getAlign();
            var valign = style._getValign();
            var endAdjust = valign !== 0 || align !== 0 || lineHeight != 0;
            var oneLayout;
            var x = 0;
            var y = 0;
            var w = 0;
            var h = 0;
            var tBottom = 0;
            var lines = new Array;
            var curStyle;
            var curPadding;
            var curLine = lines[0] = new LayoutLine();
            var newLine = false, nextNewline = false;
            var htmlWord;
            var sprite;
            curLine.h = 0;
            if (style.italic)
                width -= style.fontSize / 3;
            var tWordWidth = 0;
            var tLineFirstKey = true;
            function addLine() {
                curLine.y = y;
                y += curLine.h + leading;
                if (curLine.h == 0)
                    y += lineHeight;
                curLine.mWidth = tWordWidth;
                tWordWidth = 0;
                curLine = new LayoutLine();
                lines.push(curLine);
                curLine.h = 0;
                x = 0;
                tLineFirstKey = true;
                newLine = false;
            }
            for (i = 0; i < n; i++) {
                oneLayout = elements[i];
                if (oneLayout == null) {
                    if (!tLineFirstKey) {
                        x += Layout.DIV_ELEMENT_PADDING;
                    }
                    curLine.wordStartIndex = curLine.elements.length;
                    continue;
                }
                tLineFirstKey = false;
                if ((oneLayout instanceof laya.html.dom.HTMLBrElement)) {
                    addLine();
                    curLine.y = y;
                    continue;
                }
                else if (oneLayout._isChar()) {
                    htmlWord = oneLayout;
                    if (!htmlWord.isWord) {
                        if (lines.length > 0 && (x + w) > width && curLine.wordStartIndex > 0) {
                            var tLineWord = 0;
                            tLineWord = curLine.elements.length - curLine.wordStartIndex + 1;
                            curLine.elements.length = curLine.wordStartIndex;
                            i -= tLineWord;
                            addLine();
                            continue;
                        }
                        newLine = false;
                        tWordWidth += htmlWord.width;
                    }
                    else {
                        newLine = nextNewline || (htmlWord.char === '\n');
                        curLine.wordStartIndex = curLine.elements.length;
                    }
                    w = htmlWord.width + letterSpacing;
                    h = htmlWord.height;
                    nextNewline = false;
                    newLine = newLine || ((x + w) > width);
                    newLine && addLine();
                    curLine.minTextHeight = Math.min(curLine.minTextHeight, oneLayout.height);
                }
                else {
                    curStyle = oneLayout._getCSSStyle();
                    sprite = oneLayout;
                    curPadding = curStyle.padding;
                    curStyle._getCssFloat() === 0 || (endAdjust = true);
                    newLine = nextNewline || curStyle.lineElement;
                    w = sprite.width * sprite._style._tf.scaleX + curPadding[1] + curPadding[3] + letterSpacing;
                    h = sprite.height * sprite._style._tf.scaleY + curPadding[0] + curPadding[2];
                    nextNewline = curStyle.lineElement;
                    newLine = newLine || ((x + w) > width && curStyle.wordWrap);
                    newLine && addLine();
                }
                curLine.elements.push(oneLayout);
                curLine.h = Math.max(curLine.h, h);
                oneLayout.x = x;
                oneLayout.y = y;
                x += w;
                curLine.w = x - letterSpacing;
                curLine.y = y;
                maxWidth = Math.max(x + exWidth, maxWidth);
            }
            y = curLine.y + curLine.h;
            if (endAdjust) {
                var tY = 0;
                var tWidth = width;
                for (i = 0, n = lines.length; i < n; i++) {
                    lines[i].updatePos(0, tWidth, i, tY, align, valign, lineHeight);
                    tY += Math.max(lineHeight, lines[i].h + leading);
                }
                y = tY;
            }
            widthAuto && (element.width = maxWidth);
            (y > element.height) && (element.height = y);
            for (i = 0, n = lines.length; i < n; i++) {
                lines[i].revertOrder(width);
            }
            return [maxWidth, y];
        };
        Layout._will = null;
        Layout.DIV_ELEMENT_PADDING = 0;
        return Layout;
    })();
    var LayoutLine = (function () {
        function LayoutLine() {
            this.x = 0;
            this.y = 0;
            this.w = 0;
            this.h = 0;
            this.wordStartIndex = 0;
            this.minTextHeight = 99999;
            this.mWidth = 0;
            this.elements = new Array;
        }
        __class(LayoutLine, 'laya.html.utils.LayoutLine');
        var __proto = LayoutLine.prototype;
        __proto.updatePos = function (left, width, lineNum, dy, align, valign, lineHeight) {
            var w = 0;
            var one;
            if (this.elements.length > 0) {
                one = this.elements[this.elements.length - 1];
                w = one.x + one.width - this.elements[0].x;
            }
            ;
            var dx = 0, ddy = NaN;
            align === 1 && (dx = (width - w) / 2);
            align === 2 && (dx = (width - w));
            lineHeight === 0 || valign != 0 || (valign = 1);
            for (var i = 0, n = this.elements.length; i < n; i++) {
                one = this.elements[i];
                var tCSSStyle = one._getCSSStyle();
                dx !== 0 && (one.x += dx);
                switch (tCSSStyle._getValign()) {
                    case 0:
                        one.y = dy;
                        break;
                    case 1:
                        ;
                        var tMinTextHeight = 0;
                        if (this.minTextHeight != 99999) {
                            tMinTextHeight = this.minTextHeight;
                        }
                        ;
                        var tBottomLineY = (tMinTextHeight + lineHeight) / 2;
                        tBottomLineY = Math.max(tBottomLineY, this.h);
                        if ((one instanceof laya.html.dom.HTMLImageElement)) {
                            ddy = dy + tBottomLineY - one.height;
                        }
                        else {
                            ddy = dy + tBottomLineY - one.height;
                        }
                        one.y = ddy;
                        break;
                    case 2:
                        one.y = dy + (lineHeight - one.height);
                        break;
                }
            }
        };
        __proto.revertOrder = function (width) {
            var one;
            if (this.elements.length > 0) {
                var i = 0, len = 0;
                len = this.elements.length;
                for (i = 0; i < len; i++) {
                    one = this.elements[i];
                    one.x = width - one.x - one.width;
                }
            }
        };
        return LayoutLine;
    })();
    var HTMLElement = (function (_super) {
        function HTMLElement() {
            this.URI = null;
            this._href = null;
            HTMLElement.__super.call(this);
            this._text = HTMLElement._EMPTYTEXT;
            this.setStyle(new CSSStyle(this));
            this._getCSSStyle().valign = "middle";
            this.mouseEnabled = true;
        }
        __class(HTMLElement, 'laya.html.dom.HTMLElement', _super);
        var __proto = HTMLElement.prototype;
        __proto.the3outCallNative = function () {
            var n = 0;
            if (this._childs && (n = this._childs.length) > 0) {
                for (var i = 0; i < n; i++) {
                    this._childs[i].the3outCallNative && this._childs[i].the3outCallNative();
                }
            }
            ;
            var word = this._getWords();
            word ? laya.html.dom.HTMLElement.fillWords(this, word, 0, 0, this.style.font, this.style.color, this.style.underLine) : this.graphics.clear();
        };
        __proto.appendChild = function (c) {
            return this.addChild(c);
        };
        __proto._getWords2 = function () {
            var txt = this._text.text;
            if (!txt || txt.length === 0)
                return null;
            var i = 0, n = 0;
            var realWords;
            var drawWords;
            if (!this._text.drawWords) {
                realWords = txt.split(" ");
                n = realWords.length - 1;
                drawWords = [];
                for (i = 0; i < n; i++) {
                    drawWords.push(realWords[i], " ");
                }
                if (n >= 0)
                    drawWords.push(realWords[n]);
                this._text.drawWords = drawWords;
            }
            else {
                drawWords = this._text.drawWords;
            }
            ;
            var words = this._text.words;
            if (words && words.length === drawWords.length)
                return words;
            words === null && (this._text.words = words = []);
            words.length = drawWords.length;
            var size;
            var style = this.style;
            var fontStr = style.font;
            for (i = 0, n = drawWords.length; i < n; i++) {
                size = Utils.measureText(drawWords[i], fontStr);
                var tHTMLChar = words[i] = new HTMLChar(drawWords[i], size.width, size.height || style.fontSize, style);
                if (tHTMLChar.char.length > 1) {
                    tHTMLChar.charNum = tHTMLChar.char;
                }
                if (this.href) {
                    var tSprite = new Sprite();
                    this.addChild(tSprite);
                    tHTMLChar.setSprite(tSprite);
                }
            }
            return words;
        };
        __proto._getWords = function () {
            if (!Text.CharacterCache)
                return this._getWords2();
            var txt = this._text.text;
            if (!txt || txt.length === 0)
                return null;
            var words = this._text.words;
            if (words && words.length === txt.length)
                return words;
            words === null && (this._text.words = words = []);
            words.length = txt.length;
            var size;
            var style = this.style;
            var fontStr = style.font;
            var startX = 0;
            for (var i = 0, n = txt.length; i < n; i++) {
                size = Utils.measureText(txt.charAt(i), fontStr);
                var tHTMLChar = words[i] = new HTMLChar(txt.charAt(i), size.width, size.height || style.fontSize, style);
                if (this.href) {
                    var tSprite = new Sprite();
                    this.addChild(tSprite);
                    tHTMLChar.setSprite(tSprite);
                }
            }
            return words;
        };
        __proto.showLinkSprite = function () {
            var words = this._text.words;
            if (words) {
                var tLinkSpriteList = [];
                var tSprite;
                var tHtmlChar;
                for (var i = 0; i < words.length; i++) {
                    tHtmlChar = words[i];
                    tSprite = new Sprite();
                    tSprite.graphics.drawRect(0, 0, tHtmlChar.width, tHtmlChar.height, "#ff0000");
                    tSprite.width = tHtmlChar.width;
                    tSprite.height = tHtmlChar.height;
                    this.addChild(tSprite);
                    tLinkSpriteList.push(tSprite);
                }
            }
        };
        __proto._layoutLater = function () {
            var style = this.style;
            if ((style._type & 0x200))
                return;
            if (style.widthed(this) && (this._childs.length > 0 || this._getWords() != null) && style.block) {
                Layout.later(this);
                style._type |= 0x200;
            }
            else {
                this.parent && (this.parent)._layoutLater();
            }
        };
        __proto._setAttributes = function (name, value) {
            switch (name) {
                case 'style':
                    this.style.cssText(value);
                    return;
                case 'class':
                    this.className = value;
                    return;
            }
            _super.prototype._setAttributes.call(this, name, value);
        };
        __proto.updateHref = function () {
            if (this._href != null) {
                var words = this._getWords();
                if (words) {
                    var tHTMLChar;
                    var tSprite;
                    for (var i = 0; i < words.length; i++) {
                        tHTMLChar = words[i];
                        tSprite = tHTMLChar.getSprite();
                        if (tSprite) {
                            tSprite.size(tHTMLChar.width, tHTMLChar.height);
                            tSprite.on("click", this, this.onLinkHandler);
                        }
                    }
                }
            }
        };
        __proto.onLinkHandler = function (e) {
            switch (e.type) {
                case "click":
                    ;
                    var target = this;
                    while (target) {
                        target.event("link", [this.href]);
                        target = target.parent;
                    }
                    break;
            }
        };
        __proto.formatURL = function (url) {
            if (!this.URI)
                return url;
            return URL.formatURL(url, this.URI ? this.URI.path : null);
        };
        __getset(0, __proto, 'href', function () {
            return this._href;
        }, function (url) {
            this._href = url;
            if (url != null) {
                this._getCSSStyle().underLine = 1;
                this.updateHref();
            }
        });
        __getset(0, __proto, 'color', null, function (value) {
            this.style.color = value;
        });
        __getset(0, __proto, 'onClick', null, function (value) {
            var fn;
            Laya._runScript("fn=function(event){" + value + ";}");
            this.on("click", this, fn);
        });
        __getset(0, __proto, 'id', null, function (value) {
            HTMLDocument.document.setElementById(value, this);
        });
        __getset(0, __proto, 'innerTEXT', function () {
            return this._text.text;
        }, function (value) {
            this.text = value;
        });
        __getset(0, __proto, 'style', function () {
            return this._style;
        });
        __getset(0, __proto, 'text', function () {
            return this._text.text;
        }, function (value) {
            if (this._text == HTMLElement._EMPTYTEXT) {
                this._text = { text: value, words: null };
            }
            else {
                this._text.text = value;
                this._text.words && (this._text.words.length = 0);
            }
            Render.isConchApp && this.the3outCallNative();
            this._renderType |= 0x800;
            this.repaint();
            this.updateHref();
        });
        __getset(0, __proto, 'parent', _super.prototype._$get_parent, function (value) {
            if ((value instanceof laya.html.dom.HTMLElement)) {
                var p = value;
                this.URI || (this.URI = p.URI);
                this.style.inherit(p.style);
            }
            Laya.superSet(Sprite, this, 'parent', value);
        });
        __getset(0, __proto, 'className', null, function (value) {
            this.style.attrs(HTMLDocument.document.styleSheets['.' + value]);
        });
        HTMLElement.fillWords = function (ele, words, x, y, font, color, underLine) {
            ele.graphics.clear();
            for (var i = 0, n = words.length; i < n; i++) {
                var a = words[i];
                ele.graphics.fillText(a.char, a.x + x, a.y + y, font, color, 'left', underLine);
            }
        };
        HTMLElement._EMPTYTEXT = { text: null, words: null };
        return HTMLElement;
    })(Sprite);
    var HTMLBrElement = (function (_super) {
        function HTMLBrElement() {
            HTMLBrElement.__super.call(this);
            this.style.lineElement = true;
            this.style.block = true;
        }
        __class(HTMLBrElement, 'laya.html.dom.HTMLBrElement', _super);
        return HTMLBrElement;
    })(HTMLElement);
    var HTMLDivElement = (function (_super) {
        function HTMLDivElement() {
            this.contextHeight = NaN;
            this.contextWidth = NaN;
            HTMLDivElement.__super.call(this);
            this.style.block = true;
            this.style.lineElement = true;
            this.style.width = 200;
            this.style.height = 200;
            HTMLStyleElement;
        }
        __class(HTMLDivElement, 'laya.html.dom.HTMLDivElement', _super);
        var __proto = HTMLDivElement.prototype;
        __proto.appendHTML = function (text) {
            HTMLParse.parse(this, text, this.URI);
            this.layout();
        };
        __proto._addChildsToLayout = function (out) {
            var words = this._getWords();
            if (words == null && this._childs.length == 0)
                return false;
            words && words.forEach(function (o) {
                out.push(o);
            });
            var tFirstKey = true;
            for (var i = 0, len = this._childs.length; i < len; i++) {
                var o = this._childs[i];
                if (tFirstKey) {
                    tFirstKey = false;
                }
                else {
                    out.push(null);
                }
                o._addToLayout(out);
            }
            return true;
        };
        __proto._addToLayout = function (out) {
            this.layout();
        };
        __proto.layout = function () {
            if (!this.style)
                return;
            this.style._type |= 0x200;
            var tArray = Layout.layout(this);
            if (tArray) {
                if (!this._$P.mHtmlBounds)
                    this._set$P("mHtmlBounds", new Rectangle());
                var tRectangle = this._$P.mHtmlBounds;
                tRectangle.x = tRectangle.y = 0;
                tRectangle.width = this.contextWidth = tArray[0];
                tRectangle.height = this.contextHeight = tArray[1];
                this.setBounds(tRectangle);
            }
        };
        __getset(0, __proto, 'height', function () {
            if (this._height)
                return this._height;
            return this.contextHeight;
        }, _super.prototype._$set_height);
        __getset(0, __proto, 'innerHTML', null, function (text) {
            this.destroyChildren();
            this.appendHTML(text);
        });
        __getset(0, __proto, 'width', function () {
            if (this._width)
                return this._width;
            return this.contextWidth;
        }, function (value) {
            var changed = false;
            if (value === 0) {
                changed = value != this._width;
            }
            else {
                changed = value != this.width;
            }
            Laya.superSet(HTMLElement, this, 'width', value);
            if (changed)
                this.layout();
        });
        return HTMLDivElement;
    })(HTMLElement);
    var HTMLImageElement = (function (_super) {
        function HTMLImageElement() {
            this._tex = null;
            this._url = null;
            this._renderArgs = [];
            HTMLImageElement.__super.call(this);
            this.style.block = true;
        }
        __class(HTMLImageElement, 'laya.html.dom.HTMLImageElement', _super);
        var __proto = HTMLImageElement.prototype;
        __proto._addToLayout = function (out) {
            !this._style.absolute && out.push(this);
        };
        __proto.render = function (context, x, y) {
            if (!this._tex || !this._tex.loaded || !this._tex.loaded || this._width < 1 || this._height < 1)
                return;
            Stat.spriteCount++;
            this._renderArgs[0] = this._tex;
            this._renderArgs[1] = this.x;
            this._renderArgs[2] = this.y;
            this._renderArgs[3] = this.width || this._tex.width;
            this._renderArgs[4] = this.height || this._tex.height;
            context.ctx.drawTexture2(x, y, this.style.translateX, this.style.translateY, this.transform, this.style.alpha, this.style.blendMode, this._renderArgs);
        };
        __proto.the3outCallNative = function () {
            var n = 0;
            if (this._childs && (n = this._childs.length) > 0) {
                for (var i = 0; i < n; i++) {
                    this._childs[i].the3outCallNative && this._childs[i].the3outCallNative();
                }
            }
        };
        __getset(0, __proto, 'src', null, function (url) {
            var _$this = this;
            url = this.formatURL(url);
            if (this._url == url)
                return;
            this._url = url;
            var tex = this._tex = Loader.getRes(url);
            if (!tex) {
                this._tex = tex = new Texture();
                tex.load(url);
                Loader.cacheRes(url, tex);
            }
            function onloaded() {
                if (_$this.destroyed)
                    return;
                var style = _$this._style;
                var w = style.widthed(_$this) ? -1 : _$this._tex.width;
                var h = style.heighted(_$this) ? -1 : _$this._tex.height;
                if (!style.widthed(_$this) && _$this._width != _$this._tex.width) {
                    _$this.width = _$this._tex.width;
                    _$this.parent && (_$this.parent)._layoutLater();
                }
                if (!style.heighted(_$this) && _$this._height != _$this._tex.height) {
                    _$this.height = _$this._tex.height;
                    _$this.parent && (_$this.parent)._layoutLater();
                }
                if (Render.isConchApp) {
                    _$this._renderArgs[0] = _$this._tex;
                    _$this._renderArgs[1] = _$this.x;
                    _$this._renderArgs[2] = _$this.y;
                    _$this._renderArgs[3] = _$this.width || _$this._tex.width;
                    _$this._renderArgs[4] = _$this.height || _$this._tex.height;
                    _$this.graphics.drawTexture(_$this._tex, 0, 0, _$this._renderArgs[3], _$this._renderArgs[4]);
                }
                _$this.repaint();
                _$this.parentRepaint();
            }
            tex.loaded ? onloaded() : tex.on("loaded", null, onloaded);
        });
        return HTMLImageElement;
    })(HTMLElement);
})(window, document, Laya);
if (typeof define === 'function' && define.amd) {
    define('laya.core', ['require', "exports"], function (require, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        for (var i in Laya) {
            var o = Laya[i];
            o && o.__isclass && (exports[i] = o);
        }
    });
}
(function (window, document, Laya) {
    var __un = Laya.un, __uns = Laya.uns, __static = Laya.static, __class = Laya.class, __getset = Laya.getset, __newvec = Laya.__newvec;
    var DiagonalMovement = (function () {
        function DiagonalMovement() { }
        __class(DiagonalMovement, 'PathFinding.core.DiagonalMovement');
        DiagonalMovement.Always = 1;
        DiagonalMovement.Never = 2;
        DiagonalMovement.IfAtMostOneObstacle = 3;
        DiagonalMovement.OnlyWhenNoObstacles = 4;
        return DiagonalMovement;
    })();
    var Grid = (function () {
        function Grid(width_or_matrix, height, matrix) {
            this.width = 0;
            this.height = 0;
            this.nodes = null;
            var width = 0;
            if ((typeof width_or_matrix == 'number')) {
                width = width_or_matrix;
            }
            else {
                height = width_or_matrix.length;
                width = width_or_matrix[0].length;
                matrix = width_or_matrix;
            }
            this.width = width;
            this.height = height;
            this.nodes = this._buildNodes(width, height, matrix);
        }
        __class(Grid, 'PathFinding.core.Grid');
        var __proto = Grid.prototype;
        __proto._buildNodes = function (width, height, matrix) {
            var i = 0, j = 0, nodes = [];
            for (i = 0; i < height; ++i) {
                nodes[i] = [];
                for (j = 0; j < width; ++j) {
                    nodes[i][j] = new Node$1(j, i);
                }
            }
            if (matrix == null) {
                return nodes;
            }
            if (matrix.length != height || matrix[0].length != width) {
                throw new Error('Matrix size does not fit');
            }
            for (i = 0; i < height; ++i) {
                for (j = 0; j < width; ++j) {
                    if (matrix[i][j]) {
                        nodes[i][j].walkable = false;
                    }
                }
            }
            return nodes;
        };
        __proto.getNodeAt = function (x, y) {
            return this.nodes[y][x];
        };
        __proto.isWalkableAt = function (x, y) {
            return this.isInside(x, y) && this.nodes[y][x].walkable;
        };
        __proto.isInside = function (x, y) {
            return (x >= 0 && x < this.width) && (y >= 0 && y < this.height);
        };
        __proto.setWalkableAt = function (x, y, walkable) {
            this.nodes[y][x].walkable = walkable;
        };
        __proto.getNeighbors = function (node, diagonalMovement) {
            var x = node.x, y = node.y, neighbors = [], s0 = false, d0 = false, s1 = false, d1 = false, s2 = false, d2 = false, s3 = false, d3 = false, nodes = this.nodes;
            if (this.isWalkableAt(x, y - 1)) {
                neighbors.push(nodes[y - 1][x]);
                s0 = true;
            }
            if (this.isWalkableAt(x + 1, y)) {
                neighbors.push(nodes[y][x + 1]);
                s1 = true;
            }
            if (this.isWalkableAt(x, y + 1)) {
                neighbors.push(nodes[y + 1][x]);
                s2 = true;
            }
            if (this.isWalkableAt(x - 1, y)) {
                neighbors.push(nodes[y][x - 1]);
                s3 = true;
            }
            if (diagonalMovement == DiagonalMovement.Never) {
                return neighbors;
            }
            if (diagonalMovement == DiagonalMovement.OnlyWhenNoObstacles) {
                d0 = s3 && s0;
                d1 = s0 && s1;
                d2 = s1 && s2;
                d3 = s2 && s3;
            }
            else if (diagonalMovement == DiagonalMovement.IfAtMostOneObstacle) {
                d0 = s3 || s0;
                d1 = s0 || s1;
                d2 = s1 || s2;
                d3 = s2 || s3;
            }
            else if (diagonalMovement == DiagonalMovement.Always) {
                d0 = true;
                d1 = true;
                d2 = true;
                d3 = true;
            }
            else {
                throw new Error('Incorrect value of diagonalMovement');
            }
            if (d0 && this.isWalkableAt(x - 1, y - 1)) {
                neighbors.push(nodes[y - 1][x - 1]);
            }
            if (d1 && this.isWalkableAt(x + 1, y - 1)) {
                neighbors.push(nodes[y - 1][x + 1]);
            }
            if (d2 && this.isWalkableAt(x + 1, y + 1)) {
                neighbors.push(nodes[y + 1][x + 1]);
            }
            if (d3 && this.isWalkableAt(x - 1, y + 1)) {
                neighbors.push(nodes[y + 1][x - 1]);
            }
            return neighbors;
        };
        __proto.clone = function () {
            var i = 0, j = 0, width = this.width, height = this.height, thisNodes = this.nodes, newGrid = new Grid(width, height), newNodes = [];
            for (i = 0; i < height; ++i) {
                newNodes[i] = [];
                for (j = 0; j < width; ++j) {
                    newNodes[i][j] = new Node$1(j, i, thisNodes[i][j].walkable);
                }
            }
            newGrid.nodes = newNodes;
            return newGrid;
        };
        __proto.reset = function () {
            var _node;
            for (var i = 0; i < this.height; ++i) {
                for (var j = 0; j < this.width; ++j) {
                    _node = this.nodes[i][j];
                    _node.g = 0;
                    _node.f = 0;
                    _node.h = 0;
                    _node.by = 0;
                    _node.parent = null;
                    _node.opened = null;
                    _node.closed = null;
                    _node.tested = null;
                }
            }
        };
        Grid.createGridFromAStarMap = function (texture) {
            var textureWidth = texture.width;
            var textureHeight = texture.height;
            var pixelsInfo = texture.getPixels();
            var aStarArr = [];
            var index = 0;
            for (var w = 0; w < textureWidth; w++) {
                var colaStarArr = aStarArr[w] = [];
                for (var h = 0; h < textureHeight; h++) {
                    var r = pixelsInfo[index++];
                    var g = pixelsInfo[index++];
                    var b = pixelsInfo[index++];
                    var a = pixelsInfo[index++];
                    if (r == 255 && g == 255 && b == 255 && a == 255)
                        colaStarArr[h] = 1;
                    else {
                        colaStarArr[h] = 0;
                    }
                }
            }
            ;
            var gird = new Grid(textureWidth, textureHeight, aStarArr);
            return gird;
        };
        return Grid;
    })();
    var Heuristic = (function () {
        function Heuristic() { }
        __class(Heuristic, 'PathFinding.core.Heuristic');
        Heuristic.manhattan = function (dx, dy) {
            return dx + dy;
        };
        Heuristic.euclidean = function (dx, dy) {
            return Math.sqrt(dx * dx + dy * dy);
        };
        Heuristic.octile = function (dx, dy) {
            var F = Math.SQRT2 - 1;
            return (dx < dy) ? F * dx + dy : F * dy + dx;
        };
        Heuristic.chebyshev = function (dx, dy) {
            return Math.max(dx, dy);
        };
        return Heuristic;
    })();
    var Node$1 = (function () {
        function Node(x, y, walkable) {
            this.x = 0;
            this.y = 0;
            this.g = 0;
            this.f = 0;
            this.h = 0;
            this.by = 0;
            this.parent = null;
            this.opened = null;
            this.closed = null;
            this.tested = null;
            this.retainCount = null;
            this.walkable = false;
            (walkable === void 0) && (walkable = true);
            this.x = x;
            this.y = y;
            this.walkable = walkable;
        }
        __class(Node, 'PathFinding.core.Node', null, 'Node$1');
        return Node;
    })();
    var Util = (function () {
        function Util() { }
        __class(Util, 'PathFinding.core.Util');
        Util.backtrace = function (node) {
            var path = [[node.x, node.y]];
            while (node.parent) {
                node = node.parent;
                path.push([node.x, node.y]);
            }
            return path.reverse();
        };
        Util.biBacktrace = function (nodeA, nodeB) {
            var pathA = Util.backtrace(nodeA), pathB = Util.backtrace(nodeB);
            return pathA.concat(pathB.reverse());
        };
        Util.pathLength = function (path) {
            var i = 0, sum = 0, a = 0, b = 0, dx = 0, dy = 0;
            for (i = 1; i < path.length; ++i) {
                a = path[i - 1];
                b = path[i];
                dx = a[0] - b[0];
                dy = a[1] - b[1];
                sum += Math.sqrt(dx * dx + dy * dy);
            }
            return sum;
        };
        Util.interpolate = function (x0, y0, x1, y1) {
            var abs = Math.abs, line = [], sx = 0, sy = 0, dx = 0, dy = 0, err = 0, e2 = 0;
            dx = abs(x1 - x0);
            dy = abs(y1 - y0);
            sx = (x0 < x1) ? 1 : -1;
            sy = (y0 < y1) ? 1 : -1;
            err = dx - dy;
            while (true) {
                line.push([x0, y0]);
                if (x0 == x1 && y0 == y1) {
                    break;
                }
                e2 = 2 * err;
                if (e2 > -dy) {
                    err = err - dy;
                    x0 = x0 + sx;
                }
                if (e2 < dx) {
                    err = err + dx;
                    y0 = y0 + sy;
                }
            }
            return line;
        };
        Util.expandPath = function (path) {
            var expanded = [], len = path.length, coord0, coord1, interpolated, interpolatedLen = 0, i = 0, j = 0;
            if (len < 2) {
                return expanded;
            }
            for (i = 0; i < len - 1; ++i) {
                coord0 = path[i];
                coord1 = path[i + 1];
                interpolated = Util.interpolate(coord0[0], coord0[1], coord1[0], coord1[1]);
                interpolatedLen = interpolated.length;
                for (j = 0; j < interpolatedLen - 1; ++j) {
                    expanded.push(interpolated[j]);
                }
            }
            expanded.push(path[len - 1]);
            return expanded;
        };
        Util.smoothenPath = function (grid, path) {
            var len = path.length, x0 = path[0][0], y0 = path[0][1], x1 = path[len - 1][0], y1 = path[len - 1][1], sx = 0, sy = 0, ex = 0, ey = 0, newPath, i = 0, j = 0, coord, line, testCoord, blocked = false, lastValidCoord;
            sx = x0;
            sy = y0;
            newPath = [[sx, sy]];
            for (i = 2; i < len; ++i) {
                coord = path[i];
                ex = coord[0];
                ey = coord[1];
                line = Util.interpolate(sx, sy, ex, ey);
                blocked = false;
                for (j = 1; j < line.length; ++j) {
                    testCoord = line[j];
                    if (!grid.isWalkableAt(testCoord[0], testCoord[1])) {
                        blocked = true;
                        break;
                    }
                }
                if (blocked) {
                    lastValidCoord = path[i - 1];
                    newPath.push(lastValidCoord);
                    sx = lastValidCoord[0];
                    sy = lastValidCoord[1];
                }
            }
            newPath.push([x1, y1]);
            return newPath;
        };
        Util.compressPath = function (path) {
            if (path.length < 3) {
                return path;
            }
            ;
            var compressed = [], sx = path[0][0], sy = path[0][1], px = path[1][0], py = path[1][1], dx = px - sx, dy = py - sy, lx = 0, ly = 0, ldx = 0, ldy = 0, sq = NaN, i = 0;
            sq = Math.sqrt(dx * dx + dy * dy);
            dx /= sq;
            dy /= sq;
            compressed.push([sx, sy]);
            for (i = 2; i < path.length; i++) {
                lx = px;
                ly = py;
                ldx = dx;
                ldy = dy;
                px = path[i][0];
                py = path[i][1];
                dx = px - lx;
                dy = py - ly;
                sq = Math.sqrt(dx * dx + dy * dy);
                dx /= sq;
                dy /= sq;
                if (dx !== ldx || dy !== ldy) {
                    compressed.push([lx, ly]);
                }
            }
            compressed.push([px, py]);
            return compressed;
        };
        return Util;
    })();
    var AStarFinder = (function () {
        function AStarFinder(opt) {
            this.allowDiagonal = false;
            this.dontCrossCorners = false;
            this.heuristic = null;
            this.weight = 0;
            this.diagonalMovement = 0;
            opt = opt || {};
            this.allowDiagonal = opt.allowDiagonal;
            this.dontCrossCorners = opt.dontCrossCorners;
            this.heuristic = opt.heuristic || Heuristic.manhattan;
            this.weight = opt.weight || 1;
            this.diagonalMovement = opt.diagonalMovement;
            if (!this.diagonalMovement) {
                if (!this.allowDiagonal) {
                    this.diagonalMovement = DiagonalMovement.Never;
                }
                else {
                    if (this.dontCrossCorners) {
                        this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
                    }
                    else {
                        this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
                    }
                }
            }
            if (this.diagonalMovement === DiagonalMovement.Never) {
                this.heuristic = opt.heuristic || Heuristic.manhattan;
            }
            else {
                this.heuristic = opt.heuristic || Heuristic.octile;
            }
        }
        __class(AStarFinder, 'PathFinding.finders.AStarFinder');
        var __proto = AStarFinder.prototype;
        __proto.findPath = function (startX, startY, endX, endY, grid) {
            var openList = new Heap(function (nodeA, nodeB) {
                return nodeA.f - nodeB.f;
            }), startNode = grid.getNodeAt(startX, startY), endNode = grid.getNodeAt(endX, endY), heuristic = this.heuristic, diagonalMovement = this.diagonalMovement, weight = this.weight, abs = Math.abs, SQRT2 = Math.SQRT2, node, neighbors, neighbor, i = 0, l = 0, x = 0, y = 0, ng = 0;
            startNode.g = 0;
            startNode.f = 0;
            openList.push(startNode);
            startNode.opened = true;
            while (!openList.empty()) {
                node = openList.pop();
                node.closed = true;
                if (node === endNode) {
                    return Util.backtrace(endNode);
                }
                neighbors = grid.getNeighbors(node, diagonalMovement);
                for (i = 0, l = neighbors.length; i < l; ++i) {
                    neighbor = neighbors[i];
                    if (neighbor.closed) {
                        continue;
                    }
                    x = neighbor.x;
                    y = neighbor.y;
                    ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);
                    if (!neighbor.opened || ng < neighbor.g) {
                        neighbor.g = ng;
                        neighbor.h = neighbor.h || weight * heuristic(abs(x - endX), abs(y - endY));
                        neighbor.f = neighbor.g + neighbor.h;
                        neighbor.parent = node;
                        if (!neighbor.opened) {
                            openList.push(neighbor);
                            neighbor.opened = true;
                        }
                        else {
                            openList.updateItem(neighbor);
                        }
                    }
                }
            }
            return [];
        };
        return AStarFinder;
    })();
    var BiAStarFinder = (function () {
        function BiAStarFinder(opt) {
            this.allowDiagonal = false;
            this.dontCrossCorners = false;
            this.diagonalMovement = 0;
            this.heuristic = null;
            this.weight = 0;
            opt = opt || {};
            this.allowDiagonal = opt.allowDiagonal;
            this.dontCrossCorners = opt.dontCrossCorners;
            this.diagonalMovement = opt.diagonalMovement;
            this.heuristic = opt.heuristic || Heuristic.manhattan;
            this.weight = opt.weight || 1;
            if (!this.diagonalMovement) {
                if (!this.allowDiagonal) {
                    this.diagonalMovement = DiagonalMovement.Never;
                }
                else {
                    if (this.dontCrossCorners) {
                        this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
                    }
                    else {
                        this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
                    }
                }
            }
            if (this.diagonalMovement == DiagonalMovement.Never) {
                this.heuristic = opt.heuristic || Heuristic.manhattan;
            }
            else {
                this.heuristic = opt.heuristic || Heuristic.octile;
            }
        }
        __class(BiAStarFinder, 'PathFinding.finders.BiAStarFinder');
        var __proto = BiAStarFinder.prototype;
        __proto.findPath = function (startX, startY, endX, endY, grid) {
            var cmp = function (nodeA, nodeB) {
                return nodeA.f - nodeB.f;
            };
            var startOpenList = new Heap(cmp), endOpenList = new Heap(cmp), startNode = grid.getNodeAt(startX, startY), endNode = grid.getNodeAt(endX, endY), heuristic = this.heuristic, diagonalMovement = this.diagonalMovement, weight = this.weight, abs = Math.abs, SQRT2 = Math.SQRT2, node, neighbors, neighbor, i = 0, l = 0, x = 0, y = 0, ng = 0, BY_START = 1, BY_END = 2;
            startNode.g = 0;
            startNode.f = 0;
            startOpenList.push(startNode);
            startNode.opened = BY_START;
            endNode.g = 0;
            endNode.f = 0;
            endOpenList.push(endNode);
            endNode.opened = BY_END;
            while (!startOpenList.empty() && !endOpenList.empty()) {
                node = startOpenList.pop();
                node.closed = true;
                neighbors = grid.getNeighbors(node, diagonalMovement);
                for (i = 0, l = neighbors.length; i < l; ++i) {
                    neighbor = neighbors[i];
                    if (neighbor.closed) {
                        continue;
                    }
                    if (neighbor.opened === BY_END) {
                        return Util.biBacktrace(node, neighbor);
                    }
                    x = neighbor.x;
                    y = neighbor.y;
                    ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);
                    if (!neighbor.opened || ng < neighbor.g) {
                        neighbor.g = ng;
                        neighbor.h = neighbor.h || weight * heuristic(abs(x - endX), abs(y - endY));
                        neighbor.f = neighbor.g + neighbor.h;
                        neighbor.parent = node;
                        if (!neighbor.opened) {
                            startOpenList.push(neighbor);
                            neighbor.opened = BY_START;
                        }
                        else {
                            startOpenList.updateItem(neighbor);
                        }
                    }
                }
                node = endOpenList.pop();
                node.closed = true;
                neighbors = grid.getNeighbors(node, diagonalMovement);
                for (i = 0, l = neighbors.length; i < l; ++i) {
                    neighbor = neighbors[i];
                    if (neighbor.closed) {
                        continue;
                    }
                    if (neighbor.opened === BY_START) {
                        return Util.biBacktrace(neighbor, node);
                    }
                    x = neighbor.x;
                    y = neighbor.y;
                    ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);
                    if (!neighbor.opened || ng < neighbor.g) {
                        neighbor.g = ng;
                        neighbor.h = neighbor.h || weight * heuristic(abs(x - startX), abs(y - startY));
                        neighbor.f = neighbor.g + neighbor.h;
                        neighbor.parent = node;
                        if (!neighbor.opened) {
                            endOpenList.push(neighbor);
                            neighbor.opened = BY_END;
                        }
                        else {
                            endOpenList.updateItem(neighbor);
                        }
                    }
                }
            }
            return [];
        };
        return BiAStarFinder;
    })();
    var BiBreadthFirstFinder = (function () {
        function BiBreadthFirstFinder(opt) {
            this.allowDiagonal = false;
            this.dontCrossCorners = false;
            this.heuristic = null;
            this.weight = 0;
            this.diagonalMovement = 0;
            opt = opt || {};
            this.allowDiagonal = opt.allowDiagonal;
            this.dontCrossCorners = opt.dontCrossCorners;
            this.diagonalMovement = opt.diagonalMovement;
            if (!this.diagonalMovement) {
                if (!this.allowDiagonal) {
                    this.diagonalMovement = DiagonalMovement.Never;
                }
                else {
                    if (this.dontCrossCorners) {
                        this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
                    }
                    else {
                        this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
                    }
                }
            }
        }
        __class(BiBreadthFirstFinder, 'PathFinding.finders.BiBreadthFirstFinder');
        var __proto = BiBreadthFirstFinder.prototype;
        __proto.findPath = function (startX, startY, endX, endY, grid) {
            var startNode = grid.getNodeAt(startX, startY), endNode = grid.getNodeAt(endX, endY), startOpenList = [], endOpenList = [], neighbors, neighbor, node, diagonalMovement = this.diagonalMovement, BY_START = 0, BY_END = 1, i = 0, l = 0;
            startOpenList.push(startNode);
            startNode.opened = true;
            startNode.by = BY_START;
            endOpenList.push(endNode);
            endNode.opened = true;
            endNode.by = BY_END;
            while (startOpenList.length && endOpenList.length) {
                node = startOpenList.shift();
                node.closed = true;
                neighbors = grid.getNeighbors(node, diagonalMovement);
                for (i = 0, l = neighbors.length; i < l; ++i) {
                    neighbor = neighbors[i];
                    if (neighbor.closed) {
                        continue;
                    }
                    if (neighbor.opened) {
                        if (neighbor.by === BY_END) {
                            return Util.biBacktrace(node, neighbor);
                        }
                        continue;
                    }
                    startOpenList.push(neighbor);
                    neighbor.parent = node;
                    neighbor.opened = true;
                    neighbor.by = BY_START;
                }
                node = endOpenList.shift();
                node.closed = true;
                neighbors = grid.getNeighbors(node, diagonalMovement);
                for (i = 0, l = neighbors.length; i < l; ++i) {
                    neighbor = neighbors[i];
                    if (neighbor.closed) {
                        continue;
                    }
                    if (neighbor.opened) {
                        if (neighbor.by === BY_START) {
                            return Util.biBacktrace(neighbor, node);
                        }
                        continue;
                    }
                    endOpenList.push(neighbor);
                    neighbor.parent = node;
                    neighbor.opened = true;
                    neighbor.by = BY_END;
                }
            }
            return [];
        };
        return BiBreadthFirstFinder;
    })();
    var BreadthFirstFinder = (function () {
        function BreadthFirstFinder(opt) {
            this.allowDiagonal = false;
            this.dontCrossCorners = false;
            this.heuristic = null;
            this.weight = 0;
            this.diagonalMovement = 0;
            opt = opt || {};
            this.allowDiagonal = opt.allowDiagonal;
            this.dontCrossCorners = opt.dontCrossCorners;
            this.diagonalMovement = opt.diagonalMovement;
            if (!this.diagonalMovement) {
                if (!this.allowDiagonal) {
                    this.diagonalMovement = DiagonalMovement.Never;
                }
                else {
                    if (this.dontCrossCorners) {
                        this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
                    }
                    else {
                        this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
                    }
                }
            }
        }
        __class(BreadthFirstFinder, 'PathFinding.finders.BreadthFirstFinder');
        var __proto = BreadthFirstFinder.prototype;
        __proto.findPath = function (startX, startY, endX, endY, grid) {
            var openList = [], diagonalMovement = this.diagonalMovement, startNode = grid.getNodeAt(startX, startY), endNode = grid.getNodeAt(endX, endY), neighbors, neighbor, node, i = 0, l = 0;
            openList.push(startNode);
            startNode.opened = true;
            while (openList.length) {
                node = openList.shift();
                node.closed = true;
                if (node === endNode) {
                    return Util.backtrace(endNode);
                }
                neighbors = grid.getNeighbors(node, diagonalMovement);
                for (i = 0, l = neighbors.length; i < l; ++i) {
                    neighbor = neighbors[i];
                    if (neighbor.closed || neighbor.opened) {
                        continue;
                    }
                    openList.push(neighbor);
                    neighbor.opened = true;
                    neighbor.parent = node;
                }
            }
            return [];
        };
        return BreadthFirstFinder;
    })();
    var IDAStarFinder = (function () {
        function IDAStarFinder(opt) {
            this.allowDiagonal = false;
            this.dontCrossCorners = false;
            this.heuristic = null;
            this.weight = 0;
            this.diagonalMovement = 0;
            this.trackRecursion = false;
            this.timeLimit = NaN;
            opt = opt || {};
            this.allowDiagonal = opt.allowDiagonal;
            this.dontCrossCorners = opt.dontCrossCorners;
            this.diagonalMovement = opt.diagonalMovement;
            this.heuristic = opt.heuristic || Heuristic.manhattan;
            this.weight = opt.weight || 1;
            this.trackRecursion = opt.trackRecursion || false;
            this.timeLimit = opt.timeLimit || Infinity;
            if (!this.diagonalMovement) {
                if (!this.allowDiagonal) {
                    this.diagonalMovement = DiagonalMovement.Never;
                }
                else {
                    if (this.dontCrossCorners) {
                        this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
                    }
                    else {
                        this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
                    }
                }
            }
            if (this.diagonalMovement === DiagonalMovement.Never) {
                this.heuristic = opt.heuristic || Heuristic.manhattan;
            }
            else {
                this.heuristic = opt.heuristic || Heuristic.octile;
            }
        }
        __class(IDAStarFinder, 'PathFinding.finders.IDAStarFinder');
        var __proto = IDAStarFinder.prototype;
        __proto.findPath = function (startX, startY, endX, endY, grid) {
            var _$this = this;
            var nodesVisited = 0;
            var startTime = new Date().getTime();
            var h = function (a, b) {
                return _$this.heuristic(Math.abs(b.x - a.x), Math.abs(b.y - a.y));
            };
            var cost = function (a, b) {
                return (a.x === b.x || a.y === b.y) ? 1 : Math.SQRT2;
            };
            var search = function (node, g, cutoff, route, depth) {
                nodesVisited++;
                if (_$this.timeLimit > 0 && new Date().getTime() - startTime > _$this.timeLimit * 1000) {
                    return Infinity;
                }
                ;
                var f = g + h(node, end) * _$this.weight;
                if (f > cutoff) {
                    return f;
                }
                if (node == end) {
                    route[depth] = [node.x, node.y];
                    return node;
                }
                ;
                var min = 0, t = 0, k = 0, neighbour;
                var neighbours = grid.getNeighbors(node, _$this.diagonalMovement);
                for (k = 0, min = Infinity; neighbour = neighbours[k]; ++k) {
                    if (_$this.trackRecursion) {
                        neighbour.retainCount = neighbour.retainCount + 1 || 1;
                        if (neighbour.tested != true) {
                            neighbour.tested = true;
                        }
                    }
                    t = search(neighbour, g + cost(node, neighbour), cutoff, route, depth + 1);
                    if ((t instanceof PathFinding.core.Node)) {
                        route[depth] = [node.x, node.y];
                        return t;
                    }
                    if (_$this.trackRecursion && (--neighbour.retainCount) === 0) {
                        neighbour.tested = false;
                    }
                    if (t < min) {
                        min = t;
                    }
                }
                return min;
            };
            var start = grid.getNodeAt(startX, startY);
            var end = grid.getNodeAt(endX, endY);
            var cutOff = h(start, end);
            var j = 0, route, t = 0;
            for (j = 0; true; ++j) {
                route = [];
                t = search(start, 0, cutOff, route, 0);
                if (t == Infinity) {
                    route = [];
                    break;
                }
                if ((t instanceof PathFinding.core.Node)) {
                    break;
                }
                cutOff = t;
            }
            return route;
        };
        return IDAStarFinder;
    })();
    var JumpPointFinderBase = (function () {
        function JumpPointFinderBase(opt) {
            this.grid = null;
            this.openList = null;
            this.startNode = null;
            this.endNode = null;
            this.heuristic = null;
            this.trackJumpRecursion = false;
            opt = opt || {};
            this.heuristic = opt.heuristic || Heuristic.manhattan;
            this.trackJumpRecursion = opt.trackJumpRecursion || false;
        }
        __class(JumpPointFinderBase, 'PathFinding.finders.JumpPointFinderBase');
        var __proto = JumpPointFinderBase.prototype;
        __proto.findPath = function (startX, startY, endX, endY, grid) {
            var openList = this.openList = new Heap(function (nodeA, nodeB) {
                return nodeA.f - nodeB.f;
            }), startNode = this.startNode = grid.getNodeAt(startX, startY), endNode = this.endNode = grid.getNodeAt(endX, endY), node;
            this.grid = grid;
            startNode.g = 0;
            startNode.f = 0;
            openList.push(startNode);
            startNode.opened = true;
            while (!openList.empty()) {
                node = openList.pop();
                node.closed = true;
                if (node == endNode) {
                    return Util.expandPath(Util.backtrace(endNode));
                }
                this._identifySuccessors(node);
            }
            return [];
        };
        __proto._identifySuccessors = function (node) {
            var grid = this.grid, heuristic = this.heuristic, openList = this.openList, endX = this.endNode.x, endY = this.endNode.y, neighbors, neighbor, jumpPoint, i = 0, l = 0, x = node.x, y = node.y, jx = 0, jy = 0, dx = 0, dy = 0, d = 0, ng = 0, jumpNode, abs = Math.abs, max = Math.max;
            neighbors = this._findNeighbors(node);
            for (i = 0, l = neighbors.length; i < l; ++i) {
                neighbor = neighbors[i];
                jumpPoint = this._jump(neighbor[0], neighbor[1], x, y);
                if (jumpPoint) {
                    jx = jumpPoint[0];
                    jy = jumpPoint[1];
                    jumpNode = grid.getNodeAt(jx, jy);
                    if (jumpNode.closed) {
                        continue;
                    }
                    d = Heuristic.octile(abs(jx - x), abs(jy - y));
                    ng = node.g + d;
                    if (!jumpNode.opened || ng < jumpNode.g) {
                        jumpNode.g = ng;
                        jumpNode.h = jumpNode.h || heuristic(abs(jx - endX), abs(jy - endY));
                        jumpNode.f = jumpNode.g + jumpNode.h;
                        jumpNode.parent = node;
                        if (!jumpNode.opened) {
                            openList.push(jumpNode);
                            jumpNode.opened = true;
                        }
                        else {
                            openList.updateItem(jumpNode);
                        }
                    }
                }
            }
        };
        __proto._jump = function (x, y, px, py) {
            return [];
        };
        __proto._findNeighbors = function (node) {
            return [];
        };
        return JumpPointFinderBase;
    })();
    var JumpPointFinder = (function () {
        function JumpPointFinder(opt) { }
        __class(JumpPointFinder, 'PathFinding.finders.JumpPointFinder');
        return JumpPointFinder;
    })();
    var TraceFinder = (function () {
        function TraceFinder(opt) {
            this.allowDiagonal = false;
            this.dontCrossCorners = false;
            this.diagonalMovement = 0;
            this.heuristic = null;
            opt = opt || {};
            this.allowDiagonal = opt.allowDiagonal;
            this.dontCrossCorners = opt.dontCrossCorners;
            this.heuristic = opt.heuristic || Heuristic.manhattan;
            this.diagonalMovement = opt.diagonalMovement;
            if (!this.diagonalMovement) {
                if (!this.allowDiagonal) {
                    this.diagonalMovement = DiagonalMovement.Never;
                }
                else {
                    if (this.dontCrossCorners) {
                        this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
                    }
                    else {
                        this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
                    }
                }
            }
            if (this.diagonalMovement == DiagonalMovement.Never) {
                this.heuristic = opt.heuristic || Heuristic.manhattan;
            }
            else {
                this.heuristic = opt.heuristic || Heuristic.octile;
            }
        }
        __class(TraceFinder, 'PathFinding.finders.TraceFinder');
        var __proto = TraceFinder.prototype;
        __proto.findPath = function (startX, startY, endX, endY, grid) {
            var openList = new Heap(function (nodeA, nodeB) {
                return nodeA.f - nodeB.f;
            }), startNode = grid.getNodeAt(startX, startY), endNode = grid.getNodeAt(endX, endY), heuristic = this.heuristic, allowDiagonal = this.allowDiagonal, dontCrossCorners = this.dontCrossCorners, abs = Math.abs, SQRT2 = Math.SQRT2, node, neighbors, neighbor, i = 0, l = 0, x = 0, y = 0, ng = 0;
            startNode.g = 0;
            startNode.f = 0;
            openList.push(startNode);
            startNode.opened = true;
            while (!openList.empty()) {
                node = openList.pop();
                node.closed = true;
                if (node === endNode) {
                    return Util.backtrace(endNode);
                }
                neighbors = grid.getNeighbors(node, this.diagonalMovement);
                for (i = 0, l = neighbors.length; i < l; ++i) {
                    neighbor = neighbors[i];
                    if (neighbor.closed) {
                        continue;
                    }
                    x = neighbor.x;
                    y = neighbor.y;
                    ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);
                    if (!neighbor.opened || ng < neighbor.g) {
                        neighbor.g = ng * l / 9;
                        neighbor.h = neighbor.h || heuristic(abs(x - endX), abs(y - endY));
                        neighbor.f = neighbor.g + neighbor.h;
                        neighbor.parent = node;
                        if (!neighbor.opened) {
                            openList.push(neighbor);
                            neighbor.opened = true;
                        }
                        else {
                            openList.updateItem(neighbor);
                        }
                    }
                }
            }
            return [];
        };
        return TraceFinder;
    })();
    var Heap = (function () {
        function Heap(cmp) {
            this.cmp = null;
            this.nodes = null;
            this.heapFunction = new HeapFunction();
            this.cmp = cmp != null ? cmp : this.heapFunction.defaultCmp;
            this.nodes = [];
        }
        __class(Heap, 'PathFinding.libs.Heap');
        var __proto = Heap.prototype;
        __proto.push = function (x) {
            return this.heapFunction.heappush(this.nodes, x, this.cmp);
        };
        __proto.pop = function () {
            return this.heapFunction.heappop(this.nodes, this.cmp);
        };
        __proto.peek = function () {
            return this.nodes[0];
        };
        __proto.contains = function (x) {
            return this.nodes.indexOf(x) !== -1;
        };
        __proto.replace = function (x) {
            return this.heapFunction.heapreplace(this.nodes, x, this.cmp);
        };
        __proto.pushpop = function (x) {
            return this.heapFunction.heappushpop(this.nodes, x, this.cmp);
        };
        __proto.heapify = function () {
            return this.heapFunction.heapify(this.nodes, this.cmp);
        };
        __proto.updateItem = function (x) {
            return this.heapFunction.updateItem(this.nodes, x, this.cmp);
        };
        __proto.clear = function () {
            return this.nodes = [];
        };
        __proto.empty = function () {
            return this.nodes.length === 0;
        };
        __proto.size = function () {
            return this.nodes.length;
        };
        __proto.clone = function () {
            var heap = new Heap();
            heap.nodes = this.nodes.slice(0);
            return heap;
        };
        __proto.toArray = function () {
            return this.nodes.slice(0);
        };
        return Heap;
    })();
    var HeapFunction = (function () {
        function HeapFunction() {
            this.defaultCmp = function (x, y) {
                if (x < y) {
                    return -1;
                }
                if (x > y) {
                    return 1;
                }
                return 0;
            };
        }
        __class(HeapFunction, 'PathFinding.libs.HeapFunction');
        var __proto = HeapFunction.prototype;
        __proto.insort = function (a, x, lo, hi, cmp) {
            var mid = NaN;
            if (lo == null) {
                lo = 0;
            }
            if (cmp == null) {
                cmp = this.defaultCmp;
            }
            if (lo < 0) {
                throw new Error('lo must be non-negative');
            }
            if (hi == null) {
                hi = a.length;
            }
            while (lo < hi) {
                mid = Math.floor((lo + hi) / 2);
                if (cmp(x, a[mid]) < 0) {
                    hi = mid;
                }
                else {
                    lo = mid + 1;
                }
            }
            return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);
        };
        __proto.heappush = function (array, item, cmp) {
            if (cmp == null) {
                cmp = this.defaultCmp;
            }
            array.push(item);
            return this._siftdown(array, 0, array.length - 1, cmp);
        };
        __proto.heappop = function (array, cmp) {
            var lastelt, returnitem;
            if (cmp == null) {
                cmp = this.defaultCmp;
            }
            lastelt = array.pop();
            if (array.length) {
                returnitem = array[0];
                array[0] = lastelt;
                this._siftup(array, 0, cmp);
            }
            else {
                returnitem = lastelt;
            }
            return returnitem;
        };
        __proto.heapreplace = function (array, item, cmp) {
            var returnitem;
            if (cmp == null) {
                cmp = this.defaultCmp;
            }
            returnitem = array[0];
            array[0] = item;
            this._siftup(array, 0, cmp);
            return returnitem;
        };
        __proto.heappushpop = function (array, item, cmp) {
            var _ref;
            if (cmp == null) {
                cmp = this.defaultCmp;
            }
            if (array.length && cmp(array[0], item) < 0) {
                _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];
                this._siftup(array, 0, cmp);
            }
            return item;
        };
        __proto.heapify = function (array, cmp) {
            var i = 0, _i = 0, _j = 0, _len = 0, _ref, _ref1, _results, _results1;
            if (cmp == null) {
                cmp = this.defaultCmp;
            }
            _ref1 = (function () {
                _results1 = [];
                for (_j = 0, _ref = Math.floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--) {
                    _results1.push(_j);
                }
                return _results1;
            }).apply(this).reverse();
            _results = [];
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                i = _ref1[_i];
                _results.push(this._siftup(array, i, cmp));
            }
            return _results;
        };
        __proto.updateItem = function (array, item, cmp) {
            var pos = 0;
            if (cmp == null) {
                cmp = this.defaultCmp;
            }
            pos = array.indexOf(item);
            if (pos === -1) {
                return null;
            }
            this._siftdown(array, 0, pos, cmp);
            return this._siftup(array, pos, cmp);
        };
        __proto.nlargest = function (array, n, cmp) {
            var elem, result, _i = 0, _len = 0, _ref;
            if (cmp == null) {
                cmp = this.defaultCmp;
            }
            result = array.slice(0, n);
            if (!result.length) {
                return result;
            }
            this.heapify(result, cmp);
            _ref = array.slice(n);
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                elem = _ref[_i];
                this.heappushpop(result, elem, cmp);
            }
            return result.sort(cmp).reverse();
        };
        __proto.nsmallest = function (array, n, cmp) {
            var elem, i, los, result, _i = 0, _j = 0, _len, _ref, _ref1, _results;
            if (cmp == null) {
                cmp = this.defaultCmp;
            }
            if (n * 10 <= array.length) {
                result = array.slice(0, n).sort(cmp);
                if (!result.length) {
                    return result;
                }
                los = result[result.length - 1];
                _ref = array.slice(n);
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    elem = _ref[_i];
                    if (cmp(elem, los) < 0) {
                        this.insort(result, elem, 0, null, cmp);
                        result.pop();
                        los = result[result.length - 1];
                    }
                }
                return result;
            }
            this.heapify(array, cmp);
            _results = [];
            for (i = _j = 0, _ref1 = Math.min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
                _results.push(this.heappop(array, cmp));
            }
            return _results;
        };
        __proto._siftdown = function (array, startpos, pos, cmp) {
            var newitem, parent, parentpos = 0;
            if (cmp == null) {
                cmp = this.defaultCmp;
            }
            newitem = array[pos];
            while (pos > startpos) {
                parentpos = (pos - 1) >> 1;
                parent = array[parentpos];
                if (cmp(newitem, parent) < 0) {
                    array[pos] = parent;
                    pos = parentpos;
                    continue;
                }
                break;
            }
            return array[pos] = newitem;
        };
        __proto._siftup = function (array, pos, cmp) {
            var childpos = 0, endpos = 0, newitem, rightpos = 0, startpos = 0;
            if (cmp == null) {
                cmp = this.defaultCmp;
            }
            endpos = array.length;
            startpos = pos;
            newitem = array[pos];
            childpos = 2 * pos + 1;
            while (childpos < endpos) {
                rightpos = childpos + 1;
                if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {
                    childpos = rightpos;
                }
                array[pos] = array[childpos];
                pos = childpos;
                childpos = 2 * pos + 1;
            }
            array[pos] = newitem;
            return this._siftdown(array, startpos, pos, cmp);
        };
        return HeapFunction;
    })();
    var BestFirstFinder = (function (_super) {
        function BestFirstFinder(opt) {
            BestFirstFinder.__super.call(this, opt);
            var orig = this.heuristic;
            this.heuristic = function (dx, dy) {
                return orig(dx, dy) * 1000000;
            };
        }
        __class(BestFirstFinder, 'PathFinding.finders.BestFirstFinder', _super);
        return BestFirstFinder;
    })(AStarFinder);
    var BiBestFirstFinder = (function (_super) {
        function BiBestFirstFinder(opt) {
            BiBestFirstFinder.__super.call(this, opt);
            var orig = this.heuristic;
            this.heuristic = function (dx, dy) {
                return orig(dx, dy) * 1000000;
            };
        }
        __class(BiBestFirstFinder, 'PathFinding.finders.BiBestFirstFinder', _super);
        return BiBestFirstFinder;
    })(BiAStarFinder);
    var BiDijkstraFinder = (function (_super) {
        function BiDijkstraFinder(opt) {
            BiDijkstraFinder.__super.call(this, opt);
            this.heuristic = function (dx, dy) {
                return 0;
            };
        }
        __class(BiDijkstraFinder, 'PathFinding.finders.BiDijkstraFinder', _super);
        return BiDijkstraFinder;
    })(BiAStarFinder);
    var DijkstraFinder = (function (_super) {
        function DijkstraFinder(opt) {
            DijkstraFinder.__super.call(this, opt);
            this.heuristic = function (dx, dy) {
                return 0;
            };
        }
        __class(DijkstraFinder, 'PathFinding.finders.DijkstraFinder', _super);
        return DijkstraFinder;
    })(AStarFinder);
    var JPFAlwaysMoveDiagonally = (function (_super) {
        function JPFAlwaysMoveDiagonally(opt) {
            JPFAlwaysMoveDiagonally.__super.call(this, opt);
        }
        __class(JPFAlwaysMoveDiagonally, 'PathFinding.finders.JPFAlwaysMoveDiagonally', _super);
        var __proto = JPFAlwaysMoveDiagonally.prototype;
        __proto._jump = function (x, y, px, py) {
            var grid = this.grid, dx = x - px, dy = y - py;
            if (!grid.isWalkableAt(x, y)) {
                return null;
            }
            if (this.trackJumpRecursion == true) {
                grid.getNodeAt(x, y).tested = true;
            }
            if (grid.getNodeAt(x, y) == this.endNode) {
                return [x, y];
            }
            if (dx !== 0 && dy !== 0) {
                if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) || (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {
                    return [x, y];
                }
                if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {
                    return [x, y];
                }
            }
            else {
                if (dx !== 0) {
                    if ((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) || (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {
                        return [x, y];
                    }
                }
                else {
                    if ((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) || (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {
                        return [x, y];
                    }
                }
            }
            return this._jump(x + dx, y + dy, x, y);
        };
        __proto._findNeighbors = function (node) {
            var parent = node.parent, x = node.x, y = node.y, grid = this.grid, px = 0, py = 0, nx = 0, ny = 0, dx = 0, dy = 0, neighbors = [], neighborNodes, neighborNode, i = 0, l = 0;
            if (parent) {
                px = parent.x;
                py = parent.y;
                dx = (x - px) / Math.max(Math.abs(x - px), 1);
                dy = (y - py) / Math.max(Math.abs(y - py), 1);
                if (dx !== 0 && dy !== 0) {
                    if (grid.isWalkableAt(x, y + dy)) {
                        neighbors.push([x, y + dy]);
                    }
                    if (grid.isWalkableAt(x + dx, y)) {
                        neighbors.push([x + dx, y]);
                    }
                    if (grid.isWalkableAt(x + dx, y + dy)) {
                        neighbors.push([x + dx, y + dy]);
                    }
                    if (!grid.isWalkableAt(x - dx, y)) {
                        neighbors.push([x - dx, y + dy]);
                    }
                    if (!grid.isWalkableAt(x, y - dy)) {
                        neighbors.push([x + dx, y - dy]);
                    }
                }
                else {
                    if (dx === 0) {
                        if (grid.isWalkableAt(x, y + dy)) {
                            neighbors.push([x, y + dy]);
                        }
                        if (!grid.isWalkableAt(x + 1, y)) {
                            neighbors.push([x + 1, y + dy]);
                        }
                        if (!grid.isWalkableAt(x - 1, y)) {
                            neighbors.push([x - 1, y + dy]);
                        }
                    }
                    else {
                        if (grid.isWalkableAt(x + dx, y)) {
                            neighbors.push([x + dx, y]);
                        }
                        if (!grid.isWalkableAt(x, y + 1)) {
                            neighbors.push([x + dx, y + 1]);
                        }
                        if (!grid.isWalkableAt(x, y - 1)) {
                            neighbors.push([x + dx, y - 1]);
                        }
                    }
                }
            }
            else {
                neighborNodes = grid.getNeighbors(node, DiagonalMovement.Always);
                for (i = 0, l = neighborNodes.length; i < l; ++i) {
                    neighborNode = neighborNodes[i];
                    neighbors.push([neighborNode.x, neighborNode.y]);
                }
            }
            return neighbors;
        };
        return JPFAlwaysMoveDiagonally;
    })(JumpPointFinderBase);
    var JPFMoveDiagonallyIfAtMostOneObstacle = (function (_super) {
        function JPFMoveDiagonallyIfAtMostOneObstacle(opt) {
            JPFMoveDiagonallyIfAtMostOneObstacle.__super.call(this, opt);
        }
        __class(JPFMoveDiagonallyIfAtMostOneObstacle, 'PathFinding.finders.JPFMoveDiagonallyIfAtMostOneObstacle', _super);
        var __proto = JPFMoveDiagonallyIfAtMostOneObstacle.prototype;
        __proto._jump = function (x, y, px, py) {
            var grid = this.grid, dx = x - px, dy = y - py;
            if (!grid.isWalkableAt(x, y)) {
                return null;
            }
            if (this.trackJumpRecursion === true) {
                grid.getNodeAt(x, y).tested = true;
            }
            if (grid.getNodeAt(x, y) == this.endNode) {
                return [x, y];
            }
            if (dx !== 0 && dy !== 0) {
                if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) || (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {
                    return [x, y];
                }
                if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {
                    return [x, y];
                }
            }
            else {
                if (dx !== 0) {
                    if ((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) || (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {
                        return [x, y];
                    }
                }
                else {
                    if ((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) || (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {
                        return [x, y];
                    }
                }
            }
            if (grid.isWalkableAt(x + dx, y) || grid.isWalkableAt(x, y + dy)) {
                return this._jump(x + dx, y + dy, x, y);
            }
            else {
                return null;
            }
        };
        __proto._findNeighbors = function (node) {
            var parent = node.parent, x = node.x, y = node.y, grid = this.grid, px = 0, py = 0, nx = 0, ny = 0, dx = 0, dy = 0, neighbors = [], neighborNodes, neighborNode, i = 0, l = 0;
            if (parent) {
                px = parent.x;
                py = parent.y;
                dx = (x - px) / Math.max(Math.abs(x - px), 1);
                dy = (y - py) / Math.max(Math.abs(y - py), 1);
                if (dx !== 0 && dy !== 0) {
                    if (grid.isWalkableAt(x, y + dy)) {
                        neighbors.push([x, y + dy]);
                    }
                    if (grid.isWalkableAt(x + dx, y)) {
                        neighbors.push([x + dx, y]);
                    }
                    if (grid.isWalkableAt(x, y + dy) || grid.isWalkableAt(x + dx, y)) {
                        neighbors.push([x + dx, y + dy]);
                    }
                    if (!grid.isWalkableAt(x - dx, y) && grid.isWalkableAt(x, y + dy)) {
                        neighbors.push([x - dx, y + dy]);
                    }
                    if (!grid.isWalkableAt(x, y - dy) && grid.isWalkableAt(x + dx, y)) {
                        neighbors.push([x + dx, y - dy]);
                    }
                }
                else {
                    if (dx === 0) {
                        if (grid.isWalkableAt(x, y + dy)) {
                            neighbors.push([x, y + dy]);
                            if (!grid.isWalkableAt(x + 1, y)) {
                                neighbors.push([x + 1, y + dy]);
                            }
                            if (!grid.isWalkableAt(x - 1, y)) {
                                neighbors.push([x - 1, y + dy]);
                            }
                        }
                    }
                    else {
                        if (grid.isWalkableAt(x + dx, y)) {
                            neighbors.push([x + dx, y]);
                            if (!grid.isWalkableAt(x, y + 1)) {
                                neighbors.push([x + dx, y + 1]);
                            }
                            if (!grid.isWalkableAt(x, y - 1)) {
                                neighbors.push([x + dx, y - 1]);
                            }
                        }
                    }
                }
            }
            else {
                neighborNodes = grid.getNeighbors(node, DiagonalMovement.IfAtMostOneObstacle);
                for (i = 0, l = neighborNodes.length; i < l; ++i) {
                    neighborNode = neighborNodes[i];
                    neighbors.push([neighborNode.x, neighborNode.y]);
                }
            }
            return neighbors;
        };
        return JPFMoveDiagonallyIfAtMostOneObstacle;
    })(JumpPointFinderBase);
    var JPFMoveDiagonallyIfNoObstacles = (function (_super) {
        function JPFMoveDiagonallyIfNoObstacles(opt) {
            JPFMoveDiagonallyIfNoObstacles.__super.call(this, opt);
        }
        __class(JPFMoveDiagonallyIfNoObstacles, 'PathFinding.finders.JPFMoveDiagonallyIfNoObstacles', _super);
        var __proto = JPFMoveDiagonallyIfNoObstacles.prototype;
        __proto._jump = function (x, y, px, py) {
            var grid = this.grid, dx = x - px, dy = y - py;
            if (!grid.isWalkableAt(x, y)) {
                return null;
            }
            if (this.trackJumpRecursion === true) {
                grid.getNodeAt(x, y).tested = true;
            }
            if (grid.getNodeAt(x, y) === this.endNode) {
                return [x, y];
            }
            if (dx !== 0 && dy !== 0) {
                if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {
                    return [x, y];
                }
            }
            else {
                if (dx !== 0) {
                    if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) || (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {
                        return [x, y];
                    }
                }
                else if (dy !== 0) {
                    if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) || (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {
                        return [x, y];
                    }
                }
            }
            if (grid.isWalkableAt(x + dx, y) && grid.isWalkableAt(x, y + dy)) {
                return this._jump(x + dx, y + dy, x, y);
            }
            else {
                return null;
            }
        };
        __proto._findNeighbors = function (node) {
            var parent = node.parent, x = node.x, y = node.y, grid = this.grid, px = 0, py = 0, nx = 0, ny = 0, dx = 0, dy = 0, neighbors = [], neighborNodes, neighborNode, i = 0, l = 0;
            if (parent) {
                px = parent.x;
                py = parent.y;
                dx = (x - px) / Math.max(Math.abs(x - px), 1);
                dy = (y - py) / Math.max(Math.abs(y - py), 1);
                if (dx !== 0 && dy !== 0) {
                    if (grid.isWalkableAt(x, y + dy)) {
                        neighbors.push([x, y + dy]);
                    }
                    if (grid.isWalkableAt(x + dx, y)) {
                        neighbors.push([x + dx, y]);
                    }
                    if (grid.isWalkableAt(x, y + dy) && grid.isWalkableAt(x + dx, y)) {
                        neighbors.push([x + dx, y + dy]);
                    }
                }
                else {
                    var isNextWalkable = false;
                    if (dx !== 0) {
                        isNextWalkable = grid.isWalkableAt(x + dx, y);
                        var isTopWalkable = grid.isWalkableAt(x, y + 1);
                        var isBottomWalkable = grid.isWalkableAt(x, y - 1);
                        if (isNextWalkable) {
                            neighbors.push([x + dx, y]);
                            if (isTopWalkable) {
                                neighbors.push([x + dx, y + 1]);
                            }
                            if (isBottomWalkable) {
                                neighbors.push([x + dx, y - 1]);
                            }
                        }
                        if (isTopWalkable) {
                            neighbors.push([x, y + 1]);
                        }
                        if (isBottomWalkable) {
                            neighbors.push([x, y - 1]);
                        }
                    }
                    else if (dy !== 0) {
                        isNextWalkable = grid.isWalkableAt(x, y + dy);
                        var isRightWalkable = grid.isWalkableAt(x + 1, y);
                        var isLeftWalkable = grid.isWalkableAt(x - 1, y);
                        if (isNextWalkable) {
                            neighbors.push([x, y + dy]);
                            if (isRightWalkable) {
                                neighbors.push([x + 1, y + dy]);
                            }
                            if (isLeftWalkable) {
                                neighbors.push([x - 1, y + dy]);
                            }
                        }
                        if (isRightWalkable) {
                            neighbors.push([x + 1, y]);
                        }
                        if (isLeftWalkable) {
                            neighbors.push([x - 1, y]);
                        }
                    }
                }
            }
            else {
                neighborNodes = grid.getNeighbors(node, DiagonalMovement.OnlyWhenNoObstacles);
                for (i = 0, l = neighborNodes.length; i < l; ++i) {
                    neighborNode = neighborNodes[i];
                    neighbors.push([neighborNode.x, neighborNode.y]);
                }
            }
            return neighbors;
        };
        return JPFMoveDiagonallyIfNoObstacles;
    })(JumpPointFinderBase);
    var JPFNeverMoveDiagonally = (function (_super) {
        function JPFNeverMoveDiagonally(opt) {
            JPFNeverMoveDiagonally.__super.call(this, opt);
        }
        __class(JPFNeverMoveDiagonally, 'PathFinding.finders.JPFNeverMoveDiagonally', _super);
        var __proto = JPFNeverMoveDiagonally.prototype;
        __proto._jump = function (x, y, px, py) {
            var grid = this.grid, dx = x - px, dy = y - py;
            if (!grid.isWalkableAt(x, y)) {
                return null;
            }
            if (this.trackJumpRecursion === true) {
                grid.getNodeAt(x, y).tested = true;
            }
            if (grid.getNodeAt(x, y) == this.endNode) {
                return [x, y];
            }
            if (dx !== 0) {
                if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) || (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {
                    return [x, y];
                }
            }
            else if (dy !== 0) {
                if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) || (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {
                    return [x, y];
                }
                if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {
                    return [x, y];
                }
            }
            else {
                throw new Error("Only horizontal and vertical movements are allowed");
            }
            return this._jump(x + dx, y + dy, x, y);
        };
        __proto._findNeighbors = function (node) {
            var parent = node.parent, x = node.x, y = node.y, grid = this.grid, px = 0, py = 0, nx = 0, ny = 0, dx = 0, dy = 0, neighbors = [], neighborNodes, neighborNode, i = 0, l = 0;
            if (parent) {
                px = parent.x;
                py = parent.y;
                dx = (x - px) / Math.max(Math.abs(x - px), 1);
                dy = (y - py) / Math.max(Math.abs(y - py), 1);
                if (dx !== 0) {
                    if (grid.isWalkableAt(x, y - 1)) {
                        neighbors.push([x, y - 1]);
                    }
                    if (grid.isWalkableAt(x, y + 1)) {
                        neighbors.push([x, y + 1]);
                    }
                    if (grid.isWalkableAt(x + dx, y)) {
                        neighbors.push([x + dx, y]);
                    }
                }
                else if (dy !== 0) {
                    if (grid.isWalkableAt(x - 1, y)) {
                        neighbors.push([x - 1, y]);
                    }
                    if (grid.isWalkableAt(x + 1, y)) {
                        neighbors.push([x + 1, y]);
                    }
                    if (grid.isWalkableAt(x, y + dy)) {
                        neighbors.push([x, y + dy]);
                    }
                }
            }
            else {
                neighborNodes = grid.getNeighbors(node, DiagonalMovement.Never);
                for (i = 0, l = neighborNodes.length; i < l; ++i) {
                    neighborNode = neighborNodes[i];
                    neighbors.push([neighborNode.x, neighborNode.y]);
                }
            }
            return neighbors;
        };
        return JPFNeverMoveDiagonally;
    })(JumpPointFinderBase);
})(window, document, Laya);
if (typeof define === 'function' && define.amd) {
    define('laya.core', ['require', "exports"], function (require, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        for (var i in Laya) {
            var o = Laya[i];
            o && o.__isclass && (exports[i] = o);
        }
    });
}
(function (window, document, Laya) {
    var __un = Laya.un, __uns = Laya.uns, __static = Laya.static, __class = Laya.class, __getset = Laya.getset, __newvec = Laya.__newvec;
    var Bezier = laya.maths.Bezier, Browser = laya.utils.Browser, Byte = laya.utils.Byte, Event = laya.events.Event;
    var EventDispatcher = laya.events.EventDispatcher, Graphics = laya.display.Graphics, HTMLCanvas = laya.resource.HTMLCanvas;
    var Handler = laya.utils.Handler, Loader = laya.net.Loader, MathUtil = laya.maths.MathUtil, Matrix = laya.maths.Matrix;
    var Node = laya.display.Node, Point = laya.maths.Point, Rectangle = laya.maths.Rectangle, Render = laya.renders.Render;
    var RenderContext = laya.renders.RenderContext, Resource = laya.resource.Resource, RunDriver = laya.utils.RunDriver;
    var Sprite = laya.display.Sprite, Stat = laya.utils.Stat, Texture = laya.resource.Texture, URL = laya.net.URL, Utils = laya.utils.Utils;
    var AnimationContent = (function () {
        function AnimationContent() {
            this.nodes = null;
            this.name = null;
            this.playTime = NaN;
            this.bone3DMap = null;
            this.totalKeyframeDatasLength = 0;
        }
        __class(AnimationContent, 'laya.ani.AnimationContent');
        return AnimationContent;
    })();
    var AnimationNodeContent = (function () {
        function AnimationNodeContent() {
            this.name = null;
            this.parentIndex = 0;
            this.parent = null;
            this.keyframeWidth = 0;
            this.lerpType = 0;
            this.interpolationMethod = null;
            this.childs = null;
            this.keyFrame = null;
            this.playTime = NaN;
            this.extenData = null;
            this.dataOffset = 0;
        }
        __class(AnimationNodeContent, 'laya.ani.AnimationNodeContent');
        return AnimationNodeContent;
    })();
    var AnimationParser01 = (function () {
        function AnimationParser01() { }
        __class(AnimationParser01, 'laya.ani.AnimationParser01');
        AnimationParser01.parse = function (templet, reader) {
            var data = reader.__getBuffer();
            var i = 0, j = 0, k = 0, n = 0, l = 0, m = 0, o = 0;
            var aniClassName = reader.readUTFString();
            templet._aniClassName = aniClassName;
            var strList = reader.readUTFString().split("\n");
            var aniCount = reader.getUint8();
            var publicDataPos = reader.getUint32();
            var publicExtDataPos = reader.getUint32();
            var publicData;
            if (publicDataPos > 0)
                publicData = data.slice(publicDataPos, publicExtDataPos);
            var publicRead = new Byte(publicData);
            if (publicExtDataPos > 0)
                templet._publicExtData = data.slice(publicExtDataPos, data.byteLength);
            templet._useParent = !!reader.getUint8();
            templet._anis.length = aniCount;
            for (i = 0; i < aniCount; i++) {
                var ani = templet._anis[i] = new AnimationContent();
                { }
                ;
                ani.nodes = new Array;
                var name = ani.name = strList[reader.getUint16()];
                templet._aniMap[name] = i;
                ani.bone3DMap = {};
                ani.playTime = reader.getFloat32();
                var boneCount = ani.nodes.length = reader.getUint8();
                ani.totalKeyframeDatasLength = 0;
                for (j = 0; j < boneCount; j++) {
                    var node = ani.nodes[j] = new AnimationNodeContent();
                    { }
                    ;
                    node.childs = [];
                    var nameIndex = reader.getInt16();
                    if (nameIndex >= 0) {
                        node.name = strList[nameIndex];
                        ani.bone3DMap[node.name] = j;
                    }
                    node.keyFrame = new Array;
                    node.parentIndex = reader.getInt16();
                    node.parentIndex == -1 ? node.parent = null : node.parent = ani.nodes[node.parentIndex];
                    node.lerpType = reader.getUint8();
                    var keyframeParamsOffset = reader.getUint32();
                    publicRead.pos = keyframeParamsOffset;
                    var keyframeDataCount = node.keyframeWidth = publicRead.getUint16();
                    ani.totalKeyframeDatasLength += keyframeDataCount;
                    if (node.lerpType === 0 || node.lerpType === 1) {
                        node.interpolationMethod = [];
                        node.interpolationMethod.length = keyframeDataCount;
                        for (k = 0; k < keyframeDataCount; k++)
                            node.interpolationMethod[k] = AnimationTemplet.interpolation[publicRead.getUint8()];
                    }
                    if (node.parent != null)
                        node.parent.childs.push(node);
                    var privateDataLen = reader.getUint16();
                    if (privateDataLen > 0) {
                        node.extenData = data.slice(reader.pos, reader.pos + privateDataLen);
                        reader.pos += privateDataLen;
                    }
                    ;
                    var keyframeCount = reader.getUint16();
                    node.keyFrame.length = keyframeCount;
                    var startTime = 0;
                    var keyFrame;
                    for (k = 0, n = keyframeCount; k < n; k++) {
                        keyFrame = node.keyFrame[k] = new KeyFramesContent();
                        { }
                        ;
                        keyFrame.duration = reader.getFloat32();
                        keyFrame.startTime = startTime;
                        if (node.lerpType === 2) {
                            keyFrame.interpolationData = [];
                            var interDataLength = reader.getUint8();
                            var lerpType = 0;
                            lerpType = reader.getFloat32();
                            switch (lerpType) {
                                case 254:
                                    keyFrame.interpolationData.length = keyframeDataCount;
                                    for (o = 0; o < keyframeDataCount; o++)
                                        keyFrame.interpolationData[o] = 0;
                                    break;
                                case 255:
                                    keyFrame.interpolationData.length = keyframeDataCount;
                                    for (o = 0; o < keyframeDataCount; o++)
                                        keyFrame.interpolationData[o] = 5;
                                    break;
                                default:
                                    keyFrame.interpolationData.push(lerpType);
                                    for (m = 1; m < interDataLength; m++) {
                                        keyFrame.interpolationData.push(reader.getFloat32());
                                    }
                            }
                        }
                        keyFrame.data = new Float32Array(keyframeDataCount);
                        for (l = 0; l < keyframeDataCount; l++) {
                            keyFrame.data[l] = reader.getFloat32();
                            if (keyFrame.data[l] > -0.00000001 && keyFrame.data[l] < 0.00000001)
                                keyFrame.data[l] = 0;
                        }
                        startTime += keyFrame.duration;
                    }
                    keyFrame.startTime = ani.playTime;
                    node.playTime = ani.playTime;
                    templet._calculateKeyFrame(node, keyframeCount, keyframeDataCount);
                }
            }
        };
        return AnimationParser01;
    })();
    var AnimationParser02 = (function () {
        function AnimationParser02() { }
        __class(AnimationParser02, 'laya.ani.AnimationParser02');
        AnimationParser02.READ_DATA = function () {
            AnimationParser02._DATA.offset = AnimationParser02._reader.getUint32();
            AnimationParser02._DATA.size = AnimationParser02._reader.getUint32();
        };
        AnimationParser02.READ_BLOCK = function () {
            var count = AnimationParser02._BLOCK.count = AnimationParser02._reader.getUint16();
            var blockStarts = AnimationParser02._BLOCK.blockStarts = [];
            var blockLengths = AnimationParser02._BLOCK.blockLengths = [];
            for (var i = 0; i < count; i++) {
                blockStarts.push(AnimationParser02._reader.getUint32());
                blockLengths.push(AnimationParser02._reader.getUint32());
            }
        };
        AnimationParser02.READ_STRINGS = function () {
            var offset = AnimationParser02._reader.getUint32();
            var count = AnimationParser02._reader.getUint16();
            var prePos = AnimationParser02._reader.pos;
            AnimationParser02._reader.pos = offset + AnimationParser02._DATA.offset;
            for (var i = 0; i < count; i++)
                AnimationParser02._strings[i] = AnimationParser02._reader.readUTFString();
            AnimationParser02._reader.pos = prePos;
        };
        AnimationParser02.parse = function (templet, reader) {
            AnimationParser02._templet = templet;
            AnimationParser02._reader = reader;
            var arrayBuffer = reader.__getBuffer();
            AnimationParser02.READ_DATA();
            AnimationParser02.READ_BLOCK();
            AnimationParser02.READ_STRINGS();
            for (var i = 0, n = AnimationParser02._BLOCK.count; i < n; i++) {
                var index = reader.getUint16();
                var blockName = AnimationParser02._strings[index];
                var fn = AnimationParser02["READ_" + blockName];
                if (fn == null)
                    throw new Error("model file err,no this function:" + index + " " + blockName);
                else
                    fn.call();
            }
        };
        AnimationParser02.READ_ANIMATIONS = function () {
            var reader = AnimationParser02._reader;
            var arrayBuffer = reader.__getBuffer();
            var i = 0, j = 0, k = 0, n = 0, l = 0;
            var keyframeWidth = reader.getUint16();
            var interpolationMethod = [];
            interpolationMethod.length = keyframeWidth;
            for (i = 0; i < keyframeWidth; i++)
                interpolationMethod[i] = AnimationTemplet.interpolation[reader.getByte()];
            var aniCount = reader.getUint8();
            AnimationParser02._templet._anis.length = aniCount;
            for (i = 0; i < aniCount; i++) {
                var ani = AnimationParser02._templet._anis[i] =
                    {};
                ani.nodes = new Array;
                var aniName = ani.name = AnimationParser02._strings[reader.getUint16()];
                AnimationParser02._templet._aniMap[aniName] = i;
                ani.bone3DMap = {};
                ani.playTime = reader.getFloat32();
                var boneCount = ani.nodes.length = reader.getInt16();
                ani.totalKeyframeDatasLength = 0;
                for (j = 0; j < boneCount; j++) {
                    var node = ani.nodes[j] =
                        {};
                    node.keyframeWidth = keyframeWidth;
                    node.childs = [];
                    var nameIndex = reader.getUint16();
                    if (nameIndex >= 0) {
                        node.name = AnimationParser02._strings[nameIndex];
                        ani.bone3DMap[node.name] = j;
                    }
                    node.keyFrame = new Array;
                    node.parentIndex = reader.getInt16();
                    node.parentIndex == -1 ? node.parent = null : node.parent = ani.nodes[node.parentIndex];
                    ani.totalKeyframeDatasLength += keyframeWidth;
                    node.interpolationMethod = interpolationMethod;
                    if (node.parent != null)
                        node.parent.childs.push(node);
                    var keyframeCount = reader.getUint16();
                    node.keyFrame.length = keyframeCount;
                    var keyFrame = null, lastKeyFrame = null;
                    for (k = 0, n = keyframeCount; k < n; k++) {
                        keyFrame = node.keyFrame[k] =
                            {};
                        keyFrame.startTime = reader.getFloat32();
                        (lastKeyFrame) && (lastKeyFrame.duration = keyFrame.startTime - lastKeyFrame.startTime);
                        var offset = AnimationParser02._DATA.offset;
                        var keyframeDataOffset = reader.getUint32();
                        var keyframeDataLength = keyframeWidth * 4;
                        var keyframeArrayBuffer = arrayBuffer.slice(offset + keyframeDataOffset, offset + keyframeDataOffset + keyframeDataLength);
                        keyFrame.data = new Float32Array(keyframeArrayBuffer);
                        lastKeyFrame = keyFrame;
                    }
                    keyFrame.duration = 0;
                    node.playTime = ani.playTime;
                    AnimationParser02._templet._calculateKeyFrame(node, keyframeCount, keyframeWidth);
                }
            }
        };
        AnimationParser02._templet = null;
        AnimationParser02._reader = null;
        AnimationParser02._strings = [];
        __static(AnimationParser02, ['_BLOCK', function () { return this._BLOCK = { count: 0 }; }, '_DATA', function () { return this._DATA = { offset: 0, size: 0 }; }
        ]);
        return AnimationParser02;
    })();
    var AnimationState = (function () {
        function AnimationState() { }
        __class(AnimationState, 'laya.ani.AnimationState');
        AnimationState.stopped = 0;
        AnimationState.paused = 1;
        AnimationState.playing = 2;
        return AnimationState;
    })();
    var Bone = (function () {
        function Bone() {
            this.name = null;
            this.root = null;
            this.parentBone = null;
            this.length = 10;
            this.transform = null;
            this.inheritScale = true;
            this.inheritRotation = true;
            this.rotation = NaN;
            this.resultRotation = NaN;
            this.d = -1;
            this._tempMatrix = null;
            this._sprite = null;
            this.resultTransform = new Transform();
            this.resultMatrix = new Matrix();
            this._children = [];
        }
        __class(Bone, 'laya.ani.bone.Bone');
        var __proto = Bone.prototype;
        __proto.setTempMatrix = function (matrix) {
            this._tempMatrix = matrix;
            var i = 0, n = 0;
            var tBone;
            for (i = 0, n = this._children.length; i < n; i++) {
                tBone = this._children[i];
                tBone.setTempMatrix(this._tempMatrix);
            }
        };
        __proto.update = function (pMatrix) {
            this.rotation = this.transform.skX;
            var tResultMatrix;
            if (pMatrix) {
                tResultMatrix = this.resultTransform.getMatrix();
                Matrix.mul(tResultMatrix, pMatrix, this.resultMatrix);
                this.resultRotation = this.rotation;
            }
            else {
                this.resultRotation = this.rotation + this.parentBone.resultRotation;
                if (this.parentBone) {
                    if (this.inheritRotation && this.inheritScale) {
                        tResultMatrix = this.resultTransform.getMatrix();
                        Matrix.mul(tResultMatrix, this.parentBone.resultMatrix, this.resultMatrix);
                    }
                    else {
                        var temp = 0;
                        var parent = this.parentBone;
                        var tAngle = NaN;
                        var cos = NaN;
                        var sin = NaN;
                        var tParentMatrix = this.parentBone.resultMatrix;
                        tResultMatrix = this.resultTransform.getMatrix();
                        var worldX = tParentMatrix.a * tResultMatrix.tx + tParentMatrix.c * tResultMatrix.ty + tParentMatrix.tx;
                        var worldY = tParentMatrix.b * tResultMatrix.tx + tParentMatrix.d * tResultMatrix.ty + tParentMatrix.ty;
                        var tTestMatrix = new Matrix();
                        if (this.inheritRotation) {
                            tAngle = Math.atan2(parent.resultMatrix.b, parent.resultMatrix.a);
                            cos = Math.cos(tAngle), sin = Math.sin(tAngle);
                            tTestMatrix.setTo(cos, sin, -sin, cos, 0, 0);
                            Matrix.mul(this._tempMatrix, tTestMatrix, Matrix.TEMP);
                            Matrix.TEMP.copyTo(tTestMatrix);
                            tResultMatrix = this.resultTransform.getMatrix();
                            Matrix.mul(tResultMatrix, tTestMatrix, this.resultMatrix);
                            if (this.resultTransform.scX * this.resultTransform.scY < 0) {
                                this.resultMatrix.rotate(Math.PI * 0.5);
                            }
                            this.resultMatrix.tx = worldX;
                            this.resultMatrix.ty = worldY;
                        }
                        else if (this.inheritScale) {
                            tResultMatrix = this.resultTransform.getMatrix();
                            Matrix.TEMP.identity();
                            Matrix.TEMP.d = this.d;
                            Matrix.mul(tResultMatrix, Matrix.TEMP, this.resultMatrix);
                            this.resultMatrix.tx = worldX;
                            this.resultMatrix.ty = worldY;
                        }
                        else {
                            tResultMatrix = this.resultTransform.getMatrix();
                            Matrix.TEMP.identity();
                            Matrix.TEMP.d = this.d;
                            Matrix.mul(tResultMatrix, Matrix.TEMP, this.resultMatrix);
                            this.resultMatrix.tx = worldX;
                            this.resultMatrix.ty = worldY;
                        }
                    }
                }
                else {
                    tResultMatrix = this.resultTransform.getMatrix();
                    tResultMatrix.copyTo(this.resultMatrix);
                }
            }
            ;
            var i = 0, n = 0;
            var tBone;
            for (i = 0, n = this._children.length; i < n; i++) {
                tBone = this._children[i];
                tBone.update();
            }
        };
        __proto.updateChild = function () {
            var i = 0, n = 0;
            var tBone;
            for (i = 0, n = this._children.length; i < n; i++) {
                tBone = this._children[i];
                tBone.update();
            }
        };
        __proto.setRotation = function (rd) {
            if (this._sprite) {
                this._sprite.rotation = rd * 180 / Math.PI;
            }
        };
        __proto.updateDraw = function (x, y) {
            if (!Bone.ShowBones || Bone.ShowBones[this.name]) {
                if (this._sprite) {
                    this._sprite.x = x + this.resultMatrix.tx;
                    this._sprite.y = y + this.resultMatrix.ty;
                }
                else {
                    this._sprite = new Sprite();
                    this._sprite.graphics.drawCircle(0, 0, 5, "#ff0000");
                    this._sprite.graphics.drawLine(0, 0, this.length, 0, "#00ff00");
                    this._sprite.graphics.fillText(this.name, 0, 0, "20px Arial", "#00ff00", "center");
                    Laya.stage.addChild(this._sprite);
                    this._sprite.x = x + this.resultMatrix.tx;
                    this._sprite.y = y + this.resultMatrix.ty;
                }
            }
            ;
            var i = 0, n = 0;
            var tBone;
            for (i = 0, n = this._children.length; i < n; i++) {
                tBone = this._children[i];
                tBone.updateDraw(x, y);
            }
        };
        __proto.addChild = function (bone) {
            this._children.push(bone);
            bone.parentBone = this;
        };
        __proto.findBone = function (boneName) {
            if (this.name == boneName) {
                return this;
            }
            else {
                var i = 0, n = 0;
                var tBone;
                var tResult;
                for (i = 0, n = this._children.length; i < n; i++) {
                    tBone = this._children[i];
                    tResult = tBone.findBone(boneName);
                    if (tResult) {
                        return tResult;
                    }
                }
            }
            return null;
        };
        __proto.localToWorld = function (local) {
            var localX = local[0];
            var localY = local[1];
            local[0] = localX * this.resultMatrix.a + localY * this.resultMatrix.c + this.resultMatrix.tx;
            local[1] = localX * this.resultMatrix.b + localY * this.resultMatrix.d + this.resultMatrix.ty;
        };
        Bone.ShowBones = {};
        return Bone;
    })();
    var BoneSlot = (function () {
        function BoneSlot() {
            this.name = null;
            this.parent = null;
            this.attachmentName = null;
            this.srcDisplayIndex = -1;
            this.type = "src";
            this.templet = null;
            this.currSlotData = null;
            this.currTexture = null;
            this.currDisplayData = null;
            this.displayIndex = -1;
            this._diyTexture = null;
            this._parentMatrix = null;
            this._resultMatrix = null;
            this._replaceDic = {};
            this._curDiyUV = null;
            this._curDiyVS = null;
            this._skinSprite = null;
            this.deformData = null;
            this._mVerticleArr = null;
        }
        __class(BoneSlot, 'laya.ani.bone.BoneSlot');
        var __proto = BoneSlot.prototype;
        __proto.showSlotData = function (slotData, freshIndex) {
            (freshIndex === void 0) && (freshIndex = true);
            this.currSlotData = slotData;
            if (freshIndex)
                this.displayIndex = this.srcDisplayIndex;
            this.currDisplayData = null;
            this.currTexture = null;
        };
        __proto.showDisplayByName = function (name) {
            if (this.currSlotData) {
                this.showDisplayByIndex(this.currSlotData.getDisplayByName(name));
            }
        };
        __proto.replaceDisplayByName = function (tarName, newName) {
            if (!this.currSlotData)
                return;
            var preIndex = 0;
            preIndex = this.currSlotData.getDisplayByName(tarName);
            var newIndex = 0;
            newIndex = this.currSlotData.getDisplayByName(newName);
            this.replaceDisplayByIndex(preIndex, newIndex);
        };
        __proto.replaceDisplayByIndex = function (tarIndex, newIndex) {
            if (!this.currSlotData)
                return;
            this._replaceDic[tarIndex] = newIndex;
            if (this.displayIndex == tarIndex) {
                this.showDisplayByIndex(tarIndex);
            }
        };
        __proto.showDisplayByIndex = function (index) {
            if (this._replaceDic[index] != null)
                index = this._replaceDic[index];
            if (this.currSlotData && index > -1 && index < this.currSlotData.displayArr.length) {
                this.displayIndex = index;
                this.currDisplayData = this.currSlotData.displayArr[index];
                if (this.currDisplayData) {
                    var tName = this.currDisplayData.name;
                    this.currTexture = this.templet.getTexture(tName);
                    if (this.currTexture && !Render.isConchApp && this.currDisplayData.type == 0 && this.currDisplayData.uvs) {
                        this.currTexture = this.currDisplayData.createTexture(this.currTexture);
                    }
                }
            }
            else {
                this.displayIndex = -1;
                this.currDisplayData = null;
                this.currTexture = null;
            }
        };
        __proto.replaceSkin = function (_texture) {
            this._diyTexture = _texture;
            if (this._curDiyUV)
                this._curDiyUV.length = 0;
            if (this.currDisplayData && this._diyTexture == this.currDisplayData.texture) {
                this._diyTexture = null;
            }
        };
        __proto.setParentMatrix = function (parentMatrix) {
            this._parentMatrix = parentMatrix;
        };
        __proto.draw = function (graphics, boneMatrixArray, noUseSave, alpha) {
            (noUseSave === void 0) && (noUseSave = false);
            (alpha === void 0) && (alpha = 1);
            if ((this._diyTexture == null && this.currTexture == null) || this.currDisplayData == null) {
                if (!(this.currDisplayData && this.currDisplayData.type == 3)) {
                    return;
                }
            }
            ;
            var tTexture = this.currTexture;
            if (this._diyTexture)
                tTexture = this._diyTexture;
            var tSkinSprite;
            switch (this.currDisplayData.type) {
                case 0:
                    if (graphics) {
                        var tCurrentMatrix = this.getDisplayMatrix();
                        if (this._parentMatrix) {
                            var tRotateKey = false;
                            if (tCurrentMatrix) {
                                Matrix.mul(tCurrentMatrix, this._parentMatrix, Matrix.TEMP);
                                var tResultMatrix;
                                if (noUseSave) {
                                    if (this._resultMatrix == null)
                                        this._resultMatrix = new Matrix();
                                    tResultMatrix = this._resultMatrix;
                                }
                                else {
                                    tResultMatrix = new Matrix();
                                }
                                if ((!Render.isWebGL && this.currDisplayData.uvs) || (Render.isWebGL && this._diyTexture && this.currDisplayData.uvs)) {
                                    var tTestMatrix = BoneSlot._tempMatrix;
                                    tTestMatrix.identity();
                                    if (this.currDisplayData.uvs[1] > this.currDisplayData.uvs[5]) {
                                        tTestMatrix.d = -1;
                                    }
                                    if (this.currDisplayData.uvs[0] > this.currDisplayData.uvs[4]
                                        && this.currDisplayData.uvs[1] > this.currDisplayData.uvs[5]) {
                                        tRotateKey = true;
                                        tTestMatrix.rotate(-Math.PI / 2);
                                    }
                                    Matrix.mul(tTestMatrix, Matrix.TEMP, tResultMatrix);
                                }
                                else {
                                    Matrix.TEMP.copyTo(tResultMatrix);
                                }
                                if (tRotateKey) {
                                    graphics.drawTexture(tTexture, -this.currDisplayData.height / 2, -this.currDisplayData.width / 2, this.currDisplayData.height, this.currDisplayData.width, tResultMatrix);
                                }
                                else {
                                    graphics.drawTexture(tTexture, -this.currDisplayData.width / 2, -this.currDisplayData.height / 2, this.currDisplayData.width, this.currDisplayData.height, tResultMatrix);
                                }
                            }
                        }
                    }
                    break;
                case 1:
                    if (noUseSave) {
                        if (this._skinSprite == null) {
                            this._skinSprite = BoneSlot.createSkinMesh();
                        }
                        tSkinSprite = this._skinSprite;
                    }
                    else {
                        tSkinSprite = BoneSlot.createSkinMesh();
                    }
                    if (tSkinSprite == null) {
                        return;
                    }
                    ;
                    var tIBArray;
                    var tRed = 1;
                    var tGreed = 1;
                    var tBlue = 1;
                    var tAlpha = 1;
                    if (this.currDisplayData.bones == null) {
                        var tVertices = this.currDisplayData.weights;
                        if (this.deformData) {
                            tVertices = this.deformData;
                        }
                        ;
                        var tUVs;
                        if (this._diyTexture) {
                            if (!this._curDiyUV) {
                                this._curDiyUV = [];
                            }
                            if (this._curDiyUV.length == 0) {
                                this._curDiyUV = UVTools.getRelativeUV(this.currTexture.uv, this.currDisplayData.uvs, this._curDiyUV);
                                this._curDiyUV = UVTools.getAbsoluteUV(this._diyTexture.uv, this._curDiyUV, this._curDiyUV);
                            }
                            tUVs = this._curDiyUV;
                        }
                        else {
                            tUVs = this.currDisplayData.uvs;
                        }
                        this._mVerticleArr = tVertices;
                        var tTriangleNum = this.currDisplayData.triangles.length / 3;
                        tIBArray = this.currDisplayData.triangles;
                        tSkinSprite.init2(tTexture, null, tIBArray, this._mVerticleArr, tUVs);
                        var tCurrentMatrix2 = this.getDisplayMatrix();
                        if (this._parentMatrix) {
                            if (tCurrentMatrix2) {
                                Matrix.mul(tCurrentMatrix2, this._parentMatrix, Matrix.TEMP);
                                var tResultMatrix2;
                                if (noUseSave) {
                                    if (this._resultMatrix == null)
                                        this._resultMatrix = new Matrix();
                                    tResultMatrix2 = this._resultMatrix;
                                }
                                else {
                                    tResultMatrix2 = new Matrix();
                                }
                                Matrix.TEMP.copyTo(tResultMatrix2);
                                tSkinSprite.transform = tResultMatrix2;
                            }
                        }
                    }
                    else {
                        this.skinMesh(boneMatrixArray, tSkinSprite, alpha);
                    }
                    graphics.drawSkin(tSkinSprite);
                    break;
                case 2:
                    if (noUseSave) {
                        if (this._skinSprite == null) {
                            this._skinSprite = BoneSlot.createSkinMesh();
                        }
                        tSkinSprite = this._skinSprite;
                    }
                    else {
                        tSkinSprite = BoneSlot.createSkinMesh();
                    }
                    if (tSkinSprite == null) {
                        return;
                    }
                    this.skinMesh(boneMatrixArray, tSkinSprite, alpha);
                    graphics.drawSkin(tSkinSprite);
                    break;
                case 3:
                    break;
            }
        };
        __proto.skinMesh = function (boneMatrixArray, skinSprite, alpha) {
            var tTexture = this.currTexture;
            var tBones = this.currDisplayData.bones;
            var tUvs;
            if (this._diyTexture) {
                tTexture = this._diyTexture;
                if (!this._curDiyUV) {
                    this._curDiyUV = [];
                }
                if (this._curDiyUV.length == 0) {
                    this._curDiyUV = UVTools.getRelativeUV(this.currTexture.uv, this.currDisplayData.uvs, this._curDiyUV);
                    this._curDiyUV = UVTools.getAbsoluteUV(this._diyTexture.uv, this._curDiyUV, this._curDiyUV);
                }
                tUvs = this._curDiyUV;
            }
            else {
                tUvs = this.currDisplayData.uvs;
            }
            ;
            var tWeights = this.currDisplayData.weights;
            var tTriangles = this.currDisplayData.triangles;
            var tIBArray;
            var tRx = 0;
            var tRy = 0;
            var nn = 0;
            var tMatrix;
            var tX = NaN;
            var tY = NaN;
            var tB = 0;
            var tWeight = 0;
            var tVertices = [];
            var i = 0, j = 0, n = 0;
            var tRed = 1;
            var tGreed = 1;
            var tBlue = 1;
            var tAlpha = alpha;
            if (this.deformData && this.deformData.length > 0) {
                var f = 0;
                for (i = 0, n = tBones.length; i < n;) {
                    nn = tBones[i++] + i;
                    tRx = 0, tRy = 0;
                    for (; i < nn; i++) {
                        tMatrix = boneMatrixArray[tBones[i]];
                        tX = tWeights[tB] + this.deformData[f++];
                        tY = tWeights[tB + 1] + this.deformData[f++];
                        tWeight = tWeights[tB + 2];
                        tRx += (tX * tMatrix.a + tY * tMatrix.c + tMatrix.tx) * tWeight;
                        tRy += (tX * tMatrix.b + tY * tMatrix.d + tMatrix.ty) * tWeight;
                        tB += 3;
                    }
                    tVertices.push(tRx, tRy);
                }
            }
            else {
                for (i = 0, n = tBones.length; i < n;) {
                    nn = tBones[i++] + i;
                    tRx = 0, tRy = 0;
                    for (; i < nn; i++) {
                        tMatrix = boneMatrixArray[tBones[i]];
                        tX = tWeights[tB];
                        tY = tWeights[tB + 1];
                        tWeight = tWeights[tB + 2];
                        tRx += (tX * tMatrix.a + tY * tMatrix.c + tMatrix.tx) * tWeight;
                        tRy += (tX * tMatrix.b + tY * tMatrix.d + tMatrix.ty) * tWeight;
                        tB += 3;
                    }
                    tVertices.push(tRx, tRy);
                }
            }
            this._mVerticleArr = tVertices;
            tIBArray = tTriangles;
            skinSprite.init2(tTexture, null, tIBArray, this._mVerticleArr, tUvs);
        };
        __proto.drawBonePoint = function (graphics) {
            if (graphics && this._parentMatrix) {
                graphics.drawCircle(this._parentMatrix.tx, this._parentMatrix.ty, 5, "#ff0000");
            }
        };
        __proto.getDisplayMatrix = function () {
            if (this.currDisplayData) {
                return this.currDisplayData.transform.getMatrix();
            }
            return null;
        };
        __proto.getMatrix = function () {
            return this._resultMatrix;
        };
        __proto.copy = function () {
            var tBoneSlot = new BoneSlot();
            tBoneSlot.type = "copy";
            tBoneSlot.name = this.name;
            tBoneSlot.attachmentName = this.attachmentName;
            tBoneSlot.srcDisplayIndex = this.srcDisplayIndex;
            tBoneSlot.parent = this.parent;
            tBoneSlot.displayIndex = this.displayIndex;
            tBoneSlot.templet = this.templet;
            tBoneSlot.currSlotData = this.currSlotData;
            tBoneSlot.currTexture = this.currTexture;
            tBoneSlot.currDisplayData = this.currDisplayData;
            return tBoneSlot;
        };
        BoneSlot.createSkinMesh = function () {
            if (Render.isWebGL || Render.isConchApp) {
                return RunDriver.skinAniSprite();
            }
            else {
                if (!Render.isWebGL) {
                    if (Skeleton.useSimpleMeshInCanvas) {
                        return new SimpleSkinMeshCanvas();
                    }
                    else {
                        return new SkinMeshCanvas();
                    }
                }
            }
            return null;
        };
        __static(BoneSlot, ['_tempMatrix', function () { return this._tempMatrix = new Matrix(); }
        ]);
        return BoneSlot;
    })();
    var CanvasMeshRender = (function () {
        function CanvasMeshRender() {
            this.mesh = null;
            this.transform = null;
            this.context = null;
            this.mode = 0;
        }
        __class(CanvasMeshRender, 'laya.ani.bone.canvasmesh.CanvasMeshRender');
        var __proto = CanvasMeshRender.prototype;
        __proto.renderToContext = function (context) {
            this.context = context.ctx || context;
            if (this.mesh) {
                if (this.mode == 0) {
                    this._renderWithIndexes(this.mesh);
                }
                else {
                    this._renderNoIndexes(this.mesh);
                }
            }
        };
        __proto._renderNoIndexes = function (mesh) {
            var i = 0, len = mesh.vertices.length / 2;
            var index = 0;
            for (i = 0; i < len - 2; i++) {
                index = i * 2;
                this._renderDrawTriangle(mesh, index, (index + 2), (index + 4));
            }
        };
        __proto._renderWithIndexes = function (mesh) {
            var indexes = mesh.indexes;
            var i = 0, len = indexes.length;
            for (i = 0; i < len; i += 3) {
                var index0 = indexes[i] * 2;
                var index1 = indexes[i + 1] * 2;
                var index2 = indexes[i + 2] * 2;
                this._renderDrawTriangle(mesh, index0, index1, index2);
            }
        };
        __proto._renderDrawTriangle = function (mesh, index0, index1, index2) {
            var context = this.context;
            var uvs = mesh.uvs;
            var vertices = mesh.vertices;
            var texture = mesh.texture;
            var source = texture.bitmap;
            var textureSource = source.source;
            var textureWidth = texture.width;
            var textureHeight = texture.height;
            var sourceWidth = source.width;
            var sourceHeight = source.height;
            var u0 = NaN;
            var u1 = NaN;
            var u2 = NaN;
            var v0 = NaN;
            var v1 = NaN;
            var v2 = NaN;
            if (mesh.useUvTransform) {
                var ut = mesh.uvTransform;
                u0 = ((uvs[index0] * ut.a) + (uvs[index0 + 1] * ut.c) + ut.tx) * sourceWidth;
                u1 = ((uvs[index1] * ut.a) + (uvs[index1 + 1] * ut.c) + ut.tx) * sourceWidth;
                u2 = ((uvs[index2] * ut.a) + (uvs[index2 + 1] * ut.c) + ut.tx) * sourceWidth;
                v0 = ((uvs[index0] * ut.b) + (uvs[index0 + 1] * ut.d) + ut.ty) * sourceHeight;
                v1 = ((uvs[index1] * ut.b) + (uvs[index1 + 1] * ut.d) + ut.ty) * sourceHeight;
                v2 = ((uvs[index2] * ut.b) + (uvs[index2 + 1] * ut.d) + ut.ty) * sourceHeight;
            }
            else {
                u0 = uvs[index0] * sourceWidth;
                u1 = uvs[index1] * sourceWidth;
                u2 = uvs[index2] * sourceWidth;
                v0 = uvs[index0 + 1] * sourceHeight;
                v1 = uvs[index1 + 1] * sourceHeight;
                v2 = uvs[index2 + 1] * sourceHeight;
            }
            ;
            var x0 = vertices[index0];
            var x1 = vertices[index1];
            var x2 = vertices[index2];
            var y0 = vertices[index0 + 1];
            var y1 = vertices[index1 + 1];
            var y2 = vertices[index2 + 1];
            if (mesh.canvasPadding > 0) {
                var paddingX = mesh.canvasPadding;
                var paddingY = mesh.canvasPadding;
                var centerX = (x0 + x1 + x2) / 3;
                var centerY = (y0 + y1 + y2) / 3;
                var normX = x0 - centerX;
                var normY = y0 - centerY;
                var dist = Math.sqrt((normX * normX) + (normY * normY));
                x0 = centerX + ((normX / dist) * (dist + paddingX));
                y0 = centerY + ((normY / dist) * (dist + paddingY));
                normX = x1 - centerX;
                normY = y1 - centerY;
                dist = Math.sqrt((normX * normX) + (normY * normY));
                x1 = centerX + ((normX / dist) * (dist + paddingX));
                y1 = centerY + ((normY / dist) * (dist + paddingY));
                normX = x2 - centerX;
                normY = y2 - centerY;
                dist = Math.sqrt((normX * normX) + (normY * normY));
                x2 = centerX + ((normX / dist) * (dist + paddingX));
                y2 = centerY + ((normY / dist) * (dist + paddingY));
            }
            context.save();
            if (this.transform) {
                var mt = this.transform;
                context.transform(mt.a, mt.b, mt.c, mt.d, mt.tx, mt.ty);
            }
            context.beginPath();
            context.moveTo(x0, y0);
            context.lineTo(x1, y1);
            context.lineTo(x2, y2);
            context.closePath();
            context.clip();
            var delta = (u0 * v1) + (v0 * u2) + (u1 * v2) - (v1 * u2) - (v0 * u1) - (u0 * v2);
            var dDelta = 1 / delta;
            var deltaA = (x0 * v1) + (v0 * x2) + (x1 * v2) - (v1 * x2) - (v0 * x1) - (x0 * v2);
            var deltaB = (u0 * x1) + (x0 * u2) + (u1 * x2) - (x1 * u2) - (x0 * u1) - (u0 * x2);
            var deltaC = (u0 * v1 * x2) + (v0 * x1 * u2) + (x0 * u1 * v2) - (x0 * v1 * u2) - (v0 * u1 * x2) - (u0 * x1 * v2);
            var deltaD = (y0 * v1) + (v0 * y2) + (y1 * v2) - (v1 * y2) - (v0 * y1) - (y0 * v2);
            var deltaE = (u0 * y1) + (y0 * u2) + (u1 * y2) - (y1 * u2) - (y0 * u1) - (u0 * y2);
            var deltaF = (u0 * v1 * y2) + (v0 * y1 * u2) + (y0 * u1 * v2) - (y0 * v1 * u2) - (v0 * u1 * y2) - (u0 * y1 * v2);
            context.transform(deltaA * dDelta, deltaD * dDelta, deltaB * dDelta, deltaE * dDelta, deltaC * dDelta, deltaF * dDelta);
            context.drawImage(textureSource, texture.uv[0] * sourceWidth, texture.uv[1] * sourceHeight, textureWidth, textureHeight, texture.uv[0] * sourceWidth, texture.uv[1] * sourceHeight, textureWidth, textureHeight);
            context.restore();
        };
        return CanvasMeshRender;
    })();
    var MeshData = (function () {
        function MeshData() {
            this.texture = null;
            this.uvs = [0, 0, 1, 0, 1, 1, 0, 1];
            this.vertices = [0, 0, 100, 0, 100, 100, 0, 100];
            this.indexes = [0, 1, 3, 3, 1, 2];
            this.uvTransform = null;
            this.useUvTransform = false;
            this.canvasPadding = 1;
        }
        __class(MeshData, 'laya.ani.bone.canvasmesh.MeshData');
        var __proto = MeshData.prototype;
        __proto.getBounds = function () {
            return Rectangle._getWrapRec(this.vertices);
        };
        return MeshData;
    })();
    var DeformAniData = (function () {
        function DeformAniData() {
            this.skinName = null;
            this.deformSlotDataList = [];
        }
        __class(DeformAniData, 'laya.ani.bone.DeformAniData');
        return DeformAniData;
    })();
    var DeformSlotData = (function () {
        function DeformSlotData() {
            this.deformSlotDisplayList = [];
        }
        __class(DeformSlotData, 'laya.ani.bone.DeformSlotData');
        return DeformSlotData;
    })();
    var DeformSlotDisplayData = (function () {
        function DeformSlotDisplayData() {
            this.boneSlot = null;
            this.slotIndex = -1;
            this.attachment = null;
            this.deformData = null;
            this.frameIndex = 0;
            this.timeList = [];
            this.vectices = [];
            this.tweenKeyList = [];
        }
        __class(DeformSlotDisplayData, 'laya.ani.bone.DeformSlotDisplayData');
        var __proto = DeformSlotDisplayData.prototype;
        __proto.binarySearch1 = function (values, target) {
            var low = 0;
            var high = values.length - 2;
            if (high == 0)
                return 1;
            var current = high >>> 1;
            while (true) {
                if (values[Math.floor(current + 1)] <= target)
                    low = current + 1;
                else
                    high = current;
                if (low == high)
                    return low + 1;
                current = (low + high) >>> 1;
            }
            return 0;
        };
        __proto.apply = function (time, boneSlot, alpha) {
            (alpha === void 0) && (alpha = 1);
            time += 0.05;
            if (this.timeList.length <= 0) {
                return;
            }
            ;
            var i = 0;
            var n = 0;
            var tTime = this.timeList[0];
            if (time < tTime) {
                return;
            }
            ;
            var tVertexCount = this.vectices[0].length;
            var tVertices = [];
            var tFrameIndex = this.binarySearch1(this.timeList, time);
            this.frameIndex = tFrameIndex;
            if (time >= this.timeList[this.timeList.length - 1]) {
                var lastVertices = this.vectices[this.vectices.length - 1];
                if (alpha < 1) {
                    for (i = 0; i < tVertexCount; i++) {
                        tVertices[i] += (lastVertices[i] - tVertices[i]) * alpha;
                    }
                }
                else {
                    for (i = 0; i < tVertexCount; i++) {
                        tVertices[i] = lastVertices[i];
                    }
                }
                this.deformData = tVertices;
                return;
            }
            ;
            var tTweenKey = this.tweenKeyList[this.frameIndex];
            var tPrevVertices = this.vectices[this.frameIndex - 1];
            var tNextVertices = this.vectices[this.frameIndex];
            var tPreFrameTime = this.timeList[this.frameIndex - 1];
            var tFrameTime = this.timeList[this.frameIndex];
            if (this.tweenKeyList[tFrameIndex - 1]) {
                alpha = (time - tPreFrameTime) / (tFrameTime - tPreFrameTime);
            }
            else {
                alpha = 0;
            }
            ;
            var tPrev = NaN;
            for (i = 0; i < tVertexCount; i++) {
                tPrev = tPrevVertices[i];
                tVertices[i] = tPrev + (tNextVertices[i] - tPrev) * alpha;
            }
            this.deformData = tVertices;
        };
        return DeformSlotDisplayData;
    })();
    var DrawOrderData = (function () {
        function DrawOrderData() {
            this.time = NaN;
            this.drawOrder = [];
        }
        __class(DrawOrderData, 'laya.ani.bone.DrawOrderData');
        return DrawOrderData;
    })();
    var EventData = (function () {
        function EventData() {
            this.name = null;
            this.intValue = 0;
            this.floatValue = NaN;
            this.stringValue = null;
            this.time = NaN;
        }
        __class(EventData, 'laya.ani.bone.EventData');
        return EventData;
    })();
    var IkConstraint = (function () {
        function IkConstraint(data, bones) {
            this._targetBone = null;
            this._bones = null;
            this._data = null;
            this.name = null;
            this.mix = NaN;
            this.bendDirection = NaN;
            this.isSpine = true;
            this._sp = null;
            this.isDebug = false;
            this._data = data;
            this._targetBone = bones[data.targetBoneIndex];
            this.isSpine = data.isSpine;
            if (this._bones == null)
                this._bones = [];
            this._bones.length = 0;
            for (var i = 0, n = data.boneIndexs.length; i < n; i++) {
                this._bones.push(bones[data.boneIndexs[i]]);
            }
            this.name = data.name;
            this.mix = data.mix;
            this.bendDirection = data.bendDirection;
        }
        __class(IkConstraint, 'laya.ani.bone.IkConstraint');
        var __proto = IkConstraint.prototype;
        __proto.apply = function () {
            switch (this._bones.length) {
                case 1:
                    this._applyIk1(this._bones[0], this._targetBone.resultMatrix.tx, this._targetBone.resultMatrix.ty, this.mix);
                    break;
                case 2:
                    if (this.isSpine) {
                        this._applyIk2(this._bones[0], this._bones[1], this._targetBone.resultMatrix.tx, this._targetBone.resultMatrix.ty, this.bendDirection, this.mix);
                    }
                    else {
                        this._applyIk3(this._bones[0], this._bones[1], this._targetBone.resultMatrix.tx, this._targetBone.resultMatrix.ty, this.bendDirection, this.mix);
                    }
                    break;
            }
        };
        __proto._applyIk1 = function (bone, targetX, targetY, alpha) {
            var pp = bone.parentBone;
            var id = 1 / (pp.resultMatrix.a * pp.resultMatrix.d - pp.resultMatrix.b * pp.resultMatrix.c);
            var x = targetX - pp.resultMatrix.tx;
            var y = targetY - pp.resultMatrix.ty;
            var tx = (x * pp.resultMatrix.d - y * pp.resultMatrix.c) * id - bone.transform.x;
            var ty = (y * pp.resultMatrix.a - x * pp.resultMatrix.b) * id - bone.transform.y;
            var rotationIK = Math.atan2(ty, tx) * IkConstraint.radDeg - 0 - bone.transform.skX;
            if (bone.transform.scX < 0)
                rotationIK += 180;
            if (rotationIK > 180)
                rotationIK -= 360;
            else if (rotationIK < -180)
                rotationIK += 360;
            bone.transform.skX = bone.transform.skY = bone.transform.skX + rotationIK * alpha;
            bone.update();
        };
        __proto.updatePos = function (x, y) {
            if (this._sp) {
                this._sp.pos(x, y);
            }
        };
        __proto._applyIk2 = function (parent, child, targetX, targetY, bendDir, alpha) {
            if (alpha == 0) {
                return;
            }
            ;
            var px = parent.resultTransform.x, py = parent.resultTransform.y;
            var psx = parent.transform.scX, psy = parent.transform.scY;
            var csx = child.transform.scX;
            var os1 = 0, os2 = 0, s2 = 0;
            if (psx < 0) {
                psx = -psx;
                os1 = 180;
                s2 = -1;
            }
            else {
                os1 = 0;
                s2 = 1;
            }
            if (psy < 0) {
                psy = -psy;
                s2 = -s2;
            }
            if (csx < 0) {
                csx = -csx;
                os2 = 180;
            }
            else {
                os2 = 0;
            }
            ;
            var cx = child.resultTransform.x, cy = NaN, cwx = NaN, cwy = NaN;
            var a = parent.resultMatrix.a, b = parent.resultMatrix.c;
            var c = parent.resultMatrix.b, d = parent.resultMatrix.d;
            var u = Math.abs(psx - psy) <= 0.0001;
            if (!u) {
                cy = 0;
                cwx = a * cx + parent.resultMatrix.tx;
                cwy = c * cx + parent.resultMatrix.ty;
            }
            else {
                cy = child.resultTransform.y;
                cwx = a * cx + b * cy + parent.resultMatrix.tx;
                cwy = c * cx + d * cy + parent.resultMatrix.ty;
            }
            if (this.isDebug) {
                if (!this._sp) {
                    this._sp = new Sprite();
                    Laya.stage.addChild(this._sp);
                }
                this._sp.graphics.clear();
                this._sp.graphics.drawCircle(targetX, targetY, 15, "#ffff00");
                this._sp.graphics.drawCircle(cwx, cwy, 15, "#ff00ff");
            }
            parent.setRotation(Math.atan2(cwy - parent.resultMatrix.ty, cwx - parent.resultMatrix.tx));
            var pp = parent.parentBone;
            a = pp.resultMatrix.a;
            b = pp.resultMatrix.c;
            c = pp.resultMatrix.b;
            d = pp.resultMatrix.d;
            var id = 1 / (a * d - b * c);
            var x = targetX - pp.resultMatrix.tx, y = targetY - pp.resultMatrix.ty;
            var tx = (x * d - y * b) * id - px;
            var ty = (y * a - x * c) * id - py;
            x = cwx - pp.resultMatrix.tx;
            y = cwy - pp.resultMatrix.ty;
            var dx = (x * d - y * b) * id - px;
            var dy = (y * a - x * c) * id - py;
            var l1 = Math.sqrt(dx * dx + dy * dy);
            var l2 = child.length * csx;
            var a1 = NaN, a2 = NaN;
            if (u) {
                l2 *= psx;
                var cos = (tx * tx + ty * ty - l1 * l1 - l2 * l2) / (2 * l1 * l2);
                if (cos < -1)
                    cos = -1;
                else if (cos > 1)
                    cos = 1;
                a2 = Math.acos(cos) * bendDir;
                a = l1 + l2 * cos;
                b = l2 * Math.sin(a2);
                a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);
            }
            else {
                a = psx * l2;
                b = psy * l2;
                var aa = a * a, bb = b * b, dd = tx * tx + ty * ty, ta = Math.atan2(ty, tx);
                c = bb * l1 * l1 + aa * dd - aa * bb;
                var c1 = -2 * bb * l1, c2 = bb - aa;
                d = c1 * c1 - 4 * c2 * c;
                if (d > 0) {
                    var q = Math.sqrt(d);
                    if (c1 < 0)
                        q = -q;
                    q = -(c1 + q) / 2;
                    var r0 = q / c2, r1 = c / q;
                    var r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;
                    if (r * r <= dd) {
                        y = Math.sqrt(dd - r * r) * bendDir;
                        a1 = ta - Math.atan2(y, r);
                        a2 = Math.atan2(y / psy, (r - l1) / psx);
                    }
                }
                ;
                var minAngle = 0, minDist = Number.MAX_VALUE, minX = 0, minY = 0;
                var maxAngle = 0, maxDist = 0, maxX = 0, maxY = 0;
                x = l1 + a;
                d = x * x;
                if (d > maxDist) {
                    maxAngle = 0;
                    maxDist = d;
                    maxX = x;
                }
                x = l1 - a;
                d = x * x;
                if (d < minDist) {
                    minAngle = Math.PI;
                    minDist = d;
                    minX = x;
                }
                ;
                var angle = Math.acos(-a * l1 / (aa - bb));
                x = a * Math.cos(angle) + l1;
                y = b * Math.sin(angle);
                d = x * x + y * y;
                if (d < minDist) {
                    minAngle = angle;
                    minDist = d;
                    minX = x;
                    minY = y;
                }
                if (d > maxDist) {
                    maxAngle = angle;
                    maxDist = d;
                    maxX = x;
                    maxY = y;
                }
                if (dd <= (minDist + maxDist) / 2) {
                    a1 = ta - Math.atan2(minY * bendDir, minX);
                    a2 = minAngle * bendDir;
                }
                else {
                    a1 = ta - Math.atan2(maxY * bendDir, maxX);
                    a2 = maxAngle * bendDir;
                }
            }
            ;
            var os = Math.atan2(cy, cx) * s2;
            var rotation = parent.resultTransform.skX;
            a1 = (a1 - os) * IkConstraint.radDeg + os1 - rotation;
            if (a1 > 180)
                a1 -= 360;
            else if (a1 < -180)
                a1 += 360;
            parent.resultTransform.x = px;
            parent.resultTransform.y = py;
            parent.resultTransform.skX = parent.resultTransform.skY = rotation + a1 * alpha;
            rotation = child.resultTransform.skX;
            rotation = rotation % 360;
            a2 = ((a2 + os) * IkConstraint.radDeg - 0) * s2 + os2 - rotation;
            if (a2 > 180)
                a2 -= 360;
            else if (a2 < -180)
                a2 += 360;
            child.resultTransform.x = cx;
            child.resultTransform.y = cy;
            child.resultTransform.skX = child.resultTransform.skY = child.resultTransform.skY + a2 * alpha;
            parent.update();
        };
        __proto._applyIk3 = function (parent, child, targetX, targetY, bendDir, alpha) {
            if (alpha == 0) {
                return;
            }
            ;
            var cwx = NaN, cwy = NaN;
            var x = child.resultMatrix.a * child.length;
            var y = child.resultMatrix.b * child.length;
            var lLL = x * x + y * y;
            var lL = Math.sqrt(lLL);
            var parentX = parent.resultMatrix.tx;
            var parentY = parent.resultMatrix.ty;
            var childX = child.resultMatrix.tx;
            var childY = child.resultMatrix.ty;
            var dX = childX - parentX;
            var dY = childY - parentY;
            var lPP = dX * dX + dY * dY;
            var lP = Math.sqrt(lPP);
            dX = targetX - parent.resultMatrix.tx;
            dY = targetY - parent.resultMatrix.ty;
            var lTT = dX * dX + dY * dY;
            var lT = Math.sqrt(lTT);
            var ikRadianA = 0;
            if (lL + lP <= lT || lT + lL <= lP || lT + lP <= lL) {
                var rate = NaN;
                if (lL + lP <= lT) {
                    rate = 1;
                }
                else {
                    rate = -1;
                }
                childX = parentX + rate * (targetX - parentX) * lP / lT;
                childY = parentY + rate * (targetY - parentY) * lP / lT;
            }
            else {
                var h = (lPP - lLL + lTT) / (2 * lTT);
                var r = Math.sqrt(lPP - h * h * lTT) / lT;
                var hX = parentX + (dX * h);
                var hY = parentY + (dY * h);
                var rX = -dY * r;
                var rY = dX * r;
                if (bendDir > 0) {
                    childX = hX - rX;
                    childY = hY - rY;
                }
                else {
                    childX = hX + rX;
                    childY = hY + rY;
                }
            }
            cwx = childX;
            cwy = childY;
            if (this.isDebug) {
                if (!this._sp) {
                    this._sp = new Sprite();
                    Laya.stage.addChild(this._sp);
                }
                this._sp.graphics.clear();
                this._sp.graphics.drawCircle(parentX, parentY, 15, "#ff00ff");
                this._sp.graphics.drawCircle(targetX, targetY, 15, "#ffff00");
                this._sp.graphics.drawCircle(cwx, cwy, 15, "#ff00ff");
            }
            ;
            var pRotation = NaN;
            pRotation = Math.atan2(cwy - parent.resultMatrix.ty, cwx - parent.resultMatrix.tx);
            parent.setRotation(pRotation);
            var pTarMatrix;
            pTarMatrix = IkConstraint._tempMatrix;
            pTarMatrix.identity();
            pTarMatrix.rotate(pRotation);
            pTarMatrix.scale(parent.resultMatrix.getScaleX(), parent.resultMatrix.getScaleY());
            pTarMatrix.translate(parent.resultMatrix.tx, parent.resultMatrix.ty);
            pTarMatrix.copyTo(parent.resultMatrix);
            parent.updateChild();
            var childRotation = NaN;
            childRotation = Math.atan2(targetY - cwy, targetX - cwx);
            child.setRotation(childRotation);
            var childTarMatrix;
            childTarMatrix = IkConstraint._tempMatrix;
            childTarMatrix.identity();
            childTarMatrix.rotate(childRotation);
            childTarMatrix.scale(child.resultMatrix.getScaleX(), child.resultMatrix.getScaleY());
            childTarMatrix.translate(cwx, cwy);
            pTarMatrix.copyTo(child.resultMatrix);
            child.updateChild();
        };
        __static(IkConstraint, ['radDeg', function () { return this.radDeg = 180 / Math.PI; }, 'degRad', function () { return this.degRad = Math.PI / 180; }, '_tempMatrix', function () { return this._tempMatrix = new Matrix(); }
        ]);
        return IkConstraint;
    })();
    var IkConstraintData = (function () {
        function IkConstraintData() {
            this.name = null;
            this.targetBoneName = null;
            this.bendDirection = 1;
            this.mix = 1;
            this.isSpine = true;
            this.targetBoneIndex = -1;
            this.boneNames = [];
            this.boneIndexs = [];
        }
        __class(IkConstraintData, 'laya.ani.bone.IkConstraintData');
        return IkConstraintData;
    })();
    var MeshTools = (function () {
        function MeshTools() { }
        __class(MeshTools, 'laya.ani.bone.MeshTools');
        MeshTools.findEdge = function (verticles, offI, min) {
            (offI === void 0) && (offI = 0);
            (min === void 0) && (min = true);
            var i = 0, len = 0;
            var tIndex = 0;
            len = verticles.length;
            tIndex = -1;
            for (i = 0; i < len; i += 2) {
                if (tIndex < 0 || (min == (verticles[tIndex + offI] < verticles[i + offI]))) {
                    tIndex = i;
                }
            }
            return tIndex;
        };
        MeshTools.findBestTriangle = function (verticles) {
            var topI = 0;
            topI = MeshTools.findEdge(verticles, 1, true);
            var bottomI = 0;
            bottomI = MeshTools.findEdge(verticles, 1, false);
            var leftI = 0;
            leftI = MeshTools.findEdge(verticles, 0, true);
            var rightI = 0;
            rightI = MeshTools.findEdge(verticles, 0, false);
            var rst;
            rst = MeshTools._bestTriangle;
            rst.length = 0;
            rst.push(leftI, rightI);
            if (rst.indexOf(topI) < 0)
                rst.push(topI);
            if (rst.indexOf(bottomI) < 0)
                rst.push(bottomI);
            return rst;
        };
        MeshTools.solveMesh = function (mesh, rst) {
            rst = rst || [];
            rst.length = 0;
            var mUv;
            mUv = mesh.uvs;
            var mVer;
            mVer = mesh.vertices;
            var uvAbs;
            var indexs;
            indexs = MeshTools.findBestTriangle(mUv);
            var index0 = 0;
            var index1 = 0;
            var index2 = 0;
            index0 = indexs[0];
            index1 = indexs[1];
            index2 = indexs[2];
            MeshTools._absArr.length = 0;
            uvAbs = MeshTools.solvePoints(mesh.texture.uv, mUv[index0], mUv[index0 + 1], mUv[index1] - mUv[index0], mUv[index1 + 1] - mUv[index0 + 1], mUv[index2] - mUv[index0], mUv[index2 + 1] - mUv[index0 + 1], MeshTools._absArr);
            var newVerticles;
            newVerticles = MeshTools.transPoints(uvAbs, mVer[index0], mVer[index0 + 1], mVer[index1] - mVer[index0], mVer[index1 + 1] - mVer[index0 + 1], mVer[index2] - mVer[index0], mVer[index2 + 1] - mVer[index0 + 1], rst);
            return newVerticles;
        };
        MeshTools.solvePoints = function (pointList, oX, oY, v1x, v1y, v2x, v2y, rst) {
            rst = rst || [];
            var i = 0, len = 0;
            len = pointList.length;
            var tRst;
            for (i = 0; i < len; i += 2) {
                tRst = MeshTools.solve2(pointList[i], pointList[i + 1], oX, oY, v1x, v1y, v2x, v2y);
                rst.push(tRst[0], tRst[1]);
            }
            return rst;
        };
        MeshTools.transPoints = function (abs, oX, oY, v1x, v1y, v2x, v2y, rst) {
            rst = rst || [];
            var i = 0, len = 0;
            len = abs.length;
            var tRst;
            for (i = 0; i < len; i += 2) {
                tRst = MeshTools.transPoint(abs[i], abs[i + 1], oX, oY, v1x, v1y, v2x, v2y, rst);
            }
            return rst;
        };
        MeshTools.transPoint = function (a, b, oX, oY, v1x, v1y, v2x, v2y, rst) {
            rst = rst || [];
            var nX = NaN;
            var nY = NaN;
            nX = oX + v1x * a + v2x * b;
            nY = oY + v1y * a + v2y * b;
            rst.push(nX, nY);
            return rst;
        };
        MeshTools.solve2 = function (rx, ry, oX, oY, v1x, v1y, v2x, v2y, rv, rst) {
            (rv === void 0) && (rv = false);
            rst = rst || [];
            var a = NaN, b = NaN;
            if (v1x == 0) {
                return MeshTools.solve2(rx, ry, oX, oY, v2x, v2y, v1x, v1y, true, rst);
            }
            ;
            var dX = NaN;
            var dY = NaN;
            dX = rx - oX;
            dY = ry - oY;
            b = (dY - dX * v1y / v1x) / (v2y - v2x * v1y / v1x);
            a = (dX - b * v2x) / v1x;
            if (rv) {
                rst.push(b, a);
            }
            else {
                rst.push(a, b);
            }
            return rst;
        };
        MeshTools.solve = function (pointC, point0, v1, v2) {
            return MeshTools.solve2(pointC.x, pointC.y, point0.x, point0.y, v1.x, v1.y, v2.x, v2.y);
        };
        MeshTools._bestTriangle = [];
        MeshTools._absArr = [];
        return MeshTools;
    })();
    var PathConstraint = (function () {
        function PathConstraint(data, bones) {
            this.target = null;
            this.data = null;
            this.bones = null;
            this.position = NaN;
            this.spacing = NaN;
            this.rotateMix = NaN;
            this.translateMix = NaN;
            this._debugKey = false;
            this._spaces = null;
            this._segments = [];
            this._curves = [];
            this.data = data;
            this.position = data.position;
            this.spacing = data.spacing;
            this.rotateMix = data.rotateMix;
            this.translateMix = data.translateMix;
            this.bones = [];
            var tBoneIds = this.data.bones;
            for (var i = 0, n = tBoneIds.length; i < n; i++) {
                this.bones.push(bones[tBoneIds[i]]);
            }
        }
        __class(PathConstraint, 'laya.ani.bone.PathConstraint');
        var __proto = PathConstraint.prototype;
        __proto.apply = function (boneList, graphics) {
            if (!this.target)
                return;
            var tTranslateMix = this.translateMix;
            var tRotateMix = this.translateMix;
            var tTranslate = tTranslateMix > 0;
            var tRotate = tRotateMix > 0;
            var tSpacingMode = this.data.spacingMode;
            var tLengthSpacing = tSpacingMode == "length";
            var tRotateMode = this.data.rotateMode;
            var tTangents = tRotateMode == "tangent";
            var tScale = tRotateMode == "chainScale";
            var lengths = [];
            var boneCount = this.bones.length;
            var spacesCount = tTangents ? boneCount : boneCount + 1;
            var spaces = [];
            this._spaces = spaces;
            spaces[0] = this.position;
            var spacing = this.spacing;
            if (tScale || tLengthSpacing) {
                for (var i = 0, n = spacesCount - 1; i < n;) {
                    var bone = this.bones[i];
                    var length = bone.length;
                    var x = length * bone.resultMatrix.a;
                    var y = length * bone.resultMatrix.b;
                    length = Math.sqrt(x * x + y * y);
                    if (tScale)
                        lengths[i] = length;
                    spaces[++i] = tLengthSpacing ? Math.max(0, length + spacing) : spacing;
                }
            }
            else {
                for (i = 1; i < spacesCount; i++) {
                    spaces[i] = spacing;
                }
            }
            ;
            var positions = this.computeWorldPositions(this.target, boneList, graphics, spacesCount, tTangents, this.data.positionMode == "percent", tSpacingMode == "percent");
            if (this._debugKey) {
                for (i = 0; i < positions.length; i++) {
                    graphics.drawCircle(positions[i++], positions[i++], 5, "#00ff00");
                }
                ;
                var tLinePos = [];
                for (i = 0; i < positions.length; i++) {
                    tLinePos.push(positions[i++], positions[i++]);
                }
                graphics.drawLines(0, 0, tLinePos, "#ff0000");
            }
            ;
            var skeletonX = NaN;
            var skeletonY = NaN;
            var boneX = positions[0];
            var boneY = positions[1];
            var offsetRotation = this.data.offsetRotation;
            var tip = tRotateMode == "chain" && offsetRotation == 0;
            var p = NaN;
            for (i = 0, p = 3; i < boneCount; i++, p += 3) {
                bone = this.bones[i];
                bone.resultMatrix.tx += (boneX - bone.resultMatrix.tx) * tTranslateMix;
                bone.resultMatrix.ty += (boneY - bone.resultMatrix.ty) * tTranslateMix;
                x = positions[p];
                y = positions[p + 1];
                var dx = x - boneX, dy = y - boneY;
                if (tScale) {
                    length = lengths[i];
                    if (length != 0) {
                        var s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * tRotateMix + 1;
                        bone.resultMatrix.a *= s;
                        bone.resultMatrix.c *= s;
                    }
                }
                boneX = x;
                boneY = y;
                if (tRotate) {
                    var a = bone.resultMatrix.a;
                    var b = bone.resultMatrix.c;
                    var c = bone.resultMatrix.b;
                    var d = bone.resultMatrix.d;
                    var r = NaN;
                    var cos = NaN;
                    var sin = NaN;
                    if (tTangents) {
                        r = positions[p - 1];
                    }
                    else if (spaces[i + 1] == 0) {
                        r = positions[p + 2];
                    }
                    else {
                        r = Math.atan2(dy, dx);
                    }
                    r -= Math.atan2(c, a) - offsetRotation / 180 * Math.PI;
                    if (tip) {
                        cos = Math.cos(r);
                        sin = Math.sin(r);
                        length = bone.length;
                        boneX += (length * (cos * a - sin * c) - dx) * tRotateMix;
                        boneY += (length * (sin * a + cos * c) - dy) * tRotateMix;
                    }
                    if (r > Math.PI) {
                        r -= (Math.PI * 2);
                    }
                    else if (r < -Math.PI) {
                        r += (Math.PI * 2);
                    }
                    r *= tRotateMix;
                    cos = Math.cos(r);
                    sin = Math.sin(r);
                    bone.resultMatrix.a = cos * a - sin * c;
                    bone.resultMatrix.c = cos * b - sin * d;
                    bone.resultMatrix.b = sin * a + cos * c;
                    bone.resultMatrix.d = sin * b + cos * d;
                }
            }
        };
        __proto.computeWorldVertices2 = function (boneSlot, boneList, start, count, worldVertices, offset) {
            var tBones = boneSlot.currDisplayData.bones;
            var tWeights = boneSlot.currDisplayData.weights;
            var tTriangles = boneSlot.currDisplayData.triangles;
            var tMatrix;
            var i = 0;
            var v = 0;
            var skip = 0;
            var n = 0;
            var w = 0;
            var b = 0;
            var wx = 0;
            var wy = 0;
            var vx = 0;
            var vy = 0;
            var bone;
            var len = 0;
            if (tBones == null) {
                if (!tTriangles)
                    tTriangles = tWeights;
                if (boneSlot.deformData)
                    tTriangles = boneSlot.deformData;
                var parentName;
                parentName = boneSlot.parent;
                if (boneList) {
                    len = boneList.length;
                    for (i = 0; i < len; i++) {
                        if (boneList[i].name == parentName) {
                            bone = boneList[i];
                            break;
                        }
                    }
                }
                ;
                var tBoneMt;
                if (bone) {
                    tBoneMt = bone.resultMatrix;
                }
                if (!tBoneMt)
                    tBoneMt = PathConstraint._tempMt;
                var x = tBoneMt.tx;
                var y = tBoneMt.ty;
                var a = tBoneMt.a, bb = tBoneMt.b, c = tBoneMt.c, d = tBoneMt.d;
                if (bone)
                    d *= bone.d;
                for (v = start, w = offset; w < count; v += 2, w += 2) {
                    vx = tTriangles[v], vy = tTriangles[v + 1];
                    worldVertices[w] = vx * a + vy * bb + x;
                    worldVertices[w + 1] = -(vx * c + vy * d + y);
                }
                return;
            }
            for (i = 0; i < start; i += 2) {
                n = tBones[v];
                v += n + 1;
                skip += n;
            }
            ;
            var skeletonBones = boneList;
            for (w = offset, b = skip * 3; w < count; w += 2) {
                wx = 0, wy = 0;
                n = tBones[v++];
                n += v;
                for (; v < n; v++, b += 3) {
                    tMatrix = skeletonBones[tBones[v]].resultMatrix;
                    vx = tWeights[b];
                    vy = tWeights[b + 1];
                    var weight = tWeights[b + 2];
                    wx += (vx * tMatrix.a + vy * tMatrix.c + tMatrix.tx) * weight;
                    wy += (vx * tMatrix.b + vy * tMatrix.d + tMatrix.ty) * weight;
                }
                worldVertices[w] = wx;
                worldVertices[w + 1] = wy;
            }
        };
        __proto.computeWorldPositions = function (boneSlot, boneList, graphics, spacesCount, tangents, percentPosition, percentSpacing) {
            var tBones = boneSlot.currDisplayData.bones;
            var tWeights = boneSlot.currDisplayData.weights;
            var tTriangles = boneSlot.currDisplayData.triangles;
            var tRx = 0;
            var tRy = 0;
            var nn = 0;
            var tMatrix;
            var tX = NaN;
            var tY = NaN;
            var tB = 0;
            var tWeight = 0;
            var tVertices = [];
            var i = 0, j = 0, n = 0;
            var verticesLength = boneSlot.currDisplayData.verLen;
            var target = boneSlot;
            var position = this.position;
            var spaces = this._spaces;
            var world = [];
            var out = [];
            var closed = false;
            var curveCount = verticesLength / 6;
            var prevCurve = -1;
            var pathLength = NaN;
            var o = 0, curve = 0;
            var p = NaN;
            var space = NaN;
            var prev = NaN;
            var length = NaN;
            if (!true) {
                var lengths = boneSlot.currDisplayData.lengths;
                curveCount -= closed ? 1 : 2;
                pathLength = lengths[curveCount];
                if (percentPosition)
                    position *= pathLength;
                if (percentSpacing) {
                    for (i = 0; i < spacesCount; i++)
                        spaces[i] *= pathLength;
                }
                world.length = 8;
                for (i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {
                    space = spaces[i];
                    position += space;
                    p = position;
                    if (closed) {
                        p %= pathLength;
                        if (p < 0)
                            p += pathLength;
                        curve = 0;
                    }
                    else if (p < 0) {
                        if (prevCurve != PathConstraint.BEFORE) {
                            prevCurve = PathConstraint.BEFORE;
                            this.computeWorldVertices2(target, boneList, 2, 4, world, 0);
                        }
                        this.addBeforePosition(p, world, 0, out, o);
                        continue;
                    }
                    else if (p > pathLength) {
                        if (prevCurve != PathConstraint.AFTER) {
                            prevCurve = PathConstraint.AFTER;
                            this.computeWorldVertices2(target, boneList, verticesLength - 6, 4, world, 0);
                        }
                        this.addAfterPosition(p - pathLength, world, 0, out, o);
                        continue;
                    }
                    for (; ; curve++) {
                        length = lengths[curve];
                        if (p > length)
                            continue;
                        if (curve == 0)
                            p /= length;
                        else {
                            prev = lengths[curve - 1];
                            p = (p - prev) / (length - prev);
                        }
                        break;
                    }
                    if (curve != prevCurve) {
                        prevCurve = curve;
                        if (closed && curve == curveCount) {
                            this.computeWorldVertices2(target, boneList, verticesLength - 4, 4, world, 0);
                            this.computeWorldVertices2(target, boneList, 0, 4, world, 4);
                        }
                        else
                            this.computeWorldVertices2(target, boneList, curve * 6 + 2, 8, world, 0);
                    }
                    this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || (i > 0 && space == 0));
                }
                return out;
            }
            if (closed) {
                verticesLength += 2;
                world[verticesLength - 2] = world[0];
                world[verticesLength - 1] = world[1];
            }
            else {
                curveCount--;
                verticesLength -= 4;
                this.computeWorldVertices2(boneSlot, boneList, 2, verticesLength, tVertices, 0);
                if (this._debugKey) {
                    for (i = 0; i < tVertices.length;) {
                        graphics.drawCircle(tVertices[i++], tVertices[i++], 10, "#ff0000");
                    }
                }
                world = tVertices;
            }
            this._curves.length = curveCount;
            var curves = this._curves;
            pathLength = 0;
            var x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;
            var tmpx = NaN, tmpy = NaN, dddfx = NaN, dddfy = NaN, ddfx = NaN, ddfy = NaN, dfx = NaN, dfy = NaN;
            var w = 0;
            for (i = 0, w = 2; i < curveCount; i++, w += 6) {
                cx1 = world[w];
                cy1 = world[w + 1];
                cx2 = world[w + 2];
                cy2 = world[w + 3];
                x2 = world[w + 4];
                y2 = world[w + 5];
                tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;
                tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;
                dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;
                dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;
                ddfx = tmpx * 2 + dddfx;
                ddfy = tmpy * 2 + dddfy;
                dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;
                dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;
                pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                dfx += ddfx;
                dfy += ddfy;
                ddfx += dddfx;
                ddfy += dddfy;
                pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                dfx += ddfx;
                dfy += ddfy;
                pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                dfx += ddfx + dddfx;
                dfy += ddfy + dddfy;
                pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                curves[i] = pathLength;
                x1 = x2;
                y1 = y2;
            }
            if (percentPosition)
                position *= pathLength;
            if (percentSpacing) {
                for (i = 0; i < spacesCount; i++)
                    spaces[i] *= pathLength;
            }
            ;
            var segments = this._segments;
            var curveLength = 0;
            var segment = 0;
            for (i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {
                space = spaces[i];
                position += space;
                p = position;
                if (closed) {
                    p %= pathLength;
                    if (p < 0)
                        p += pathLength;
                    curve = 0;
                }
                else if (p < 0) {
                    this.addBeforePosition(p, world, 0, out, o);
                    continue;
                }
                else if (p > pathLength) {
                    this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);
                    continue;
                }
                for (; ; curve++) {
                    length = curves[curve];
                    if (p > length)
                        continue;
                    if (curve == 0)
                        p /= length;
                    else {
                        prev = curves[curve - 1];
                        p = (p - prev) / (length - prev);
                    }
                    break;
                }
                if (curve != prevCurve) {
                    prevCurve = curve;
                    var ii = curve * 6;
                    x1 = world[ii];
                    y1 = world[ii + 1];
                    cx1 = world[ii + 2];
                    cy1 = world[ii + 3];
                    cx2 = world[ii + 4];
                    cy2 = world[ii + 5];
                    x2 = world[ii + 6];
                    y2 = world[ii + 7];
                    tmpx = (x1 - cx1 * 2 + cx2) * 0.03;
                    tmpy = (y1 - cy1 * 2 + cy2) * 0.03;
                    dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;
                    dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;
                    ddfx = tmpx * 2 + dddfx;
                    ddfy = tmpy * 2 + dddfy;
                    dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;
                    dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;
                    curveLength = Math.sqrt(dfx * dfx + dfy * dfy);
                    segments[0] = curveLength;
                    for (ii = 1; ii < 8; ii++) {
                        dfx += ddfx;
                        dfy += ddfy;
                        ddfx += dddfx;
                        ddfy += dddfy;
                        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
                        segments[ii] = curveLength;
                    }
                    dfx += ddfx;
                    dfy += ddfy;
                    curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
                    segments[8] = curveLength;
                    dfx += ddfx + dddfx;
                    dfy += ddfy + dddfy;
                    curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
                    segments[9] = curveLength;
                    segment = 0;
                }
                p *= curveLength;
                for (; ; segment++) {
                    length = segments[segment];
                    if (p > length)
                        continue;
                    if (segment == 0)
                        p /= length;
                    else {
                        prev = segments[segment - 1];
                        p = segment + (p - prev) / (length - prev);
                    }
                    break;
                }
                this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || (i > 0 && space == 0));
            }
            return out;
        };
        __proto.addBeforePosition = function (p, temp, i, out, o) {
            var x1 = temp[i], y1 = temp[i + 1], dx = temp[i + 2] - x1, dy = temp[i + 3] - y1, r = Math.atan2(dy, dx);
            out[o] = x1 + p * Math.cos(r);
            out[o + 1] = y1 + p * Math.sin(r);
            out[o + 2] = r;
        };
        __proto.addAfterPosition = function (p, temp, i, out, o) {
            var x1 = temp[i + 2], y1 = temp[i + 3], dx = x1 - temp[i], dy = y1 - temp[i + 1], r = Math.atan2(dy, dx);
            out[o] = x1 + p * Math.cos(r);
            out[o + 1] = y1 + p * Math.sin(r);
            out[o + 2] = r;
        };
        __proto.addCurvePosition = function (p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {
            if (p == 0)
                p = 0.0001;
            var tt = p * p, ttt = tt * p, u = 1 - p, uu = u * u, uuu = uu * u;
            var ut = u * p, ut3 = ut * 3, uut3 = u * ut3, utt3 = ut3 * p;
            var x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;
            out[o] = x;
            out[o + 1] = y;
            if (tangents) {
                out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));
            }
            else {
                out[o + 2] = 0;
            }
        };
        PathConstraint.NONE = -1;
        PathConstraint.BEFORE = -2;
        PathConstraint.AFTER = -3;
        __static(PathConstraint, ['_tempMt', function () { return this._tempMt = new Matrix(); }
        ]);
        return PathConstraint;
    })();
    var PathConstraintData = (function () {
        function PathConstraintData() {
            this.name = null;
            this.target = null;
            this.positionMode = null;
            this.spacingMode = null;
            this.rotateMode = null;
            this.offsetRotation = NaN;
            this.position = NaN;
            this.spacing = NaN;
            this.rotateMix = NaN;
            this.translateMix = NaN;
            this.bones = [];
        }
        __class(PathConstraintData, 'laya.ani.bone.PathConstraintData');
        return PathConstraintData;
    })();
    var SkinData = (function () {
        function SkinData() {
            this.name = null;
            this.slotArr = [];
        }
        __class(SkinData, 'laya.ani.bone.SkinData');
        return SkinData;
    })();
    var SkinSlotDisplayData = (function () {
        function SkinSlotDisplayData() {
            this.name = null;
            this.attachmentName = null;
            this.type = 0;
            this.transform = null;
            this.width = NaN;
            this.height = NaN;
            this.texture = null;
            this.bones = null;
            this.uvs = null;
            this.weights = null;
            this.triangles = null;
            this.vertices = null;
            this.lengths = null;
            this.verLen = 0;
        }
        __class(SkinSlotDisplayData, 'laya.ani.bone.SkinSlotDisplayData');
        var __proto = SkinSlotDisplayData.prototype;
        __proto.createTexture = function (currTexture) {
            if (this.texture)
                return this.texture;
            this.texture = new Texture(currTexture.bitmap, this.uvs);
            if (this.uvs[0] > this.uvs[4]
                && this.uvs[1] > this.uvs[5]) {
                this.texture.width = currTexture.height;
                this.texture.height = currTexture.width;
                this.texture.offsetX = -currTexture.offsetX;
                this.texture.offsetY = -currTexture.offsetY;
                this.texture.sourceWidth = currTexture.sourceHeight;
                this.texture.sourceHeight = currTexture.sourceWidth;
            }
            else {
                this.texture.width = currTexture.width;
                this.texture.height = currTexture.height;
                this.texture.offsetX = -currTexture.offsetX;
                this.texture.offsetY = -currTexture.offsetY;
                this.texture.sourceWidth = currTexture.sourceWidth;
                this.texture.sourceHeight = currTexture.sourceHeight;
            }
            if (!Render.isWebGL) {
                if (this.uvs[1] > this.uvs[5]) {
                    this.texture.offsetY = this.texture.sourceHeight - this.texture.height - this.texture.offsetY;
                }
            }
            return this.texture;
        };
        __proto.destory = function () {
            if (this.texture)
                this.texture.destroy();
        };
        return SkinSlotDisplayData;
    })();
    var SlotData = (function () {
        function SlotData() {
            this.name = null;
            this.displayArr = [];
        }
        __class(SlotData, 'laya.ani.bone.SlotData');
        var __proto = SlotData.prototype;
        __proto.getDisplayByName = function (name) {
            var tDisplay;
            for (var i = 0, n = this.displayArr.length; i < n; i++) {
                tDisplay = this.displayArr[i];
                if (tDisplay.attachmentName == name) {
                    return i;
                }
            }
            return -1;
        };
        return SlotData;
    })();
    var TfConstraint = (function () {
        function TfConstraint(data, bones) {
            this._data = null;
            this._bones = null;
            this.target = null;
            this.rotateMix = NaN;
            this.translateMix = NaN;
            this.scaleMix = NaN;
            this.shearMix = NaN;
            this._temp = __newvec(2, 0);
            this._data = data;
            if (this._bones == null) {
                this._bones = [];
            }
            this.target = bones[data.targetIndex];
            var j = 0, n = 0;
            for (j = 0, n = data.boneIndexs.length; j < n; j++) {
                this._bones.push(bones[data.boneIndexs[j]]);
            }
            this.rotateMix = data.rotateMix;
            this.translateMix = data.translateMix;
            this.scaleMix = data.scaleMix;
            this.shearMix = data.shearMix;
        }
        __class(TfConstraint, 'laya.ani.bone.TfConstraint');
        var __proto = TfConstraint.prototype;
        __proto.apply = function () {
            var tTfBone;
            var ta = this.target.resultMatrix.a, tb = this.target.resultMatrix.b, tc = this.target.resultMatrix.c, td = this.target.resultMatrix.d;
            for (var j = 0, n = this._bones.length; j < n; j++) {
                tTfBone = this._bones[j];
                if (this.rotateMix > 0) {
                    var a = tTfBone.resultMatrix.a, b = tTfBone.resultMatrix.b, c = tTfBone.resultMatrix.c, d = tTfBone.resultMatrix.d;
                    var r = Math.atan2(tc, ta) - Math.atan2(c, a) + this._data.offsetRotation * Math.PI / 180;
                    if (r > Math.PI)
                        r -= Math.PI * 2;
                    else if (r < -Math.PI)
                        r += Math.PI * 2;
                    r *= this.rotateMix;
                    var cos = Math.cos(r), sin = Math.sin(r);
                    tTfBone.resultMatrix.a = cos * a - sin * c;
                    tTfBone.resultMatrix.b = cos * b - sin * d;
                    tTfBone.resultMatrix.c = sin * a + cos * c;
                    tTfBone.resultMatrix.d = sin * b + cos * d;
                }
                if (this.translateMix) {
                    this._temp[0] = this._data.offsetX;
                    this._temp[1] = this._data.offsetY;
                    this.target.localToWorld(this._temp);
                    tTfBone.resultMatrix.tx += (this._temp[0] - tTfBone.resultMatrix.tx) * this.translateMix;
                    tTfBone.resultMatrix.ty += (this._temp[1] - tTfBone.resultMatrix.ty) * this.translateMix;
                    tTfBone.updateChild();
                }
                if (this.scaleMix > 0) {
                    var bs = Math.sqrt(tTfBone.resultMatrix.a * tTfBone.resultMatrix.a + tTfBone.resultMatrix.c * tTfBone.resultMatrix.c);
                    var ts = Math.sqrt(ta * ta + tc * tc);
                    var s = bs > 0.00001 ? (bs + (ts - bs + this._data.offsetScaleX) * this.scaleMix) / bs : 0;
                    tTfBone.resultMatrix.a *= s;
                    tTfBone.resultMatrix.c *= s;
                    bs = Math.sqrt(tTfBone.resultMatrix.b * tTfBone.resultMatrix.b + tTfBone.resultMatrix.d * tTfBone.resultMatrix.d);
                    ts = Math.sqrt(tb * tb + td * td);
                    s = bs > 0.00001 ? (bs + (ts - bs + this._data.offsetScaleY) * this.scaleMix) / bs : 0;
                    tTfBone.resultMatrix.b *= s;
                    tTfBone.resultMatrix.d *= s;
                }
                if (this.shearMix > 0) {
                    b = tTfBone.resultMatrix.b, d = tTfBone.resultMatrix.d;
                    var by = Math.atan2(d, b);
                    r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(tTfBone.resultMatrix.c, tTfBone.resultMatrix.a));
                    if (r > Math.PI)
                        r -= Math.PI * 2;
                    else if (r < -Math.PI)
                        r += Math.PI * 2;
                    r = by + (r + this._data.offsetShearY * Math.PI / 180) * this.shearMix;
                    s = Math.sqrt(b * b + d * d);
                    tTfBone.resultMatrix.b = Math.cos(r) * s;
                    tTfBone.resultMatrix.d = Math.sin(r) * s;
                }
            }
        };
        return TfConstraint;
    })();
    var TfConstraintData = (function () {
        function TfConstraintData() {
            this.name = null;
            this.targetIndex = 0;
            this.rotateMix = NaN;
            this.translateMix = NaN;
            this.scaleMix = NaN;
            this.shearMix = NaN;
            this.offsetRotation = NaN;
            this.offsetX = NaN;
            this.offsetY = NaN;
            this.offsetScaleX = NaN;
            this.offsetScaleY = NaN;
            this.offsetShearY = NaN;
            this.boneIndexs = [];
        }
        __class(TfConstraintData, 'laya.ani.bone.TfConstraintData');
        return TfConstraintData;
    })();
    var Transform = (function () {
        function Transform() {
            this.skX = 0;
            this.skY = 0;
            this.scX = 1;
            this.scY = 1;
            this.x = 0;
            this.y = 0;
            this.skewX = 0;
            this.skewY = 0;
            this.mMatrix = null;
        }
        __class(Transform, 'laya.ani.bone.Transform');
        var __proto = Transform.prototype;
        __proto.initData = function (data) {
            if (data.x != undefined) {
                this.x = data.x;
            }
            if (data.y != undefined) {
                this.y = data.y;
            }
            if (data.skX != undefined) {
                this.skX = data.skX;
            }
            if (data.skY != undefined) {
                this.skY = data.skY;
            }
            if (data.scX != undefined) {
                this.scX = data.scX;
            }
            if (data.scY != undefined) {
                this.scY = data.scY;
            }
        };
        __proto.getMatrix = function () {
            var tMatrix;
            if (this.mMatrix) {
                tMatrix = this.mMatrix;
            }
            else {
                tMatrix = this.mMatrix = new Matrix();
            }
            tMatrix.identity();
            tMatrix.scale(this.scX, this.scY);
            if (this.skewX || this.skewY) {
                this.skew(tMatrix, this.skewX * Math.PI / 180, this.skewY * Math.PI / 180);
            }
            tMatrix.rotate(this.skX * Math.PI / 180);
            tMatrix.translate(this.x, this.y);
            return tMatrix;
        };
        __proto.skew = function (m, x, y) {
            var sinX = Math.sin(y);
            var cosX = Math.cos(y);
            var sinY = Math.sin(x);
            var cosY = Math.cos(x);
            m.setTo(m.a * cosY - m.b * sinX, m.a * sinY + m.b * cosX, m.c * cosY - m.d * sinX, m.c * sinY + m.d * cosX, m.tx * cosY - m.ty * sinX, m.tx * sinY + m.ty * cosX);
            return m;
        };
        return Transform;
    })();
    var UVTools = (function () {
        function UVTools() { }
        __class(UVTools, 'laya.ani.bone.UVTools');
        UVTools.getRelativeUV = function (bigUV, smallUV, rst) {
            var startX = bigUV[0];
            var width = bigUV[2] - bigUV[0];
            var startY = bigUV[1];
            var height = bigUV[5] - bigUV[1];
            if (!rst)
                rst = [];
            rst.length = smallUV.length;
            var i = 0, len = 0;
            len = rst.length;
            var dWidth = 1 / width;
            var dHeight = 1 / height;
            for (i = 0; i < len; i += 2) {
                rst[i] = (smallUV[i] - startX) * dWidth;
                rst[i + 1] = (smallUV[i + 1] - startY) * dHeight;
            }
            return rst;
        };
        UVTools.getAbsoluteUV = function (bigUV, smallUV, rst) {
            if (bigUV[0] == 0 && bigUV[1] == 0 && bigUV[4] == 1 && bigUV[5] == 1) {
                if (rst) {
                    Utils.copyArray(rst, smallUV);
                    return rst;
                }
                else {
                    return smallUV;
                }
            }
            ;
            var startX = bigUV[0];
            var width = bigUV[2] - bigUV[0];
            var startY = bigUV[1];
            var height = bigUV[5] - bigUV[1];
            if (!rst)
                rst = [];
            rst.length = smallUV.length;
            var i = 0, len = 0;
            len = rst.length;
            for (i = 0; i < len; i += 2) {
                rst[i] = smallUV[i] * width + startX;
                rst[i + 1] = smallUV[i + 1] * height + startY;
            }
            return rst;
        };
        return UVTools;
    })();
    var KeyFramesContent = (function () {
        function KeyFramesContent() {
            this.startTime = NaN;
            this.duration = NaN;
            this.interpolationData = null;
            this.data = null;
            this.nextData = null;
        }
        __class(KeyFramesContent, 'laya.ani.KeyFramesContent');
        return KeyFramesContent;
    })();
    var BezierLerp = (function () {
        function BezierLerp() { }
        __class(BezierLerp, 'laya.ani.math.BezierLerp');
        BezierLerp.getBezierRate = function (t, px0, py0, px1, py1) {
            var key = BezierLerp._getBezierParamKey(px0, py0, px1, py1);
            var vKey = key * 100 + t;
            if (BezierLerp._bezierResultCache[vKey])
                return BezierLerp._bezierResultCache[vKey];
            var points = BezierLerp._getBezierPoints(px0, py0, px1, py1, key);
            var i = 0, len = 0;
            len = points.length;
            for (i = 0; i < len; i += 2) {
                if (t <= points[i]) {
                    BezierLerp._bezierResultCache[vKey] = points[i + 1];
                    return points[i + 1];
                }
            }
            BezierLerp._bezierResultCache[vKey] = 1;
            return 1;
        };
        BezierLerp._getBezierParamKey = function (px0, py0, px1, py1) {
            return (((px0 * 100 + py0) * 100 + px1) * 100 + py1) * 100;
        };
        BezierLerp._getBezierPoints = function (px0, py0, px1, py1, key) {
            if (BezierLerp._bezierPointsCache[key])
                return BezierLerp._bezierPointsCache[key];
            var controlPoints;
            controlPoints = [0, 0, px0, py0, px1, py1, 1, 1];
            var bz;
            bz = new Bezier();
            var points;
            points = bz.getBezierPoints(controlPoints, 100, 3);
            BezierLerp._bezierPointsCache[key] = points;
            return points;
        };
        BezierLerp._bezierResultCache = {};
        BezierLerp._bezierPointsCache = {};
        return BezierLerp;
    })();
    var AnimationPlayer = (function (_super) {
        function AnimationPlayer() {
            this._destroyed = false;
            this._templet = null;
            this._currentTime = NaN;
            this._currentFrameTime = NaN;
            this._playStart = NaN;
            this._playEnd = NaN;
            this._playDuration = NaN;
            this._overallDuration = NaN;
            this._stopWhenCircleFinish = false;
            this._elapsedPlaybackTime = NaN;
            this._startUpdateLoopCount = NaN;
            this._currentAnimationClipIndex = 0;
            this._currentKeyframeIndex = 0;
            this._paused = false;
            this._cacheFrameRate = 0;
            this._cacheFrameRateInterval = NaN;
            this._cachePlayRate = NaN;
            this._fullFrames = null;
            this.isCache = true;
            this.playbackRate = 1.0;
            this.returnToZeroStopped = false;
            AnimationPlayer.__super.call(this);
            this._destroyed = false;
            this._currentAnimationClipIndex = -1;
            this._currentKeyframeIndex = -1;
            this._currentTime = 0.0;
            this._overallDuration = Number.MAX_VALUE;
            this._stopWhenCircleFinish = false;
            this._elapsedPlaybackTime = 0;
            this._startUpdateLoopCount = -1;
            this._cachePlayRate = 1.0;
            this.cacheFrameRate = 60;
            this.returnToZeroStopped = false;
        }
        __class(AnimationPlayer, 'laya.ani.AnimationPlayer', _super);
        var __proto = AnimationPlayer.prototype;
        Laya.imps(__proto, { "laya.resource.IDestroy": true });
        __proto._onTempletLoadedComputeFullKeyframeIndices = function (cachePlayRate, cacheFrameRate, templet) {
            if (this._templet === templet && this._cachePlayRate === cachePlayRate && this._cacheFrameRate === cacheFrameRate)
                this._computeFullKeyframeIndices();
        };
        __proto._computeFullKeyframeIndices = function () {
            var anifullFrames = this._fullFrames = [];
            var templet = this._templet;
            var cacheFrameInterval = this._cacheFrameRateInterval * this._cachePlayRate;
            for (var i = 0, iNum = templet.getAnimationCount(); i < iNum; i++) {
                var aniFullFrame = [];
                for (var j = 0, jNum = templet.getAnimation(i).nodes.length; j < jNum; j++) {
                    var node = templet.getAnimation(i).nodes[j];
                    var frameCount = Math.floor(node.playTime / cacheFrameInterval + 0.01);
                    var nodeFullFrames = new Uint16Array(frameCount + 1);
                    var lastFrameIndex = -1;
                    for (var n = 0, nNum = node.keyFrame.length; n < nNum; n++) {
                        var keyFrame = node.keyFrame[n];
                        var tm = keyFrame.startTime;
                        var endTm = tm + keyFrame.duration + cacheFrameInterval;
                        do {
                            var frameIndex = Math.floor(tm / cacheFrameInterval + 0.5);
                            for (var k = lastFrameIndex + 1; k < frameIndex; k++)
                                nodeFullFrames[k] = n;
                            lastFrameIndex = frameIndex;
                            nodeFullFrames[frameIndex] = n;
                            tm += cacheFrameInterval;
                        } while (tm <= endTm);
                    }
                    aniFullFrame.push(nodeFullFrames);
                }
                anifullFrames.push(aniFullFrame);
            }
        };
        __proto._onAnimationTempletLoaded = function () {
            (this.destroyed) || (this._calculatePlayDuration());
        };
        __proto._calculatePlayDuration = function () {
            if (this.state !== 0) {
                var oriDuration = this._templet.getAniDuration(this._currentAnimationClipIndex);
                (this._playEnd === 0) && (this._playEnd = oriDuration);
                if (this._playEnd > oriDuration)
                    this._playEnd = oriDuration;
                this._playDuration = this._playEnd - this._playStart;
            }
        };
        __proto._setPlayParams = function (time, cacheFrameInterval) {
            this._currentTime = time;
            this._currentKeyframeIndex = Math.max(Math.floor((this.currentPlayTime) / cacheFrameInterval + 0.01), 0);
            this._currentFrameTime = this._currentKeyframeIndex * cacheFrameInterval;
        };
        __proto._setPlayParamsWhenStop = function (currentAniClipPlayDuration, cacheFrameInterval) {
            this._currentTime = currentAniClipPlayDuration;
            this._currentKeyframeIndex = Math.max(Math.floor(currentAniClipPlayDuration / cacheFrameInterval + 0.01), 0);
            this._currentFrameTime = this._currentKeyframeIndex * cacheFrameInterval;
            this._currentAnimationClipIndex = -1;
        };
        __proto._update = function (elapsedTime) {
            if (this._currentAnimationClipIndex === -1 || this._paused || !this._templet || !this._templet.loaded)
                return;
            var cacheFrameInterval = this._cacheFrameRateInterval * this._cachePlayRate;
            var time = 0;
            (this._startUpdateLoopCount !== Stat.loopCount) && (time = elapsedTime * this.playbackRate, this._elapsedPlaybackTime += time);
            var currentAniClipPlayDuration = this.playDuration;
            if ((this._overallDuration !== 0 && this._elapsedPlaybackTime >= this._overallDuration) || (this._overallDuration === 0 && this._elapsedPlaybackTime >= currentAniClipPlayDuration)) {
                this._setPlayParamsWhenStop(currentAniClipPlayDuration, cacheFrameInterval);
                this.event("stopped");
                return;
            }
            time += this._currentTime;
            if (currentAniClipPlayDuration > 0) {
                if (time >= currentAniClipPlayDuration) {
                    do {
                        time -= currentAniClipPlayDuration;
                        if (this._stopWhenCircleFinish) {
                            this._setPlayParamsWhenStop(currentAniClipPlayDuration, cacheFrameInterval);
                            this._stopWhenCircleFinish = false;
                            this.event("stopped");
                            return;
                        }
                        if (time < currentAniClipPlayDuration) {
                            this._setPlayParams(time, cacheFrameInterval);
                            this.event("complete");
                        }
                    } while (time >= currentAniClipPlayDuration);
                }
                else {
                    this._setPlayParams(time, cacheFrameInterval);
                }
            }
            else {
                if (this._stopWhenCircleFinish) {
                    this._setPlayParamsWhenStop(currentAniClipPlayDuration, cacheFrameInterval);
                    this._stopWhenCircleFinish = false;
                    this.event("stopped");
                    return;
                }
                this._currentTime = this._currentFrameTime = this._currentKeyframeIndex = 0;
                this.event("complete");
            }
        };
        __proto._destroy = function () {
            this.offAll();
            this._templet = null;
            this._fullFrames = null;
            this._destroyed = true;
        };
        __proto.play = function (index, playbackRate, overallDuration, playStart, playEnd) {
            (index === void 0) && (index = 0);
            (playbackRate === void 0) && (playbackRate = 1.0);
            (overallDuration === void 0) && (overallDuration = 2147483647);
            (playStart === void 0) && (playStart = 0);
            (playEnd === void 0) && (playEnd = 0);
            if (!this._templet)
                throw new Error("AnimationPlayer:templet must not be null,maybe you need to set url.");
            if (overallDuration < 0 || playStart < 0 || playEnd < 0)
                throw new Error("AnimationPlayer:overallDuration,playStart and playEnd must large than zero.");
            if ((playEnd !== 0) && (playStart > playEnd))
                throw new Error("AnimationPlayer:start must less than end.");
            this._currentTime = 0;
            this._currentFrameTime = 0;
            this._elapsedPlaybackTime = 0;
            this.playbackRate = playbackRate;
            this._overallDuration = overallDuration;
            this._playStart = playStart;
            this._playEnd = playEnd;
            this._paused = false;
            this._currentAnimationClipIndex = index;
            this._currentKeyframeIndex = 0;
            this._startUpdateLoopCount = Stat.loopCount;
            this.event("played");
            if (this._templet.loaded)
                this._calculatePlayDuration();
            else
                this._templet.once("loaded", this, this._onAnimationTempletLoaded);
            this._update(0);
        };
        __proto.playByFrame = function (index, playbackRate, overallDuration, playStartFrame, playEndFrame, fpsIn3DBuilder) {
            (index === void 0) && (index = 0);
            (playbackRate === void 0) && (playbackRate = 1.0);
            (overallDuration === void 0) && (overallDuration = 2147483647);
            (playStartFrame === void 0) && (playStartFrame = 0);
            (playEndFrame === void 0) && (playEndFrame = 0);
            (fpsIn3DBuilder === void 0) && (fpsIn3DBuilder = 30);
            var interval = 1000.0 / fpsIn3DBuilder;
            this.play(index, playbackRate, overallDuration, playStartFrame * interval, playEndFrame * interval);
        };
        __proto.stop = function (immediate) {
            (immediate === void 0) && (immediate = true);
            if (immediate) {
                this._currentTime = this._currentFrameTime = this._currentKeyframeIndex = 0;
                this._currentAnimationClipIndex = -1;
                this.event("stopped");
            }
            else {
                this._stopWhenCircleFinish = true;
            }
        };
        __getset(0, __proto, 'playEnd', function () {
            return this._playEnd;
        });
        __getset(0, __proto, 'templet', function () {
            return this._templet;
        }, function (value) {
            if (!this.state === 0)
                this.stop(true);
            if (this._templet !== value) {
                this._templet = value;
                if (value.loaded)
                    this._computeFullKeyframeIndices();
                else
                    value.once("loaded", this, this._onTempletLoadedComputeFullKeyframeIndices, [this._cachePlayRate, this._cacheFrameRate]);
            }
        });
        __getset(0, __proto, 'playStart', function () {
            return this._playStart;
        });
        __getset(0, __proto, 'playDuration', function () {
            return this._playDuration;
        });
        __getset(0, __proto, 'state', function () {
            if (this._currentAnimationClipIndex === -1)
                return 0;
            if (this._paused)
                return 1;
            return 2;
        });
        __getset(0, __proto, 'currentKeyframeIndex', function () {
            return this._currentKeyframeIndex;
        });
        __getset(0, __proto, 'overallDuration', function () {
            return this._overallDuration;
        });
        __getset(0, __proto, 'currentFrameTime', function () {
            return this._currentFrameTime;
        });
        __getset(0, __proto, 'currentAnimationClipIndex', function () {
            return this._currentAnimationClipIndex;
        });
        __getset(0, __proto, 'currentPlayTime', function () {
            return this._currentTime + this._playStart;
        });
        __getset(0, __proto, 'cachePlayRate', function () {
            return this._cachePlayRate;
        }, function (value) {
            if (this._cachePlayRate !== value) {
                this._cachePlayRate = value;
                if (this._templet)
                    if (this._templet.loaded)
                        this._computeFullKeyframeIndices();
                    else
                        this._templet.once("loaded", this, this._onTempletLoadedComputeFullKeyframeIndices, [value, this._cacheFrameRate]);
            }
        });
        __getset(0, __proto, 'cacheFrameRate', function () {
            return this._cacheFrameRate;
        }, function (value) {
            if (this._cacheFrameRate !== value) {
                this._cacheFrameRate = value;
                this._cacheFrameRateInterval = 1000.0 / this._cacheFrameRate;
                if (this._templet)
                    if (this._templet.loaded)
                        this._computeFullKeyframeIndices();
                    else
                        this._templet.once("loaded", this, this._onTempletLoadedComputeFullKeyframeIndices, [this._cachePlayRate, value]);
            }
        });
        __getset(0, __proto, 'currentTime', null, function (value) {
            if (this._currentAnimationClipIndex === -1 || !this._templet || !this._templet.loaded)
                return;
            if (value < this._playStart || value > this._playEnd)
                throw new Error("AnimationPlayer:value must large than playStartTime,small than playEndTime.");
            this._startUpdateLoopCount = Stat.loopCount;
            var cacheFrameInterval = this._cacheFrameRateInterval * this._cachePlayRate;
            this._currentTime = value;
            this._currentKeyframeIndex = Math.max(Math.floor(this.currentPlayTime / cacheFrameInterval), 0);
            this._currentFrameTime = this._currentKeyframeIndex * cacheFrameInterval;
        });
        __getset(0, __proto, 'paused', function () {
            return this._paused;
        }, function (value) {
            this._paused = value;
            value && this.event("paused");
        });
        __getset(0, __proto, 'cacheFrameRateInterval', function () {
            return this._cacheFrameRateInterval;
        });
        __getset(0, __proto, 'destroyed', function () {
            return this._destroyed;
        });
        __getset(0, __proto, 'disposed', function () {
            return this._destroyed;
        });
        return AnimationPlayer;
    })(EventDispatcher);
    var GraphicsAni = (function (_super) {
        function GraphicsAni() {
            GraphicsAni.__super.call(this);
            if (Render.isConchNode) {
                this["drawSkin"] = function (skin) {
                    skin.transform || (skin.transform = Matrix.EMPTY);
                    this.setSkinMesh && this.setSkinMesh(skin._ps, skin.mVBData, skin.mEleNum, 0, skin.mTexture, skin.transform);
                };
            }
        }
        __class(GraphicsAni, 'laya.ani.GraphicsAni', _super);
        var __proto = GraphicsAni.prototype;
        __proto.drawSkin = function (skin) {
            var arr = [skin];
            this._saveToCmd(Render._context._drawSkin, arr);
        };
        return GraphicsAni;
    })(Graphics);
    var SkinMeshCanvas = (function (_super) {
        function SkinMeshCanvas() {
            SkinMeshCanvas.__super.call(this);
            this.mesh = new MeshData();
        }
        __class(SkinMeshCanvas, 'laya.ani.bone.canvasmesh.SkinMeshCanvas', _super);
        var __proto = SkinMeshCanvas.prototype;
        __proto.init2 = function (texture, vs, ps, verticles, uvs) {
            if (this.transform) {
                this.transform = null;
            }
            ;
            var _ps;
            if (ps) {
                _ps = ps;
            }
            else {
                _ps = [];
                _ps.push(0, 1, 3, 3, 1, 2);
            }
            this.mesh.texture = texture;
            this.mesh.indexes = _ps;
            this.mesh.vertices = verticles;
            this.mesh.uvs = uvs;
        };
        __proto.render = function (context, x, y) {
            if (!this.mesh.texture)
                return;
            if (!this.transform) {
                this.transform = SkinMeshCanvas._tempMatrix;
                this.transform.identity();
                this.transform.translate(x, y);
                this.renderToContext(context);
                this.transform.translate(-x, -y);
                this.transform = null;
            }
            else {
                this.transform.translate(x, y);
                this.renderToContext(context);
                this.transform.translate(-x, -y);
            }
        };
        __static(SkinMeshCanvas, ['_tempMatrix', function () { return this._tempMatrix = new Matrix(); }
        ]);
        return SkinMeshCanvas;
    })(CanvasMeshRender);
    var AnimationTemplet = (function (_super) {
        function AnimationTemplet() {
            this._aniMap = {};
            this.unfixedLastAniIndex = -1;
            AnimationTemplet.__super.call(this);
            this._anis = new Array;
        }
        __class(AnimationTemplet, 'laya.ani.AnimationTemplet', _super);
        var __proto = AnimationTemplet.prototype;
        __proto.parse = function (data) {
            var reader = new Byte(data);
            this._aniVersion = reader.readUTFString();
            AnimationParser01.parse(this, reader);
        };
        __proto._calculateKeyFrame = function (node, keyframeCount, keyframeDataCount) {
            var keyFrames = node.keyFrame;
            keyFrames[keyframeCount] = keyFrames[0];
            for (var i = 0; i < keyframeCount; i++) {
                var keyFrame = keyFrames[i];
                keyFrame.nextData = (keyFrame.duration === 0) ? keyFrame.data : keyFrames[i + 1].data;
            }
            keyFrames.length--;
        };
        __proto.onAsynLoaded = function (url, data, params) {
            var reader = new Byte(data);
            this._aniVersion = reader.readUTFString();
            switch (this._aniVersion) {
                case "LAYAANIMATION:02":
                    AnimationParser02.parse(this, reader);
                    break;
                default:
                    AnimationParser01.parse(this, reader);
            }
            this._endLoaded();
        };
        __proto.disposeResource = function () {
            this._aniVersion = null;
            this._anis = null;
            this._aniMap = null;
            this._publicExtData = null;
            this.unfixedCurrentFrameIndexes = null;
            this.unfixedCurrentTimes = null;
            this.unfixedKeyframes = null;
            this._aniClassName = null;
            this._animationDatasCache = null;
        };
        __proto.getAnimationCount = function () {
            return this._anis.length;
        };
        __proto.getAnimation = function (aniIndex) {
            return this._anis[aniIndex];
        };
        __proto.getAniDuration = function (aniIndex) {
            return this._anis[aniIndex].playTime;
        };
        __proto.getNodes = function (aniIndex) {
            return this._anis[aniIndex].nodes;
        };
        __proto.getNodeIndexWithName = function (aniIndex, name) {
            return this._anis[aniIndex].bone3DMap[name];
        };
        __proto.getNodeCount = function (aniIndex) {
            return this._anis[aniIndex].nodes.length;
        };
        __proto.getTotalkeyframesLength = function (aniIndex) {
            return this._anis[aniIndex].totalKeyframeDatasLength;
        };
        __proto.getPublicExtData = function () {
            return this._publicExtData;
        };
        __proto.getAnimationDataWithCache = function (key, cacheDatas, aniIndex, frameIndex) {
            var aniDatas = cacheDatas[aniIndex];
            if (!aniDatas) {
                return null;
            }
            else {
                var keyDatas = aniDatas[key];
                if (!keyDatas)
                    return null;
                else {
                    return keyDatas[frameIndex];
                }
            }
        };
        __proto.setAnimationDataWithCache = function (key, cacheDatas, aniIndex, frameIndex, data) {
            var aniDatas = (cacheDatas[aniIndex]) || (cacheDatas[aniIndex] = {});
            var aniDatasCache = (aniDatas[key]) || (aniDatas[key] = []);
            aniDatasCache[frameIndex] = data;
        };
        __proto.getOriginalData = function (aniIndex, originalData, nodesFrameIndices, frameIndex, playCurTime) {
            var oneAni = this._anis[aniIndex];
            var nodes = oneAni.nodes;
            var j = 0;
            for (var i = 0, n = nodes.length, outOfs = 0; i < n; i++) {
                var node = nodes[i];
                var key;
                key = node.keyFrame[nodesFrameIndices[i][frameIndex]];
                node.dataOffset = outOfs;
                var dt = playCurTime - key.startTime;
                var lerpType = node.lerpType;
                if (lerpType) {
                    switch (lerpType) {
                        case 0:
                        case 1:
                            for (j = 0; j < node.keyframeWidth;)
                                j += node.interpolationMethod[j](node, j, originalData, outOfs + j, key.data, dt, null, key.duration, key.nextData);
                            break;
                        case 2:
                            ;
                            var interpolationData = key.interpolationData;
                            var interDataLen = interpolationData.length;
                            var dataIndex = 0;
                            for (j = 0; j < interDataLen;) {
                                var type = interpolationData[j];
                                switch (type) {
                                    case 6:
                                        j += AnimationTemplet.interpolation[type](node, dataIndex, originalData, outOfs + dataIndex, key.data, dt, null, key.duration, key.nextData, interpolationData, j + 1);
                                        break;
                                    case 7:
                                        j += AnimationTemplet.interpolation[type](node, dataIndex, originalData, outOfs + dataIndex, key.data, dt, null, key.duration, key.nextData, interpolationData, j + 1);
                                        break;
                                    default:
                                        j += AnimationTemplet.interpolation[type](node, dataIndex, originalData, outOfs + dataIndex, key.data, dt, null, key.duration, key.nextData);
                                }
                                dataIndex++;
                            }
                            break;
                    }
                }
                else {
                    for (j = 0; j < node.keyframeWidth;)
                        j += node.interpolationMethod[j](node, j, originalData, outOfs + j, key.data, dt, null, key.duration, key.nextData);
                }
                outOfs += node.keyframeWidth;
            }
        };
        __proto.getNodesCurrentFrameIndex = function (aniIndex, playCurTime) {
            var ani = this._anis[aniIndex];
            var nodes = ani.nodes;
            if (aniIndex !== this.unfixedLastAniIndex) {
                this.unfixedCurrentFrameIndexes = new Uint32Array(nodes.length);
                this.unfixedCurrentTimes = new Float32Array(nodes.length);
                this.unfixedLastAniIndex = aniIndex;
            }
            for (var i = 0, n = nodes.length, outOfs = 0; i < n; i++) {
                var node = nodes[i];
                if (playCurTime < this.unfixedCurrentTimes[i])
                    this.unfixedCurrentFrameIndexes[i] = 0;
                this.unfixedCurrentTimes[i] = playCurTime;
                while ((this.unfixedCurrentFrameIndexes[i] < node.keyFrame.length)) {
                    if (node.keyFrame[this.unfixedCurrentFrameIndexes[i]].startTime > this.unfixedCurrentTimes[i])
                        break;
                    this.unfixedCurrentFrameIndexes[i]++;
                }
                this.unfixedCurrentFrameIndexes[i]--;
            }
            return this.unfixedCurrentFrameIndexes;
        };
        __proto.getOriginalDataUnfixedRate = function (aniIndex, originalData, playCurTime) {
            var oneAni = this._anis[aniIndex];
            var nodes = oneAni.nodes;
            if (aniIndex !== this.unfixedLastAniIndex) {
                this.unfixedCurrentFrameIndexes = new Uint32Array(nodes.length);
                this.unfixedCurrentTimes = new Float32Array(nodes.length);
                this.unfixedKeyframes = __newvec(nodes.length);
                this.unfixedLastAniIndex = aniIndex;
            }
            ;
            var j = 0;
            for (var i = 0, n = nodes.length, outOfs = 0; i < n; i++) {
                var node = nodes[i];
                if (playCurTime < this.unfixedCurrentTimes[i])
                    this.unfixedCurrentFrameIndexes[i] = 0;
                this.unfixedCurrentTimes[i] = playCurTime;
                while (this.unfixedCurrentFrameIndexes[i] < node.keyFrame.length) {
                    if (node.keyFrame[this.unfixedCurrentFrameIndexes[i]].startTime > this.unfixedCurrentTimes[i])
                        break;
                    this.unfixedKeyframes[i] = node.keyFrame[this.unfixedCurrentFrameIndexes[i]];
                    this.unfixedCurrentFrameIndexes[i]++;
                }
                ;
                var key = this.unfixedKeyframes[i];
                node.dataOffset = outOfs;
                var dt = playCurTime - key.startTime;
                var lerpType = node.lerpType;
                if (lerpType) {
                    switch (node.lerpType) {
                        case 0:
                        case 1:
                            for (j = 0; j < node.keyframeWidth;)
                                j += node.interpolationMethod[j](node, j, originalData, outOfs + j, key.data, dt, null, key.duration, key.nextData);
                            break;
                        case 2:
                            ;
                            var interpolationData = key.interpolationData;
                            var interDataLen = interpolationData.length;
                            var dataIndex = 0;
                            for (j = 0; j < interDataLen;) {
                                var type = interpolationData[j];
                                switch (type) {
                                    case 6:
                                        j += AnimationTemplet.interpolation[type](node, dataIndex, originalData, outOfs + dataIndex, key.data, dt, null, key.duration, key.nextData, interpolationData, j + 1);
                                        break;
                                    case 7:
                                        j += AnimationTemplet.interpolation[type](node, dataIndex, originalData, outOfs + dataIndex, key.data, dt, null, key.duration, key.nextData, interpolationData, j + 1);
                                        break;
                                    default:
                                        j += AnimationTemplet.interpolation[type](node, dataIndex, originalData, outOfs + dataIndex, key.data, dt, null, key.duration, key.nextData);
                                }
                                dataIndex++;
                            }
                            break;
                    }
                }
                else {
                    for (j = 0; j < node.keyframeWidth;)
                        j += node.interpolationMethod[j](node, j, originalData, outOfs + j, key.data, dt, null, key.duration, key.nextData);
                }
                outOfs += node.keyframeWidth;
            }
        };
        AnimationTemplet._LinearInterpolation_0 = function (bone, index, out, outOfs, data, dt, dData, duration, nextData, interData) {
            var amount = duration === 0 ? 0 : dt / duration;
            out[outOfs] = (1.0 - amount) * data[index] + amount * nextData[index];
            return 1;
        };
        AnimationTemplet._QuaternionInterpolation_1 = function (bone, index, out, outOfs, data, dt, dData, duration, nextData, interData) {
            var amount = duration === 0 ? 0 : dt / duration;
            MathUtil.slerpQuaternionArray(data, index, nextData, index, amount, out, outOfs);
            return 4;
        };
        AnimationTemplet._AngleInterpolation_2 = function (bone, index, out, outOfs, data, dt, dData, duration, nextData, interData) {
            return 0;
        };
        AnimationTemplet._RadiansInterpolation_3 = function (bone, index, out, outOfs, data, dt, dData, duration, nextData, interData) {
            return 0;
        };
        AnimationTemplet._Matrix4x4Interpolation_4 = function (bone, index, out, outOfs, data, dt, dData, duration, nextData, interData) {
            for (var i = 0; i < 16; i++, index++)
                out[outOfs + i] = data[index] + dt * dData[index];
            return 16;
        };
        AnimationTemplet._NoInterpolation_5 = function (bone, index, out, outOfs, data, dt, dData, duration, nextData, interData) {
            out[outOfs] = data[index];
            return 1;
        };
        AnimationTemplet._BezierInterpolation_6 = function (bone, index, out, outOfs, data, dt, dData, duration, nextData, interData, offset) {
            (offset === void 0) && (offset = 0);
            out[outOfs] = data[index] + (nextData[index] - data[index]) * BezierLerp.getBezierRate(dt / duration, interData[offset], interData[offset + 1], interData[offset + 2], interData[offset + 3]);
            return 5;
        };
        AnimationTemplet._BezierInterpolation_7 = function (bone, index, out, outOfs, data, dt, dData, duration, nextData, interData, offset) {
            (offset === void 0) && (offset = 0);
            out[outOfs] = interData[offset + 4] + interData[offset + 5] * BezierLerp.getBezierRate((dt * 0.001 + interData[offset + 6]) / interData[offset + 7], interData[offset], interData[offset + 1], interData[offset + 2], interData[offset + 3]);
            return 9;
        };
        AnimationTemplet.load = function (url) {
            return Laya.loader.create(url, null, null, AnimationTemplet);
        };
        AnimationTemplet.interpolation = [AnimationTemplet._LinearInterpolation_0, AnimationTemplet._QuaternionInterpolation_1, AnimationTemplet._AngleInterpolation_2, AnimationTemplet._RadiansInterpolation_3, AnimationTemplet._Matrix4x4Interpolation_4, AnimationTemplet._NoInterpolation_5, AnimationTemplet._BezierInterpolation_6, AnimationTemplet._BezierInterpolation_7];
        return AnimationTemplet;
    })(Resource);
    var CacheAbleSkinMesh = (function (_super) {
        function CacheAbleSkinMesh() {
            this.isCached = false;
            this.canvas = null;
            this.tex = null;
            this.rec = null;
            CacheAbleSkinMesh.__super.call(this);
        }
        __class(CacheAbleSkinMesh, 'laya.ani.bone.canvasmesh.CacheAbleSkinMesh', _super);
        var __proto = CacheAbleSkinMesh.prototype;
        __proto.getCanvasPic = function () {
            var canvas = new HTMLCanvas("2D");
            var ctx = canvas.getContext('2d');
            this.rec = this.mesh.getBounds();
            canvas.size(this.rec.width, this.rec.height);
            var preTransform;
            preTransform = this.transform;
            this.transform = CacheAbleSkinMesh.tempMt;
            this.transform.identity();
            this.transform.translate(-this.rec.x, -this.rec.y);
            this.renderToContext(ctx);
            this.transform.translate(+this.rec.x, +this.rec.y);
            this.transform = preTransform;
            return new Texture(canvas);
        };
        __proto.render = function (context, x, y) {
            if (!this.mesh.texture)
                return;
            if (!this.isCached) {
                this.isCached = true;
                this.tex = this.getCanvasPic();
            }
            if (!this.transform) {
                this.transform = SkinMeshCanvas._tempMatrix;
                this.transform.identity();
                this.transform.translate(x, y);
                this._renderTextureToContext(context);
                this.transform.translate(-x, -y);
                this.transform = null;
            }
            else {
                this.transform.translate(x, y);
                this._renderTextureToContext(context);
                this.transform.translate(-x, -y);
            }
        };
        __proto._renderTextureToContext = function (context) {
            this.context = context.ctx || context;
            context.save();
            var texture;
            texture = this.tex;
            if (this.transform) {
                var mt = this.transform;
                context.transform(mt.a, mt.b, mt.c, mt.d, mt.tx, mt.ty);
            }
            this.rec = this.mesh.getBounds();
            context.translate(this.rec.x, this.rec.y);
            context.drawTexture(texture, 0, 0, texture.width, texture.height, 0, 0);
            context.restore();
        };
        __static(CacheAbleSkinMesh, ['tempMt', function () { return this.tempMt = new Matrix(); }
        ]);
        return CacheAbleSkinMesh;
    })(SkinMeshCanvas);
    var SimpleSkinMeshCanvas = (function (_super) {
        function SimpleSkinMeshCanvas() {
            this.cacheOK = false;
            this.cacheCmdOK = false;
            this.transformCmds = [];
            this.drawCmds = [];
            SimpleSkinMeshCanvas.__super.call(this);
            this.tempMesh = new MeshData();
        }
        __class(SimpleSkinMeshCanvas, 'laya.ani.bone.canvasmesh.SimpleSkinMeshCanvas', _super);
        var __proto = SimpleSkinMeshCanvas.prototype;
        __proto.init2 = function (texture, vs, ps, verticles, uvs) {
            _super.prototype.init2.call(this, texture, vs, ps, verticles, uvs);
            this.cacheOK = false;
            this.cacheCmdOK = false;
            this.transformCmds.length = 6;
            this.drawCmds.length = 9;
        };
        __proto.renderToContext = function (context) {
            this.context = context.ctx || context;
            if (this.mesh) {
                if (this.mesh.uvs.length <= 8) {
                    if (this.mode == 0) {
                        this._renderWithIndexes(this.mesh);
                    }
                    else {
                        this._renderNoIndexes(this.mesh);
                    }
                    return;
                }
                if (!this.cacheOK) {
                    this.tempMesh.texture = this.mesh.texture;
                    this.tempMesh.uvs = this.mesh.texture.uv;
                    this.tempMesh.vertices = MeshTools.solveMesh(this.mesh, this.tempMesh.vertices);
                    this.cacheOK = true;
                }
                if (this.mode == 0) {
                    this._renderWithIndexes(this.tempMesh);
                }
                else {
                    this._renderNoIndexes(this.tempMesh);
                }
            }
        };
        __proto._renderWithIndexes = function (mesh) {
            if (this.cacheCmdOK) {
                this.renderByCache(mesh);
                return;
            }
            ;
            var indexes = mesh.indexes;
            var i = 0, len = indexes.length;
            if (len > 1)
                len = 1;
            for (i = 0; i < len; i += 3) {
                var index0 = indexes[i] * 2;
                var index1 = indexes[i + 1] * 2;
                var index2 = indexes[i + 2] * 2;
                this._renderDrawTriangle(mesh, index0, index1, index2);
            }
            this.cacheCmdOK = true;
        };
        __proto._renderDrawTriangle = function (mesh, index0, index1, index2) {
            var context = this.context;
            var uvs = mesh.uvs;
            var vertices = mesh.vertices;
            var texture = mesh.texture;
            var source = texture.bitmap;
            var textureSource = source.source;
            var textureWidth = texture.width;
            var textureHeight = texture.height;
            var sourceWidth = source.width;
            var sourceHeight = source.height;
            var u0 = NaN;
            var u1 = NaN;
            var u2 = NaN;
            var v0 = NaN;
            var v1 = NaN;
            var v2 = NaN;
            if (mesh.useUvTransform) {
                var ut = mesh.uvTransform;
                u0 = ((uvs[index0] * ut.a) + (uvs[index0 + 1] * ut.c) + ut.tx) * sourceWidth;
                u1 = ((uvs[index1] * ut.a) + (uvs[index1 + 1] * ut.c) + ut.tx) * sourceWidth;
                u2 = ((uvs[index2] * ut.a) + (uvs[index2 + 1] * ut.c) + ut.tx) * sourceWidth;
                v0 = ((uvs[index0] * ut.b) + (uvs[index0 + 1] * ut.d) + ut.ty) * sourceHeight;
                v1 = ((uvs[index1] * ut.b) + (uvs[index1 + 1] * ut.d) + ut.ty) * sourceHeight;
                v2 = ((uvs[index2] * ut.b) + (uvs[index2 + 1] * ut.d) + ut.ty) * sourceHeight;
            }
            else {
                u0 = uvs[index0] * sourceWidth;
                u1 = uvs[index1] * sourceWidth;
                u2 = uvs[index2] * sourceWidth;
                v0 = uvs[index0 + 1] * sourceHeight;
                v1 = uvs[index1 + 1] * sourceHeight;
                v2 = uvs[index2 + 1] * sourceHeight;
            }
            ;
            var x0 = vertices[index0];
            var x1 = vertices[index1];
            var x2 = vertices[index2];
            var y0 = vertices[index0 + 1];
            var y1 = vertices[index1 + 1];
            var y2 = vertices[index2 + 1];
            var delta = (u0 * v1) + (v0 * u2) + (u1 * v2) - (v1 * u2) - (v0 * u1) - (u0 * v2);
            var dDelta = 1 / delta;
            var deltaA = (x0 * v1) + (v0 * x2) + (x1 * v2) - (v1 * x2) - (v0 * x1) - (x0 * v2);
            var deltaB = (u0 * x1) + (x0 * u2) + (u1 * x2) - (x1 * u2) - (x0 * u1) - (u0 * x2);
            var deltaC = (u0 * v1 * x2) + (v0 * x1 * u2) + (x0 * u1 * v2) - (x0 * v1 * u2) - (v0 * u1 * x2) - (u0 * x1 * v2);
            var deltaD = (y0 * v1) + (v0 * y2) + (y1 * v2) - (v1 * y2) - (v0 * y1) - (y0 * v2);
            var deltaE = (u0 * y1) + (y0 * u2) + (u1 * y2) - (y1 * u2) - (y0 * u1) - (u0 * y2);
            var deltaF = (u0 * v1 * y2) + (v0 * y1 * u2) + (y0 * u1 * v2) - (y0 * v1 * u2) - (v0 * u1 * y2) - (u0 * y1 * v2);
            this.transformCmds[0] = deltaA * dDelta;
            this.transformCmds[1] = deltaD * dDelta;
            this.transformCmds[2] = deltaB * dDelta;
            this.transformCmds[3] = deltaE * dDelta;
            this.transformCmds[4] = deltaC * dDelta;
            this.transformCmds[5] = deltaF * dDelta;
            this.drawCmds[0] = textureSource;
            this.drawCmds[1] = texture.uv[0] * sourceWidth;
            this.drawCmds[2] = texture.uv[1] * sourceHeight;
            this.drawCmds[3] = textureWidth;
            this.drawCmds[4] = textureHeight;
            this.drawCmds[5] = texture.uv[0] * sourceWidth;
            this.drawCmds[6] = texture.uv[1] * sourceHeight;
            this.drawCmds[7] = textureWidth;
            this.drawCmds[8] = textureHeight;
            context.save();
            if (this.transform) {
                var mt = this.transform;
                context.transform(mt.a, mt.b, mt.c, mt.d, mt.tx, mt.ty);
            }
            context.transform.apply(context, this.transformCmds);
            context.drawImage.apply(context, this.drawCmds);
            context.restore();
        };
        __proto.renderByCache = function (mesh) {
            var context = this.context;
            context.save();
            if (this.transform) {
                var mt = this.transform;
                context.transform(mt.a, mt.b, mt.c, mt.d, mt.tx, mt.ty);
            }
            context.transform.apply(context, this.transformCmds);
            context.drawImage.apply(context, this.drawCmds);
            context.restore();
        };
        return SimpleSkinMeshCanvas;
    })(SkinMeshCanvas);
    var Skeleton = (function (_super) {
        function Skeleton(templet, aniMode) {
            this._templet = null;
            this._player = null;
            this._curOriginalData = null;
            this._boneMatrixArray = [];
            this._lastTime = 0;
            this._currAniName = null;
            this._currAniIndex = -1;
            this._pause = true;
            this._aniClipIndex = -1;
            this._clipIndex = -1;
            this._skinIndex = 0;
            this._skinName = "default";
            this._aniMode = 0;
            this._graphicsCache = null;
            this._boneSlotDic = null;
            this._bindBoneBoneSlotDic = null;
            this._boneSlotArray = null;
            this._index = -1;
            this._total = -1;
            this._indexControl = false;
            this._aniPath = null;
            this._texturePath = null;
            this._complete = null;
            this._loadAniMode = 0;
            this._yReverseMatrix = null;
            this._ikArr = null;
            this._tfArr = null;
            this._pathDic = null;
            this._rootBone = null;
            this._boneList = null;
            this._aniSectionDic = null;
            this._eventIndex = 0;
            this._drawOrderIndex = 0;
            this._drawOrder = null;
            this._lastAniClipIndex = -1;
            this._lastUpdateAniClipIndex = -1;
            Skeleton.__super.call(this);
            (aniMode === void 0) && (aniMode = 0);
            if (templet)
                this.init(templet, aniMode);
        }
        __class(Skeleton, 'laya.ani.bone.Skeleton', _super);
        var __proto = Skeleton.prototype;
        __proto.init = function (templet, aniMode) {
            (aniMode === void 0) && (aniMode = 0);
            var i = 0, n = 0;
            if (aniMode == 1) {
                this._graphicsCache = [];
                for (i = 0, n = templet.getAnimationCount(); i < n; i++) {
                    this._graphicsCache.push([]);
                }
            }
            this._yReverseMatrix = templet.yReverseMatrix;
            this._aniMode = aniMode;
            this._templet = templet;
            this._player = new AnimationPlayer();
            this._player.cacheFrameRate = templet.rate;
            this._player.templet = templet;
            this._player.play();
            this._parseSrcBoneMatrix();
            this._boneList = templet.mBoneArr;
            this._rootBone = templet.mRootBone;
            this._aniSectionDic = templet.aniSectionDic;
            if (templet.ikArr.length > 0) {
                this._ikArr = [];
                for (i = 0, n = templet.ikArr.length; i < n; i++) {
                    this._ikArr.push(new IkConstraint(templet.ikArr[i], this._boneList));
                }
            }
            if (templet.pathArr.length > 0) {
                var tPathData;
                var tPathConstraint;
                if (this._pathDic == null)
                    this._pathDic = {};
                var tBoneSlot;
                for (i = 0, n = templet.pathArr.length; i < n; i++) {
                    tPathData = templet.pathArr[i];
                    tPathConstraint = new PathConstraint(tPathData, this._boneList);
                    tBoneSlot = this._boneSlotDic[tPathData.name];
                    if (tBoneSlot) {
                        tPathConstraint = new PathConstraint(tPathData, this._boneList);
                        tPathConstraint.target = tBoneSlot;
                    }
                    this._pathDic[tPathData.name] = tPathConstraint;
                }
            }
            if (templet.tfArr.length > 0) {
                this._tfArr = [];
                for (i = 0, n = templet.tfArr.length; i < n; i++) {
                    this._tfArr.push(new TfConstraint(templet.tfArr[i], this._boneList));
                }
            }
            if (templet.skinDataArray.length > 0) {
                var tSkinData = this._templet.skinDataArray[this._skinIndex];
                this._skinName = tSkinData.name;
            }
            this._player.on("played", this, this._onPlay);
            this._player.on("stopped", this, this._onStop);
            this._player.on("paused", this, this._onPause);
        };
        __proto.load = function (path, complete, aniMode) {
            (aniMode === void 0) && (aniMode = 0);
            this._aniPath = path;
            this._complete = complete;
            this._loadAniMode = aniMode;
            Laya.loader.load([{ url: path, type: "arraybuffer" }], Handler.create(this, this._onLoaded));
        };
        __proto._onLoaded = function () {
            var arraybuffer = Loader.getRes(this._aniPath);
            if (arraybuffer == null)
                return;
            if (Templet.TEMPLET_DICTIONARY == null) {
                Templet.TEMPLET_DICTIONARY = {};
            }
            ;
            var tFactory;
            tFactory = Templet.TEMPLET_DICTIONARY[this._aniPath];
            if (tFactory) {
                if (tFactory.isParseFail) {
                    this._parseFail();
                }
                else {
                    if (tFactory.isParserComplete) {
                        this._parseComplete();
                    }
                    else {
                        tFactory.on("complete", this, this._parseComplete);
                        tFactory.on("error", this, this._parseFail);
                    }
                }
            }
            else {
                tFactory = new Templet();
                tFactory._setUrl(this._aniPath);
                Templet.TEMPLET_DICTIONARY[this._aniPath] = tFactory;
                tFactory.on("complete", this, this._parseComplete);
                tFactory.on("error", this, this._parseFail);
                tFactory.isParserComplete = false;
                tFactory.parseData(null, arraybuffer);
            }
        };
        __proto._parseComplete = function () {
            var tTemple = Templet.TEMPLET_DICTIONARY[this._aniPath];
            if (tTemple) {
                this.init(tTemple, this._loadAniMode);
                this.play(0, true);
            }
            this._complete && this._complete.runWith(this);
        };
        __proto._parseFail = function () {
            console_log("[Error]:" + this._aniPath + "解析失败");
        };
        __proto._onPlay = function () {
            this.event("played");
        };
        __proto._onStop = function () {
            var tEventData;
            var tEventAniArr = this._templet.eventAniArr;
            var tEventArr = tEventAniArr[this._aniClipIndex];
            if (tEventArr && this._eventIndex < tEventArr.length) {
                for (; this._eventIndex < tEventArr.length; this._eventIndex++) {
                    tEventData = tEventArr[this._eventIndex];
                    if (tEventData.time >= this._player.playStart && tEventData.time <= this._player.playEnd) {
                        this.event("label", tEventData);
                    }
                }
            }
            this._eventIndex = 0;
            this._drawOrder = null;
            this.event("stopped");
        };
        __proto._onPause = function () {
            this.event("paused");
        };
        __proto._parseSrcBoneMatrix = function () {
            var i = 0, n = 0;
            n = this._templet.srcBoneMatrixArr.length;
            for (i = 0; i < n; i++) {
                this._boneMatrixArray.push(new Matrix());
            }
            if (this._aniMode == 0) {
                this._boneSlotDic = this._templet.boneSlotDic;
                this._bindBoneBoneSlotDic = this._templet.bindBoneBoneSlotDic;
                this._boneSlotArray = this._templet.boneSlotArray;
            }
            else {
                if (this._boneSlotDic == null)
                    this._boneSlotDic = {};
                if (this._bindBoneBoneSlotDic == null)
                    this._bindBoneBoneSlotDic = {};
                if (this._boneSlotArray == null)
                    this._boneSlotArray = [];
                var tArr = this._templet.boneSlotArray;
                var tBS;
                var tBSArr;
                for (i = 0, n = tArr.length; i < n; i++) {
                    tBS = tArr[i];
                    tBSArr = this._bindBoneBoneSlotDic[tBS.parent];
                    if (tBSArr == null) {
                        this._bindBoneBoneSlotDic[tBS.parent] = tBSArr = [];
                    }
                    this._boneSlotDic[tBS.name] = tBS = tBS.copy();
                    tBSArr.push(tBS);
                    this._boneSlotArray.push(tBS);
                }
            }
        };
        __proto._emitMissedEvents = function (startTime, endTime, startIndex) {
            (startIndex === void 0) && (startIndex = 0);
            var tEventAniArr = this._templet.eventAniArr;
            var tEventArr = tEventAniArr[this._player.currentAnimationClipIndex];
            if (tEventArr) {
                var i = 0, len = 0;
                var tEventData;
                len = tEventArr.length;
                for (i = startIndex; i < len; i++) {
                    tEventData = tEventArr[i];
                    if (tEventData.time >= this._player.playStart && tEventData.time <= this._player.playEnd) {
                        this.event("label", tEventData);
                    }
                }
            }
        };
        __proto._update = function (autoKey) {
            (autoKey === void 0) && (autoKey = true);
            if (this._pause)
                return;
            if (autoKey && this._indexControl) {
                return;
            }
            ;
            var tCurrTime = this.timer.currTimer;
            var preIndex = this._player.currentKeyframeIndex;
            var dTime = tCurrTime - this._lastTime;
            if (autoKey) {
                this._player._update(dTime);
            }
            else {
                preIndex = -1;
            }
            this._lastTime = tCurrTime;
            if (!this._player)
                return;
            this._index = this._clipIndex = this._player.currentKeyframeIndex;
            if (this._index < 0)
                return;
            if (dTime > 0 && this._clipIndex == preIndex && this._lastUpdateAniClipIndex == this._aniClipIndex) {
                return;
            }
            this._lastUpdateAniClipIndex = this._aniClipIndex;
            if (preIndex > this._clipIndex && this._eventIndex != 0) {
                this._emitMissedEvents(this._player.playStart, this._player.playEnd, this._eventIndex);
                this._eventIndex = 0;
            }
            ;
            var tEventData;
            var tEventAniArr = this._templet.eventAniArr;
            var tEventArr = tEventAniArr[this._aniClipIndex];
            if (tEventArr && this._eventIndex < tEventArr.length) {
                tEventData = tEventArr[this._eventIndex];
                if (tEventData.time >= this._player.playStart && tEventData.time <= this._player.playEnd) {
                    if (this._player.currentPlayTime >= tEventData.time) {
                        this.event("label", tEventData);
                        this._eventIndex++;
                    }
                }
                else {
                    this._eventIndex++;
                }
            }
            ;
            var tGraphics;
            if (this._aniMode == 0) {
                tGraphics = this._templet.getGrahicsDataWithCache(this._aniClipIndex, this._clipIndex);
                if (tGraphics) {
                    if (this.graphics != tGraphics) {
                        this.graphics = tGraphics;
                    }
                    return;
                }
                else {
                    var i = 0, minIndex = 0;
                    minIndex = this._clipIndex;
                    while ((!this._templet.getGrahicsDataWithCache(this._aniClipIndex, minIndex - 1)) && (minIndex > 0)) {
                        minIndex--;
                    }
                    if (minIndex < this._clipIndex) {
                        for (i = minIndex; i < this._clipIndex; i++) {
                            this._createGraphics(i);
                        }
                    }
                }
            }
            else if (this._aniMode == 1) {
                tGraphics = this._getGrahicsDataWithCache(this._aniClipIndex, this._clipIndex);
                if (tGraphics) {
                    if (this.graphics != tGraphics) {
                        this.graphics = tGraphics;
                    }
                    return;
                }
                else {
                    minIndex = this._clipIndex;
                    while ((!this._getGrahicsDataWithCache(this._aniClipIndex, minIndex - 1)) && (minIndex > 0)) {
                        minIndex--;
                    }
                    if (minIndex < this._clipIndex) {
                        for (i = minIndex; i < this._clipIndex; i++) {
                            this._createGraphics(i);
                        }
                    }
                }
            }
            this._createGraphics();
        };
        __proto._createGraphics = function (_clipIndex) {
            (_clipIndex === void 0) && (_clipIndex = -1);
            if (_clipIndex == -1)
                _clipIndex = this._clipIndex;
            var curTime = _clipIndex * this._player.cacheFrameRateInterval;
            var tDrawOrderData;
            var tDrawOrderAniArr = this._templet.drawOrderAniArr;
            var tDrawOrderArr = tDrawOrderAniArr[this._aniClipIndex];
            if (tDrawOrderArr && tDrawOrderArr.length > 0) {
                this._drawOrderIndex = 0;
                tDrawOrderData = tDrawOrderArr[this._drawOrderIndex];
                while (curTime >= tDrawOrderData.time) {
                    this._drawOrder = tDrawOrderData.drawOrder;
                    this._drawOrderIndex++;
                    if (this._drawOrderIndex >= tDrawOrderArr.length) {
                        break;
                    }
                    tDrawOrderData = tDrawOrderArr[this._drawOrderIndex];
                }
            }
            ;
            var tGraphics;
            if (this._aniMode == 0 || this._aniMode == 1) {
                this.graphics = new GraphicsAni();
            }
            else {
                if ((this.graphics instanceof laya.ani.GraphicsAni)) {
                    this.graphics.clear();
                }
                else {
                    this.graphics = new GraphicsAni();
                }
            }
            tGraphics = this.graphics;
            var bones = this._templet.getNodes(this._aniClipIndex);
            this._templet.getOriginalData(this._aniClipIndex, this._curOriginalData, this._player._fullFrames[this._aniClipIndex], _clipIndex, curTime);
            var tSectionArr = this._aniSectionDic[this._aniClipIndex];
            var tParentMatrix;
            var tStartIndex = 0;
            var i = 0, j = 0, k = 0, n = 0;
            var tDBBoneSlot;
            var tDBBoneSlotArr;
            var tParentTransform;
            var tSrcBone;
            var boneCount = this._templet.srcBoneMatrixArr.length;
            for (i = 0, n = tSectionArr[0]; i < boneCount; i++) {
                tSrcBone = this._boneList[i];
                tParentTransform = this._templet.srcBoneMatrixArr[i];
                tSrcBone.resultTransform.scX = tParentTransform.scX * this._curOriginalData[tStartIndex++];
                tSrcBone.resultTransform.skX = tParentTransform.skX + this._curOriginalData[tStartIndex++];
                tSrcBone.resultTransform.skY = tParentTransform.skY + this._curOriginalData[tStartIndex++];
                tSrcBone.resultTransform.scY = tParentTransform.scY * this._curOriginalData[tStartIndex++];
                tSrcBone.resultTransform.x = tParentTransform.x + this._curOriginalData[tStartIndex++];
                tSrcBone.resultTransform.y = tParentTransform.y + this._curOriginalData[tStartIndex++];
                if (this._templet.tMatrixDataLen === 8) {
                    tSrcBone.resultTransform.skewX = tParentTransform.skewX + this._curOriginalData[tStartIndex++];
                    tSrcBone.resultTransform.skewY = tParentTransform.skewY + this._curOriginalData[tStartIndex++];
                }
            }
            ;
            var tSlotDic = {};
            var tSlotAlphaDic = {};
            var tBoneData;
            for (n += tSectionArr[1]; i < n; i++) {
                tBoneData = bones[i];
                tSlotDic[tBoneData.name] = this._curOriginalData[tStartIndex++];
                tSlotAlphaDic[tBoneData.name] = this._curOriginalData[tStartIndex++];
                this._curOriginalData[tStartIndex++];
                this._curOriginalData[tStartIndex++];
                this._curOriginalData[tStartIndex++];
                this._curOriginalData[tStartIndex++];
            }
            ;
            var tBendDirectionDic = {};
            var tMixDic = {};
            for (n += tSectionArr[2]; i < n; i++) {
                tBoneData = bones[i];
                tBendDirectionDic[tBoneData.name] = this._curOriginalData[tStartIndex++];
                tMixDic[tBoneData.name] = this._curOriginalData[tStartIndex++];
                this._curOriginalData[tStartIndex++];
                this._curOriginalData[tStartIndex++];
                this._curOriginalData[tStartIndex++];
                this._curOriginalData[tStartIndex++];
            }
            if (this._pathDic) {
                var tPathConstraint;
                for (n += tSectionArr[3]; i < n; i++) {
                    tBoneData = bones[i];
                    tPathConstraint = this._pathDic[tBoneData.name];
                    if (tPathConstraint) {
                        var tByte = new Byte(tBoneData.extenData);
                        switch (tByte.getByte()) {
                            case 1:
                                tPathConstraint.position = this._curOriginalData[tStartIndex++];
                                break;
                            case 2:
                                tPathConstraint.spacing = this._curOriginalData[tStartIndex++];
                                break;
                            case 3:
                                tPathConstraint.rotateMix = this._curOriginalData[tStartIndex++];
                                tPathConstraint.translateMix = this._curOriginalData[tStartIndex++];
                                break;
                        }
                    }
                }
            }
            if (this._yReverseMatrix) {
                this._rootBone.update(this._yReverseMatrix);
            }
            else {
                this._rootBone.update(Matrix.TEMP.identity());
            }
            if (this._ikArr) {
                var tIkConstraint;
                for (i = 0, n = this._ikArr.length; i < n; i++) {
                    tIkConstraint = this._ikArr[i];
                    if (tBendDirectionDic.hasOwnProperty(tIkConstraint.name)) {
                        tIkConstraint.bendDirection = tBendDirectionDic[tIkConstraint.name];
                    }
                    if (tMixDic.hasOwnProperty(tIkConstraint.name)) {
                        tIkConstraint.mix = tMixDic[tIkConstraint.name];
                    }
                    tIkConstraint.apply();
                }
            }
            if (this._pathDic) {
                for (var tPathStr in this._pathDic) {
                    tPathConstraint = this._pathDic[tPathStr];
                    tPathConstraint.apply(this._boneList, tGraphics);
                }
            }
            if (this._tfArr) {
                var tTfConstraint;
                for (i = 0, k = this._tfArr.length; i < k; i++) {
                    tTfConstraint = this._tfArr[i];
                    tTfConstraint.apply();
                }
            }
            for (i = 0, k = this._boneList.length; i < k; i++) {
                tSrcBone = this._boneList[i];
                tDBBoneSlotArr = this._bindBoneBoneSlotDic[tSrcBone.name];
                tSrcBone.resultMatrix.copyTo(this._boneMatrixArray[i]);
                if (tDBBoneSlotArr) {
                    for (j = 0, n = tDBBoneSlotArr.length; j < n; j++) {
                        tDBBoneSlot = tDBBoneSlotArr[j];
                        if (tDBBoneSlot) {
                            tDBBoneSlot.setParentMatrix(tSrcBone.resultMatrix);
                        }
                    }
                }
            }
            ;
            var tDeformDic = {};
            var tDeformAniArr = this._templet.deformAniArr;
            var tDeformAniData;
            var tDeformSlotData;
            var tDeformSlotDisplayData;
            if (tDeformAniArr && tDeformAniArr.length > 0) {
                if (this._lastAniClipIndex != this._aniClipIndex) {
                    this._lastAniClipIndex = this._aniClipIndex;
                    for (i = 0, n = this._boneSlotArray.length; i < n; i++) {
                        tDBBoneSlot = this._boneSlotArray[i];
                        tDBBoneSlot.deformData = null;
                    }
                }
                ;
                var tSkinDeformAni = tDeformAniArr[this._aniClipIndex];
                tDeformAniData = (tSkinDeformAni["default"]);
                this._setDeform(tDeformAniData, tDeformDic, this._boneSlotArray, curTime);
                var tSkin;
                for (tSkin in tSkinDeformAni) {
                    if (tSkin != "default" && tSkin != this._skinName) {
                        tDeformAniData = tSkinDeformAni[tSkin];
                        this._setDeform(tDeformAniData, tDeformDic, this._boneSlotArray, curTime);
                    }
                }
                tDeformAniData = (tSkinDeformAni[this._skinName]);
                this._setDeform(tDeformAniData, tDeformDic, this._boneSlotArray, curTime);
            }
            ;
            var tSlotData2;
            var tSlotData3;
            var tObject;
            if (this._drawOrder) {
                for (i = 0, n = this._drawOrder.length; i < n; i++) {
                    tDBBoneSlot = this._boneSlotArray[this._drawOrder[i]];
                    tSlotData2 = tSlotDic[tDBBoneSlot.name];
                    tSlotData3 = tSlotAlphaDic[tDBBoneSlot.name];
                    if (!isNaN(tSlotData3)) {
                        tGraphics.save();
                        tGraphics.alpha(tSlotData3);
                    }
                    if (!isNaN(tSlotData2) && tSlotData2 != -2) {
                        if (this._templet.attachmentNames) {
                            tDBBoneSlot.showDisplayByName(this._templet.attachmentNames[tSlotData2]);
                        }
                        else {
                            tDBBoneSlot.showDisplayByIndex(tSlotData2);
                        }
                    }
                    if (tDeformDic[this._drawOrder[i]]) {
                        tObject = tDeformDic[this._drawOrder[i]];
                        if (tDBBoneSlot.currDisplayData && tObject[tDBBoneSlot.currDisplayData.attachmentName]) {
                            tDBBoneSlot.deformData = tObject[tDBBoneSlot.currDisplayData.attachmentName];
                        }
                        else {
                            tDBBoneSlot.deformData = null;
                        }
                    }
                    else {
                        tDBBoneSlot.deformData = null;
                    }
                    if (!isNaN(tSlotData3)) {
                        tDBBoneSlot.draw(tGraphics, this._boneMatrixArray, this._aniMode == 2, tSlotData3);
                    }
                    else {
                        tDBBoneSlot.draw(tGraphics, this._boneMatrixArray, this._aniMode == 2);
                    }
                    if (!isNaN(tSlotData3)) {
                        tGraphics.restore();
                    }
                }
            }
            else {
                for (i = 0, n = this._boneSlotArray.length; i < n; i++) {
                    tDBBoneSlot = this._boneSlotArray[i];
                    tSlotData2 = tSlotDic[tDBBoneSlot.name];
                    tSlotData3 = tSlotAlphaDic[tDBBoneSlot.name];
                    if (!isNaN(tSlotData3)) {
                        tGraphics.save();
                        tGraphics.alpha(tSlotData3);
                    }
                    if (!isNaN(tSlotData2) && tSlotData2 != -2) {
                        if (this._templet.attachmentNames) {
                            tDBBoneSlot.showDisplayByName(this._templet.attachmentNames[tSlotData2]);
                        }
                        else {
                            tDBBoneSlot.showDisplayByIndex(tSlotData2);
                        }
                    }
                    if (tDeformDic[i]) {
                        tObject = tDeformDic[i];
                        if (tDBBoneSlot.currDisplayData && tObject[tDBBoneSlot.currDisplayData.attachmentName]) {
                            tDBBoneSlot.deformData = tObject[tDBBoneSlot.currDisplayData.attachmentName];
                        }
                        else {
                            tDBBoneSlot.deformData = null;
                        }
                    }
                    else {
                        tDBBoneSlot.deformData = null;
                    }
                    if (!isNaN(tSlotData3)) {
                        tDBBoneSlot.draw(tGraphics, this._boneMatrixArray, this._aniMode == 2, tSlotData3);
                    }
                    else {
                        tDBBoneSlot.draw(tGraphics, this._boneMatrixArray, this._aniMode == 2);
                    }
                    if (!isNaN(tSlotData3)) {
                        tGraphics.restore();
                    }
                }
            }
            if (this._aniMode == 0) {
                this._templet.setGrahicsDataWithCache(this._aniClipIndex, _clipIndex, tGraphics);
            }
            else if (this._aniMode == 1) {
                this._setGrahicsDataWithCache(this._aniClipIndex, _clipIndex, tGraphics);
            }
        };
        __proto._setDeform = function (tDeformAniData, tDeformDic, _boneSlotArray, curTime) {
            if (!tDeformAniData)
                return;
            var tDeformSlotData;
            var tDeformSlotDisplayData;
            var tDBBoneSlot;
            var i = 0, n = 0, j = 0;
            if (tDeformAniData) {
                for (i = 0, n = tDeformAniData.deformSlotDataList.length; i < n; i++) {
                    tDeformSlotData = tDeformAniData.deformSlotDataList[i];
                    for (j = 0; j < tDeformSlotData.deformSlotDisplayList.length; j++) {
                        tDeformSlotDisplayData = tDeformSlotData.deformSlotDisplayList[j];
                        tDBBoneSlot = _boneSlotArray[tDeformSlotDisplayData.slotIndex];
                        tDeformSlotDisplayData.apply(curTime, tDBBoneSlot);
                        if (!tDeformDic[tDeformSlotDisplayData.slotIndex]) {
                            tDeformDic[tDeformSlotDisplayData.slotIndex] = {};
                        }
                        tDeformDic[tDeformSlotDisplayData.slotIndex][tDeformSlotDisplayData.attachment] = tDeformSlotDisplayData.deformData;
                    }
                }
            }
        };
        __proto.getAnimNum = function () {
            return this._templet.getAnimationCount();
        };
        __proto.getAniNameByIndex = function (index) {
            return this._templet.getAniNameByIndex(index);
        };
        __proto.getSlotByName = function (name) {
            return this._boneSlotDic[name];
        };
        __proto.showSkinByName = function (name, freshSlotIndex) {
            (freshSlotIndex === void 0) && (freshSlotIndex = true);
            this.showSkinByIndex(this._templet.getSkinIndexByName(name), freshSlotIndex);
        };
        __proto.showSkinByIndex = function (skinIndex, freshSlotIndex) {
            (freshSlotIndex === void 0) && (freshSlotIndex = true);
            for (var i = 0; i < this._boneSlotArray.length; i++) {
                (this._boneSlotArray[i]).showSlotData(null, freshSlotIndex);
            }
            if (this._templet.showSkinByIndex(this._boneSlotDic, skinIndex, freshSlotIndex)) {
                var tSkinData = this._templet.skinDataArray[skinIndex];
                this._skinIndex = skinIndex;
                this._skinName = tSkinData.name;
            }
            this._clearCache();
        };
        __proto.showSlotSkinByIndex = function (slotName, index) {
            if (this._aniMode == 0)
                return;
            var tBoneSlot = this.getSlotByName(slotName);
            if (tBoneSlot) {
                tBoneSlot.showDisplayByIndex(index);
            }
            this._clearCache();
        };
        __proto.showSlotSkinByName = function (slotName, name) {
            if (this._aniMode == 0)
                return;
            var tBoneSlot = this.getSlotByName(slotName);
            if (tBoneSlot) {
                tBoneSlot.showDisplayByName(name);
            }
            this._clearCache();
        };
        __proto.replaceSlotSkinName = function (slotName, oldName, newName) {
            if (this._aniMode == 0)
                return;
            var tBoneSlot = this.getSlotByName(slotName);
            if (tBoneSlot) {
                tBoneSlot.replaceDisplayByName(oldName, newName);
            }
            this._clearCache();
        };
        __proto.replaceSlotSkinByIndex = function (slotName, oldIndex, newIndex) {
            if (this._aniMode == 0)
                return;
            var tBoneSlot = this.getSlotByName(slotName);
            if (tBoneSlot) {
                tBoneSlot.replaceDisplayByIndex(oldIndex, newIndex);
            }
            this._clearCache();
        };
        __proto.setSlotSkin = function (slotName, texture) {
            if (this._aniMode == 0)
                return;
            var tBoneSlot = this.getSlotByName(slotName);
            if (tBoneSlot) {
                tBoneSlot.replaceSkin(texture);
            }
            this._clearCache();
        };
        __proto._clearCache = function () {
            if (this._aniMode == 1) {
                for (var i = 0, n = this._graphicsCache.length; i < n; i++) {
                    this._graphicsCache[i].length = 0;
                }
            }
        };
        __proto.play = function (nameOrIndex, loop, force, start, end, freshSkin) {
            (force === void 0) && (force = true);
            (start === void 0) && (start = 0);
            (end === void 0) && (end = 0);
            (freshSkin === void 0) && (freshSkin = true);
            this._indexControl = false;
            var index = -1;
            var duration = NaN;
            if (loop) {
                duration = 2147483647;
            }
            else {
                duration = 0;
            }
            if ((typeof nameOrIndex == 'string')) {
                for (var i = 0, n = this._templet.getAnimationCount(); i < n; i++) {
                    var animation = this._templet.getAnimation(i);
                    if (animation && nameOrIndex == animation.name) {
                        index = i;
                        break;
                    }
                }
            }
            else {
                index = nameOrIndex;
            }
            if (index > -1 && index < this.getAnimNum()) {
                this._aniClipIndex = index;
                if (force || this._pause || this._currAniIndex != index) {
                    this._currAniIndex = index;
                    this._curOriginalData = new Float32Array(this._templet.getTotalkeyframesLength(index));
                    this._drawOrder = null;
                    this._eventIndex = 0;
                    this._player.play(index, this._player.playbackRate, duration, start, end);
                    if (freshSkin)
                        this._templet.showSkinByIndex(this._boneSlotDic, this._skinIndex);
                    if (this._pause) {
                        this._pause = false;
                        this._lastTime = Browser.now();
                        this.timer.frameLoop(1, this, this._update, null, true);
                    }
                    this._update();
                }
            }
        };
        __proto.stop = function () {
            if (!this._pause) {
                this._pause = true;
                if (this._player) {
                    this._player.stop(true);
                }
                this.timer.clear(this, this._update);
            }
        };
        __proto.playbackRate = function (value) {
            if (this._player) {
                this._player.playbackRate = value;
            }
        };
        __proto.paused = function () {
            if (!this._pause) {
                this._pause = true;
                if (this._player) {
                    this._player.paused = true;
                }
                this.timer.clear(this, this._update);
            }
        };
        __proto.resume = function () {
            this._indexControl = false;
            if (this._pause) {
                this._pause = false;
                if (this._player) {
                    this._player.paused = false;
                }
                this._lastTime = Browser.now();
                this.timer.frameLoop(1, this, this._update, null, true);
            }
        };
        __proto._getGrahicsDataWithCache = function (aniIndex, frameIndex) {
            return this._graphicsCache[aniIndex][frameIndex];
        };
        __proto._setGrahicsDataWithCache = function (aniIndex, frameIndex, graphics) {
            this._graphicsCache[aniIndex][frameIndex] = graphics;
        };
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            _super.prototype.destroy.call(this, destroyChild);
            this._templet = null;
            if (this._player)
                this._player.offAll();
            this._player = null;
            this._curOriginalData = null;
            this._boneMatrixArray.length = 0;
            this._lastTime = 0;
            this.timer.clear(this, this._update);
        };
        __getset(0, __proto, 'url', function () {
            return this._aniPath;
        }, function (path) {
            this.load(path);
        });
        __getset(0, __proto, 'index', function () {
            return this._index;
        }, function (value) {
            if (this.player) {
                this._index = value;
                this._player.currentTime = this._index * 1000 / this._player.cacheFrameRate;
                this._indexControl = true;
                this._update(false);
            }
        });
        __getset(0, __proto, 'total', function () {
            if (this._templet && this._player) {
                this._total = Math.floor(this._templet.getAniDuration(this._player.currentAnimationClipIndex) / 1000 * this._player.cacheFrameRate);
            }
            else {
                this._total = -1;
            }
            return this._total;
        });
        __getset(0, __proto, 'templet', function () {
            return this._templet;
        });
        __getset(0, __proto, 'player', function () {
            return this._player;
        });
        Skeleton.useSimpleMeshInCanvas = false;
        return Skeleton;
    })(Sprite);
    var MovieClip = (function (_super) {
        function MovieClip(parentMovieClip) {
            this._start = 0;
            this._Pos = 0;
            this._data = null;
            this._curIndex = 0;
            this._preIndex = 0;
            this._playIndex = 0;
            this._playing = false;
            this._ended = true;
            this._count = 0;
            this._ids = null;
            this._loadedImage = {};
            this._idOfSprite = null;
            this._parentMovieClip = null;
            this._movieClipList = null;
            this._labels = null;
            this.basePath = null;
            this._atlasPath = null;
            this._url = null;
            this._isRoot = false;
            this._completeHandler = null;
            this._endFrame = -1;
            this.interval = 30;
            this.loop = false;
            MovieClip.__super.call(this);
            this._ids = {};
            this._idOfSprite = [];
            this._reset();
            this._playing = false;
            this._parentMovieClip = parentMovieClip;
            if (!parentMovieClip) {
                this._movieClipList = [this];
                this._isRoot = true;
                this._setUpNoticeType(0x1);
            }
            else {
                this._isRoot = false;
                this._movieClipList = parentMovieClip._movieClipList;
                this._movieClipList.push(this);
            }
        }
        __class(MovieClip, 'laya.ani.swf.MovieClip', _super);
        var __proto = MovieClip.prototype;
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            this._clear();
            _super.prototype.destroy.call(this, destroyChild);
        };
        __proto._setDisplay = function (value) {
            _super.prototype._setDisplay.call(this, value);
            if (this._isRoot) {
                this._$3__onDisplay(value);
            }
        };
        __proto._$3__onDisplay = function (value) {
            if (value)
                this.timer.loop(this.interval, this, this.updates, null, true);
            else
                this.timer.clear(this, this.updates);
        };
        __proto.updates = function () {
            if (this._parentMovieClip)
                return;
            var i = 0, len = 0;
            len = this._movieClipList.length;
            for (i = 0; i < len; i++) {
                this._movieClipList[i] && this._movieClipList[i]._update();
            }
        };
        __proto.addLabel = function (label, index) {
            if (!this._labels)
                this._labels = {};
            this._labels[index] = label;
        };
        __proto.removeLabel = function (label) {
            if (!label)
                this._labels = null;
            else if (!this._labels) {
                for (var name in this._labels) {
                    if (this._labels[name] === label) {
                        delete this._labels[name];
                        break;
                    }
                }
            }
        };
        __proto._update = function () {
            if (!this._data)
                return;
            if (!this._playing)
                return;
            this._playIndex++;
            if (this._playIndex >= this._count) {
                if (!this.loop) {
                    this._playIndex--;
                    this.stop();
                    return;
                }
                this._playIndex = 0;
            }
            this._parse(this._playIndex);
            if (this._labels && this._labels[this._playIndex])
                this.event("label", this._labels[this._playIndex]);
            if (this._endFrame != -1 && this._endFrame == this._playIndex) {
                this._endFrame = -1;
                if (this._completeHandler != null) {
                    var handler = this._completeHandler;
                    this._completeHandler = null;
                    handler.run();
                }
                this.stop();
            }
        };
        __proto.stop = function () {
            this._playing = false;
        };
        __proto.gotoAndStop = function (index) {
            this.index = index;
            this.stop();
        };
        __proto._clear = function () {
            this.stop();
            this._idOfSprite.length = 0;
            if (!this._parentMovieClip) {
                this.timer.clear(this, this.updates);
                var i = 0, len = 0;
                len = this._movieClipList.length;
                for (i = 0; i < len; i++) {
                    if (this._movieClipList[i] != this)
                        this._movieClipList[i]._clear();
                }
                this._movieClipList.length = 0;
            }
            if (this._atlasPath) {
                Loader.clearRes(this._atlasPath);
            }
            ;
            var key;
            for (key in this._loadedImage) {
                if (this._loadedImage[key]) {
                    Loader.clearRes(key);
                    this._loadedImage[key] = false;
                }
            }
            this.removeChildren();
            this.graphics = null;
            this._parentMovieClip = null;
        };
        __proto.play = function (index, loop) {
            (index === void 0) && (index = 0);
            (loop === void 0) && (loop = true);
            this.loop = loop;
            this._playing = true;
            if (this._data)
                this._displayFrame(index);
        };
        __proto._displayFrame = function (frameIndex) {
            (frameIndex === void 0) && (frameIndex = -1);
            if (frameIndex != -1) {
                if (this._curIndex > frameIndex)
                    this._reset();
                this._parse(frameIndex);
            }
        };
        __proto._reset = function (rm) {
            (rm === void 0) && (rm = true);
            if (rm && this._curIndex != 1)
                this.removeChildren();
            this._preIndex = this._curIndex = -1;
            this._Pos = this._start;
        };
        __proto._parse = function (frameIndex) {
            var curChild = this;
            var mc, sp, key = 0, type = 0, tPos = 0, ttype = 0, ifAdd = false;
            var _idOfSprite = this._idOfSprite, _data = this._data, eStr;
            if (this._ended)
                this._reset();
            _data.pos = this._Pos;
            this._ended = false;
            this._playIndex = frameIndex;
            if (this._curIndex > frameIndex && frameIndex < this._preIndex) {
                this._reset(true);
                _data.pos = this._Pos;
            }
            while ((this._curIndex <= frameIndex) && (!this._ended)) {
                type = _data.getUint16();
                switch (type) {
                    case 12:
                        key = _data.getUint16();
                        tPos = this._ids[_data.getUint16()];
                        this._Pos = _data.pos;
                        _data.pos = tPos;
                        if ((ttype = _data.getUint8()) == 0) {
                            var pid = _data.getUint16();
                            sp = _idOfSprite[key];
                            if (!sp) {
                                sp = _idOfSprite[key] = new Sprite();
                                var spp = new Sprite();
                                spp.loadImage(this.basePath + pid + ".png");
                                this._loadedImage[this.basePath + pid + ".png"] = true;
                                sp.addChild(spp);
                                spp.size(_data.getFloat32(), _data.getFloat32());
                                var mat = _data._getMatrix();
                                spp.transform = mat;
                            }
                            sp.alpha = 1;
                        }
                        else if (ttype == 1) {
                            mc = _idOfSprite[key];
                            if (!mc) {
                                _idOfSprite[key] = mc = new MovieClip(this);
                                mc.interval = this.interval;
                                mc._ids = this._ids;
                                mc.basePath = this.basePath;
                                mc._setData(_data, tPos);
                                mc._initState();
                                mc.play(0);
                            }
                            mc.alpha = 1;
                        }
                        _data.pos = this._Pos;
                        break;
                    case 3:
                        ;
                        var node = _idOfSprite[_data.getUint16()];
                        if (node) {
                            this.addChild(node);
                            node.zOrder = _data.getUint16();
                            ifAdd = true;
                        }
                        break;
                    case 4:
                        node = _idOfSprite[_data.getUint16()];
                        node && node.removeSelf();
                        break;
                    case 5:
                        _idOfSprite[_data.getUint16()][MovieClip._ValueList[_data.getUint16()]] = (_data.getFloat32());
                        break;
                    case 6:
                        _idOfSprite[_data.getUint16()].visible = (_data.getUint8() > 0);
                        break;
                    case 7:
                        sp = _idOfSprite[_data.getUint16()];
                        var mt = sp.transform || Matrix.create();
                        mt.setTo(_data.getFloat32(), _data.getFloat32(), _data.getFloat32(), _data.getFloat32(), _data.getFloat32(), _data.getFloat32());
                        sp.transform = mt;
                        break;
                    case 8:
                        _idOfSprite[_data.getUint16()].setPos(_data.getFloat32(), _data.getFloat32());
                        break;
                    case 9:
                        _idOfSprite[_data.getUint16()].setSize(_data.getFloat32(), _data.getFloat32());
                        break;
                    case 10:
                        _idOfSprite[_data.getUint16()].alpha = _data.getFloat32();
                        break;
                    case 11:
                        _idOfSprite[_data.getUint16()].setScale(_data.getFloat32(), _data.getFloat32());
                        break;
                    case 98:
                        eStr = _data.getString();
                        this.event(eStr);
                        if (eStr == "stop")
                            this.stop();
                        break;
                    case 99:
                        this._curIndex = _data.getUint16();
                        ifAdd && this.updateZOrder();
                        break;
                    case 100:
                        this._count = this._curIndex + 1;
                        this._ended = true;
                        if (this._playing) {
                            this.event("enterframe");
                            this.event("end");
                            this.event("complete");
                        }
                        this._reset(false);
                        break;
                }
            }
            if (this._playing && !this._ended)
                this.event("enterframe");
            this._Pos = _data.pos;
        };
        __proto._setData = function (data, start) {
            this._data = data;
            this._start = start + 3;
        };
        __proto.load = function (url, atlas, atlasPath) {
            (atlas === void 0) && (atlas = false);
            this._url = url = URL.formatURL(url);
            if (atlas)
                this._atlasPath = atlasPath ? atlasPath : url.split(".swf")[0] + ".json";
            this.stop();
            this._clear();
            this._movieClipList = [this];
            var urls;
            urls = [{ url: url, type: "arraybuffer" }];
            if (this._atlasPath) {
                urls.push({ url: this._atlasPath, type: "atlas" });
            }
            Laya.loader.load(urls, Handler.create(this, this._onLoaded));
        };
        __proto._onLoaded = function () {
            var data;
            data = Loader.getRes(this._url);
            if (!data) {
                this.event("error", "file not find");
                return;
            }
            this.basePath = this._atlasPath ? Loader.getAtlas(this._atlasPath).dir : this._url.split(".swf")[0] + "/image/";
            this._initData(data);
        };
        __proto._initState = function () {
            this._reset();
            this._ended = false;
            var preState = this._playing;
            this._playing = false;
            this._curIndex = 0;
            while (!this._ended)
                this._parse(++this._curIndex);
            this._playing = preState;
        };
        __proto._initData = function (data) {
            this._data = new Byte(data);
            var i = 0, len = this._data.getUint16();
            for (i = 0; i < len; i++)
                this._ids[this._data.getInt16()] = this._data.getInt32();
            this.interval = 1000 / this._data.getUint16();
            this._setData(this._data, this._ids[32767]);
            this._initState();
            this.play(0);
            this.event("loaded");
            if (!this._parentMovieClip)
                this.timer.loop(this.interval, this, this.updates, null, true);
        };
        __proto.playTo = function (start, end, complete) {
            this._completeHandler = complete;
            this._endFrame = end;
            this.play(start, false);
        };
        __getset(0, __proto, 'index', function () {
            return this._playIndex;
        }, function (value) {
            this._playIndex = value;
            if (this._data)
                this._displayFrame(this._playIndex);
            if (this._labels && this._labels[value])
                this.event("label", this._labels[value]);
        });
        __getset(0, __proto, 'count', function () {
            return this._count;
        });
        __getset(0, __proto, 'playing', function () {
            return this._playing;
        });
        __getset(0, __proto, 'url', null, function (path) {
            this.load(path);
        });
        MovieClip._ValueList = ["x", "y", "width", "height", "scaleX", "scaleY", "rotation", "alpha"];
        return MovieClip;
    })(Sprite);
    var Templet = (function (_super) {
        function Templet() {
            this._mainTexture = null;
            this._textureJson = null;
            this._graphicsCache = [];
            this.srcBoneMatrixArr = [];
            this.ikArr = [];
            this.tfArr = [];
            this.pathArr = [];
            this.boneSlotDic = {};
            this.bindBoneBoneSlotDic = {};
            this.boneSlotArray = [];
            this.skinDataArray = [];
            this.skinDic = {};
            this.subTextureDic = {};
            this.isParseFail = false;
            this.yReverseMatrix = null;
            this.drawOrderAniArr = [];
            this.eventAniArr = [];
            this.attachmentNames = null;
            this.deformAniArr = [];
            this._isDestroyed = false;
            this._rate = 30;
            this.isParserComplete = false;
            this.aniSectionDic = {};
            this._skBufferUrl = null;
            this._textureDic = {};
            this._loadList = null;
            this._path = null;
            this.tMatrixDataLen = 0;
            this.mRootBone = null;
            Templet.__super.call(this);
            this.skinSlotDisplayDataArr = [];
            this.mBoneArr = [];
        }
        __class(Templet, 'laya.ani.bone.Templet', _super);
        var __proto = Templet.prototype;
        __proto.loadAni = function (url) {
            this._skBufferUrl = url;
            Laya.loader.load(url, Handler.create(this, this.onComplete), null, "arraybuffer");
        };
        __proto.onComplete = function (content) {
            if (this._isDestroyed) {
                this.destroy();
                return;
            }
            ;
            var tSkBuffer = Loader.getRes(this._skBufferUrl);
            if (!tSkBuffer) {
                this.event("error", "load failed:" + this._skBufferUrl);
                return;
            }
            this._path = this._skBufferUrl.slice(0, this._skBufferUrl.lastIndexOf("/")) + "/";
            this.parseData(null, tSkBuffer);
        };
        __proto.parseData = function (texture, skeletonData, playbackRate) {
            (playbackRate === void 0) && (playbackRate = 30);
            if (!this._path && this.url)
                this._path = this.url.slice(0, this.url.lastIndexOf("/")) + "/";
            this._mainTexture = texture;
            if (this._mainTexture) {
                if (Render.isWebGL && texture.bitmap) {
                    texture.bitmap.enableMerageInAtlas = false;
                }
            }
            this._rate = playbackRate;
            this.parse(skeletonData);
        };
        __proto.buildArmature = function (aniMode) {
            (aniMode === void 0) && (aniMode = 0);
            return new Skeleton(this, aniMode);
        };
        __proto.parse = function (data) {
            _super.prototype.parse.call(this, data);
            this._endLoaded();
            if (this._aniVersion != Templet.LAYA_ANIMATION_VISION) {
                console_log("[Error] 版本不一致，请使用IDE版本配套的重新导出" + this._aniVersion + "->" + Templet.LAYA_ANIMATION_VISION);
                this._loaded = false;
            }
            if (this.loaded) {
                if (this._mainTexture) {
                    this._parsePublicExtData();
                }
                else {
                    this._parseTexturePath();
                }
            }
            else {
                this.event("error", this);
                this.isParseFail = true;
            }
        };
        __proto._parseTexturePath = function () {
            if (this._isDestroyed) {
                this.destroy();
                return;
            }
            ;
            var i = 0;
            this._loadList = [];
            var tByte = new Byte(this.getPublicExtData());
            var tX = 0, tY = 0, tWidth = 0, tHeight = 0;
            var tFrameX = 0, tFrameY = 0, tFrameWidth = 0, tFrameHeight = 0;
            var tTempleData = 0;
            var tTextureLen = tByte.getInt32();
            var tTextureName = tByte.readUTFString();
            var tTextureNameArr = tTextureName.split("\n");
            var tTexture;
            var tSrcTexturePath;
            for (i = 0; i < tTextureLen; i++) {
                tSrcTexturePath = this._path + tTextureNameArr[i * 2];
                tTextureName = tTextureNameArr[i * 2 + 1];
                tX = tByte.getFloat32();
                tY = tByte.getFloat32();
                tWidth = tByte.getFloat32();
                tHeight = tByte.getFloat32();
                tTempleData = tByte.getFloat32();
                tFrameX = isNaN(tTempleData) ? 0 : tTempleData;
                tTempleData = tByte.getFloat32();
                tFrameY = isNaN(tTempleData) ? 0 : tTempleData;
                tTempleData = tByte.getFloat32();
                tFrameWidth = isNaN(tTempleData) ? tWidth : tTempleData;
                tTempleData = tByte.getFloat32();
                tFrameHeight = isNaN(tTempleData) ? tHeight : tTempleData;
                if (this._loadList.indexOf(tSrcTexturePath) == -1) {
                    this._loadList.push(tSrcTexturePath);
                }
            }
            Laya.loader.load(this._loadList, Handler.create(this, this._textureComplete));
        };
        __proto._textureComplete = function () {
            var tTexture;
            var tTextureName;
            for (var i = 0, n = this._loadList.length; i < n; i++) {
                tTextureName = this._loadList[i];
                tTexture = this._textureDic[tTextureName] = Loader.getRes(tTextureName);
                if (Render.isWebGL && tTexture && tTexture.bitmap) {
                    tTexture.bitmap.enableMerageInAtlas = false;
                }
            }
            this._parsePublicExtData();
        };
        __proto._parsePublicExtData = function () {
            var i = 0, j = 0, k = 0, l = 0, n = 0;
            for (i = 0, n = this.getAnimationCount(); i < n; i++) {
                this._graphicsCache.push([]);
            }
            ;
            var isSpine = false;
            isSpine = this._aniClassName != "Dragon";
            var tByte = new Byte(this.getPublicExtData());
            var tX = 0, tY = 0, tWidth = 0, tHeight = 0;
            var tFrameX = 0, tFrameY = 0, tFrameWidth = 0, tFrameHeight = 0;
            var tTempleData = 0;
            var tTextureLen = tByte.getInt32();
            var tTextureName = tByte.readUTFString();
            var tTextureNameArr = tTextureName.split("\n");
            var tTexture;
            var tSrcTexturePath;
            for (i = 0; i < tTextureLen; i++) {
                tTexture = this._mainTexture;
                tSrcTexturePath = this._path + tTextureNameArr[i * 2];
                tTextureName = tTextureNameArr[i * 2 + 1];
                if (this._mainTexture == null) {
                    tTexture = this._textureDic[tSrcTexturePath];
                }
                if (!tTexture) {
                    this.event("error", this);
                    this.isParseFail = true;
                    return;
                }
                tX = tByte.getFloat32();
                tY = tByte.getFloat32();
                tWidth = tByte.getFloat32();
                tHeight = tByte.getFloat32();
                tTempleData = tByte.getFloat32();
                tFrameX = isNaN(tTempleData) ? 0 : tTempleData;
                tTempleData = tByte.getFloat32();
                tFrameY = isNaN(tTempleData) ? 0 : tTempleData;
                tTempleData = tByte.getFloat32();
                tFrameWidth = isNaN(tTempleData) ? tWidth : tTempleData;
                tTempleData = tByte.getFloat32();
                tFrameHeight = isNaN(tTempleData) ? tHeight : tTempleData;
                this.subTextureDic[tTextureName] = Texture.create(tTexture, tX, tY, tWidth, tHeight, -tFrameX, -tFrameY, tFrameWidth, tFrameHeight);
            }
            this._mainTexture = tTexture;
            var tAniCount = tByte.getUint16();
            var tSectionArr;
            for (i = 0; i < tAniCount; i++) {
                tSectionArr = [];
                tSectionArr.push(tByte.getUint16());
                tSectionArr.push(tByte.getUint16());
                tSectionArr.push(tByte.getUint16());
                tSectionArr.push(tByte.getUint16());
                this.aniSectionDic[i] = tSectionArr;
            }
            ;
            var tBone;
            var tParentBone;
            var tName;
            var tParentName;
            var tBoneLen = tByte.getInt16();
            var tBoneDic = {};
            var tRootBone;
            for (i = 0; i < tBoneLen; i++) {
                tBone = new Bone();
                if (i == 0) {
                    tRootBone = tBone;
                }
                else {
                    tBone.root = tRootBone;
                }
                tBone.d = isSpine ? -1 : 1;
                tName = tByte.readUTFString();
                tParentName = tByte.readUTFString();
                tBone.length = tByte.getFloat32();
                if (tByte.getByte() == 1) {
                    tBone.inheritRotation = false;
                }
                if (tByte.getByte() == 1) {
                    tBone.inheritScale = false;
                }
                tBone.name = tName;
                if (tParentName) {
                    tParentBone = tBoneDic[tParentName];
                    if (tParentBone) {
                        tParentBone.addChild(tBone);
                    }
                    else {
                        this.mRootBone = tBone;
                    }
                }
                tBoneDic[tName] = tBone;
                this.mBoneArr.push(tBone);
            }
            this.tMatrixDataLen = tByte.getUint16();
            var tLen = tByte.getUint16();
            var parentIndex = 0;
            var boneLength = Math.floor(tLen / this.tMatrixDataLen);
            var tResultTransform;
            var tMatrixArray = this.srcBoneMatrixArr;
            for (i = 0; i < boneLength; i++) {
                tResultTransform = new Transform();
                tResultTransform.scX = tByte.getFloat32();
                tResultTransform.skX = tByte.getFloat32();
                tResultTransform.skY = tByte.getFloat32();
                tResultTransform.scY = tByte.getFloat32();
                tResultTransform.x = tByte.getFloat32();
                tResultTransform.y = tByte.getFloat32();
                if (this.tMatrixDataLen === 8) {
                    tResultTransform.skewX = tByte.getFloat32();
                    tResultTransform.skewY = tByte.getFloat32();
                }
                tMatrixArray.push(tResultTransform);
                tBone = this.mBoneArr[i];
                tBone.transform = tResultTransform;
            }
            ;
            var tIkConstraintData;
            var tIkLen = tByte.getUint16();
            var tIkBoneLen = 0;
            for (i = 0; i < tIkLen; i++) {
                tIkConstraintData = new IkConstraintData();
                tIkBoneLen = tByte.getUint16();
                for (j = 0; j < tIkBoneLen; j++) {
                    tIkConstraintData.boneNames.push(tByte.readUTFString());
                    tIkConstraintData.boneIndexs.push(tByte.getInt16());
                }
                tIkConstraintData.name = tByte.readUTFString();
                tIkConstraintData.targetBoneName = tByte.readUTFString();
                tIkConstraintData.targetBoneIndex = tByte.getInt16();
                tIkConstraintData.bendDirection = tByte.getFloat32();
                tIkConstraintData.mix = tByte.getFloat32();
                tIkConstraintData.isSpine = isSpine;
                this.ikArr.push(tIkConstraintData);
            }
            ;
            var tTfConstraintData;
            var tTfLen = tByte.getUint16();
            var tTfBoneLen = 0;
            for (i = 0; i < tTfLen; i++) {
                tTfConstraintData = new TfConstraintData();
                tTfBoneLen = tByte.getUint16();
                for (j = 0; j < tTfBoneLen; j++) {
                    tTfConstraintData.boneIndexs.push(tByte.getInt16());
                }
                tTfConstraintData.name = tByte.getUTFString();
                tTfConstraintData.targetIndex = tByte.getInt16();
                tTfConstraintData.rotateMix = tByte.getFloat32();
                tTfConstraintData.translateMix = tByte.getFloat32();
                tTfConstraintData.scaleMix = tByte.getFloat32();
                tTfConstraintData.shearMix = tByte.getFloat32();
                tTfConstraintData.offsetRotation = tByte.getFloat32();
                tTfConstraintData.offsetX = tByte.getFloat32();
                tTfConstraintData.offsetY = tByte.getFloat32();
                tTfConstraintData.offsetScaleX = tByte.getFloat32();
                tTfConstraintData.offsetScaleY = tByte.getFloat32();
                tTfConstraintData.offsetShearY = tByte.getFloat32();
                this.tfArr.push(tTfConstraintData);
            }
            ;
            var tPathConstraintData;
            var tPathLen = tByte.getUint16();
            var tPathBoneLen = 0;
            for (i = 0; i < tPathLen; i++) {
                tPathConstraintData = new PathConstraintData();
                tPathConstraintData.name = tByte.readUTFString();
                tPathBoneLen = tByte.getUint16();
                for (j = 0; j < tPathBoneLen; j++) {
                    tPathConstraintData.bones.push(tByte.getInt16());
                }
                tPathConstraintData.target = tByte.readUTFString();
                tPathConstraintData.positionMode = tByte.readUTFString();
                tPathConstraintData.spacingMode = tByte.readUTFString();
                tPathConstraintData.rotateMode = tByte.readUTFString();
                tPathConstraintData.offsetRotation = tByte.getFloat32();
                tPathConstraintData.position = tByte.getFloat32();
                tPathConstraintData.spacing = tByte.getFloat32();
                tPathConstraintData.rotateMix = tByte.getFloat32();
                tPathConstraintData.translateMix = tByte.getFloat32();
                this.pathArr.push(tPathConstraintData);
            }
            ;
            var tDeformSlotLen = 0;
            var tDeformSlotDisplayLen = 0;
            var tDSlotIndex = 0;
            var tDAttachment;
            var tDeformTimeLen = 0;
            var tDTime = NaN;
            var tDeformVecticesLen = 0;
            var tDeformAniData;
            var tDeformSlotData;
            var tDeformSlotDisplayData;
            var tDeformVectices;
            var tDeformAniLen = tByte.getInt16();
            for (i = 0; i < tDeformAniLen; i++) {
                var tDeformSkinLen = tByte.getUint8();
                var tSkinDic = {};
                this.deformAniArr.push(tSkinDic);
                for (var f = 0; f < tDeformSkinLen; f++) {
                    tDeformAniData = new DeformAniData();
                    tDeformAniData.skinName = tByte.getUTFString();
                    tSkinDic[tDeformAniData.skinName] = tDeformAniData;
                    tDeformSlotLen = tByte.getInt16();
                    for (j = 0; j < tDeformSlotLen; j++) {
                        tDeformSlotData = new DeformSlotData();
                        tDeformAniData.deformSlotDataList.push(tDeformSlotData);
                        tDeformSlotDisplayLen = tByte.getInt16();
                        for (k = 0; k < tDeformSlotDisplayLen; k++) {
                            tDeformSlotDisplayData = new DeformSlotDisplayData();
                            tDeformSlotData.deformSlotDisplayList.push(tDeformSlotDisplayData);
                            tDeformSlotDisplayData.slotIndex = tDSlotIndex = tByte.getInt16();
                            tDeformSlotDisplayData.attachment = tDAttachment = tByte.getUTFString();
                            tDeformTimeLen = tByte.getInt16();
                            for (l = 0; l < tDeformTimeLen; l++) {
                                if (tByte.getByte() == 1) {
                                    tDeformSlotDisplayData.tweenKeyList.push(true);
                                }
                                else {
                                    tDeformSlotDisplayData.tweenKeyList.push(false);
                                }
                                tDTime = tByte.getFloat32();
                                tDeformSlotDisplayData.timeList.push(tDTime);
                                tDeformVectices = [];
                                tDeformSlotDisplayData.vectices.push(tDeformVectices);
                                tDeformVecticesLen = tByte.getInt16();
                                for (n = 0; n < tDeformVecticesLen; n++) {
                                    tDeformVectices.push(tByte.getFloat32());
                                }
                            }
                        }
                    }
                }
            }
            ;
            var tDrawOrderArr;
            var tDrawOrderAniLen = tByte.getInt16();
            var tDrawOrderLen = 0;
            var tDrawOrderData;
            var tDoLen = 0;
            for (i = 0; i < tDrawOrderAniLen; i++) {
                tDrawOrderLen = tByte.getInt16();
                tDrawOrderArr = [];
                for (j = 0; j < tDrawOrderLen; j++) {
                    tDrawOrderData = new DrawOrderData();
                    tDrawOrderData.time = tByte.getFloat32();
                    tDoLen = tByte.getInt16();
                    for (k = 0; k < tDoLen; k++) {
                        tDrawOrderData.drawOrder.push(tByte.getInt16());
                    }
                    tDrawOrderArr.push(tDrawOrderData);
                }
                this.drawOrderAniArr.push(tDrawOrderArr);
            }
            ;
            var tEventArr;
            var tEventAniLen = tByte.getInt16();
            var tEventLen = 0;
            var tEventData;
            for (i = 0; i < tEventAniLen; i++) {
                tEventLen = tByte.getInt16();
                tEventArr = [];
                for (j = 0; j < tEventLen; j++) {
                    tEventData = new EventData();
                    tEventData.name = tByte.getUTFString();
                    tEventData.intValue = tByte.getInt32();
                    tEventData.floatValue = tByte.getFloat32();
                    tEventData.stringValue = tByte.getUTFString();
                    tEventData.time = tByte.getFloat32();
                    tEventArr.push(tEventData);
                }
                this.eventAniArr.push(tEventArr);
            }
            ;
            var tAttachmentLen = tByte.getInt16();
            if (tAttachmentLen > 0) {
                this.attachmentNames = [];
                for (i = 0; i < tAttachmentLen; i++) {
                    this.attachmentNames.push(tByte.getUTFString());
                }
            }
            ;
            var tBoneSlotLen = tByte.getInt16();
            var tDBBoneSlot;
            var tDBBoneSlotArr;
            for (i = 0; i < tBoneSlotLen; i++) {
                tDBBoneSlot = new BoneSlot();
                tDBBoneSlot.name = tByte.readUTFString();
                tDBBoneSlot.parent = tByte.readUTFString();
                tDBBoneSlot.attachmentName = tByte.readUTFString();
                tDBBoneSlot.srcDisplayIndex = tDBBoneSlot.displayIndex = tByte.getInt16();
                tDBBoneSlot.templet = this;
                this.boneSlotDic[tDBBoneSlot.name] = tDBBoneSlot;
                tDBBoneSlotArr = this.bindBoneBoneSlotDic[tDBBoneSlot.parent];
                if (tDBBoneSlotArr == null) {
                    this.bindBoneBoneSlotDic[tDBBoneSlot.parent] = tDBBoneSlotArr = [];
                }
                tDBBoneSlotArr.push(tDBBoneSlot);
                this.boneSlotArray.push(tDBBoneSlot);
            }
            ;
            var tNameString = tByte.readUTFString();
            var tNameArray = tNameString.split("\n");
            var tNameStartIndex = 0;
            var tSkinDataLen = tByte.getUint8();
            var tSkinData, tSlotData, tDisplayData;
            var tSlotDataLen = 0, tDisplayDataLen = 0;
            var tUvLen = 0, tWeightLen = 0, tTriangleLen = 0, tVerticeLen = 0, tLengthLen = 0;
            for (i = 0; i < tSkinDataLen; i++) {
                tSkinData = new SkinData();
                tSkinData.name = tNameArray[tNameStartIndex++];
                tSlotDataLen = tByte.getUint8();
                for (j = 0; j < tSlotDataLen; j++) {
                    tSlotData = new SlotData();
                    tSlotData.name = tNameArray[tNameStartIndex++];
                    tDBBoneSlot = this.boneSlotDic[tSlotData.name];
                    tDisplayDataLen = tByte.getUint8();
                    for (k = 0; k < tDisplayDataLen; k++) {
                        tDisplayData = new SkinSlotDisplayData();
                        this.skinSlotDisplayDataArr.push(tDisplayData);
                        tDisplayData.name = tNameArray[tNameStartIndex++];
                        tDisplayData.attachmentName = tNameArray[tNameStartIndex++];
                        tDisplayData.transform = new Transform();
                        tDisplayData.transform.scX = tByte.getFloat32();
                        tDisplayData.transform.skX = tByte.getFloat32();
                        tDisplayData.transform.skY = tByte.getFloat32();
                        tDisplayData.transform.scY = tByte.getFloat32();
                        tDisplayData.transform.x = tByte.getFloat32();
                        tDisplayData.transform.y = tByte.getFloat32();
                        tSlotData.displayArr.push(tDisplayData);
                        tDisplayData.width = tByte.getFloat32();
                        tDisplayData.height = tByte.getFloat32();
                        tDisplayData.type = tByte.getUint8();
                        tDisplayData.verLen = tByte.getUint16();
                        tBoneLen = tByte.getUint16();
                        if (tBoneLen > 0) {
                            tDisplayData.bones = [];
                            for (l = 0; l < tBoneLen; l++) {
                                var tBoneId = tByte.getUint16();
                                tDisplayData.bones.push(tBoneId);
                            }
                        }
                        tUvLen = tByte.getUint16();
                        if (tUvLen > 0) {
                            tDisplayData.uvs = [];
                            for (l = 0; l < tUvLen; l++) {
                                tDisplayData.uvs.push(tByte.getFloat32());
                            }
                        }
                        tWeightLen = tByte.getUint16();
                        if (tWeightLen > 0) {
                            tDisplayData.weights = [];
                            for (l = 0; l < tWeightLen; l++) {
                                tDisplayData.weights.push(tByte.getFloat32());
                            }
                        }
                        tTriangleLen = tByte.getUint16();
                        if (tTriangleLen > 0) {
                            tDisplayData.triangles = [];
                            for (l = 0; l < tTriangleLen; l++) {
                                tDisplayData.triangles.push(tByte.getUint16());
                            }
                        }
                        tVerticeLen = tByte.getUint16();
                        if (tVerticeLen > 0) {
                            tDisplayData.vertices = [];
                            for (l = 0; l < tVerticeLen; l++) {
                                tDisplayData.vertices.push(tByte.getFloat32());
                            }
                        }
                        tLengthLen = tByte.getUint16();
                        if (tLengthLen > 0) {
                            tDisplayData.lengths = [];
                            for (l = 0; l < tLengthLen; l++) {
                                tDisplayData.lengths.push(tByte.getFloat32());
                            }
                        }
                    }
                    tSkinData.slotArr.push(tSlotData);
                }
                this.skinDic[tSkinData.name] = tSkinData;
                this.skinDataArray.push(tSkinData);
            }
            ;
            var tReverse = tByte.getUint8();
            if (tReverse == 1) {
                this.yReverseMatrix = new Matrix(1, 0, 0, -1, 0, 0);
                if (tRootBone) {
                    tRootBone.setTempMatrix(this.yReverseMatrix);
                }
            }
            else {
                if (tRootBone) {
                    tRootBone.setTempMatrix(new Matrix());
                }
            }
            this.showSkinByIndex(this.boneSlotDic, 0);
            this.isParserComplete = true;
            this.event("complete", this);
        };
        __proto.getTexture = function (name) {
            var tTexture = this.subTextureDic[name];
            if (tTexture == null) {
                return this._mainTexture;
            }
            return tTexture;
        };
        __proto.showSkinByIndex = function (boneSlotDic, skinIndex, freshDisplayIndex) {
            (freshDisplayIndex === void 0) && (freshDisplayIndex = true);
            if (skinIndex < 0 && skinIndex >= this.skinDataArray.length)
                return false;
            var i = 0, n = 0;
            var tBoneSlot;
            var tSlotData;
            var tSkinData = this.skinDataArray[skinIndex];
            if (tSkinData) {
                for (i = 0, n = tSkinData.slotArr.length; i < n; i++) {
                    tSlotData = tSkinData.slotArr[i];
                    if (tSlotData) {
                        tBoneSlot = boneSlotDic[tSlotData.name];
                        if (tBoneSlot) {
                            tBoneSlot.showSlotData(tSlotData, freshDisplayIndex);
                            if (freshDisplayIndex && tBoneSlot.attachmentName != "undefined" && tBoneSlot.attachmentName != "null") {
                                tBoneSlot.showDisplayByName(tBoneSlot.attachmentName);
                            }
                            else {
                                tBoneSlot.showDisplayByIndex(tBoneSlot.displayIndex);
                            }
                        }
                    }
                }
                return true;
            }
            return false;
        };
        __proto.getSkinIndexByName = function (skinName) {
            var tSkinData;
            for (var i = 0, n = this.skinDataArray.length; i < n; i++) {
                tSkinData = this.skinDataArray[i];
                if (tSkinData.name == skinName) {
                    return i;
                }
            }
            return -1;
        };
        __proto.getGrahicsDataWithCache = function (aniIndex, frameIndex) {
            return this._graphicsCache[aniIndex][frameIndex];
        };
        __proto.setGrahicsDataWithCache = function (aniIndex, frameIndex, graphics) {
            this._graphicsCache[aniIndex][frameIndex] = graphics;
        };
        __proto.destroy = function () {
            this._isDestroyed = true;
            var tTexture;
            for (var $each_tTexture in this.subTextureDic) {
                tTexture = this.subTextureDic[$each_tTexture];
                if (tTexture)
                    tTexture.destroy();
            }
            var $each_tTexture;
            for ($each_tTexture in this._textureDic) {
                tTexture = this._textureDic[$each_tTexture];
                if (tTexture)
                    tTexture.destroy();
            }
            ;
            var tSkinSlotDisplayData;
            for (var i = 0, n = this.skinSlotDisplayDataArr.length; i < n; i++) {
                tSkinSlotDisplayData = this.skinSlotDisplayDataArr[i];
                tSkinSlotDisplayData.destory();
            }
            this.skinSlotDisplayDataArr.length = 0;
            if (this.url) {
                delete Templet.TEMPLET_DICTIONARY[this.url];
            }
            laya.resource.Resource.prototype.destroy.call(this);
        };
        __proto.getAniNameByIndex = function (index) {
            var tAni = this.getAnimation(index);
            if (tAni)
                return tAni.name;
            return null;
        };
        __getset(0, __proto, 'rate', function () {
            return this._rate;
        }, function (v) {
            this._rate = v;
        });
        Templet.LAYA_ANIMATION_VISION = "LAYAANIMATION:1.6.0";
        Templet.TEMPLET_DICTIONARY = null;
        return Templet;
    })(AnimationTemplet);
})(window, document, Laya);
if (typeof define === 'function' && define.amd) {
    define('laya.core', ['require', "exports"], function (require, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        for (var i in Laya) {
            var o = Laya[i];
            o && o.__isclass && (exports[i] = o);
        }
    });
}
(function (window, document, Laya) {
    var __un = Laya.un, __uns = Laya.uns, __static = Laya.static, __class = Laya.class, __getset = Laya.getset, __newvec = Laya.__newvec;
    var Browser = laya.utils.Browser, HTMLCanvas = laya.resource.HTMLCanvas, Handler = laya.utils.Handler, Loader = laya.net.Loader;
    var Point = laya.maths.Point, Rectangle = laya.maths.Rectangle, Render = laya.renders.Render, RenderContext = laya.renders.RenderContext;
    var Sprite = laya.display.Sprite, Texture = laya.resource.Texture;
    var TiledMap = (function () {
        var GRect, TileMapAniData, TileSet;
        function TiledMap() {
            this._jsonData = null;
            this._tileTexSetArr = [];
            this._texArray = [];
            this._x = 0;
            this._y = 0;
            this._width = 0;
            this._height = 0;
            this._mapW = 0;
            this._mapH = 0;
            this._mapTileW = 0;
            this._mapTileH = 0;
            this._mapSprite = null;
            this._layerArray = [];
            this._renderLayerArray = [];
            this._gridArray = [];
            this._showGridKey = false;
            this._totalGridNum = 0;
            this._gridW = 0;
            this._gridH = 0;
            this._gridWidth = 450;
            this._gridHeight = 450;
            this._jsonLoader = null;
            this._loader = null;
            this._tileSetArray = [];
            this._currTileSet = null;
            this._completeHandler = null;
            this._index = 0;
            this._animationDic = {};
            this._properties = null;
            this._tileProperties = {};
            this._tileProperties2 = {};
            this._orientation = "orthogonal";
            this._renderOrder = "right-down";
            this._colorArray = ["FF", "00", "33", "66"];
            this._scale = 1;
            this._pivotScaleX = 0.5;
            this._pivotScaleY = 0.5;
            this._centerX = 0;
            this._centerY = 0;
            this._viewPortX = 0;
            this._viewPortY = 0;
            this._viewPortWidth = 0;
            this._viewPortHeight = 0;
            this._enableLinear = true;
            this._resPath = null;
            this._pathArray = null;
            this._limitRange = false;
            this._fastDirty = true;
            this.autoCache = true;
            this.autoCacheType = "normal";
            this.enableMergeLayer = false;
            this.removeCoveredTile = false;
            this.showGridTextureCount = false;
            this.antiCrack = true;
            this.cacheAllAfterInit = false;
            this._texutreStartDic = {};
            this._rect = new Rectangle();
            this._paddingRect = new Rectangle();
            this._mapRect = new GRect();
            this._mapLogicRect = new GRect();
            this._mapLastRect = new GRect();
            this._mapSprite = new Sprite();
        }
        __class(TiledMap, 'laya.map.TiledMap');
        var __proto = TiledMap.prototype;
        __proto.createMap = function (mapName, viewRect, completeHandler, viewRectPadding, gridSize, enableLinear, limitRange) {
            (enableLinear === void 0) && (enableLinear = true);
            (limitRange === void 0) && (limitRange = false);
            this._enableLinear = enableLinear;
            this._limitRange = limitRange;
            this._rect.x = viewRect.x;
            this._rect.y = viewRect.y;
            this._rect.width = viewRect.width;
            this._rect.height = viewRect.height;
            this._viewPortWidth = viewRect.width / this._scale;
            this._viewPortHeight = viewRect.height / this._scale;
            this._completeHandler = completeHandler;
            if (viewRectPadding) {
                this._paddingRect.copyFrom(viewRectPadding);
            }
            else {
                this._paddingRect.setTo(0, 0, 0, 0);
            }
            if (gridSize) {
                this._gridWidth = gridSize.x;
                this._gridHeight = gridSize.y;
            }
            ;
            var tIndex = mapName.lastIndexOf("/");
            if (tIndex > -1) {
                this._resPath = mapName.substr(0, tIndex);
                this._pathArray = this._resPath.split("/");
            }
            else {
                this._resPath = "";
                this._pathArray = [];
            }
            this._jsonLoader = new Loader();
            this._jsonLoader.once("complete", this, this.onJsonComplete);
            this._jsonLoader.load(mapName, "json", false);
        };
        __proto.onJsonComplete = function (e) {
            var tJsonData = this._jsonData = e;
            this._properties = tJsonData.properties;
            this._orientation = tJsonData.orientation;
            this._renderOrder = tJsonData.renderorder;
            this._mapW = tJsonData.width;
            this._mapH = tJsonData.height;
            this._mapTileW = tJsonData.tilewidth;
            this._mapTileH = tJsonData.tileheight;
            this._width = this._mapTileW * this._mapW;
            this._height = this._mapTileH * this._mapH;
            if (this._orientation == "staggered") {
                this._height = (0.5 + this._mapH * 0.5) * this._mapTileH;
            }
            this._mapLastRect.top = this._mapLastRect.bottom = this._mapLastRect.left = this._mapLastRect.right = -1;
            var tArray = tJsonData.tilesets;
            var tileset;
            var tTileSet;
            var i = 0;
            for (i = 0; i < tArray.length; i++) {
                tileset = tArray[i];
                tTileSet = new TileSet();
                tTileSet.init(tileset);
                if (tTileSet.properties && tTileSet.properties.ignore)
                    continue;
                this._tileProperties[i] = tTileSet.tileproperties;
                this.addTileProperties(tTileSet.tileproperties);
                this._tileSetArray.push(tTileSet);
                var tTiles = tileset.tiles;
                if (tTiles) {
                    for (var p in tTiles) {
                        var tAnimation = tTiles[p].animation;
                        if (tAnimation) {
                            var tAniData = new TileMapAniData();
                            this._animationDic[p] = tAniData;
                            tAniData.image = tileset.image;
                            for (var j = 0; j < tAnimation.length; j++) {
                                var tAnimationItem = tAnimation[j];
                                tAniData.mAniIdArray.push(tAnimationItem.tileid);
                                tAniData.mDurationTimeArray.push(tAnimationItem.duration);
                            }
                        }
                    }
                }
            }
            this._tileTexSetArr.push(null);
            if (this._tileSetArray.length > 0) {
                tTileSet = this._currTileSet = this._tileSetArray.shift();
                this._loader = new Loader();
                this._loader.once("complete", this, this.onTextureComplete);
                var tPath = this.mergePath(this._resPath, tTileSet.image);
                this._loader.load(tPath, "image", false);
            }
        };
        __proto.mergePath = function (resPath, relativePath) {
            var tResultPath = "";
            var tImageArray = relativePath.split("/");
            var tParentPathNum = 0;
            var i = 0;
            for (i = tImageArray.length - 1; i >= 0; i--) {
                if (tImageArray[i] == "..") {
                    tParentPathNum++;
                }
            }
            if (tParentPathNum == 0) {
                if (this._pathArray.length > 0) {
                    tResultPath = resPath + "/" + relativePath;
                }
                else {
                    tResultPath = relativePath;
                }
                return tResultPath;
            }
            ;
            var tSrcNum = this._pathArray.length - tParentPathNum;
            if (tSrcNum < 0) {
                console_log("[error]path does not exist", this._pathArray, tImageArray, resPath, relativePath);
            }
            for (i = 0; i < tSrcNum; i++) {
                if (i == 0) {
                    tResultPath += this._pathArray[i];
                }
                else {
                    tResultPath = tResultPath + "/" + this._pathArray[i];
                }
            }
            for (i = tParentPathNum; i < tImageArray.length; i++) {
                tResultPath = tResultPath + "/" + tImageArray[i];
            }
            return tResultPath;
        };
        __proto.onTextureComplete = function (e) {
            var json = this._jsonData;
            var tTexture = e;
            if (Render.isWebGL && (!this._enableLinear)) {
                tTexture.bitmap.minFifter = 0x2600;
                tTexture.bitmap.magFifter = 0x2600;
                tTexture.bitmap.enableMerageInAtlas = false;
            }
            this._texArray.push(tTexture);
            var tSubTexture = null;
            var tTileSet = this._currTileSet;
            var tTileTextureW = tTileSet.tilewidth;
            var tTileTextureH = tTileSet.tileheight;
            var tImageWidth = tTileSet.imagewidth;
            var tImageHeight = tTileSet.imageheight;
            var tFirstgid = tTileSet.firstgid;
            var tTileWNum = Math.floor((tImageWidth - tTileSet.margin - tTileTextureW) / (tTileTextureW + tTileSet.spacing)) + 1;
            var tTileHNum = Math.floor((tImageHeight - tTileSet.margin - tTileTextureH) / (tTileTextureH + tTileSet.spacing)) + 1;
            var tTileTexSet = null;
            this._texutreStartDic[tTileSet.image] = this._tileTexSetArr.length;
            for (var i = 0; i < tTileHNum; i++) {
                for (var j = 0; j < tTileWNum; j++) {
                    tTileTexSet = new TileTexSet();
                    tTileTexSet.offX = tTileSet.titleoffsetX;
                    tTileTexSet.offY = tTileSet.titleoffsetY - (tTileTextureH - this._mapTileH);
                    tTileTexSet.texture = Texture.createFromTexture(tTexture, tTileSet.margin + (tTileTextureW + tTileSet.spacing) * j, tTileSet.margin + (tTileTextureH + tTileSet.spacing) * i, tTileTextureW, tTileTextureH);
                    if (this.antiCrack)
                        this.adptTexture(tTileTexSet.texture);
                    this._tileTexSetArr.push(tTileTexSet);
                    tTileTexSet.gid = this._tileTexSetArr.length;
                }
            }
            if (this._tileSetArray.length > 0) {
                tTileSet = this._currTileSet = this._tileSetArray.shift();
                this._loader.once("complete", this, this.onTextureComplete);
                var tPath = this.mergePath(this._resPath, tTileSet.image);
                this._loader.load(tPath, "image", false);
            }
            else {
                this._currTileSet = null;
                this.initMap();
            }
        };
        __proto.adptTexture = function (tex) {
            if (!tex)
                return;
            var pX = tex.uv[0];
            var pX1 = tex.uv[2];
            var pY = tex.uv[1];
            var pY1 = tex.uv[7];
            var dW = 1 / tex.bitmap.width;
            var dH = 1 / tex.bitmap.height;
            tex.uv[0] = tex.uv[6] = pX + dW;
            tex.uv[2] = tex.uv[4] = pX1 - dW;
            tex.uv[1] = tex.uv[3] = pY + dH;
            tex.uv[5] = tex.uv[7] = pY1 - dH;
        };
        __proto.initMap = function () {
            var i = 0, n = 0;
            for (var p in this._animationDic) {
                var tAniData = this._animationDic[p];
                var gStart = 0;
                gStart = this._texutreStartDic[tAniData.image];
                var tTileTexSet = this.getTexture(parseInt(p) + gStart);
                if (tAniData.mAniIdArray.length > 0) {
                    tTileTexSet.textureArray = [];
                    tTileTexSet.durationTimeArray = tAniData.mDurationTimeArray;
                    tTileTexSet.isAnimation = true;
                    tTileTexSet.animationTotalTime = 0;
                    for (i = 0, n = tTileTexSet.durationTimeArray.length; i < n; i++) {
                        tTileTexSet.animationTotalTime += tTileTexSet.durationTimeArray[i];
                    }
                    for (i = 0, n = tAniData.mAniIdArray.length; i < n; i++) {
                        var tTexture = this.getTexture(tAniData.mAniIdArray[i] + gStart);
                        tTileTexSet.textureArray.push(tTexture);
                    }
                }
            }
            this._gridWidth = Math.floor(this._gridWidth / this._mapTileW) * this._mapTileW;
            this._gridHeight = Math.floor(this._gridHeight / this._mapTileH) * this._mapTileH;
            if (this._gridWidth < this._mapTileW) {
                this._gridWidth = this._mapTileW;
            }
            if (this._gridHeight < this._mapTileH) {
                this._gridHeight = this._mapTileH;
            }
            this._gridW = Math.ceil(this._width / this._gridWidth);
            this._gridH = Math.ceil(this._height / this._gridHeight);
            this._totalGridNum = this._gridW * this._gridH;
            for (i = 0; i < this._gridH; i++) {
                var tGridArray = [];
                this._gridArray.push(tGridArray);
                for (var j = 0; j < this._gridW; j++) {
                    tGridArray.push(null);
                }
            }
            ;
            var tLayerArray = this._jsonData.layers;
            var isFirst = true;
            var tTarLayerID = 1;
            var tLayerTarLayerName;
            var preLayerTarName;
            var preLayer;
            for (var tLayerLoop = 0; tLayerLoop < tLayerArray.length; tLayerLoop++) {
                var tLayerData = tLayerArray[tLayerLoop];
                if (tLayerData.visible == true) {
                    var tMapLayer = new MapLayer();
                    tMapLayer.init(tLayerData, this);
                    if (!this.enableMergeLayer) {
                        this._mapSprite.addChild(tMapLayer);
                        this._renderLayerArray.push(tMapLayer);
                    }
                    else {
                        tLayerTarLayerName = tMapLayer.getLayerProperties("layer");
                        isFirst = isFirst || (!preLayer) || (tLayerTarLayerName != preLayerTarName);
                        if (isFirst) {
                            isFirst = false;
                            tMapLayer.tarLayer = tMapLayer;
                            preLayer = tMapLayer;
                            this._mapSprite.addChild(tMapLayer);
                            this._renderLayerArray.push(tMapLayer);
                        }
                        else {
                            tMapLayer.tarLayer = preLayer;
                        }
                        preLayerTarName = tLayerTarLayerName;
                    }
                    this._layerArray.push(tMapLayer);
                }
            }
            if (this.removeCoveredTile) {
                this.adptTiledMapData();
            }
            if (this.cacheAllAfterInit) {
                this.cacheAllGrid();
            }
            this.moveViewPort(this._rect.x, this._rect.y);
            Laya.stage.addChild(this.mapSprite());
            if (this._completeHandler != null) {
                this._completeHandler.run();
            }
        };
        __proto.addTileProperties = function (tileDataDic) {
            var key;
            for (key in tileDataDic) {
                this._tileProperties2[key] = tileDataDic[key];
            }
        };
        __proto.getTileUserData = function (id, sign, defaultV) {
            if (!this._tileProperties2 || !this._tileProperties2[id] || !(sign in this._tileProperties2[id]))
                return defaultV;
            return this._tileProperties2[id][sign];
        };
        __proto.adptTiledMapData = function () {
            var i = 0, len = 0;
            len = this._layerArray.length;
            var tLayer;
            var noNeeds = {};
            var tDatas;
            for (i = len - 1; i >= 0; i--) {
                tLayer = this._layerArray[i];
                tDatas = tLayer._mapData;
                if (!tDatas)
                    continue;
                this.removeCoverd(tDatas, noNeeds);
                this.collectCovers(tDatas, noNeeds, i);
            }
        };
        __proto.removeCoverd = function (datas, noNeeds) {
            var i = 0, len = 0;
            len = datas.length;
            for (i = 0; i < len; i++) {
                if (noNeeds[i]) {
                    datas[i] = 0;
                }
            }
        };
        __proto.collectCovers = function (datas, noNeeds, layer) {
            var i = 0, len = 0;
            len = datas.length;
            var tTileData = 0;
            var isCover = 0;
            for (i = 0; i < len; i++) {
                tTileData = datas[i];
                if (tTileData > 0) {
                    isCover = this.getTileUserData(tTileData - 1, "type", 0);
                    if (isCover > 0) {
                        noNeeds[i] = tTileData;
                    }
                }
            }
        };
        __proto.getTexture = function (index) {
            if (index < this._tileTexSetArr.length) {
                return this._tileTexSetArr[index];
            }
            return null;
        };
        __proto.getMapProperties = function (name) {
            if (this._properties) {
                return this._properties[name];
            }
            return null;
        };
        __proto.getTileProperties = function (index, id, name) {
            if (this._tileProperties[index] && this._tileProperties[index][id]) {
                return this._tileProperties[index][id][name];
            }
            return null;
        };
        __proto.getSprite = function (index, width, height) {
            if (0 < this._tileTexSetArr.length) {
                var tGridSprite = new GridSprite();
                tGridSprite.initData(this, true);
                tGridSprite.size(width, height);
                var tTileTexSet = this._tileTexSetArr[index];
                if (tTileTexSet != null && tTileTexSet.texture != null) {
                    if (tTileTexSet.isAnimation) {
                        var tAnimationSprite = new TileAniSprite();
                        this._index++;
                        tAnimationSprite.setTileTextureSet(this._index.toString(), tTileTexSet);
                        tGridSprite.addAniSprite(tAnimationSprite);
                        tGridSprite.addChild(tAnimationSprite);
                    }
                    else {
                        tGridSprite.graphics.drawTexture(tTileTexSet.texture, 0, 0, width, height);
                    }
                    tGridSprite.drawImageNum++;
                }
                return tGridSprite;
            }
            return null;
        };
        __proto.setViewPortPivotByScale = function (scaleX, scaleY) {
            this._pivotScaleX = scaleX;
            this._pivotScaleY = scaleY;
            this._fastDirty = true;
        };
        __proto.moveViewPort = function (moveX, moveY) {
            this._x = -moveX;
            this._y = -moveY;
            if (this._fastDirty) {
                this._rect.x = moveX;
                this._rect.y = moveY;
                this.updateViewPort();
            }
            else {
                var dx = NaN, dy = NaN;
                dx = moveX - this._rect.x;
                dy = moveY - this._rect.y;
                this._rect.x = moveX;
                this._rect.y = moveY;
                this.updateViewPortFast(dx, dy);
            }
        };
        __proto.changeViewPort = function (moveX, moveY, width, height) {
            if (moveX == this._rect.x && moveY == this._rect.y && width == this._rect.width && height == this._rect.height)
                return;
            if (width == this._rect.width && height == this._rect.height) {
                this.moveViewPort(moveX, moveY);
                return;
            }
            this._fastDirty = true;
            this._x = -moveX;
            this._y = -moveY;
            this._rect.x = moveX;
            this._rect.y = moveY;
            this._rect.width = width;
            this._rect.height = height;
            this._viewPortWidth = width / this._scale;
            this._viewPortHeight = height / this._scale;
            this.updateViewPort();
        };
        __proto.changeViewPortBySize = function (width, height, rect) {
            if (rect == null) {
                rect = new Rectangle();
            }
            this._centerX = this._rect.x + this._rect.width * this._pivotScaleX;
            this._centerY = this._rect.y + this._rect.height * this._pivotScaleY;
            rect.x = this._centerX - width * this._pivotScaleX;
            rect.y = this._centerY - height * this._pivotScaleY;
            rect.width = width;
            rect.height = height;
            this.changeViewPort(rect.x, rect.y, rect.width, rect.height);
            return rect;
        };
        __proto.updateViewPortFast = function (dx, dy) {
            this._centerX += dx;
            this._centerY += dy;
            this._viewPortX += dx;
            this._viewPortY += dy;
            var posChanged = false;
            var dyG = dy / this._gridHeight;
            var dxG = dx / this._gridWidth;
            this._mapLogicRect.top += dyG;
            this._mapLogicRect.bottom += dyG;
            this._mapLogicRect.left += dxG;
            this._mapLogicRect.right += dxG;
            this._mapRect.top = 0 | this._mapLogicRect.top;
            this._mapRect.bottom = 0 | this._mapLogicRect.bottom;
            this._mapRect.left = 0 | this._mapLogicRect.left;
            this._mapRect.right = 0 | this._mapLogicRect.right;
            if (this._mapRect.top != this._mapLastRect.top || this._mapRect.bottom != this._mapLastRect.bottom || this._mapRect.left != this._mapLastRect.left || this._mapRect.right != this._mapLastRect.right) {
                this.clipViewPort();
                this._mapLastRect.top = this._mapRect.top;
                this._mapLastRect.bottom = this._mapRect.bottom;
                this._mapLastRect.left = this._mapRect.left;
                this._mapLastRect.right = this._mapRect.right;
                posChanged = true;
            }
            ;
            posChanged = posChanged || (dx != 0 || dy != 0);
            if (!posChanged)
                return;
            this.updateMapLayersPos();
        };
        __proto.updateMapLayersPos = function () {
            var tMapLayer;
            var len = this._renderLayerArray.length;
            for (var i = 0; i < len; i++) {
                tMapLayer = this._renderLayerArray[i];
                if (tMapLayer._gridSpriteArray.length > 0) {
                    tMapLayer.updateAloneObject();
                    tMapLayer.pos(-this._viewPortX, -this._viewPortY);
                }
            }
        };
        __proto.updateViewPort = function () {
            this._fastDirty = false;
            var dw = this._rect.width * this._pivotScaleX;
            var dh = this._rect.height * this._pivotScaleY;
            this._centerX = this._rect.x + dw;
            this._centerY = this._rect.y + dh;
            var posChanged = false;
            var preValue = this._viewPortX;
            this._viewPortX = this._centerX - dw / this._scale;
            if (preValue != this._viewPortX) {
                posChanged = true;
            }
            else {
                preValue = this._viewPortY;
            }
            this._viewPortY = this._centerY - dh / this._scale;
            if (!posChanged && preValue != this._viewPortY) {
                posChanged = true;
            }
            if (this._limitRange) {
                var tRight = this._viewPortX + this._viewPortWidth;
                if (tRight > this._width) {
                    this._viewPortX = this._width - this._viewPortWidth;
                }
                ;
                var tBottom = this._viewPortY + this._viewPortHeight;
                if (tBottom > this._height) {
                    this._viewPortY = this._height - this._viewPortHeight;
                }
                if (this._viewPortX < 0) {
                    this._viewPortX = 0;
                }
                if (this._viewPortY < 0) {
                    this._viewPortY = 0;
                }
            }
            ;
            var tPaddingRect = this._paddingRect;
            this._mapLogicRect.top = (this._viewPortY - tPaddingRect.y) / this._gridHeight;
            this._mapLogicRect.bottom = (this._viewPortY + this._viewPortHeight + tPaddingRect.height + tPaddingRect.y) / this._gridHeight;
            this._mapLogicRect.left = (this._viewPortX - tPaddingRect.x) / this._gridWidth;
            this._mapLogicRect.right = (this._viewPortX + this._viewPortWidth + tPaddingRect.width + tPaddingRect.x) / this._gridWidth;
            this._mapRect.top = 0 | this._mapLogicRect.top;
            this._mapRect.bottom = 0 | this._mapLogicRect.bottom;
            this._mapRect.left = 0 | this._mapLogicRect.left;
            this._mapRect.right = 0 | this._mapLogicRect.right;
            if (this._mapRect.top != this._mapLastRect.top || this._mapRect.bottom != this._mapLastRect.bottom || this._mapRect.left != this._mapLastRect.left || this._mapRect.right != this._mapLastRect.right) {
                this.clipViewPort();
                this._mapLastRect.top = this._mapRect.top;
                this._mapLastRect.bottom = this._mapRect.bottom;
                this._mapLastRect.left = this._mapRect.left;
                this._mapLastRect.right = this._mapRect.right;
                posChanged = true;
            }
            if (!posChanged)
                return;
            this.updateMapLayersPos();
        };
        __proto.clipViewPort = function () {
            var tSpriteNum = 0;
            var tSprite;
            var tIndex = 0;
            var tSub = 0;
            var tAdd = 0;
            var i = 0, j = 0;
            if (this._mapRect.left > this._mapLastRect.left) {
                tSub = this._mapRect.left - this._mapLastRect.left;
                if (tSub > 0) {
                    for (j = this._mapLastRect.left; j < this._mapLastRect.left + tSub; j++) {
                        for (i = this._mapLastRect.top; i <= this._mapLastRect.bottom; i++) {
                            this.hideGrid(j, i);
                        }
                    }
                }
            }
            else {
                tAdd = Math.min(this._mapLastRect.left, this._mapRect.right + 1) - this._mapRect.left;
                if (tAdd > 0) {
                    for (j = this._mapRect.left; j < this._mapRect.left + tAdd; j++) {
                        for (i = this._mapRect.top; i <= this._mapRect.bottom; i++) {
                            this.showGrid(j, i);
                        }
                    }
                }
            }
            if (this._mapRect.right > this._mapLastRect.right) {
                tAdd = this._mapRect.right - this._mapLastRect.right;
                if (tAdd > 0) {
                    for (j = Math.max(this._mapLastRect.right + 1, this._mapRect.left); j <= this._mapLastRect.right + tAdd; j++) {
                        for (i = this._mapRect.top; i <= this._mapRect.bottom; i++) {
                            this.showGrid(j, i);
                        }
                    }
                }
            }
            else {
                tSub = this._mapLastRect.right - this._mapRect.right;
                if (tSub > 0) {
                    for (j = this._mapRect.right + 1; j <= this._mapRect.right + tSub; j++) {
                        for (i = this._mapLastRect.top; i <= this._mapLastRect.bottom; i++) {
                            this.hideGrid(j, i);
                        }
                    }
                }
            }
            if (this._mapRect.top > this._mapLastRect.top) {
                tSub = this._mapRect.top - this._mapLastRect.top;
                if (tSub > 0) {
                    for (i = this._mapLastRect.top; i < this._mapLastRect.top + tSub; i++) {
                        for (j = this._mapLastRect.left; j <= this._mapLastRect.right; j++) {
                            this.hideGrid(j, i);
                        }
                    }
                }
            }
            else {
                tAdd = Math.min(this._mapLastRect.top, this._mapRect.bottom + 1) - this._mapRect.top;
                if (tAdd > 0) {
                    for (i = this._mapRect.top; i < this._mapRect.top + tAdd; i++) {
                        for (j = this._mapRect.left; j <= this._mapRect.right; j++) {
                            this.showGrid(j, i);
                        }
                    }
                }
            }
            if (this._mapRect.bottom > this._mapLastRect.bottom) {
                tAdd = this._mapRect.bottom - this._mapLastRect.bottom;
                if (tAdd > 0) {
                    for (i = Math.max(this._mapLastRect.bottom + 1, this._mapRect.top); i <= this._mapLastRect.bottom + tAdd; i++) {
                        for (j = this._mapRect.left; j <= this._mapRect.right; j++) {
                            this.showGrid(j, i);
                        }
                    }
                }
            }
            else {
                tSub = this._mapLastRect.bottom - this._mapRect.bottom;
                if (tSub > 0) {
                    for (i = this._mapRect.bottom + 1; i <= this._mapRect.bottom + tSub; i++) {
                        for (j = this._mapLastRect.left; j <= this._mapLastRect.right; j++) {
                            this.hideGrid(j, i);
                        }
                    }
                }
            }
        };
        __proto.showGrid = function (gridX, gridY) {
            if (gridX < 0 || gridX >= this._gridW || gridY < 0 || gridY >= this._gridH) {
                return;
            }
            ;
            var i = 0, j = 0;
            var tGridSprite;
            var tTempArray = this._gridArray[gridY][gridX];
            if (tTempArray == null) {
                tTempArray = this.getGridArray(gridX, gridY);
            }
            else {
                for (i = 0; i < tTempArray.length && i < this._layerArray.length; i++) {
                    var tLayerSprite = this._layerArray[i];
                    if (tLayerSprite && tTempArray[i]) {
                        tGridSprite = tTempArray[i];
                        if (tGridSprite.visible == false && tGridSprite.drawImageNum > 0) {
                            tGridSprite.show();
                        }
                    }
                }
            }
        };
        __proto.cacheAllGrid = function () {
            var i = 0, j = 0;
            var tempArr;
            for (i = 0; i < this._gridW; i++) {
                for (j = 0; j < this._gridH; j++) {
                    tempArr = this.getGridArray(i, j);
                    this.cacheGridsArray(tempArr);
                }
            }
        };
        __proto.cacheGridsArray = function (arr) {
            var canvas;
            if (!TiledMap._tempContext) {
                TiledMap._tempContext = new RenderContext(1, 1, HTMLCanvas.create("AUTO"));
            }
            canvas = TiledMap._tempContext.canvas;
            canvas.context.asBitmap = false;
            var i = 0, len = 0;
            len = arr.length;
            var tGrid;
            for (i = 0; i < len; i++) {
                tGrid = arr[i];
                canvas.clear();
                canvas.size(1, 1);
                tGrid.render(TiledMap._tempContext, 0, 0);
                tGrid.hide();
            }
            canvas.clear();
            canvas.size(1, 1);
        };
        __proto.getGridArray = function (gridX, gridY) {
            var i = 0, j = 0;
            var tGridSprite;
            var tTempArray = this._gridArray[gridY][gridX];
            if (tTempArray == null) {
                tTempArray = this._gridArray[gridY][gridX] = [];
                var tLeft = 0;
                var tRight = 0;
                var tTop = 0;
                var tBottom = 0;
                var tGridWidth = this._gridWidth;
                var tGridHeight = this._gridHeight;
                switch (this.orientation) {
                    case "isometric":
                        tLeft = Math.floor(gridX * tGridWidth);
                        tRight = Math.floor(gridX * tGridWidth + tGridWidth);
                        tTop = Math.floor(gridY * tGridHeight);
                        tBottom = Math.floor(gridY * tGridHeight + tGridHeight);
                        var tLeft1 = 0, tRight1 = 0, tTop1 = 0, tBottom1 = 0;
                        break;
                    case "staggered":
                        tLeft = Math.floor(gridX * tGridWidth / this._mapTileW);
                        tRight = Math.floor((gridX * tGridWidth + tGridWidth) / this._mapTileW);
                        tTop = Math.floor(gridY * tGridHeight / (this._mapTileH / 2));
                        tBottom = Math.floor((gridY * tGridHeight + tGridHeight) / (this._mapTileH / 2));
                        break;
                    case "orthogonal":
                        tLeft = Math.floor(gridX * tGridWidth / this._mapTileW);
                        tRight = Math.floor((gridX * tGridWidth + tGridWidth) / this._mapTileW);
                        tTop = Math.floor(gridY * tGridHeight / this._mapTileH);
                        tBottom = Math.floor((gridY * tGridHeight + tGridHeight) / this._mapTileH);
                        break;
                    case "hexagonal":
                        ;
                        var tHeight = this._mapTileH * 2 / 3;
                        tLeft = Math.floor(gridX * tGridWidth / this._mapTileW);
                        tRight = Math.ceil((gridX * tGridWidth + tGridWidth) / this._mapTileW);
                        tTop = Math.floor(gridY * tGridHeight / tHeight);
                        tBottom = Math.ceil((gridY * tGridHeight + tGridHeight) / tHeight);
                        break;
                }
                ;
                var tLayer = null;
                var tTGridSprite;
                var tDrawMapLayer;
                for (var z = 0; z < this._layerArray.length; z++) {
                    tLayer = this._layerArray[z];
                    if (this.enableMergeLayer) {
                        if (tLayer.tarLayer != tDrawMapLayer) {
                            tTGridSprite = null;
                            tDrawMapLayer = tLayer.tarLayer;
                        }
                        if (!tTGridSprite) {
                            tTGridSprite = tDrawMapLayer.getDrawSprite(gridX, gridY);
                            tTempArray.push(tTGridSprite);
                        }
                        tGridSprite = tTGridSprite;
                    }
                    else {
                        tGridSprite = tLayer.getDrawSprite(gridX, gridY);
                        tTempArray.push(tGridSprite);
                    }
                    ;
                    var tColorStr;
                    if (this._showGridKey) {
                        tColorStr = "#";
                        tColorStr += this._colorArray[Math.floor(Math.random() * this._colorArray.length)];
                        tColorStr += this._colorArray[Math.floor(Math.random() * this._colorArray.length)];
                        tColorStr += this._colorArray[Math.floor(Math.random() * this._colorArray.length)];
                    }
                    switch (this.orientation) {
                        case "isometric":
                            ;
                            var tHalfTileHeight = this.tileHeight / 2;
                            var tHalfTileWidth = this.tileWidth / 2;
                            var tHalfMapWidth = this._width / 2;
                            tTop1 = Math.floor(tTop / tHalfTileHeight);
                            tBottom1 = Math.floor(tBottom / tHalfTileHeight);
                            tLeft1 = this._mapW + Math.floor((tLeft - tHalfMapWidth) / tHalfTileWidth);
                            tRight1 = this._mapW + Math.floor((tRight - tHalfMapWidth) / tHalfTileWidth);
                            var tMapW = this._mapW * 2;
                            var tMapH = this._mapH * 2;
                            if (tTop1 < 0) {
                                tTop1 = 0;
                            }
                            if (tTop1 >= tMapH) {
                                tTop1 = tMapH - 1;
                            }
                            if (tBottom1 < 0) {
                                tBottom = 0;
                            }
                            if (tBottom1 >= tMapH) {
                                tBottom1 = tMapH - 1;
                            }
                            tGridSprite.zOrder = this._totalGridNum * z + gridY * this._gridW + gridX;
                            for (i = tTop1; i < tBottom1; i++) {
                                for (j = 0; j <= i; j++) {
                                    var tIndexX = i - j;
                                    var tIndexY = j;
                                    var tIndexValue = (tIndexX - tIndexY) + this._mapW;
                                    if (tIndexValue > tLeft1 && tIndexValue <= tRight1) {
                                        if (tLayer.drawTileTexture(tGridSprite, tIndexX, tIndexY)) {
                                            tGridSprite.drawImageNum++;
                                        }
                                    }
                                }
                            }
                            break;
                        case "staggered":
                            tGridSprite.zOrder = z * this._totalGridNum + gridY * this._gridW + gridX;
                            for (i = tTop; i < tBottom; i++) {
                                for (j = tLeft; j < tRight; j++) {
                                    if (tLayer.drawTileTexture(tGridSprite, j, i)) {
                                        tGridSprite.drawImageNum++;
                                    }
                                }
                            }
                            break;
                        case "orthogonal":
                        case "hexagonal":
                            switch (this._renderOrder) {
                                case "right-down":
                                    tGridSprite.zOrder = z * this._totalGridNum + gridY * this._gridW + gridX;
                                    for (i = tTop; i < tBottom; i++) {
                                        for (j = tLeft; j < tRight; j++) {
                                            if (tLayer.drawTileTexture(tGridSprite, j, i)) {
                                                tGridSprite.drawImageNum++;
                                            }
                                        }
                                    }
                                    break;
                                case "right-up":
                                    tGridSprite.zOrder = z * this._totalGridNum + (this._gridH - 1 - gridY) * this._gridW + gridX;
                                    for (i = tBottom - 1; i >= tTop; i--) {
                                        for (j = tLeft; j < tRight; j++) {
                                            if (tLayer.drawTileTexture(tGridSprite, j, i)) {
                                                tGridSprite.drawImageNum++;
                                            }
                                        }
                                    }
                                    break;
                                case "left-down":
                                    tGridSprite.zOrder = z * this._totalGridNum + gridY * this._gridW + (this._gridW - 1 - gridX);
                                    for (i = tTop; i < tBottom; i++) {
                                        for (j = tRight - 1; j >= tLeft; j--) {
                                            if (tLayer.drawTileTexture(tGridSprite, j, i)) {
                                                tGridSprite.drawImageNum++;
                                            }
                                        }
                                    }
                                    break;
                                case "left-up":
                                    tGridSprite.zOrder = z * this._totalGridNum + (this._gridH - 1 - gridY) * this._gridW + (this._gridW - 1 - gridX);
                                    for (i = tBottom - 1; i >= tTop; i--) {
                                        for (j = tRight - 1; j >= tLeft; j--) {
                                            if (tLayer.drawTileTexture(tGridSprite, j, i)) {
                                                tGridSprite.drawImageNum++;
                                            }
                                        }
                                    }
                                    break;
                            }
                            break;
                    }
                    if (!tGridSprite.isHaveAnimation) {
                        tGridSprite.autoSize = true;
                        if (this.autoCache)
                            tGridSprite.cacheAs = this.autoCacheType;
                        tGridSprite.autoSize = false;
                    }
                    if (!this.enableMergeLayer) {
                        if (tGridSprite.drawImageNum > 0) {
                            tLayer.addChild(tGridSprite);
                            tGridSprite.visible = false;
                            tGridSprite.show();
                        }
                        if (this._showGridKey) {
                            tGridSprite.graphics.drawRect(0, 0, tGridWidth, tGridHeight, null, tColorStr);
                        }
                    }
                    else {
                        if (tTGridSprite && tTGridSprite.drawImageNum > 0 && tDrawMapLayer) {
                            tDrawMapLayer.addChild(tTGridSprite);
                            tTGridSprite.visible = false;
                            tTGridSprite.show();
                        }
                    }
                }
                if (this.enableMergeLayer && this.showGridTextureCount) {
                    if (tTGridSprite) {
                        tTGridSprite.graphics.fillText(tTGridSprite.drawImageNum + "", 20, 20, null, "#ff0000", "left");
                    }
                }
            }
            return tTempArray;
        };
        __proto.hideGrid = function (gridX, gridY) {
            if (gridX < 0 || gridX >= this._gridW || gridY < 0 || gridY >= this._gridH) {
                return;
            }
            ;
            var tTempArray = this._gridArray[gridY][gridX];
            if (tTempArray) {
                var tGridSprite;
                for (var i = 0; i < tTempArray.length; i++) {
                    tGridSprite = tTempArray[i];
                    if (tGridSprite.drawImageNum > 0) {
                        if (tGridSprite != null) {
                            tGridSprite.hide();
                        }
                    }
                }
            }
        };
        __proto.getLayerObject = function (layerName, objectName) {
            var tLayer = null;
            for (var i = 0; i < this._layerArray.length; i++) {
                tLayer = this._layerArray[i];
                if (tLayer.layerName == layerName) {
                    break;
                }
            }
            if (tLayer) {
                return tLayer.getObjectByName(objectName);
            }
            return null;
        };
        __proto.destroy = function () {
            this._orientation = "orthogonal";
            this._jsonData = null;
            var i = 0;
            var j = 0;
            var z = 0;
            this._gridArray = [];
            var tTileTexSet;
            for (i = 0; i < this._tileTexSetArr.length; i++) {
                tTileTexSet = this._tileTexSetArr[i];
                if (tTileTexSet) {
                    tTileTexSet.clearAll();
                }
            }
            this._tileTexSetArr = [];
            var tTexture;
            for (i = 0; i < this._texArray.length; i++) {
                tTexture = this._texArray[i];
                tTexture.destroy();
            }
            this._texArray = [];
            this._width = 0;
            this._height = 0;
            this._mapW = 0;
            this._mapH = 0;
            this._mapTileW = 0;
            this._mapTileH = 0;
            this._rect.setTo(0, 0, 0, 0);
            var tLayer;
            for (i = 0; i < this._layerArray.length; i++) {
                tLayer = this._layerArray[i];
                tLayer.clearAll();
            }
            this._layerArray = [];
            this._renderLayerArray = [];
            if (this._mapSprite) {
                this._mapSprite.destroy();
                this._mapSprite = null;
            }
            this._jsonLoader = null;
            this._loader = null;
            var tDic = this._animationDic;
            for (var p in tDic) {
                delete tDic[p];
            }
            this._properties = null;
            tDic = this._tileProperties;
            for (p in tDic) {
                delete tDic[p];
            }
            this._currTileSet = null;
            this._completeHandler = null;
            this._mapRect.clearAll();
            this._mapLastRect.clearAll();
            this._tileSetArray = [];
            this._gridWidth = 450;
            this._gridHeight = 450;
            this._gridW = 0;
            this._gridH = 0;
            this._x = 0;
            this._y = 0;
            this._index = 0;
            this._enableLinear = true;
            this._resPath = null;
            this._pathArray = null;
        };
        __proto.mapSprite = function () {
            return this._mapSprite;
        };
        __proto.getLayerByName = function (layerName) {
            var tMapLayer;
            for (var i = 0; i < this._layerArray.length; i++) {
                tMapLayer = this._layerArray[i];
                if (layerName == tMapLayer.layerName) {
                    return tMapLayer;
                }
            }
            return null;
        };
        __proto.getLayerByIndex = function (index) {
            if (index < this._layerArray.length) {
                return this._layerArray[index];
            }
            return null;
        };
        __getset(0, __proto, 'orientation', function () {
            return this._orientation;
        });
        __getset(0, __proto, 'viewPortX', function () {
            return -this._viewPortX;
        });
        __getset(0, __proto, 'scale', function () {
            return this._scale;
        }, function (scale) {
            if (scale <= 0)
                return;
            this._scale = scale;
            this._viewPortWidth = this._rect.width / scale;
            this._viewPortHeight = this._rect.height / scale;
            this._mapSprite.scale(this._scale, this._scale);
            this.updateViewPort();
        });
        __getset(0, __proto, 'tileWidth', function () {
            return this._mapTileW;
        });
        __getset(0, __proto, 'viewPortY', function () {
            return -this._viewPortY;
        });
        __getset(0, __proto, 'tileHeight', function () {
            return this._mapTileH;
        });
        __getset(0, __proto, 'width', function () {
            return this._width;
        });
        __getset(0, __proto, 'numRowsTile', function () {
            return this._mapH;
        });
        __getset(0, __proto, 'numColumnsTile', function () {
            return this._mapW;
        });
        __getset(0, __proto, 'height', function () {
            return this._height;
        });
        __getset(0, __proto, 'viewPortWidth', function () {
            return this._viewPortWidth;
        });
        __getset(0, __proto, 'viewPortHeight', function () {
            return this._viewPortHeight;
        });
        __getset(0, __proto, 'x', function () {
            return this._x;
        });
        __getset(0, __proto, 'y', function () {
            return this._y;
        });
        __getset(0, __proto, 'gridWidth', function () {
            return this._gridWidth;
        });
        __getset(0, __proto, 'gridHeight', function () {
            return this._gridHeight;
        });
        __getset(0, __proto, 'numColumnsGrid', function () {
            return this._gridW;
        });
        __getset(0, __proto, 'numRowsGrid', function () {
            return this._gridH;
        });
        __getset(0, __proto, 'renderOrder', function () {
            return this._renderOrder;
        });
        TiledMap.ORIENTATION_ORTHOGONAL = "orthogonal";
        TiledMap.ORIENTATION_ISOMETRIC = "isometric";
        TiledMap.ORIENTATION_STAGGERED = "staggered";
        TiledMap.ORIENTATION_HEXAGONAL = "hexagonal";
        TiledMap.RENDERORDER_RIGHTDOWN = "right-down";
        TiledMap.RENDERORDER_RIGHTUP = "right-up";
        TiledMap.RENDERORDER_LEFTDOWN = "left-down";
        TiledMap.RENDERORDER_LEFTUP = "left-up";
        TiledMap._tempContext = null;
        TiledMap.__init$ = function () {
            GRect = (function () {
                function GRect() {
                    this.left = 0;
                    this.top = 0;
                    this.right = 0;
                    this.bottom = 0;
                }
                __class(GRect, '');
                var __proto = GRect.prototype;
                __proto.clearAll = function () {
                    this.left = this.top = this.right = this.bottom = 0;
                };
                return GRect;
            })();
            TileMapAniData = (function () {
                function TileMapAniData() {
                    this.mAniIdArray = [];
                    this.mDurationTimeArray = [];
                    this.mTileTexSetArr = [];
                    this.image = null;
                }
                __class(TileMapAniData, '');
                return TileMapAniData;
            })();
            TileSet = (function () {
                function TileSet() {
                    this.firstgid = 0;
                    this.image = "";
                    this.imageheight = 0;
                    this.imagewidth = 0;
                    this.margin = 0;
                    this.name = 0;
                    this.properties = null;
                    this.spacing = 0;
                    this.tileheight = 0;
                    this.tilewidth = 0;
                    this.titleoffsetX = 0;
                    this.titleoffsetY = 0;
                    this.tileproperties = null;
                }
                __class(TileSet, '');
                var __proto = TileSet.prototype;
                __proto.init = function (data) {
                    this.firstgid = data.firstgid;
                    this.image = data.image;
                    this.imageheight = data.imageheight;
                    this.imagewidth = data.imagewidth;
                    this.margin = data.margin;
                    this.name = data.name;
                    this.properties = data.properties;
                    this.spacing = data.spacing;
                    this.tileheight = data.tileheight;
                    this.tilewidth = data.tilewidth;
                    this.tileproperties = data.tileproperties;
                    var tTileoffset = data.tileoffset;
                    if (tTileoffset) {
                        this.titleoffsetX = tTileoffset.x;
                        this.titleoffsetY = tTileoffset.y;
                    }
                };
                return TileSet;
            })();
        };
        return TiledMap;
    })();
    var TileTexSet = (function () {
        function TileTexSet() {
            this.gid = -1;
            this.texture = null;
            this.offX = 0;
            this.offY = 0;
            this.textureArray = null;
            this.durationTimeArray = null;
            this.animationTotalTime = 0;
            this.isAnimation = false;
            this._spriteNum = 0;
            this._aniDic = null;
            this._frameIndex = 0;
            this._time = 0;
            this._interval = 0;
            this._preFrameTime = 0;
        }
        __class(TileTexSet, 'laya.map.TileTexSet');
        var __proto = TileTexSet.prototype;
        __proto.addAniSprite = function (aniName, sprite) {
            if (this.animationTotalTime == 0) {
                return;
            }
            if (this._aniDic == null) {
                this._aniDic = {};
            }
            if (this._spriteNum == 0) {
                Laya.timer.frameLoop(3, this, this.animate);
                this._preFrameTime = Browser.now();
                this._frameIndex = 0;
                this._time = 0;
                this._interval = 0;
            }
            this._spriteNum++;
            this._aniDic[aniName] = sprite;
            if (this.textureArray && this._frameIndex < this.textureArray.length) {
                var tTileTextureSet = this.textureArray[this._frameIndex];
                this.drawTexture(sprite, tTileTextureSet);
            }
        };
        __proto.animate = function () {
            if (this.textureArray && this.textureArray.length > 0 && this.durationTimeArray && this.durationTimeArray.length > 0) {
                var tNow = Browser.now();
                this._interval = tNow - this._preFrameTime;
                this._preFrameTime = tNow;
                if (this._interval > this.animationTotalTime) {
                    this._interval = this._interval % this.animationTotalTime;
                }
                this._time += this._interval;
                var tTime = this.durationTimeArray[this._frameIndex];
                while (this._time > tTime) {
                    this._time -= tTime;
                    this._frameIndex++;
                    if (this._frameIndex >= this.durationTimeArray.length || this._frameIndex >= this.textureArray.length) {
                        this._frameIndex = 0;
                    }
                    ;
                    var tTileTextureSet = this.textureArray[this._frameIndex];
                    var tSprite;
                    for (var p in this._aniDic) {
                        tSprite = this._aniDic[p];
                        this.drawTexture(tSprite, tTileTextureSet);
                    }
                    tTime = this.durationTimeArray[this._frameIndex];
                }
            }
        };
        __proto.drawTexture = function (sprite, tileTextSet) {
            sprite.graphics.clear();
            sprite.graphics.drawTexture(tileTextSet.texture, tileTextSet.offX, tileTextSet.offY);
        };
        __proto.removeAniSprite = function (_name) {
            if (this._aniDic && this._aniDic[_name]) {
                delete this._aniDic[_name];
                this._spriteNum--;
                if (this._spriteNum == 0) {
                    Laya.timer.clear(this, this.animate);
                }
            }
        };
        __proto.showDebugInfo = function () {
            var tInfo = null;
            if (this._spriteNum > 0) {
                tInfo = "TileTextureSet::gid:" + this.gid.toString() + " 动画数:" + this._spriteNum.toString();
            }
            return tInfo;
        };
        __proto.clearAll = function () {
            this.gid = -1;
            if (this.texture) {
                this.texture.destroy();
                this.texture = null;
            }
            this.offX = 0;
            this.offY = 0;
            this.textureArray = null;
            this.durationTimeArray = null;
            this.isAnimation = false;
            this._spriteNum = 0;
            this._aniDic = null;
            this._frameIndex = 0;
            this._preFrameTime = 0;
            this._time = 0;
            this._interval = 0;
        };
        return TileTexSet;
    })();
    var GridSprite = (function (_super) {
        function GridSprite() {
            this.relativeX = 0;
            this.relativeY = 0;
            this.isAloneObject = false;
            this.isHaveAnimation = false;
            this.aniSpriteArray = null;
            this.drawImageNum = 0;
            this._map = null;
            GridSprite.__super.call(this);
        }
        __class(GridSprite, 'laya.map.GridSprite', _super);
        var __proto = GridSprite.prototype;
        __proto.initData = function (map, objectKey) {
            (objectKey === void 0) && (objectKey = false);
            this._map = map;
            this.isAloneObject = objectKey;
        };
        __proto._setDisplay = function (value) {
            if (!value) {
                var cc = this._$P.cacheCanvas;
                if (cc && cc.ctx) {
                    cc.ctx.canvas.destroy();
                    cc.ctx = null;
                }
                ;
                var fc = this._$P._filterCache;
                if (fc) {
                    fc.destroy();
                    fc.recycle();
                    this._set$P('_filterCache', null);
                }
                this._$P._isHaveGlowFilter && this._set$P('_isHaveGlowFilter', false);
            }
            _super.prototype._setDisplay.call(this, value);
        };
        __proto.addAniSprite = function (sprite) {
            if (this.aniSpriteArray == null) {
                this.aniSpriteArray = [];
            }
            this.aniSpriteArray.push(sprite);
        };
        __proto.show = function () {
            if (!this.visible) {
                this.visible = true;
                if (!this.isAloneObject) {
                    var tParent;
                    tParent = this.parent;
                    if (tParent) {
                        tParent.showGridSprite(this);
                    }
                }
                if (!Render.isWebGL && this._map.autoCache) {
                    this.cacheAs = this._map.autoCacheType;
                }
                if (this.aniSpriteArray == null) {
                    return;
                }
                ;
                var tAniSprite;
                for (var i = 0; i < this.aniSpriteArray.length; i++) {
                    tAniSprite = this.aniSpriteArray[i];
                    tAniSprite.show();
                }
            }
        };
        __proto.hide = function () {
            if (this.visible) {
                this.visible = false;
                if (!this.isAloneObject) {
                    var tParent;
                    tParent = this.parent;
                    if (tParent) {
                        tParent.hideGridSprite(this);
                    }
                }
                if (!Render.isWebGL && this._map.autoCache) {
                    this.cacheAs = "none";
                }
                if (this.aniSpriteArray == null) {
                    return;
                }
                ;
                var tAniSprite;
                for (var i = 0; i < this.aniSpriteArray.length; i++) {
                    tAniSprite = this.aniSpriteArray[i];
                    tAniSprite.hide();
                }
            }
        };
        __proto.updatePos = function () {
            if (this.isAloneObject) {
                if (this._map) {
                    this.x = this.relativeX;
                    this.y = this.relativeY;
                }
                if (this.x < 0 || this.x > this._map.viewPortWidth || this.y < 0 || this.y > this._map.viewPortHeight) {
                    this.hide();
                }
                else {
                    this.show();
                }
            }
            else {
                if (this._map) {
                    this.x = this.relativeX;
                    this.y = this.relativeY;
                }
            }
        };
        __proto.clearAll = function () {
            if (this._map) {
                this._map = null;
            }
            this.visible = false;
            if (this.aniSpriteArray == null) {
                return;
            }
            ;
            var tAniSprite;
            for (var i = 0; i < this.aniSpriteArray.length; i++) {
                tAniSprite = this.aniSpriteArray[i];
                tAniSprite.clearAll();
            }
            this.destroy();
            this.relativeX = 0;
            this.relativeY = 0;
            this.isHaveAnimation = false;
            this.aniSpriteArray = null;
            this.drawImageNum = 0;
        };
        return GridSprite;
    })(Sprite);
    var MapLayer = (function (_super) {
        function MapLayer() {
            this._map = null;
            this._mapData = null;
            this._tileWidthHalf = 0;
            this._tileHeightHalf = 0;
            this._mapWidthHalf = 0;
            this._mapHeightHalf = 0;
            this._gridSpriteArray = [];
            this._objDic = null;
            this._dataDic = null;
            this._properties = null;
            this.tarLayer = null;
            this.layerName = null;
            this._showGridList = [];
            this._aloneObjs = [];
            MapLayer.__super.call(this);
            this._tempMapPos = new Point();
        }
        __class(MapLayer, 'laya.map.MapLayer', _super);
        var __proto = MapLayer.prototype;
        __proto.init = function (layerData, map) {
            this._map = map;
            this._mapData = layerData.data;
            var tHeight = layerData.height;
            var tWidth = layerData.width;
            var tTileW = map.tileWidth;
            var tTileH = map.tileHeight;
            this.layerName = layerData.name;
            this._properties = layerData.properties;
            this.alpha = layerData.opacity;
            this._tileWidthHalf = tTileW / 2;
            this._tileHeightHalf = tTileH / 2;
            this._mapWidthHalf = this._map.width / 2 - this._tileWidthHalf;
            this._mapHeightHalf = this._map.height / 2;
            switch (layerData.type) {
                case "tilelayer":
                    break;
                case "objectgroup":
                    ;
                    var tObjectGid = 0;
                    var tArray = layerData.objects;
                    if (tArray.length > 0) {
                        this._objDic = {};
                        this._dataDic = {};
                    }
                    ;
                    var tObjectData;
                    var tObjWidth = NaN;
                    var tObjHeight = NaN;
                    for (var i = 0; i < tArray.length; i++) {
                        tObjectData = tArray[i];
                        this._dataDic[tObjectData.name] = tObjectData;
                        if (tObjectData.visible == true) {
                            tObjWidth = tObjectData.width;
                            tObjHeight = tObjectData.height;
                            var tSprite = map.getSprite(tObjectData.gid, tObjWidth, tObjHeight);
                            if (tSprite != null) {
                                switch (this._map.orientation) {
                                    case "isometric":
                                        this.getScreenPositionByTilePos(tObjectData.x / tTileH, tObjectData.y / tTileH, Point.TEMP);
                                        tSprite.pivot(tObjWidth / 2, tObjHeight / 2);
                                        tSprite.rotation = tObjectData.rotation;
                                        tSprite.x = tSprite.relativeX = Point.TEMP.x + this._map.viewPortX;
                                        tSprite.y = tSprite.relativeY = Point.TEMP.y + this._map.viewPortY - tObjHeight / 2;
                                        break;
                                    case "staggered":
                                        tSprite.pivot(tObjWidth / 2, tObjHeight / 2);
                                        tSprite.rotation = tObjectData.rotation;
                                        tSprite.x = tSprite.relativeX = tObjectData.x + tObjWidth / 2;
                                        tSprite.y = tSprite.relativeY = tObjectData.y - tObjHeight / 2;
                                        break;
                                    case "orthogonal":
                                        tSprite.pivot(tObjWidth / 2, tObjHeight / 2);
                                        tSprite.rotation = tObjectData.rotation;
                                        tSprite.x = tSprite.relativeX = tObjectData.x + tObjWidth / 2;
                                        tSprite.y = tSprite.relativeY = tObjectData.y - tObjHeight / 2;
                                        break;
                                    case "hexagonal":
                                        tSprite.x = tSprite.relativeX = tObjectData.x;
                                        tSprite.y = tSprite.relativeY = tObjectData.y;
                                        break;
                                }
                                this.addChild(tSprite);
                                this._gridSpriteArray.push(tSprite);
                                if (tSprite.isAloneObject) {
                                    this._showGridList.push(tSprite);
                                    this._aloneObjs.push(tSprite);
                                }
                                this._objDic[tObjectData.name] = tSprite;
                            }
                        }
                    }
                    break;
            }
        };
        __proto.getObjectByName = function (objName) {
            if (this._objDic) {
                return this._objDic[objName];
            }
            return null;
        };
        __proto.getObjectDataByName = function (objName) {
            if (this._dataDic) {
                return this._dataDic[objName];
            }
            return null;
        };
        __proto.getLayerProperties = function (name) {
            if (this._properties) {
                return this._properties[name];
            }
            return null;
        };
        __proto.getTileData = function (tileX, tileY) {
            if (tileY >= 0 && tileY < this._map.numRowsTile && tileX >= 0 && tileX < this._map.numColumnsTile) {
                var tIndex = tileY * this._map.numColumnsTile + tileX;
                var tMapData = this._mapData;
                if (tMapData != null && tIndex < tMapData.length) {
                    return tMapData[tIndex];
                }
            }
            return 0;
        };
        __proto.getScreenPositionByTilePos = function (tileX, tileY, screenPos) {
            if (screenPos) {
                switch (this._map.orientation) {
                    case "isometric":
                        screenPos.x = this._map.width / 2 - (tileY - tileX) * this._tileWidthHalf;
                        screenPos.y = (tileY + tileX) * this._tileHeightHalf;
                        break;
                    case "staggered":
                        tileX = Math.floor(tileX);
                        tileY = Math.floor(tileY);
                        screenPos.x = tileX * this._map.tileWidth + (tileY & 1) * this._tileWidthHalf;
                        screenPos.y = tileY * this._tileHeightHalf;
                        break;
                    case "orthogonal":
                        screenPos.x = tileX * this._map.tileWidth;
                        screenPos.y = tileY * this._map.tileHeight;
                        break;
                    case "hexagonal":
                        tileX = Math.floor(tileX);
                        tileY = Math.floor(tileY);
                        var tTileHeight = this._map.tileHeight * 2 / 3;
                        screenPos.x = (tileX * this._map.tileWidth + tileY % 2 * this._tileWidthHalf) % this._map.gridWidth;
                        screenPos.y = (tileY * tTileHeight) % this._map.gridHeight;
                        break;
                }
                screenPos.x = (screenPos.x + this._map.viewPortX) * this._map.scale;
                screenPos.y = (screenPos.y + this._map.viewPortY) * this._map.scale;
            }
        };
        __proto.getTileDataByScreenPos = function (screenX, screenY) {
            var tData = 0;
            if (this.getTilePositionByScreenPos(screenX, screenY, this._tempMapPos)) {
                tData = this.getTileData(Math.floor(this._tempMapPos.x), Math.floor(this._tempMapPos.y));
            }
            return tData;
        };
        __proto.getTilePositionByScreenPos = function (screenX, screenY, result) {
            screenX = screenX / this._map.scale - this._map.viewPortX;
            screenY = screenY / this._map.scale - this._map.viewPortY;
            var tTileW = this._map.tileWidth;
            var tTileH = this._map.tileHeight;
            var tV = 0;
            var tU = 0;
            switch (this._map.orientation) {
                case "isometric":
                    ;
                    var tDirX = screenX - this._map.width / 2;
                    var tDirY = screenY;
                    tV = -(tDirX / tTileW - tDirY / tTileH);
                    tU = tDirX / tTileW + tDirY / tTileH;
                    if (result) {
                        result.x = tU;
                        result.y = tV;
                    }
                    return true;
                    break;
                case "staggered":
                    if (result) {
                        var cx = 0, cy = 0, rx = 0, ry = 0;
                        cx = Math.floor(screenX / tTileW) * tTileW + tTileW / 2;
                        cy = Math.floor(screenY / tTileH) * tTileH + tTileH / 2;
                        rx = (screenX - cx) * tTileH / 2;
                        ry = (screenY - cy) * tTileW / 2;
                        if (Math.abs(rx) + Math.abs(ry) <= tTileW * tTileH / 4) {
                            tU = Math.floor(screenX / tTileW);
                            tV = Math.floor(screenY / tTileH) * 2;
                        }
                        else {
                            screenX = screenX - tTileW / 2;
                            tU = Math.floor(screenX / tTileW) + 1;
                            screenY = screenY - tTileH / 2;
                            tV = Math.floor(screenY / tTileH) * 2 + 1;
                        }
                        result.x = tU - (tV & 1);
                        result.y = tV;
                    }
                    return true;
                    break;
                case "orthogonal":
                    tU = screenX / tTileW;
                    tV = screenY / tTileH;
                    if (result) {
                        result.x = tU;
                        result.y = tV;
                    }
                    return true;
                    break;
                case "hexagonal":
                    ;
                    var tTileHeight = tTileH * 2 / 3;
                    tV = screenY / tTileHeight;
                    tU = (screenX - tV % 2 * this._tileWidthHalf) / tTileW;
                    if (result) {
                        result.x = tU;
                        result.y = tV;
                    }
                    break;
            }
            return false;
        };
        __proto.getDrawSprite = function (gridX, gridY) {
            var tSprite = new GridSprite();
            tSprite.relativeX = gridX * this._map.gridWidth;
            tSprite.relativeY = gridY * this._map.gridHeight;
            tSprite.initData(this._map);
            tSprite.updatePos();
            this._gridSpriteArray.push(tSprite);
            return tSprite;
        };
        __proto.showGridSprite = function (gridSprite) {
            var gridList = this._showGridList;
            var i = 0, len = 0;
            len = gridList.length;
            var ok_i = -1;
            var tGridSprite;
            for (i = 0; i < len; i++) {
                tGridSprite = gridList[i];
                if (tGridSprite == gridSprite)
                    return;
                if (!tGridSprite.isAloneObject && !tGridSprite.visible) {
                    ok_i = i;
                }
            }
            if (ok_i >= 0) {
                gridList[ok_i] = gridSprite;
            }
            else {
                gridList.push(gridSprite);
            }
        };
        __proto.hideGridSprite = function (gridSprite) {
            gridSprite.visible = false;
        };
        __proto.updateGridPos = function () {
            var tSprite;
            var tList;
            tList = this._showGridList;
            var len = 0;
            len = tList.length;
            for (var i = 0; i < len; i++) {
                tSprite = tList[i];
                if ((tSprite._style.visible || tSprite.isAloneObject) && tSprite.drawImageNum > 0) {
                    tSprite.updatePos();
                }
            }
        };
        __proto.updateAloneObject = function () {
            var tSprite;
            var tList;
            tList = this._aloneObjs;
            var len = 0;
            len = tList.length;
            for (var i = 0; i < len; i++) {
                tSprite = tList[i];
                if (tSprite.drawImageNum > 0) {
                    tSprite.updatePos();
                }
            }
        };
        __proto.render = function (context, x, y) {
            var childs = this._childs;
            this._childs = this._showGridList;
            _super.prototype.render.call(this, context, x, y);
            this._childs = childs;
        };
        __proto.drawTileTexture = function (gridSprite, tileX, tileY) {
            if (tileY >= 0 && tileY < this._map.numRowsTile && tileX >= 0 && tileX < this._map.numColumnsTile) {
                var tIndex = tileY * this._map.numColumnsTile + tileX;
                var tMapData = this._mapData;
                if (tMapData != null && tIndex < tMapData.length) {
                    if (tMapData[tIndex] != 0) {
                        var tTileTexSet = this._map.getTexture(tMapData[tIndex]);
                        if (tTileTexSet) {
                            var tX = 0;
                            var tY = 0;
                            var tTexture = tTileTexSet.texture;
                            switch (this._map.orientation) {
                                case "staggered":
                                    tX = tileX * this._map.tileWidth % this._map.gridWidth + (tileY & 1) * this._tileWidthHalf;
                                    tY = tileY * this._tileHeightHalf % this._map.gridHeight;
                                    break;
                                case "orthogonal":
                                    tX = tileX * this._map.tileWidth % this._map.gridWidth;
                                    tY = tileY * this._map.tileHeight % this._map.gridHeight;
                                    break;
                                case "isometric":
                                    tX = (this._mapWidthHalf + (tileX - tileY) * this._tileWidthHalf) % this._map.gridWidth;
                                    tY = ((tileX + tileY) * this._tileHeightHalf) % this._map.gridHeight;
                                    break;
                                case "hexagonal":
                                    ;
                                    var tTileHeight = this._map.tileHeight * 2 / 3;
                                    tX = (tileX * this._map.tileWidth + tileY % 2 * this._tileWidthHalf) % this._map.gridWidth;
                                    tY = (tileY * tTileHeight) % this._map.gridHeight;
                                    break;
                            }
                            if (tTileTexSet.isAnimation) {
                                var tAnimationSprite = new TileAniSprite();
                                tAnimationSprite.x = tX;
                                tAnimationSprite.y = tY;
                                tAnimationSprite.setTileTextureSet(tIndex.toString(), tTileTexSet);
                                gridSprite.addAniSprite(tAnimationSprite);
                                gridSprite.addChild(tAnimationSprite);
                                gridSprite.isHaveAnimation = true;
                            }
                            else {
                                gridSprite.graphics.drawTexture(tTileTexSet.texture, tX + tTileTexSet.offX, tY + tTileTexSet.offY);
                            }
                            return true;
                        }
                    }
                }
            }
            return false;
        };
        __proto.clearAll = function () {
            this._map = null;
            this._mapData = null;
            this._tileWidthHalf = 0;
            this._tileHeightHalf = 0;
            this._mapWidthHalf = 0;
            this._mapHeightHalf = 0;
            this.layerName = null;
            var i = 0;
            if (this._objDic) {
                for (var p in this._objDic) {
                    delete this._objDic[p];
                }
                this._objDic = null;
            }
            if (this._dataDic) {
                for (p in this._dataDic) {
                    delete this._dataDic[p];
                }
                this._dataDic = null;
            }
            ;
            var tGridSprite;
            for (i = 0; i < this._gridSpriteArray.length; i++) {
                tGridSprite = this._gridSpriteArray[i];
                tGridSprite.clearAll();
            }
            this._properties = null;
            this._tempMapPos = null;
            this.tarLayer = null;
        };
        return MapLayer;
    })(Sprite);
    var TileAniSprite = (function (_super) {
        function TileAniSprite() {
            this._tileTextureSet = null;
            this._aniName = null;
            TileAniSprite.__super.call(this);
        }
        __class(TileAniSprite, 'laya.map.TileAniSprite', _super);
        var __proto = TileAniSprite.prototype;
        __proto.setTileTextureSet = function (aniName, tileTextureSet) {
            this._aniName = aniName;
            this._tileTextureSet = tileTextureSet;
            tileTextureSet.addAniSprite(this._aniName, this);
        };
        __proto.show = function () {
            this._tileTextureSet.addAniSprite(this._aniName, this);
        };
        __proto.hide = function () {
            this._tileTextureSet.removeAniSprite(this._aniName);
        };
        __proto.clearAll = function () {
            this._tileTextureSet.removeAniSprite(this._aniName);
            this.destroy();
            this._tileTextureSet = null;
            this._aniName = null;
        };
        return TileAniSprite;
    })(Sprite);
    Laya.__init([TiledMap]);
})(window, document, Laya);
if (typeof define === 'function' && define.amd) {
    define('laya.core', ['require', "exports"], function (require, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        for (var i in Laya) {
            var o = Laya[i];
            o && o.__isclass && (exports[i] = o);
        }
    });
}
(function (window, document, Laya) {
    var __un = Laya.un, __uns = Laya.uns, __static = Laya.static, __class = Laya.class, __getset = Laya.getset, __newvec = Laya.__newvec;
    var Bitmap = laya.resource.Bitmap, Browser = laya.utils.Browser, Event = laya.events.Event, EventDispatcher = laya.events.EventDispatcher;
    var Handler = laya.utils.Handler, Rectangle = laya.maths.Rectangle, Render = laya.renders.Render, Sprite = laya.display.Sprite;
    var Stage = laya.display.Stage, Texture = laya.resource.Texture, Utils = laya.utils.Utils, WebGL = laya.webgl.WebGL;
    var WebGLContext = laya.webgl.WebGLContext;
    var Geolocation = (function () {
        function Geolocation() { }
        __class(Geolocation, 'laya.device.geolocation.Geolocation');
        Geolocation.getCurrentPosition = function (onSuccess, onError) {
            Geolocation.navigator.geolocation.getCurrentPosition(function (pos) {
                Geolocation.position.setPosition(pos);
                onSuccess.runWith(Geolocation.position);
            }, function (error) {
                onError.runWith(error);
            }, {
                enableHighAccuracy: laya.device.geolocation.Geolocation.enableHighAccuracy,
                timeout: laya.device.geolocation.Geolocation.timeout,
                maximumAge: laya.device.geolocation.Geolocation.maximumAge
            });
        };
        Geolocation.watchPosition = function (onSuccess, onError) {
            return Geolocation.navigator.geolocation.watchPosition(function (pos) {
                Geolocation.position.setPosition(pos);
                onSuccess.runWith(Geolocation.position);
            }, function (error) {
                onError.runWith(error);
            }, {
                enableHighAccuracy: Geolocation.enableHighAccuracy,
                timeout: Geolocation.timeout,
                maximumAge: Geolocation.maximumAge
            });
        };
        Geolocation.clearWatch = function (id) {
            Geolocation.navigator.geolocation.clearWatch(id);
        };
        Geolocation.PERMISSION_DENIED = 1;
        Geolocation.POSITION_UNAVAILABLE = 2;
        Geolocation.TIMEOUT = 3;
        Geolocation.enableHighAccuracy = false;
        Geolocation.maximumAge = 0;
        __static(Geolocation, ['navigator', function () { return this.navigator = Browser.window.navigator; }, 'position', function () { return this.position = new GeolocationInfo(); }, 'supported', function () { return this.supported = !!Geolocation.navigator.geolocation; }, 'timeout', function () { return this.timeout = 1E10; }
        ]);
        return Geolocation;
    })();
    var GeolocationInfo = (function () {
        function GeolocationInfo() {
            this.pos = null;
            this.coords = null;
        }
        __class(GeolocationInfo, 'laya.device.geolocation.GeolocationInfo');
        var __proto = GeolocationInfo.prototype;
        __proto.setPosition = function (pos) {
            this.pos = pos;
            this.coords = pos.coords;
        };
        __getset(0, __proto, 'heading', function () {
            return this.coords.heading;
        });
        __getset(0, __proto, 'latitude', function () {
            return this.coords.latitude;
        });
        __getset(0, __proto, 'altitudeAccuracy', function () {
            return this.coords.altitudeAccuracy;
        });
        __getset(0, __proto, 'longitude', function () {
            return this.coords.longitude;
        });
        __getset(0, __proto, 'altitude', function () {
            return this.coords.altitude;
        });
        __getset(0, __proto, 'accuracy', function () {
            return this.coords.accuracy;
        });
        __getset(0, __proto, 'speed', function () {
            return this.coords.speed;
        });
        __getset(0, __proto, 'timestamp', function () {
            return this.pos.timestamp;
        });
        return GeolocationInfo;
    })();
    var Media = (function () {
        function Media() { }
        __class(Media, 'laya.device.media.Media');
        Media.supported = function () {
            return !!Browser.window.navigator.getUserMedia;
        };
        Media.getMedia = function (options, onSuccess, onError) {
            if (Browser.window.navigator.getUserMedia) {
                Browser.window.navigator.getUserMedia(options, function (stream) {
                    onSuccess.runWith(Browser.window.URL.createObjectURL(stream));
                }, function (err) {
                    onError.runWith(err);
                });
            }
        };
        Media.__init$ = function () {
            navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
            ;
        };
        return Media;
    })();
    var AccelerationInfo = (function () {
        function AccelerationInfo() {
            this.x = NaN;
            this.y = NaN;
            this.z = NaN;
        }
        __class(AccelerationInfo, 'laya.device.motion.AccelerationInfo');
        return AccelerationInfo;
    })();
    var RotationInfo = (function () {
        function RotationInfo() {
            this.absolute = false;
            this.alpha = NaN;
            this.beta = NaN;
            this.gamma = NaN;
            this.compassAccuracy = NaN;
        }
        __class(RotationInfo, 'laya.device.motion.RotationInfo');
        return RotationInfo;
    })();
    var Accelerator = (function (_super) {
        function Accelerator(singleton) {
            Accelerator.__super.call(this);
            this.onDeviceOrientationChange = this.onDeviceOrientationChange.bind(this);
        }
        __class(Accelerator, 'laya.device.motion.Accelerator', _super);
        var __proto = Accelerator.prototype;
        __proto.on = function (type, caller, listener, args) {
            _super.prototype.on.call(this, type, caller, listener, args);
            Browser.window.addEventListener('devicemotion', this.onDeviceOrientationChange);
            return this;
        };
        __proto.off = function (type, caller, listener, onceOnly) {
            (onceOnly === void 0) && (onceOnly = false);
            if (!this.hasListener(type))
                Browser.window.removeEventListener('devicemotion', this.onDeviceOrientationChange);
            return _super.prototype.off.call(this, type, caller, listener, onceOnly);
        };
        __proto.onDeviceOrientationChange = function (e) {
            var interval = e.interval;
            Accelerator.acceleration.x = e.acceleration.x;
            Accelerator.acceleration.y = e.acceleration.y;
            Accelerator.acceleration.z = e.acceleration.z;
            Accelerator.accelerationIncludingGravity.x = e.accelerationIncludingGravity.x;
            Accelerator.accelerationIncludingGravity.y = e.accelerationIncludingGravity.y;
            Accelerator.accelerationIncludingGravity.z = e.accelerationIncludingGravity.z;
            Accelerator.rotationRate.alpha = e.rotationRate.gamma * -1;
            Accelerator.rotationRate.beta = e.rotationRate.alpha * -1;
            Accelerator.rotationRate.gamma = e.rotationRate.beta;
            if (Browser.onAndriod) {
                if (Accelerator.onChrome) {
                    Accelerator.rotationRate.alpha *= 180 / Math.PI;
                    Accelerator.rotationRate.beta *= 180 / Math.PI;
                    Accelerator.rotationRate.gamma *= 180 / Math.PI;
                }
                Accelerator.acceleration.x *= -1;
                Accelerator.accelerationIncludingGravity.x *= -1;
            }
            else if (Browser.onIOS) {
                Accelerator.acceleration.y *= -1;
                Accelerator.acceleration.z *= -1;
                Accelerator.accelerationIncludingGravity.y *= -1;
                Accelerator.accelerationIncludingGravity.z *= -1;
                interval *= 1000;
            }
            this.event("change", [Accelerator.acceleration, Accelerator.accelerationIncludingGravity, Accelerator.rotationRate, interval]);
        };
        __getset(1, Accelerator, 'instance', function () {
            Accelerator._instance = Accelerator._instance || new Accelerator(0);
            return Accelerator._instance;
        }, laya.events.EventDispatcher._$SET_instance);
        Accelerator.getTransformedAcceleration = function (acceleration) {
            Accelerator.transformedAcceleration = Accelerator.transformedAcceleration || new AccelerationInfo();
            Accelerator.transformedAcceleration.z = acceleration.z;
            if (Browser.window.orientation == 90) {
                Accelerator.transformedAcceleration.x = acceleration.y;
                Accelerator.transformedAcceleration.y = -acceleration.x;
            }
            else if (Browser.window.orientation == -90) {
                Accelerator.transformedAcceleration.x = -acceleration.y;
                Accelerator.transformedAcceleration.y = acceleration.x;
            }
            else if (!Browser.window.orientation) {
                Accelerator.transformedAcceleration.x = acceleration.x;
                Accelerator.transformedAcceleration.y = acceleration.y;
            }
            else if (Browser.window.orientation == 180) {
                Accelerator.transformedAcceleration.x = -acceleration.x;
                Accelerator.transformedAcceleration.y = -acceleration.y;
            }
            ;
            var tx = NaN;
            if (Laya.stage.canvasDegree == -90) {
                tx = Accelerator.transformedAcceleration.x;
                Accelerator.transformedAcceleration.x = -Accelerator.transformedAcceleration.y;
                Accelerator.transformedAcceleration.y = tx;
            }
            else if (Laya.stage.canvasDegree == 90) {
                tx = Accelerator.transformedAcceleration.x;
                Accelerator.transformedAcceleration.x = Accelerator.transformedAcceleration.y;
                Accelerator.transformedAcceleration.y = -tx;
            }
            return Accelerator.transformedAcceleration;
        };
        Accelerator._instance = null;
        Accelerator.transformedAcceleration = null;
        __static(Accelerator, ['acceleration', function () { return this.acceleration = new AccelerationInfo(); }, 'accelerationIncludingGravity', function () { return this.accelerationIncludingGravity = new AccelerationInfo(); }, 'rotationRate', function () { return this.rotationRate = new RotationInfo(); }, 'onChrome', function () { return this.onChrome = (Browser.userAgent.indexOf("Chrome") > -1); }
        ]);
        return Accelerator;
    })(EventDispatcher);
    var Gyroscope = (function (_super) {
        function Gyroscope(singleton) {
            Gyroscope.__super.call(this);
            this.onDeviceOrientationChange = this.onDeviceOrientationChange.bind(this);
        }
        __class(Gyroscope, 'laya.device.motion.Gyroscope', _super);
        var __proto = Gyroscope.prototype;
        __proto.on = function (type, caller, listener, args) {
            _super.prototype.on.call(this, type, caller, listener, args);
            Browser.window.addEventListener('deviceorientation', this.onDeviceOrientationChange);
            return this;
        };
        __proto.off = function (type, caller, listener, onceOnly) {
            (onceOnly === void 0) && (onceOnly = false);
            if (!this.hasListener(type))
                Browser.window.removeEventListener('deviceorientation', this.onDeviceOrientationChange);
            return _super.prototype.off.call(this, type, caller, listener, onceOnly);
        };
        __proto.onDeviceOrientationChange = function (e) {
            Gyroscope.info.alpha = e.alpha;
            Gyroscope.info.beta = e.beta;
            Gyroscope.info.gamma = e.gamma;
            if (e.webkitCompassHeading) {
                Gyroscope.info.alpha = e.webkitCompassHeading * -1;
                Gyroscope.info.compassAccuracy = e.webkitCompassAccuracy;
            }
            this.event("change", [e.absolute, Gyroscope.info]);
        };
        __getset(1, Gyroscope, 'instance', function () {
            Gyroscope._instance = Gyroscope._instance || new Gyroscope(0);
            return Gyroscope._instance;
        }, laya.events.EventDispatcher._$SET_instance);
        Gyroscope._instance = null;
        __static(Gyroscope, ['info', function () { return this.info = new RotationInfo(); }
        ]);
        return Gyroscope;
    })(EventDispatcher);
    var Shake = (function (_super) {
        function Shake() {
            this.throushold = 0;
            this.shakeInterval = 0;
            this.callback = null;
            this.lastX = NaN;
            this.lastY = NaN;
            this.lastZ = NaN;
            this.lastMillSecond = NaN;
            Shake.__super.call(this);
        }
        __class(Shake, 'laya.device.Shake', _super);
        var __proto = Shake.prototype;
        __proto.start = function (throushold, interval) {
            this.throushold = throushold;
            this.shakeInterval = interval;
            this.lastX = this.lastY = this.lastZ = NaN;
            Accelerator.instance.on("change", this, this.onShake);
        };
        __proto.stop = function () {
            Accelerator.instance.off("change", this, this.onShake);
        };
        __proto.onShake = function (acceleration, accelerationIncludingGravity, rotationRate, interval) {
            if (isNaN(this.lastX)) {
                this.lastX = accelerationIncludingGravity.x;
                this.lastY = accelerationIncludingGravity.y;
                this.lastZ = accelerationIncludingGravity.z;
                this.lastMillSecond = Browser.now();
                return;
            }
            ;
            var deltaX = Math.abs(this.lastX - accelerationIncludingGravity.x);
            var deltaY = Math.abs(this.lastY - accelerationIncludingGravity.y);
            var deltaZ = Math.abs(this.lastZ - accelerationIncludingGravity.z);
            if (this.isShaked(deltaX, deltaY, deltaZ)) {
                var deltaMillSecond = Browser.now() - this.lastMillSecond;
                if (deltaMillSecond > this.shakeInterval) {
                    this.event("change");
                    this.lastMillSecond = Browser.now();
                }
            }
            this.lastX = accelerationIncludingGravity.x;
            this.lastY = accelerationIncludingGravity.y;
            this.lastZ = accelerationIncludingGravity.z;
        };
        __proto.isShaked = function (deltaX, deltaY, deltaZ) {
            return (deltaX > this.throushold && deltaY > this.throushold) ||
                (deltaX > this.throushold && deltaZ > this.throushold) ||
                (deltaY > this.throushold && deltaZ > this.throushold);
        };
        __getset(1, Shake, 'instance', function () {
            Shake._instance = Shake._instance || new Shake();
            return Shake._instance;
        }, laya.events.EventDispatcher._$SET_instance);
        Shake._instance = null;
        return Shake;
    })(EventDispatcher);
    var Video = (function (_super) {
        function Video(width, height) {
            this.htmlVideo = null;
            this.videoElement = null;
            this.internalTexture = null;
            (width === void 0) && (width = 320);
            (height === void 0) && (height = 240);
            Video.__super.call(this);
            if (Render.isWebGL)
                this.htmlVideo = new WebGLVideo();
            else
                this.htmlVideo = new HtmlVideo();
            this.videoElement = this.htmlVideo.getVideo();
            this.videoElement.the3Target = this;
            this.internalTexture = new Texture(this.htmlVideo);
            this.videoElement.addEventListener("abort", Video.onAbort);
            this.videoElement.addEventListener("canplay", Video.onCanplay);
            this.videoElement.addEventListener("canplaythrough", Video.onCanplaythrough);
            this.videoElement.addEventListener("durationchange", Video.onDurationchange);
            this.videoElement.addEventListener("emptied", Video.onEmptied);
            this.videoElement.addEventListener("error", Video.onError);
            this.videoElement.addEventListener("loadeddata", Video.onLoadeddata);
            this.videoElement.addEventListener("loadedmetadata", Video.onLoadedmetadata);
            this.videoElement.addEventListener("loadstart", Video.onLoadstart);
            this.videoElement.addEventListener("pause", Video.onPause);
            this.videoElement.addEventListener("play", Video.onPlay);
            this.videoElement.addEventListener("playing", Video.onPlaying);
            this.videoElement.addEventListener("progress", Video.onProgress);
            this.videoElement.addEventListener("ratechange", Video.onRatechange);
            this.videoElement.addEventListener("seeked", Video.onSeeked);
            this.videoElement.addEventListener("seeking", Video.onSeeking);
            this.videoElement.addEventListener("stalled", Video.onStalled);
            this.videoElement.addEventListener("suspend", Video.onSuspend);
            this.videoElement.addEventListener("timeupdate", Video.onTimeupdate);
            this.videoElement.addEventListener("volumechange", Video.onVolumechange);
            this.videoElement.addEventListener("waiting", Video.onWaiting);
            this.videoElement.addEventListener("ended", this.onPlayComplete['bind'](this));
            this.size(width, height);
            if (Browser.onMobile) {
                this.onDocumentClick = this.onDocumentClick.bind(this);
                Browser.document.addEventListener("touchend", this.onDocumentClick);
            }
        }
        __class(Video, 'laya.device.media.Video', _super);
        var __proto = Video.prototype;
        __proto.onPlayComplete = function (e) {
            Laya.timer.clear(this, this.renderCanvas);
            this.event("ended");
        };
        __proto.load = function (url) {
            if (url.indexOf("blob:") == 0)
                this.videoElement.src = url;
            else
                this.htmlVideo.setSource(url, laya.device.media.Video.MP4);
        };
        __proto.play = function () {
            this.videoElement.play();
            Laya.timer.frameLoop(1, this, this.renderCanvas);
        };
        __proto.pause = function () {
            this.videoElement.pause();
            Laya.timer.clear(this, this.renderCanvas);
        };
        __proto.reload = function () {
            this.videoElement.load();
        };
        __proto.canPlayType = function (type) {
            var typeString;
            switch (type) {
                case laya.device.media.Video.MP4:
                    typeString = "video/mp4";
                    break;
                case laya.device.media.Video.OGG:
                    typeString = "video/ogg";
                    break;
                case laya.device.media.Video.WEBM:
                    typeString = "video/webm";
                    break;
            }
            return this.videoElement.canPlayType(typeString);
        };
        __proto.renderCanvas = function () {
            if (this.readyState === 0)
                return;
            if (Render.isWebGL)
                this.htmlVideo['updateTexture']();
            this.graphics.clear();
            this.graphics.drawTexture(this.internalTexture, 0, 0, this.width, this.height);
        };
        __proto.onDocumentClick = function () {
            this.videoElement.play();
            this.videoElement.pause();
            Browser.document.removeEventListener("touchend", this.onDocumentClick);
        };
        __proto.size = function (width, height) {
            _super.prototype.size.call(this, width, height);
            this.videoElement.width = width / Browser.pixelRatio;
            if (this.paused)
                this.renderCanvas();
            return this;
        };
        __proto.destroy = function (detroyChildren) {
            (detroyChildren === void 0) && (detroyChildren = true);
            _super.prototype.destroy.call(this, detroyChildren);
            this.videoElement.removeEventListener("abort", Video.onAbort);
            this.videoElement.removeEventListener("canplay", Video.onCanplay);
            this.videoElement.removeEventListener("canplaythrough", Video.onCanplaythrough);
            this.videoElement.removeEventListener("durationchange", Video.onDurationchange);
            this.videoElement.removeEventListener("emptied", Video.onEmptied);
            this.videoElement.removeEventListener("error", Video.onError);
            this.videoElement.removeEventListener("loadeddata", Video.onLoadeddata);
            this.videoElement.removeEventListener("loadedmetadata", Video.onLoadedmetadata);
            this.videoElement.removeEventListener("loadstart", Video.onLoadstart);
            this.videoElement.removeEventListener("pause", Video.onPause);
            this.videoElement.removeEventListener("play", Video.onPlay);
            this.videoElement.removeEventListener("playing", Video.onPlaying);
            this.videoElement.removeEventListener("progress", Video.onProgress);
            this.videoElement.removeEventListener("ratechange", Video.onRatechange);
            this.videoElement.removeEventListener("seeked", Video.onSeeked);
            this.videoElement.removeEventListener("seeking", Video.onSeeking);
            this.videoElement.removeEventListener("stalled", Video.onStalled);
            this.videoElement.removeEventListener("suspend", Video.onSuspend);
            this.videoElement.removeEventListener("timeupdate", Video.onTimeupdate);
            this.videoElement.removeEventListener("volumechange", Video.onVolumechange);
            this.videoElement.removeEventListener("waiting", Video.onWaiting);
            this.videoElement.removeEventListener("ended", this.onPlayComplete);
            this.pause();
            this.videoElement = null;
        };
        __proto.syncVideoPosition = function () {
            var stage = Laya.stage;
            var rec;
            rec = Utils.getGlobalPosAndScale(this);
            var a = stage._canvasTransform.a, d = stage._canvasTransform.d;
            var x = rec.x * stage.clientScaleX * a + stage.offset.x;
            var y = rec.y * stage.clientScaleY * d + stage.offset.y;
            this.videoElement.style.left = x + 'px';
            ;
            this.videoElement.style.top = y + 'px';
            this.videoElement.width = this.width / Browser.pixelRatio;
            this.videoElement.height = this.height / Browser.pixelRatio;
        };
        __getset(0, __proto, 'buffered', function () {
            return this.videoElement.buffered;
        });
        __getset(0, __proto, 'videoWidth', function () {
            return this.videoElement.videoWidth;
        });
        __getset(0, __proto, 'currentSrc', function () {
            return this.videoElement.currentSrc;
        });
        __getset(0, __proto, 'currentTime', function () {
            return this.videoElement.currentTime;
        }, function (value) {
            this.videoElement.currentTime = value;
            this.renderCanvas();
        });
        __getset(0, __proto, 'ended', function () {
            return this.videoElement.ended;
        });
        __getset(0, __proto, 'volume', function () {
            return this.videoElement.volume;
        }, function (value) {
            this.videoElement.volume = value;
        });
        __getset(0, __proto, 'videoHeight', function () {
            return this.videoElement.videoHeight;
        });
        __getset(0, __proto, 'readyState', function () {
            return this.videoElement.readyState;
        });
        __getset(0, __proto, 'duration', function () {
            return this.videoElement.duration;
        });
        __getset(0, __proto, 'error', function () {
            return this.videoElement.error;
        });
        __getset(0, __proto, 'loop', function () {
            return this.videoElement.loop;
        }, function (value) {
            this.videoElement.loop = value;
        });
        __getset(0, __proto, 'playbackRate', function () {
            return this.videoElement.playbackRate;
        }, function (value) {
            this.videoElement.playbackRate = value;
        });
        __getset(0, __proto, 'muted', function () {
            return this.videoElement.muted;
        }, function (value) {
            this.videoElement.muted = value;
        });
        __getset(0, __proto, 'paused', function () {
            return this.videoElement.paused;
        });
        __getset(0, __proto, 'preload', function () {
            return this.videoElement.preload;
        }, function (value) {
            this.videoElement.preload = value;
        });
        __getset(0, __proto, 'seekable', function () {
            return this.videoElement.seekable;
        });
        __getset(0, __proto, 'seeking', function () {
            return this.videoElement.seeking;
        });
        __getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
            Laya.superSet(Sprite, this, 'height', value);
            if (this.paused)
                this.renderCanvas();
        });
        __getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
            this.videoElement.width = this.width / Browser.pixelRatio;
            Laya.superSet(Sprite, this, 'width', value);
            if (this.paused)
                this.renderCanvas();
        });
        Video.onAbort = function (e) { e.target.the3Target.event("abort"); };
        Video.onCanplay = function (e) { e.target.the3Target.event("canplay"); };
        Video.onCanplaythrough = function (e) { e.target.the3Target.event("canplaythrough"); };
        Video.onDurationchange = function (e) { e.target.the3Target.event("durationchange"); };
        Video.onEmptied = function (e) { e.target.the3Target.event("emptied"); };
        Video.onError = function (e) { e.target.the3Target.event("error"); };
        Video.onLoadeddata = function (e) { e.target.the3Target.event("loadeddata"); };
        Video.onLoadedmetadata = function (e) { e.target.the3Target.event("loadedmetadata"); };
        Video.onLoadstart = function (e) { e.target.the3Target.event("loadstart"); };
        Video.onPause = function (e) { e.target.the3Target.event("pause"); };
        Video.onPlay = function (e) { e.target.the3Target.event("play"); };
        Video.onPlaying = function (e) { e.target.the3Target.event("playing"); };
        Video.onProgress = function (e) { e.target.the3Target.event("progress"); };
        Video.onRatechange = function (e) { e.target.the3Target.event("ratechange"); };
        Video.onSeeked = function (e) { e.target.the3Target.event("seeked"); };
        Video.onSeeking = function (e) { e.target.the3Target.event("seeking"); };
        Video.onStalled = function (e) { e.target.the3Target.event("stalled"); };
        Video.onSuspend = function (e) { e.target.the3Target.event("suspend"); };
        Video.onTimeupdate = function (e) { e.target.the3Target.event("timeupdate"); };
        Video.onVolumechange = function (e) { e.target.the3Target.event("volumechange"); };
        Video.onWaiting = function (e) { e.target.the3Target.event("waiting"); };
        Video.MP4 = 1;
        Video.OGG = 2;
        Video.CAMERA = 4;
        Video.WEBM = 8;
        Video.SUPPORT_PROBABLY = "probably";
        Video.SUPPORT_MAYBY = "maybe";
        Video.SUPPORT_NO = "";
        return Video;
    })(Sprite);
    var HtmlVideo = (function (_super) {
        function HtmlVideo() {
            this.video = null;
            HtmlVideo.__super.call(this);
            this._w = 1;
            this._h = 1;
            this.createDomElement();
        }
        __class(HtmlVideo, 'laya.device.media.HtmlVideo', _super);
        var __proto = HtmlVideo.prototype;
        __proto.createDomElement = function () {
            var _$this = this;
            this._source = this.video = Browser.createElement("video");
            var style = this.video.style;
            style.position = 'absolute';
            style.top = '0px';
            style.left = '0px';
            this.video.addEventListener("loadedmetadata", (function () {
                this._w = _$this.video.videoWidth;
                this._h = _$this.video.videoHeight;
            })['bind'](this));
        };
        __proto.setSource = function (url, extension) {
            while (this.video.childElementCount)
                this.video.firstChild.remove();
            if (extension & Video.MP4)
                this.appendSource(url, "video/mp4");
            if (extension & Video.OGG)
                this.appendSource(url + ".ogg", "video/ogg");
        };
        __proto.appendSource = function (source, type) {
            var sourceElement = Browser.createElement("source");
            sourceElement.src = source;
            sourceElement.type = type;
            this.video.appendChild(sourceElement);
        };
        __proto.getVideo = function () {
            return this.video;
        };
        HtmlVideo.create = function () {
            return new HtmlVideo();
        };
        return HtmlVideo;
    })(Bitmap);
    var WebGLVideo = (function (_super) {
        function WebGLVideo() {
            this.gl = null;
            this.preTarget = null;
            this.preTexture = null;
            WebGLVideo.__super.call(this);
            if (Browser.onIPhone)
                return;
            this.gl = WebGL.mainContext;
            this._source = this.gl.createTexture();
            this.preTarget = WebGLContext.curBindTexTarget;
            this.preTexture = WebGLContext.curBindTexValue;
            WebGLContext.bindTexture(this.gl, 0x0DE1, this._source);
            this.gl.texParameteri(0x0DE1, 0x2802, 0x812F);
            this.gl.texParameteri(0x0DE1, 0x2803, 0x812F);
            this.gl.texParameteri(0x0DE1, 0x2800, 0x2601);
            this.gl.texParameteri(0x0DE1, 0x2801, 0x2601);
            (this.preTarget && this.preTexture) && (WebGLContext.bindTexture(this.gl, this.preTarget, this.preTexture));
        }
        __class(WebGLVideo, 'laya.device.media.WebGLVideo', _super);
        var __proto = WebGLVideo.prototype;
        __proto.updateTexture = function () {
            if (Browser.onIPhone)
                return;
            WebGLContext.bindTexture(this.gl, 0x0DE1, this._source);
            this.gl.texImage2D(0x0DE1, 0, 0x1907, 0x1907, 0x1401, this.video);
        };
        return WebGLVideo;
    })(HtmlVideo);
    Laya.__init([Media]);
})(window, document, Laya);
if (typeof define === 'function' && define.amd) {
    define('laya.core', ['require', "exports"], function (require, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        for (var i in Laya) {
            var o = Laya[i];
            o && o.__isclass && (exports[i] = o);
        }
    });
}
(function (window, document, Laya) {
    var __un = Laya.un, __uns = Laya.uns, __static = Laya.static, __class = Laya.class, __getset = Laya.getset, __newvec = Laya.__newvec;
    var BlendMode = laya.webgl.canvas.BlendMode, Event = laya.events.Event, HTMLCanvas = laya.resource.HTMLCanvas;
    var Handler = laya.utils.Handler, IndexBuffer2D = laya.webgl.utils.IndexBuffer2D, Loader = laya.net.Loader, MathUtil = laya.maths.MathUtil;
    var Matrix = laya.maths.Matrix, Render = laya.renders.Render, RenderContext = laya.renders.RenderContext, RenderSprite = laya.renders.RenderSprite;
    var Shader = laya.webgl.shader.Shader, Sprite = laya.display.Sprite, Stat = laya.utils.Stat, Texture = laya.resource.Texture;
    var Utils = laya.utils.Utils, Value2D = laya.webgl.shader.d2.value.Value2D, VertexBuffer2D = laya.webgl.utils.VertexBuffer2D;
    var WebGL = laya.webgl.WebGL, WebGLContext = laya.webgl.WebGLContext;
    var EmitterBase = (function () {
        function EmitterBase() {
            this._frameTime = 0;
            this._emissionRate = 60;
            this._emissionTime = 0;
            this.minEmissionTime = 1 / 60;
            this._particleTemplate = null;
        }
        __class(EmitterBase, 'laya.particle.emitter.EmitterBase');
        var __proto = EmitterBase.prototype;
        __proto.start = function (duration) {
            (duration === void 0) && (duration = 2147483647);
            if (this._emissionRate != 0)
                this._emissionTime = duration;
        };
        __proto.stop = function () {
            this._emissionTime = 0;
        };
        __proto.clear = function () {
            this._emissionTime = 0;
        };
        __proto.emit = function () { };
        __proto.advanceTime = function (passedTime) {
            (passedTime === void 0) && (passedTime = 1);
            this._emissionTime -= passedTime;
            if (this._emissionTime < 0)
                return;
            this._frameTime += passedTime;
            if (this._frameTime < this.minEmissionTime)
                return;
            while (this._frameTime > this.minEmissionTime) {
                this._frameTime -= this.minEmissionTime;
                this.emit();
            }
        };
        __getset(0, __proto, 'particleTemplate', null, function (particleTemplate) {
            this._particleTemplate = particleTemplate;
        });
        __getset(0, __proto, 'emissionRate', function () {
            return this._emissionRate;
        }, function (_emissionRate) {
            if (_emissionRate <= 0)
                return;
            this._emissionRate = _emissionRate;
            (_emissionRate > 0) && (this.minEmissionTime = 1 / _emissionRate);
        });
        return EmitterBase;
    })();
    var ParticleData = (function () {
        function ParticleData() {
            this.position = null;
            this.velocity = null;
            this.startColor = null;
            this.endColor = null;
            this.sizeRotation = null;
            this.radius = null;
            this.radian = null;
            this.durationAddScale = NaN;
            this.time = NaN;
        }
        __class(ParticleData, 'laya.particle.ParticleData');
        ParticleData.Create = function (settings, position, velocity, time) {
            var particleData = new ParticleData();
            particleData.position = position;
            MathUtil.scaleVector3(velocity, settings.emitterVelocitySensitivity, ParticleData._tempVelocity);
            var horizontalVelocity = MathUtil.lerp(settings.minHorizontalVelocity, settings.maxHorizontalVelocity, Math.random());
            var horizontalAngle = Math.random() * Math.PI * 2;
            ParticleData._tempVelocity[0] += horizontalVelocity * Math.cos(horizontalAngle);
            ParticleData._tempVelocity[2] += horizontalVelocity * Math.sin(horizontalAngle);
            ParticleData._tempVelocity[1] += MathUtil.lerp(settings.minVerticalVelocity, settings.maxVerticalVelocity, Math.random());
            particleData.velocity = ParticleData._tempVelocity;
            particleData.startColor = ParticleData._tempStartColor;
            particleData.endColor = ParticleData._tempEndColor;
            var i = 0;
            if (settings.disableColor) {
                for (i = 0; i < 4; i++) {
                    particleData.startColor[i] = 1;
                    particleData.endColor[i] = 1;
                }
            }
            else {
                if (settings.colorComponentInter) {
                    for (i = 0; i < 4; i++) {
                        particleData.startColor[i] = MathUtil.lerp(settings.minStartColor[i], settings.maxStartColor[i], Math.random());
                        particleData.endColor[i] = MathUtil.lerp(settings.minEndColor[i], settings.maxEndColor[i], Math.random());
                    }
                }
                else {
                    MathUtil.lerpVector4(settings.minStartColor, settings.maxStartColor, Math.random(), particleData.startColor);
                    MathUtil.lerpVector4(settings.minEndColor, settings.maxEndColor, Math.random(), particleData.endColor);
                }
            }
            particleData.sizeRotation = ParticleData._tempSizeRotation;
            var sizeRandom = Math.random();
            particleData.sizeRotation[0] = MathUtil.lerp(settings.minStartSize, settings.maxStartSize, sizeRandom);
            particleData.sizeRotation[1] = MathUtil.lerp(settings.minEndSize, settings.maxEndSize, sizeRandom);
            particleData.sizeRotation[2] = MathUtil.lerp(settings.minRotateSpeed, settings.maxRotateSpeed, Math.random());
            particleData.radius = ParticleData._tempRadius;
            var radiusRandom = Math.random();
            particleData.radius[0] = MathUtil.lerp(settings.minStartRadius, settings.maxStartRadius, radiusRandom);
            particleData.radius[1] = MathUtil.lerp(settings.minEndRadius, settings.maxEndRadius, radiusRandom);
            particleData.radian = ParticleData._tempRadian;
            particleData.radian[0] = MathUtil.lerp(settings.minHorizontalStartRadian, settings.maxHorizontalStartRadian, Math.random());
            particleData.radian[1] = MathUtil.lerp(settings.minVerticalStartRadian, settings.maxVerticalStartRadian, Math.random());
            var useEndRadian = settings.useEndRadian;
            particleData.radian[2] = useEndRadian ? MathUtil.lerp(settings.minHorizontalEndRadian, settings.maxHorizontalEndRadian, Math.random()) : particleData.radian[0];
            particleData.radian[3] = useEndRadian ? MathUtil.lerp(settings.minVerticalEndRadian, settings.maxVerticalEndRadian, Math.random()) : particleData.radian[1];
            particleData.durationAddScale = settings.ageAddScale * Math.random();
            particleData.time = time;
            return particleData;
        };
        __static(ParticleData, ['_tempVelocity', function () { return this._tempVelocity = new Float32Array(3); }, '_tempStartColor', function () { return this._tempStartColor = new Float32Array(4); }, '_tempEndColor', function () { return this._tempEndColor = new Float32Array(4); }, '_tempSizeRotation', function () { return this._tempSizeRotation = new Float32Array(3); }, '_tempRadius', function () { return this._tempRadius = new Float32Array(2); }, '_tempRadian', function () { return this._tempRadian = new Float32Array(4); }
        ]);
        return ParticleData;
    })();
    var ParticleEmitter = (function () {
        function ParticleEmitter(templet, particlesPerSecond, initialPosition) {
            this._templet = null;
            this._timeBetweenParticles = NaN;
            this._previousPosition = null;
            this._timeLeftOver = 0;
            this._tempVelocity = new Float32Array([0, 0, 0]);
            this._tempPosition = new Float32Array([0, 0, 0]);
            this._templet = templet;
            this._timeBetweenParticles = 1.0 / particlesPerSecond;
            this._previousPosition = initialPosition;
        }
        __class(ParticleEmitter, 'laya.particle.ParticleEmitter');
        var __proto = ParticleEmitter.prototype;
        __proto.update = function (elapsedTime, newPosition) {
            elapsedTime = elapsedTime / 1000;
            if (elapsedTime > 0) {
                MathUtil.subtractVector3(newPosition, this._previousPosition, this._tempVelocity);
                MathUtil.scaleVector3(this._tempVelocity, 1 / elapsedTime, this._tempVelocity);
                var timeToSpend = this._timeLeftOver + elapsedTime;
                var currentTime = -this._timeLeftOver;
                while (timeToSpend > this._timeBetweenParticles) {
                    currentTime += this._timeBetweenParticles;
                    timeToSpend -= this._timeBetweenParticles;
                    MathUtil.lerpVector3(this._previousPosition, newPosition, currentTime / elapsedTime, this._tempPosition);
                    this._templet.addParticleArray(this._tempPosition, this._tempVelocity);
                }
                this._timeLeftOver = timeToSpend;
            }
            this._previousPosition[0] = newPosition[0];
            this._previousPosition[1] = newPosition[1];
            this._previousPosition[2] = newPosition[2];
        };
        return ParticleEmitter;
    })();
    var ParticleSetting = (function () {
        function ParticleSetting() {
            this.textureName = null;
            this.textureCount = 1;
            this.maxPartices = 100;
            this.duration = 1;
            this.ageAddScale = 0;
            this.emitterVelocitySensitivity = 1;
            this.minStartSize = 100;
            this.maxStartSize = 100;
            this.minEndSize = 100;
            this.maxEndSize = 100;
            this.minHorizontalVelocity = 0;
            this.maxHorizontalVelocity = 0;
            this.minVerticalVelocity = 0;
            this.maxVerticalVelocity = 0;
            this.endVelocity = 1;
            this.minRotateSpeed = 0;
            this.maxRotateSpeed = 0;
            this.minStartRadius = 0;
            this.maxStartRadius = 0;
            this.minEndRadius = 0;
            this.maxEndRadius = 0;
            this.minHorizontalStartRadian = 0;
            this.maxHorizontalStartRadian = 0;
            this.minVerticalStartRadian = 0;
            this.maxVerticalStartRadian = 0;
            this.useEndRadian = true;
            this.minHorizontalEndRadian = 0;
            this.maxHorizontalEndRadian = 0;
            this.minVerticalEndRadian = 0;
            this.maxVerticalEndRadian = 0;
            this.colorComponentInter = false;
            this.disableColor = false;
            this.blendState = 0;
            this.emitterType = "null";
            this.emissionRate = 0;
            this.sphereEmitterRadius = 1;
            this.sphereEmitterVelocity = 0;
            this.sphereEmitterVelocityAddVariance = 0;
            this.ringEmitterRadius = 30;
            this.ringEmitterVelocity = 0;
            this.ringEmitterVelocityAddVariance = 0;
            this.ringEmitterUp = 2;
            this.gravity = new Float32Array([0, 0, 0]);
            this.minStartColor = new Float32Array([1, 1, 1, 1]);
            this.maxStartColor = new Float32Array([1, 1, 1, 1]);
            this.minEndColor = new Float32Array([1, 1, 1, 1]);
            this.maxEndColor = new Float32Array([1, 1, 1, 1]);
            this.pointEmitterPosition = new Float32Array([0, 0, 0]);
            this.pointEmitterPositionVariance = new Float32Array([0, 0, 0]);
            this.pointEmitterVelocity = new Float32Array([0, 0, 0]);
            this.pointEmitterVelocityAddVariance = new Float32Array([0, 0, 0]);
            this.boxEmitterCenterPosition = new Float32Array([0, 0, 0]);
            this.boxEmitterSize = new Float32Array([0, 0, 0]);
            this.boxEmitterVelocity = new Float32Array([0, 0, 0]);
            this.boxEmitterVelocityAddVariance = new Float32Array([0, 0, 0]);
            this.sphereEmitterCenterPosition = new Float32Array([0, 0, 0]);
            this.ringEmitterCenterPosition = new Float32Array([0, 0, 0]);
            this.positionVariance = new Float32Array([0, 0, 0]);
        }
        __class(ParticleSetting, 'laya.particle.ParticleSetting');
        ParticleSetting.checkSetting = function (setting) {
            var key;
            for (key in ParticleSetting._defaultSetting) {
                if (!setting.hasOwnProperty(key)) {
                    setting[key] = ParticleSetting._defaultSetting[key];
                }
            }
        };
        __static(ParticleSetting, ['_defaultSetting', function () { return this._defaultSetting = new ParticleSetting(); }
        ]);
        return ParticleSetting;
    })();
    var ParticleTemplateBase = (function () {
        function ParticleTemplateBase() {
            this.settings = null;
            this.texture = null;
        }
        __class(ParticleTemplateBase, 'laya.particle.ParticleTemplateBase');
        var __proto = ParticleTemplateBase.prototype;
        __proto.addParticleArray = function (position, velocity) { };
        return ParticleTemplateBase;
    })();
    var CanvasShader = (function () {
        function CanvasShader() {
            this.u_Duration = NaN;
            this.u_EndVelocity = NaN;
            this.u_Gravity = null;
            this.a_Position = null;
            this.a_Velocity = null;
            this.a_StartColor = null;
            this.a_EndColor = null;
            this.a_SizeRotation = null;
            this.a_Radius = null;
            this.a_Radian = null;
            this.a_AgeAddScale = NaN;
            this.gl_Position = null;
            this.v_Color = null;
            this.oSize = NaN;
            this._color = new Float32Array(4);
            this._position = new Float32Array(3);
        }
        __class(CanvasShader, 'laya.particle.particleUtils.CanvasShader');
        var __proto = CanvasShader.prototype;
        __proto.getLen = function (position) {
            return Math.sqrt(position[0] * position[0] + position[1] * position[1] + position[2] * position[2]);
        };
        __proto.ComputeParticlePosition = function (position, velocity, age, normalizedAge) {
            this._position[0] = position[0];
            this._position[1] = position[1];
            this._position[2] = position[2];
            var startVelocity = this.getLen(velocity);
            var endVelocity = startVelocity * this.u_EndVelocity;
            var velocityIntegral = startVelocity * normalizedAge + (endVelocity - startVelocity) * normalizedAge * normalizedAge / 2.0;
            var lenVelocity = NaN;
            lenVelocity = this.getLen(velocity);
            var i = 0, len = 0;
            len = 3;
            for (i = 0; i < len; i++) {
                this._position[i] = this._position[i] + (velocity[i] / lenVelocity) * velocityIntegral * this.u_Duration;
                this._position[i] += this.u_Gravity[i] * age * normalizedAge;
            }
            ;
            var radius = MathUtil.lerp(this.a_Radius[0], this.a_Radius[1], normalizedAge);
            var radianHorizontal = MathUtil.lerp(this.a_Radian[0], this.a_Radian[2], normalizedAge);
            var radianVertical = MathUtil.lerp(this.a_Radian[1], this.a_Radian[3], normalizedAge);
            var r = Math.cos(radianVertical) * radius;
            this._position[1] += Math.sin(radianVertical) * radius;
            this._position[0] += Math.cos(radianHorizontal) * r;
            this._position[2] += Math.sin(radianHorizontal) * r;
            return new Float32Array([this._position[0], this._position[1], 0.0, 1.0]);
        };
        __proto.ComputeParticleSize = function (startSize, endSize, normalizedAge) {
            var size = MathUtil.lerp(startSize, endSize, normalizedAge);
            return size;
        };
        __proto.ComputeParticleRotation = function (rot, age) {
            return rot * age;
        };
        __proto.ComputeParticleColor = function (startColor, endColor, normalizedAge) {
            var rst = this._color;
            MathUtil.lerpVector4(startColor, endColor, normalizedAge, rst);
            rst[3] = rst[3] * normalizedAge * (1.0 - normalizedAge) * (1.0 - normalizedAge) * 6.7;
            return rst;
        };
        __proto.clamp = function (value, min, max) {
            if (value < min)
                return min;
            if (value > max)
                return max;
            return value;
        };
        __proto.getData = function (age) {
            age *= 1.0 + this.a_AgeAddScale;
            var normalizedAge = this.clamp(age / this.u_Duration, 0.0, 1.0);
            this.gl_Position = this.ComputeParticlePosition(this.a_Position, this.a_Velocity, age, normalizedAge);
            var pSize = this.ComputeParticleSize(this.a_SizeRotation[0], this.a_SizeRotation[1], normalizedAge);
            var rotation = this.ComputeParticleRotation(this.a_SizeRotation[2], age);
            this.v_Color = this.ComputeParticleColor(this.a_StartColor, this.a_EndColor, normalizedAge);
            var matric = new Matrix();
            var scale = NaN;
            scale = pSize / this.oSize * 2;
            matric.scale(scale, scale);
            matric.rotate(rotation);
            matric.setTranslate(this.gl_Position[0], -this.gl_Position[1]);
            var alpha = NaN;
            alpha = this.v_Color[3];
            return [this.v_Color, alpha, matric, this.v_Color[0] * alpha, this.v_Color[1] * alpha, this.v_Color[2] * alpha];
        };
        return CanvasShader;
    })();
    var CMDParticle = (function () {
        function CMDParticle() {
            this.maxIndex = 0;
            this.cmds = null;
            this.id = 0;
        }
        __class(CMDParticle, 'laya.particle.particleUtils.CMDParticle');
        var __proto = CMDParticle.prototype;
        __proto.setCmds = function (cmds) {
            this.cmds = cmds;
            this.maxIndex = cmds.length - 1;
        };
        return CMDParticle;
    })();
    var PicTool = (function () {
        function PicTool() { }
        __class(PicTool, 'laya.particle.particleUtils.PicTool');
        PicTool.getCanvasPic = function (img, color) {
            img = img.bitmap;
            var canvas = new HTMLCanvas("2D");
            var ctx = canvas.getContext('2d');
            canvas.size(img.width, img.height);
            var red = (color >> 16 & 0xFF);
            var green = (color >> 8 & 0xFF);
            var blue = (color & 0xFF);
            if (Render.isConchApp) {
                ctx.setFilter(red / 255, green / 255, blue / 255, 0);
            }
            ctx.drawImage(img.source, 0, 0);
            if (!Render.isConchApp) {
                var imgdata = ctx.getImageData(0, 0, canvas.width, canvas.height);
                var data = imgdata.data;
                for (var i = 0, n = data.length; i < n; i += 4) {
                    if (data[i + 3] == 0)
                        continue;
                    data[i] *= red / 255;
                    data[i + 1] *= green / 255;
                    data[i + 2] *= blue / 255;
                }
                ctx.putImageData(imgdata, 0, 0);
            }
            return canvas;
        };
        PicTool.getRGBPic = function (img) {
            var rst;
            rst = [new Texture(PicTool.getCanvasPic(img, 0xFF0000)), new Texture(PicTool.getCanvasPic(img, 0x00FF00)), new Texture(PicTool.getCanvasPic(img, 0x0000FF))];
            return rst;
        };
        return PicTool;
    })();
    var Emitter2D = (function (_super) {
        function Emitter2D(_template) {
            this.setting = null;
            this._posRange = null;
            this._canvasTemplate = null;
            this._emitFun = null;
            Emitter2D.__super.call(this);
            this.template = _template;
        }
        __class(Emitter2D, 'laya.particle.emitter.Emitter2D', _super);
        var __proto = Emitter2D.prototype;
        __proto.emit = function () {
            _super.prototype.emit.call(this);
            if (this._emitFun != null)
                this._emitFun();
        };
        __proto.getRandom = function (value) {
            return (Math.random() * 2 - 1) * value;
        };
        __proto.webGLEmit = function () {
            var pos = new Float32Array(3);
            pos[0] = this.getRandom(this._posRange[0]);
            pos[1] = this.getRandom(this._posRange[1]);
            pos[2] = this.getRandom(this._posRange[2]);
            var v = new Float32Array(3);
            v[0] = 0;
            v[1] = 0;
            v[2] = 0;
            this._particleTemplate.addParticleArray(pos, v);
        };
        __proto.canvasEmit = function () {
            var pos = new Float32Array(3);
            pos[0] = this.getRandom(this._posRange[0]);
            pos[1] = this.getRandom(this._posRange[1]);
            pos[2] = this.getRandom(this._posRange[2]);
            var v = new Float32Array(3);
            v[0] = 0;
            v[1] = 0;
            v[2] = 0;
            this._particleTemplate.addParticleArray(pos, v);
        };
        __getset(0, __proto, 'template', function () {
            return this._particleTemplate;
        }, function (template) {
            this._particleTemplate = template;
            if (!template) {
                this._emitFun = null;
                this.setting = null;
                this._posRange = null;
            }
            ;
            this.setting = template.settings;
            this._posRange = this.setting.positionVariance;
            if ((this._particleTemplate instanceof laya.particle.ParticleTemplate2D)) {
                this._emitFun = this.webGLEmit;
            }
            else if ((this._particleTemplate instanceof laya.particle.ParticleTemplateCanvas)) {
                this._canvasTemplate = template;
                this._emitFun = this.canvasEmit;
            }
        });
        return Emitter2D;
    })(EmitterBase);
    var ParticleTemplateWebGL = (function (_super) {
        function ParticleTemplateWebGL(parSetting) {
            this._vertices = null;
            this._vertexBuffer = null;
            this._indexBuffer = null;
            this._floatCountPerVertex = 29;
            this._firstActiveElement = 0;
            this._firstNewElement = 0;
            this._firstFreeElement = 0;
            this._firstRetiredElement = 0;
            this._currentTime = 0;
            this._drawCounter = 0;
            ParticleTemplateWebGL.__super.call(this);
            this.settings = parSetting;
        }
        __class(ParticleTemplateWebGL, 'laya.particle.ParticleTemplateWebGL', _super);
        var __proto = ParticleTemplateWebGL.prototype;
        __proto.initialize = function () {
            this._vertices = new Float32Array(this.settings.maxPartices * this._floatCountPerVertex * 4);
            var particleOffset = 0;
            for (var i = 0; i < this.settings.maxPartices; i++) {
                var random = Math.random();
                var cornerYSegement = this.settings.textureCount ? 1.0 / this.settings.textureCount : 1.0;
                var cornerY = NaN;
                for (cornerY = 0; cornerY < this.settings.textureCount; cornerY += cornerYSegement) {
                    if (random < cornerY + cornerYSegement)
                        break;
                }
                particleOffset = i * this._floatCountPerVertex * 4;
                this._vertices[particleOffset + this._floatCountPerVertex * 0 + 0] = -1;
                this._vertices[particleOffset + this._floatCountPerVertex * 0 + 1] = -1;
                this._vertices[particleOffset + this._floatCountPerVertex * 0 + 2] = 0;
                this._vertices[particleOffset + this._floatCountPerVertex * 0 + 3] = cornerY;
                this._vertices[particleOffset + this._floatCountPerVertex * 1 + 0] = 1;
                this._vertices[particleOffset + this._floatCountPerVertex * 1 + 1] = -1;
                this._vertices[particleOffset + this._floatCountPerVertex * 1 + 2] = 1;
                this._vertices[particleOffset + this._floatCountPerVertex * 1 + 3] = cornerY;
                this._vertices[particleOffset + this._floatCountPerVertex * 2 + 0] = 1;
                this._vertices[particleOffset + this._floatCountPerVertex * 2 + 1] = 1;
                this._vertices[particleOffset + this._floatCountPerVertex * 2 + 2] = 1;
                this._vertices[particleOffset + this._floatCountPerVertex * 2 + 3] = cornerY + cornerYSegement;
                this._vertices[particleOffset + this._floatCountPerVertex * 3 + 0] = -1;
                this._vertices[particleOffset + this._floatCountPerVertex * 3 + 1] = 1;
                this._vertices[particleOffset + this._floatCountPerVertex * 3 + 2] = 0;
                this._vertices[particleOffset + this._floatCountPerVertex * 3 + 3] = cornerY + cornerYSegement;
            }
        };
        __proto.loadContent = function () { };
        __proto.update = function (elapsedTime) {
            this._currentTime += elapsedTime / 1000;
            this.retireActiveParticles();
            this.freeRetiredParticles();
            if (this._firstActiveElement == this._firstFreeElement)
                this._currentTime = 0;
            if (this._firstRetiredElement == this._firstActiveElement)
                this._drawCounter = 0;
        };
        __proto.retireActiveParticles = function () {
            var epsilon = 0.0001;
            var particleDuration = this.settings.duration;
            while (this._firstActiveElement != this._firstNewElement) {
                var offset = this._firstActiveElement * this._floatCountPerVertex * 4;
                var index = offset + 28;
                var particleAge = this._currentTime - this._vertices[index];
                particleAge *= (1.0 + this._vertices[offset + 27]);
                if (particleAge + epsilon < particleDuration)
                    break;
                this._vertices[index] = this._drawCounter;
                this._firstActiveElement++;
                if (this._firstActiveElement >= this.settings.maxPartices)
                    this._firstActiveElement = 0;
            }
        };
        __proto.freeRetiredParticles = function () {
            while (this._firstRetiredElement != this._firstActiveElement) {
                var age = this._drawCounter - this._vertices[this._firstRetiredElement * this._floatCountPerVertex * 4 + 28];
                if (age < 3)
                    break;
                this._firstRetiredElement++;
                if (this._firstRetiredElement >= this.settings.maxPartices)
                    this._firstRetiredElement = 0;
            }
        };
        __proto.addNewParticlesToVertexBuffer = function () { };
        __proto.addParticleArray = function (position, velocity) {
            var nextFreeParticle = this._firstFreeElement + 1;
            if (nextFreeParticle >= this.settings.maxPartices)
                nextFreeParticle = 0;
            if (nextFreeParticle === this._firstRetiredElement)
                return;
            var particleData = ParticleData.Create(this.settings, position, velocity, this._currentTime);
            var startIndex = this._firstFreeElement * this._floatCountPerVertex * 4;
            for (var i = 0; i < 4; i++) {
                var j = 0, offset = 0;
                for (j = 0, offset = 4; j < 3; j++)
                    this._vertices[startIndex + i * this._floatCountPerVertex + offset + j] = particleData.position[j];
                for (j = 0, offset = 7; j < 3; j++)
                    this._vertices[startIndex + i * this._floatCountPerVertex + offset + j] = particleData.velocity[j];
                for (j = 0, offset = 10; j < 4; j++)
                    this._vertices[startIndex + i * this._floatCountPerVertex + offset + j] = particleData.startColor[j];
                for (j = 0, offset = 14; j < 4; j++)
                    this._vertices[startIndex + i * this._floatCountPerVertex + offset + j] = particleData.endColor[j];
                for (j = 0, offset = 18; j < 3; j++)
                    this._vertices[startIndex + i * this._floatCountPerVertex + offset + j] = particleData.sizeRotation[j];
                for (j = 0, offset = 21; j < 2; j++)
                    this._vertices[startIndex + i * this._floatCountPerVertex + offset + j] = particleData.radius[j];
                for (j = 0, offset = 23; j < 4; j++)
                    this._vertices[startIndex + i * this._floatCountPerVertex + offset + j] = particleData.radian[j];
                this._vertices[startIndex + i * this._floatCountPerVertex + 27] = particleData.durationAddScale;
                this._vertices[startIndex + i * this._floatCountPerVertex + 28] = particleData.time;
            }
            this._firstFreeElement = nextFreeParticle;
        };
        return ParticleTemplateWebGL;
    })(ParticleTemplateBase);
    var ParticleTemplateCanvas = (function (_super) {
        function ParticleTemplateCanvas(particleSetting) {
            this._ready = false;
            this.textureList = [];
            this.particleList = [];
            this.pX = 0;
            this.pY = 0;
            this.activeParticles = [];
            this.deadParticles = [];
            this.iList = [];
            this._maxNumParticles = 0;
            this.textureWidth = NaN;
            this.dTextureWidth = NaN;
            this.colorChange = true;
            this.step = 1 / 60;
            this.canvasShader = new CanvasShader();
            ParticleTemplateCanvas.__super.call(this);
            this.settings = particleSetting;
            this._maxNumParticles = particleSetting.maxPartices;
            this.texture = new Texture();
            this.texture.on("loaded", this, this._textureLoaded);
            this.texture.load(particleSetting.textureName);
        }
        __class(ParticleTemplateCanvas, 'laya.particle.ParticleTemplateCanvas', _super);
        var __proto = ParticleTemplateCanvas.prototype;
        __proto._textureLoaded = function (e) {
            this.setTexture(this.texture);
            this._ready = true;
        };
        __proto.clear = function (clearTexture) {
            (clearTexture === void 0) && (clearTexture = true);
            this.deadParticles.length = 0;
            this.activeParticles.length = 0;
            this.textureList.length = 0;
        };
        __proto.setTexture = function (texture) {
            this.texture = texture;
            this.textureWidth = texture.width;
            this.dTextureWidth = 1 / this.textureWidth;
            this.pX = -texture.width * 0.5;
            this.pY = -texture.height * 0.5;
            this.textureList = ParticleTemplateCanvas.changeTexture(texture, this.textureList);
            this.particleList.length = 0;
            this.deadParticles.length = 0;
            this.activeParticles.length = 0;
        };
        __proto._createAParticleData = function (position, velocity) {
            this.canvasShader.u_EndVelocity = this.settings.endVelocity;
            this.canvasShader.u_Gravity = this.settings.gravity;
            this.canvasShader.u_Duration = this.settings.duration;
            var particle;
            particle = ParticleData.Create(this.settings, position, velocity, 0);
            this.canvasShader.a_Position = particle.position;
            this.canvasShader.a_Velocity = particle.velocity;
            this.canvasShader.a_StartColor = particle.startColor;
            this.canvasShader.a_EndColor = particle.endColor;
            this.canvasShader.a_SizeRotation = particle.sizeRotation;
            this.canvasShader.a_Radius = particle.radius;
            this.canvasShader.a_Radian = particle.radian;
            this.canvasShader.a_AgeAddScale = particle.durationAddScale;
            this.canvasShader.oSize = this.textureWidth;
            var rst = new CMDParticle();
            var i = 0, len = this.settings.duration / (1 + particle.durationAddScale);
            var params = [];
            var mStep = NaN;
            for (i = 0; i < len; i += this.step) {
                params.push(this.canvasShader.getData(i));
            }
            rst.id = this.particleList.length;
            this.particleList.push(rst);
            rst.setCmds(params);
            return rst;
        };
        __proto.addParticleArray = function (position, velocity) {
            if (!this._ready)
                return;
            var tParticle;
            if (this.particleList.length < this._maxNumParticles) {
                tParticle = this._createAParticleData(position, velocity);
                this.iList[tParticle.id] = 0;
                this.activeParticles.push(tParticle);
            }
            else {
                if (this.deadParticles.length > 0) {
                    tParticle = this.deadParticles.pop();
                    this.iList[tParticle.id] = 0;
                    this.activeParticles.push(tParticle);
                }
            }
        };
        __proto.advanceTime = function (passedTime) {
            (passedTime === void 0) && (passedTime = 1);
            if (!this._ready)
                return;
            var particleList = this.activeParticles;
            var pool = this.deadParticles;
            var i = 0, len = particleList.length;
            var tcmd;
            var tI = 0;
            var iList = this.iList;
            for (i = len - 1; i > -1; i--) {
                tcmd = particleList[i];
                tI = iList[tcmd.id];
                if (tI >= tcmd.maxIndex) {
                    tI = 0;
                    particleList.splice(i, 1);
                    pool.push(tcmd);
                }
                else {
                    tI += 1;
                }
                iList[tcmd.id] = tI;
            }
        };
        __proto.render = function (context, x, y) {
            if (!this._ready)
                return;
            if (this.activeParticles.length < 1)
                return;
            if (this.textureList.length < 2)
                return;
            if (this.settings.disableColor) {
                this.noColorRender(context, x, y);
            }
            else {
                this.canvasRender(context, x, y);
            }
        };
        __proto.noColorRender = function (context, x, y) {
            var particleList = this.activeParticles;
            var i = 0, len = particleList.length;
            var tcmd;
            var tParam;
            var tAlpha = NaN;
            var px = this.pX, py = this.pY;
            var pw = -px * 2, ph = -py * 2;
            var tI = 0;
            var textureList = this.textureList;
            var iList = this.iList;
            var preAlpha = NaN;
            context.translate(x, y);
            preAlpha = context.ctx.globalAlpha;
            for (i = 0; i < len; i++) {
                tcmd = particleList[i];
                tI = iList[tcmd.id];
                tParam = tcmd.cmds[tI];
                if (!tParam)
                    continue;
                if ((tAlpha = tParam[1]) <= 0.01)
                    continue;
                context.setAlpha(preAlpha * tAlpha);
                context.drawTextureWithTransform(this.texture, px, py, pw, ph, tParam[2], 1);
            }
            context.setAlpha(preAlpha);
            context.translate(-x, -y);
        };
        __proto.canvasRender = function (context, x, y) {
            var particleList = this.activeParticles;
            var i = 0, len = particleList.length;
            var tcmd;
            var tParam;
            var tAlpha = NaN;
            var px = this.pX, py = this.pY;
            var pw = -px * 2, ph = -py * 2;
            var tI = 0;
            var textureList = this.textureList;
            var iList = this.iList;
            var preAlpha = NaN;
            var preB;
            context.translate(x, y);
            preAlpha = context.ctx.globalAlpha;
            preB = context.ctx.globalCompositeOperation;
            context.blendMode("lighter");
            for (i = 0; i < len; i++) {
                tcmd = particleList[i];
                tI = iList[tcmd.id];
                tParam = tcmd.cmds[tI];
                if (!tParam)
                    continue;
                if ((tAlpha = tParam[1]) <= 0.01)
                    continue;
                context.save();
                context.transformByMatrix(tParam[2]);
                if (tParam[3] > 0.01) {
                    context.setAlpha(preAlpha * tParam[3]);
                    context.drawTexture(textureList[0], px, py, pw, ph);
                }
                if (tParam[4] > 0.01) {
                    context.setAlpha(preAlpha * tParam[4]);
                    context.drawTexture(textureList[1], px, py, pw, ph);
                }
                if (tParam[5] > 0.01) {
                    context.setAlpha(preAlpha * tParam[5]);
                    context.drawTexture(textureList[2], px, py, pw, ph);
                }
                context.restore();
            }
            context.setAlpha(preAlpha);
            context.translate(-x, -y);
            context.blendMode(preB);
        };
        ParticleTemplateCanvas.changeTexture = function (texture, rst, settings) {
            if (!rst)
                rst = [];
            rst.length = 0;
            if (settings && settings.disableColor) {
                rst.push(texture, texture, texture);
            }
            else {
                Utils.copyArray(rst, PicTool.getRGBPic(texture));
            }
            return rst;
        };
        return ParticleTemplateCanvas;
    })(ParticleTemplateBase);
    var ParticleTemplate2D = (function (_super) {
        function ParticleTemplate2D(parSetting) {
            this._vertexBuffer2D = null;
            this._indexBuffer2D = null;
            this.x = 0;
            this.y = 0;
            this._blendFn = null;
            this._startTime = 0;
            this.sv = new ParticleShaderValue();
            ParticleTemplate2D.__super.call(this, parSetting);
            var _this = this;
            Laya.loader.load(this.settings.textureName, Handler.create(null, function (texture) {
                (texture.bitmap).enableMerageInAtlas = false;
                _this.texture = texture;
            }));
            this.sv.u_Duration = this.settings.duration;
            this.sv.u_Gravity = this.settings.gravity;
            this.sv.u_EndVelocity = this.settings.endVelocity;
            this._blendFn = BlendMode.fns[parSetting.blendState];
            this.initialize();
            this._vertexBuffer = this._vertexBuffer2D = VertexBuffer2D.create(-1, 0x88E8);
            this._indexBuffer = this._indexBuffer2D = IndexBuffer2D.create(0x88E4);
            this.loadContent();
        }
        __class(ParticleTemplate2D, 'laya.particle.ParticleTemplate2D', _super);
        var __proto = ParticleTemplate2D.prototype;
        Laya.imps(__proto, { "laya.webgl.submit.ISubmit": true });
        __proto.getRenderType = function () { return -111; };
        __proto.releaseRender = function () { };
        __proto.addParticleArray = function (position, velocity) {
            position[0] += this.x;
            position[1] += this.y;
            _super.prototype.addParticleArray.call(this, position, velocity);
        };
        __proto.loadContent = function () {
            var indexes = new Uint16Array(this.settings.maxPartices * 6);
            for (var i = 0; i < this.settings.maxPartices; i++) {
                indexes[i * 6 + 0] = (i * 4 + 0);
                indexes[i * 6 + 1] = (i * 4 + 1);
                indexes[i * 6 + 2] = (i * 4 + 2);
                indexes[i * 6 + 3] = (i * 4 + 0);
                indexes[i * 6 + 4] = (i * 4 + 2);
                indexes[i * 6 + 5] = (i * 4 + 3);
            }
            this._indexBuffer2D.clear();
            this._indexBuffer2D.append(indexes);
            this._indexBuffer2D.upload();
        };
        __proto.addNewParticlesToVertexBuffer = function () {
            this._vertexBuffer2D.clear();
            this._vertexBuffer2D.append(this._vertices);
            var start = 0;
            if (this._firstNewElement < this._firstFreeElement) {
                start = this._firstNewElement * 4 * this._floatCountPerVertex * 4;
                this._vertexBuffer2D.subUpload(start, start, start + (this._firstFreeElement - this._firstNewElement) * 4 * this._floatCountPerVertex * 4);
            }
            else {
                start = this._firstNewElement * 4 * this._floatCountPerVertex * 4;
                this._vertexBuffer2D.subUpload(start, start, start + (this.settings.maxPartices - this._firstNewElement) * 4 * this._floatCountPerVertex * 4);
                if (this._firstFreeElement > 0) {
                    this._vertexBuffer2D.setNeedUpload();
                    this._vertexBuffer2D.subUpload(0, 0, this._firstFreeElement * 4 * this._floatCountPerVertex * 4);
                }
            }
            this._firstNewElement = this._firstFreeElement;
        };
        __proto.renderSubmit = function () {
            if (this.texture && this.texture.loaded) {
                this.update(Laya.timer.delta);
                this.sv.u_CurrentTime = this._currentTime;
                if (this._firstNewElement != this._firstFreeElement) {
                    this.addNewParticlesToVertexBuffer();
                }
                this.blend();
                if (this._firstActiveElement != this._firstFreeElement) {
                    var gl = WebGL.mainContext;
                    this._vertexBuffer2D.bind(this._indexBuffer2D);
                    this.sv.u_texture = this.texture.source;
                    this.sv.upload();
                    if (this._firstActiveElement < this._firstFreeElement) {
                        WebGL.mainContext.drawElements(0x0004, (this._firstFreeElement - this._firstActiveElement) * 6, 0x1403, this._firstActiveElement * 6 * 2);
                    }
                    else {
                        WebGL.mainContext.drawElements(0x0004, (this.settings.maxPartices - this._firstActiveElement) * 6, 0x1403, this._firstActiveElement * 6 * 2);
                        if (this._firstFreeElement > 0)
                            WebGL.mainContext.drawElements(0x0004, this._firstFreeElement * 6, 0x1403, 0);
                    }
                    Stat.drawCall++;
                }
                this._drawCounter++;
            }
            return 1;
        };
        __proto.blend = function () {
            if (BlendMode.activeBlendFunction !== this._blendFn) {
                var gl = WebGL.mainContext;
                gl.enable(0x0BE2);
                this._blendFn(gl);
                BlendMode.activeBlendFunction = this._blendFn;
            }
        };
        __proto.dispose = function () {
            this._vertexBuffer2D.dispose();
            this._indexBuffer2D.dispose();
        };
        ParticleTemplate2D.activeBlendType = -1;
        return ParticleTemplate2D;
    })(ParticleTemplateWebGL);
    var ParticleShaderValue = (function (_super) {
        function ParticleShaderValue() {
            this.a_CornerTextureCoordinate = [4, 0x1406, false, 116, 0];
            this.a_Position = [3, 0x1406, false, 116, 16];
            this.a_Velocity = [3, 0x1406, false, 116, 28];
            this.a_StartColor = [4, 0x1406, false, 116, 40];
            this.a_EndColor = [4, 0x1406, false, 116, 56];
            this.a_SizeRotation = [3, 0x1406, false, 116, 72];
            this.a_Radius = [2, 0x1406, false, 116, 84];
            this.a_Radian = [4, 0x1406, false, 116, 92];
            this.a_AgeAddScale = [1, 0x1406, false, 116, 108];
            this.a_Time = [1, 0x1406, false, 116, 112];
            this.u_CurrentTime = NaN;
            this.u_Duration = NaN;
            this.u_Gravity = null;
            this.u_EndVelocity = NaN;
            this.u_texture = null;
            ParticleShaderValue.__super.call(this, 0, 0);
        }
        __class(ParticleShaderValue, 'laya.particle.shader.value.ParticleShaderValue', _super);
        var __proto = ParticleShaderValue.prototype;
        __proto.upload = function () {
            this.refresh();
            ParticleShaderValue.pShader.upload(this);
        };
        __static(ParticleShaderValue, ['pShader', function () { return this.pShader = new ParticleShader(); }
        ]);
        return ParticleShaderValue;
    })(Value2D);
    var Particle2D = (function (_super) {
        function Particle2D(setting) {
            this._matrix4 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
            this._particleTemplate = null;
            this._canvasTemplate = null;
            this._emitter = null;
            this.autoPlay = true;
            Particle2D.__super.call(this);
            if (setting)
                this.setParticleSetting(setting);
        }
        __class(Particle2D, 'laya.particle.Particle2D', _super);
        var __proto = Particle2D.prototype;
        __proto.load = function (url) {
            Laya.loader.load(url, Handler.create(this, this.setParticleSetting), null, "json");
        };
        __proto.setParticleSetting = function (setting) {
            var _$this = this;
            if (!setting)
                return this.stop();
            ParticleSetting.checkSetting(setting);
            if (!window.ConchParticleTemplate2D || Render.isWebGL)
                this.customRenderEnable = true;
            if (Render.isWebGL) {
                this._particleTemplate = new ParticleTemplate2D(setting);
                this.graphics._saveToCmd(Render.context._drawParticle, [this._particleTemplate]);
            }
            else if (Render.isConchApp && window.ConchParticleTemplate2D) {
                this._particleTemplate = new ConchParticleTemplate2D();
                var _this = this;
                Laya.loader.load(setting.textureName, Handler.create(null, function (texture) {
                    _this._particleTemplate.texture = texture;
                    _this._particleTemplate.settings = setting;
                    if (Render.isConchNode) {
                        _this.graphics.drawParticle(_this._particleTemplate);
                    }
                    else {
                        _this.graphics._saveToCmd(Render.context._drawParticle, [_$this._particleTemplate]);
                    }
                }));
                this._emitter = { start: function () { } };
                this.play = this._particleTemplate.play.bind(this._particleTemplate);
                this.stop = this._particleTemplate.stop.bind(this._particleTemplate);
                if (this.autoPlay)
                    this.play();
                return;
            }
            else {
                this._particleTemplate = this._canvasTemplate = new ParticleTemplateCanvas(setting);
            }
            if (!this._emitter) {
                this._emitter = new Emitter2D(this._particleTemplate);
            }
            else {
                (this._emitter).template = this._particleTemplate;
            }
            if (this.autoPlay) {
                this.emitter.start();
                this.play();
            }
        };
        __proto.play = function () {
            this.timer.frameLoop(1, this, this._loop);
        };
        __proto.stop = function () {
            this.timer.clear(this, this._loop);
        };
        __proto._loop = function () {
            this.advanceTime(1 / 60);
        };
        __proto.advanceTime = function (passedTime) {
            (passedTime === void 0) && (passedTime = 1);
            if (this._canvasTemplate) {
                this._canvasTemplate.advanceTime(passedTime);
            }
            if (this._emitter) {
                this._emitter.advanceTime(passedTime);
            }
        };
        __proto.customRender = function (context, x, y) {
            if (Render.isWebGL) {
                this._matrix4[0] = context.ctx._curMat.a;
                this._matrix4[1] = context.ctx._curMat.b;
                this._matrix4[4] = context.ctx._curMat.c;
                this._matrix4[5] = context.ctx._curMat.d;
                this._matrix4[12] = context.ctx._curMat.tx;
                this._matrix4[13] = context.ctx._curMat.ty;
                var sv = (this._particleTemplate).sv;
                sv.u_xxxx = { 0: 0, 1: 0, 2: 0 };
                sv.u_mmat = this._matrix4;
            }
            if (this._canvasTemplate) {
                this._canvasTemplate.render(context, x, y);
            }
        };
        __proto.destroy = function (destroyChild) {
            (destroyChild === void 0) && (destroyChild = true);
            if ((this._particleTemplate instanceof laya.particle.ParticleTemplate2D))
                (this._particleTemplate).dispose();
            _super.prototype.destroy.call(this, destroyChild);
        };
        __getset(0, __proto, 'url', null, function (url) {
            this.load(url);
        });
        __getset(0, __proto, 'emitter', function () {
            return this._emitter;
        });
        return Particle2D;
    })(Sprite);
    var ParticleShader = (function (_super) {
        function ParticleShader() {
            ParticleShader.__super.call(this, ParticleShader.vs, ParticleShader.ps, "ParticleShader");
        }
        __class(ParticleShader, 'laya.particle.shader.ParticleShader', _super);
        __static(ParticleShader, ['vs', function () { return this.vs = "attribute vec4 a_CornerTextureCoordinate;\nattribute vec3 a_Position;\nattribute vec3 a_Velocity;\nattribute vec4 a_StartColor;\nattribute vec4 a_EndColor;\nattribute vec3 a_SizeRotation;\nattribute vec2 a_Radius;\nattribute vec4 a_Radian;\nattribute float a_AgeAddScale;\nattribute float a_Time;\n\nvarying vec4 v_Color;\nvarying vec2 v_TextureCoordinate;\n\nuniform float u_CurrentTime;\nuniform float u_Duration;\nuniform float u_EndVelocity;\nuniform vec3 u_Gravity;\n\n#ifdef PARTICLE3D\n uniform mat4 u_WorldMat;\n uniform mat4 u_View;\n uniform mat4 u_Projection;\n uniform vec2 u_ViewportScale;\n#else\n uniform vec2 size;\n uniform mat4 mmat;\n uniform mat4 u_mmat;\n#endif\n\nvec4 ComputeParticlePosition(in vec3 position, in vec3 velocity,in float age,in float normalizedAge)\n{\n\n   float startVelocity = length(velocity);//起始标量速度\n   float endVelocity = startVelocity * u_EndVelocity;//结束标量速度\n\n   float velocityIntegral = startVelocity * normalizedAge +(endVelocity - startVelocity) * normalizedAge *normalizedAge/2.0;//计算当前速度的标量（单位空间），vt=v0*t+(1/2)*a*(t^2)\n   \n   vec3 addPosition = normalize(velocity) * velocityIntegral * u_Duration;//计算受自身速度影响的位置，转换标量到矢量    \n   addPosition += u_Gravity * age * normalizedAge;//计算受重力影响的位置\n   \n   float radius=mix(a_Radius.x, a_Radius.y, normalizedAge); //计算粒子受半径和角度影响（无需计算角度和半径时，可用宏定义优化屏蔽此计算）\n   float radianHorizontal =mix(a_Radian.x,a_Radian.z,normalizedAge);\n   float radianVertical =mix(a_Radian.y,a_Radian.w,normalizedAge);\n   \n   float r =cos(radianVertical)* radius;\n   addPosition.y += sin(radianVertical) * radius;\n	\n   addPosition.x += cos(radianHorizontal) *r;\n   addPosition.z += sin(radianHorizontal) *r;\n  \n   #ifdef PARTICLE3D\n   position+=addPosition;\n    return  u_Projection*u_View*u_WorldMat*(vec4(position, 1.0));\n   #else\n   addPosition.y=-addPosition.y;//2D粒子位置更新需要取负，2D粒子坐标系Y轴正向朝上\n   position+=addPosition;\n    return  vec4(position,1.0);\n   #endif\n}\n\nfloat ComputeParticleSize(in float startSize,in float endSize, in float normalizedAge)\n{    \n    float size = mix(startSize, endSize, normalizedAge);\n    \n	#ifdef PARTICLE3D\n    //Project the size into screen coordinates.\n     return size * u_Projection[1][1];\n	#else\n	 return size;\n	#endif\n}\n\nmat2 ComputeParticleRotation(in float rot,in float age)\n{    \n    float rotation =rot * age;\n    //计算2x2旋转矩阵.\n    float c = cos(rotation);\n    float s = sin(rotation);\n    return mat2(c, -s, s, c);\n}\n\nvec4 ComputeParticleColor(in vec4 startColor,in vec4 endColor,in float normalizedAge)\n{\n	vec4 color=mix(startColor,endColor,normalizedAge);\n    //硬编码设置，使粒子淡入很快，淡出很慢,6.7的缩放因子把置归一在0到1之间，可以谷歌x*(1-x)*(1-x)*6.7的制图表\n    color.a *= normalizedAge * (1.0-normalizedAge) * (1.0-normalizedAge) * 6.7;\n   \n    return color;\n}\n\nvoid main()\n{\n   float age = u_CurrentTime - a_Time;\n   age *= 1.0 + a_AgeAddScale;\n   float normalizedAge = clamp(age / u_Duration,0.0,1.0);\n   gl_Position = ComputeParticlePosition(a_Position, a_Velocity, age, normalizedAge);//计算粒子位置\n   float pSize = ComputeParticleSize(a_SizeRotation.x,a_SizeRotation.y, normalizedAge);\n   mat2 rotation = ComputeParticleRotation(a_SizeRotation.z, age);\n	\n   #ifdef PARTICLE3D\n	gl_Position.xy += (rotation*a_CornerTextureCoordinate.xy) * pSize * u_ViewportScale;\n   #else\n    mat4 mat=u_mmat*mmat;\n    gl_Position=vec4((mat*gl_Position).xy,0.0,1.0);\n	gl_Position.xy += (rotation*a_CornerTextureCoordinate.xy) * pSize*vec2(mat[0][0],mat[1][1]);\n    gl_Position=vec4((gl_Position.x/size.x-0.5)*2.0,(0.5-gl_Position.y/size.y)*2.0,0.0,1.0);\n   #endif\n   \n   v_Color = ComputeParticleColor(a_StartColor,a_EndColor, normalizedAge);\n   v_TextureCoordinate =a_CornerTextureCoordinate.zw;\n}\n\n"; }, 'ps', function () { return this.ps = "#ifdef FSHIGHPRECISION\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nvarying vec4 v_Color;\nvarying vec2 v_TextureCoordinate;\nuniform sampler2D u_texture;\n\nvoid main()\n{	\n	gl_FragColor=texture2D(u_texture,v_TextureCoordinate)*v_Color;\n	gl_FragColor.xyz *= v_Color.w;\n}"; }
        ]);
        return ParticleShader;
    })(Shader);
})(window, document, Laya);
if (typeof define === 'function' && define.amd) {
    define('laya.core', ['require', "exports"], function (require, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        for (var i in Laya) {
            var o = Laya[i];
            o && o.__isclass && (exports[i] = o);
        }
    });
}
//------------------------------------------------------------------------------------------------------
//  GameCreator 库
//------------------------------------------------------------------------------------------------------
/**
 * 该文件在运行时附加，IDE-Stand不附加 
 * Created by 黑暗之神KDS on 2017/1/16.
 */
"use strict";
//------------------------------------------------------------------------------------------------------
// 插件用的继承关系（TS编译后的继承）
//------------------------------------------------------------------------------------------------------
// var __extends = (this && this.__extends) || function (d, b) {
//     for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
//     function __() { this.constructor = d; }
//     d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
// };
//------------------------------------------------------------------------------------------------------
// 初始化
//------------------------------------------------------------------------------------------------------
var os = {};
/**
 * 系统初始化
 * @param w 宽度
 * @param h 高度
 * @param isWebGL 是否使用WEBGL
 * @param is3D 是否启用3D模块
 */
os.init = function (w, h, isWebGL, is3D) {
    // 不输入或0的话表示全屏
    if (w == null || w == 0) w = window.innerWidth || document.body.clientWidth;
    if (h == null || h == 0) h = window.innerHeight || document.body.clientHeight;
    isWebGL = isWebGL == null ? true : isWebGL;
    is3D = is3D == null ? false : is3D;
    Browser.container = document.getElementById("layer1");
    if (is3D) {
        The33D.init(w, h, true);
    }
    else {
        isWebGL ? Laya.init(w, h, WebGL) : Laya.init(w, h);
    }
    window.stage = Laya.stage;
    window.loader = os.loader = Laya.loader;
    window.timer = Laya.timer;
    if (!isWebGL) Config.isAlpha = true;
    os.canvas = document.getElementById("gcCanvas");

    os.context = Laya.RunDriver.getWebGLContext(os.canvas);
    if (os.context) os.MAX_TEXTURE_SIZE = os.context.getParameter(os.context.MAX_TEXTURE_SIZE);

    // if (!is3D) {
    //     WorkerLoader.workerPath = "/kdsrpg/kdsrpg_core/libs/worker.js";
    //     WorkerLoader.enable = true;
    // }
    // alert(WorkerLoader)
    // 适配KS
    //for (var i in kdsrpg_staticVarInitFuncs) { kdsrpg_staticVarInitFuncs[i](); };
    //kdsrpg_staticVarInitFuncs = [];
};
// 音频默认关闭的
if (!!!window.navigator.userAgent.match(/\(i[^;]+;(U;)? CPU.+Mac OS X/)) {
    (function () {
        // window["mozAudioContext"] = top.window["mozAudioContext"];
        // window["AudioContext"] = top.window["AudioContext"];
        // window["webkitAudioContext"] = top.window["webkitAudioContext"];
        // window["_mozAudioContext"] = window["mozAudioContext"];
        // window["_AudioContext"] = window["AudioContext"];
        // window["_webkitAudioContext"] = window["webkitAudioContext"];
    })();
}

/**
 *
 * @returns Mac/Unix/Linux/Win2000/WinXP/Win2003/WinVista/Win7/Win10/Android/iPhone/other
 */
os.detectOS = function () {
    var sUserAgent = navigator.userAgent;
    if (sUserAgent.indexOf("Android") > -1 || sUserAgent.indexOf('Adr') > -1) return "Android";
    if (sUserAgent.indexOf("iPhone") != -1) return "iPhone";
    var isWin = (navigator.platform == "Win32") || (navigator.platform == "Windows");
    var isMac = (navigator.platform == "Mac68K") || (navigator.platform == "MacPPC") || (navigator.platform == "Macintosh") || (navigator.platform == "MacIntel");
    if (isMac) return "Mac";
    var isUnix = (navigator.platform == "X11") && !isWin && !isMac;
    if (isUnix) return "Unix";
    var isLinux = (String(navigator.platform).indexOf("Linux") > -1);
    if (isLinux) return "Linux";
    if (isWin) {
        var isWin2K = sUserAgent.indexOf("Windows NT 5.0") > -1 || sUserAgent.indexOf("Windows 2000") > -1;
        if (isWin2K) return "Win2000";
        var isWinXP = sUserAgent.indexOf("Windows NT 5.1") > -1 || sUserAgent.indexOf("Windows XP") > -1;
        if (isWinXP) return "WinXP";
        var isWin2003 = sUserAgent.indexOf("Windows NT 5.2") > -1 || sUserAgent.indexOf("Windows 2003") > -1;
        if (isWin2003) return "Win2003";
        var isWinVista = sUserAgent.indexOf("Windows NT 6.0") > -1 || sUserAgent.indexOf("Windows Vista") > -1;
        if (isWinVista) return "WinVista";
        var isWin7 = sUserAgent.indexOf("Windows NT 6.1") > -1 || sUserAgent.indexOf("Windows 7") > -1;
        if (isWin7) return "Win7";
        var isWIn10 = sUserAgent.indexOf("Windows NT 10.0") > -1 || sUserAgent.indexOf("Windows 10") > -1;
        if (isWIn10) return "Win10";
    }
    return "other";
};

if (typeof gcTop != "undefined" && typeof gcTop.require != "undefined") {
    os._gui = gcTop.require('nw.gui');
    os._win = os._gui.Window.get();
}

if (typeof gcTop.require != "undefined" && (window.location.href.indexOf("chrome") == 0 || window.location.href.indexOf("file") == 0)) {
    os.platform = 2;
}
else if (window.location.href.indexOf("gamecreator.com.cn") != -1 || window.location.href.indexOf("amazonaws.com/kreator.io") != -1) {
    os.platform = 0;
}
else if (os.detectOS() == "Android" && typeof cordova !== 'undefined') {
    os.platform = 4;
    os._insomnia = true;
    if (window.plugins && window.plugins.insomnia) window.plugins.insomnia.keepAwake();
    if (typeof AndroidFullScreen != "undefined") {
        AndroidFullScreen.immersiveMode();
        os._androidFullScreen = true;
    }
    //监听app后台事件
    document.addEventListener("pause", function () {
        GameAudio.pause();
    }, false);
    document.addEventListener("resume", function () {
        GameAudio.resume();
    }, false);
}
else {
    os.platform = 3;
}
/**
 * 设备震动（目前仅支持安卓设备）
 * @param time (number | number[]) number类型表示震动持续时间 number[]类型表示自定义交替的震动、暂停、震动
 */
os.shake = function (time) {
    if (os.platform != 4) return;
    if (!navigator.vibrate) {
        console.log("该手机不支持调用震动API");
        return;
    }
    navigator.vibrate(time);
}
/**
 * 设备横屏显示
 */
Object.defineProperty(os, "horizontalScreen", {
    get: function () {
        if (os.platform == 4 && window.screen && window.screen.orientation) return window.screen.orientation.type.startsWith('landscape');
        else return stage.screenMode == "horizontal";
    }, set: function (v) {
        if (v) {
            if (os.platform == 4 && window.screen && window.screen.orientation) window.screen.orientation.lock('landscape');
            else stage.screenMode = "horizontal";
        } else {
            if (os.platform == 4 && window.screen && window.screen.orientation) window.screen.orientation.lock('portrait');
            else stage.screenMode = "vertical";
        }
    }
});
Object.defineProperty(Laya.Stage.prototype, 'screenMode', {
    get: function () {
        if (os.platform == 4 && window.screen && window.screen.orientation) {
            if (window.screen.orientation.type.startsWith('landscape')) {
                return "horizontal";
            } else {
                return "vertical";
            }
        }
        else return this._screenMode;
    },
    set: function (v) {
        if (os.platform == 4 && window.screen && window.screen.orientation) {
            this._screenMode = "none";
            if (v == "horizontal") os.horizontalScreen = true;
            else os.horizontalScreen = false;
        } else {
            this._screenMode = v;
        }
    }
});

/**
 * 设备允许常亮（目前仅支持安卓设备）
 */
Object.defineProperty(os, "insomnia", {
    get: function () {
        return os._insomnia;
    }, set: function (v) {
        if (os.platform != 4) return;
        if (v) {
            os._insomnia = true;
            if (window.plugins && window.plugins.insomnia) window.plugins.insomnia.keepAwake();
        } else {
            os._insomnia = false;
            if (window.plugins && window.plugins.insomnia) window.plugins.insomnia.allowSleepAgain();
        }
    }
});

Object.defineProperty(os, "fullscreen", {
    get: function () {
        return os._androidFullScreen;
    }, set: function (v) {
        if (v) {
            if (os.platform == 4 && typeof AndroidFullScreen != "undefined") {
                AndroidFullScreen.immersiveMode();
                os._androidFullScreen = true;
            }
            else if (os.platform != 4 && os._win) {
                os._win.enterFullscreen();
                os._androidFullScreen = true;
            }
        }
        else {
            if (os.platform == 4 && typeof AndroidFullScreen != "undefined") {
                AndroidFullScreen.showSystemUI();
                os._androidFullScreen = false;
            }
            else if (os.platform != 4 && os._win) {
                os._win.leaveFullscreen();
                os._androidFullScreen = false;
            }
        }
    }
});
osWinFuncs = ["resizeTo", "moveTo", "setResizable", "setAlwaysOnTop", "restore", "minimize"];
for (var i in osWinFuncs) {
    var osWinFuncName = osWinFuncs[i];
    eval(`os["${osWinFuncName}"]=function(){if(!os._win)return;os._win["${osWinFuncName}"].apply(os._win,arguments);};`);
}
os.maximize = function () {
    if (os.platform == 4 && window.plugins && window.plugins.appMinimize) {
        window.plugins.appMinimize.minimize(function () { });
        return;
    }
    if (!os._win) return;
    os._win.maximize.apply(os._win, arguments);
}
os.closeWindow = function () {
    if (os.platform == 4 && navigator.app) {
        navigator.app.exitApp();
        return;
    }
    if (window.location.href.indexOf("gcDebugPort=") != -1) { gcTop.nw.Window.get().close(); }//修复nwjs-sdk-v0.64.1-win-x64版本关闭窗口
    if (gcTop != window && typeof gcTop.require != "undefined" && typeof top_kdsrpg != "undefined") { gcParent.close(); }
    else if (gcTop == window || (typeof process == "undefined" && typeof require == "undefined")) { window.close(); }
}
os.inGC = function (independentWindow) {
    if (independentWindow == null) independentWindow = true;
    var inGC = (gcTop != window && typeof gcTop.require != "undefined" && typeof top_kdsrpg != "undefined");
    return inGC || (independentWindow && typeof Config != "undefined" && !Config.EDIT_MODE && window.location.href.indexOf("gcDebugPort=") != -1);
}
os.showFPS = function () {
    Stat.show();
}
os.hideFPS = function () {
    Stat.hide();
}
os.resourceEncryption = false;
os.archiveEncryption = false;
//------------------------------------------------------------------------------------------------------
// 鼠标样式设定
//------------------------------------------------------------------------------------------------------
os._recordCursor = "default";
os.setCursor = function (style) { if (document.body.style.cursor == style) { return }; os._recordCursor = document.body.style.cursor; document.body.style.cursor = style; };
os.restoreCursor = function () { document.body.style.cursor = os._recordCursor; };
// enterframe 对同一个对象注册多次，在移除的时候会按照注册的顺序移除，同样要移除多次才能移除
window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (c) { return window.setTimeout(c, 1000 / 60); };
//默认帧率
os.fps = 60;
//记录ENTERFRAME侦听
os._enterframeMap = [];
os.add_ENTERFRAME = function (onHappen, thisPtr, args) {
    os._enterframeMap.push({ onHappen: onHappen, thisPtr: thisPtr, args: args });
};
os.remove_ENTERFRAME = function (onHappen, thisPtr) {
    for (var i = os._enterframeMap.length - 1; i >= 0; i--) {
        if (os._enterframeMap[i].onHappen == onHappen && os._enterframeMap[i].thisPtr == thisPtr)
            os._enterframeMap.splice(i, 1);
    }
};
// 记录初始时间
var then = Date.now();
var _loop;
os.callEnterFrame = null;
os.enterFrameCount = 0;
window.requestAnimationFrame(_loop = function () {
    os.enterFrameCount++;
    var now = Date.now();
    if (Math.round(now * os.fps * 0.001) > Math.round(then * os.fps * 0.001)) {
        for (var i = 0; i < os._enterframeMap.length; i++) {
            var enterFrame = os._enterframeMap[i];
            enterFrame.onHappen.apply(enterFrame.thisPtr, enterFrame.args);
        }
        then = now;
        os.callEnterFrame = os.enterFrameCount;
    }
    window.requestAnimationFrame(_loop); // next frame 执行本函数
});

Object.defineProperty(os, 'defaultFamily', {
    get: function () {
        return Font.defaultFamily;
    },
    set: function (v) {
        Font.defaultFamily = v;
    }
});
//------------------------------------------------------------------------------------------------------
// top namespace
//------------------------------------------------------------------------------------------------------
for (var p in Laya) {
    if (typeof window[p] == "undefined") {
        var t = Laya[p];
        if (p == "Buffer") continue;
        window[p] = t;
        if (t && t.prototype && t.prototype.destroy != null && t.prototype.dispose == null) t.prototype.dispose = t.prototype.destroy;
    }
}
window.TextField = Laya.Text;
window.URLInfo = Laya.URL;
window.EngineConfig = Laya.Config;
window.EventObject = Laya.Event;
window.TreeNode = Laya.Node;
window.UIImage = Laya.Image;
window.LayaAnimation = Laya.Animation;
window.UIEventObject = Laya.UIEvent;
window.DevGeolocation = Laya.Geolocation;
window.DivElement = Laya.HTMLDivElement;
window.Keyboard = Laya.Keyboard;
//------------------------------------------------------------------------------------------------------
// class Extends
//------------------------------------------------------------------------------------------------------
// event extends
function eventExtends(evArr, clsObj) {
    if (clsObj == null) return;
    function toUpFuncName(funcName) {
        var regx = new RegExp("[A-Z]", "g");
        var m = funcName.match(regx);
        for (var i in m)
            funcName = funcName.replace(m[i], "_" + m[i])
        return funcName.toUpperCase();;
    }
    function evPush(extStr, evUpStr, evAPI, evType) {
        clsObj.prototype[extStr + evUpStr] = function (a, b, c) {
            this[evAPI](evType, b, a, c);
        }
    }
    function evHas(evType, evUpStr) {
        clsObj.prototype["has_" + evUpStr] = function () {
            return this.hasListener(evType);
        };
    }
    function evHappen(evType, evUpStr) {
        clsObj.prototype["happen_" + evUpStr] = function (data) {
            this.event(evType, data);
        };
    }
    for (var s in evArr) {
        var evType = evArr[s];
        var evUpStr = toUpFuncName(evType);
        evPush("add_", evUpStr, "on", evType);
        evPush("remove_", evUpStr, "off", evType);
        evPush("addOnce_", evUpStr, "once", evType);
        evHas(evType, evUpStr);
        evHappen(evType, evUpStr);
    }
    clsObj.prototype.removeAllListen = function () {
        this.offAll();
    }
}
var node_events = ["added", "display", "removed", "undisplay"];
eventExtends(node_events, TreeNode);
var sprite_events = ["click", "dragend", "dragmove", "dragstart", "mousedown", "mousedown", "mousemove", "mouseout", "mouseover", "mouseup", "mousewheel", "doubleclick", "rightclick", "rightmousedown", "rightmouseup", "enterframe"];
eventExtends(sprite_events, Sprite);
var stage_events = ["blur", "focus", "focuschange", "fullscreenchange", "resize", "visibilitychange", "keydown", "keypress", "keyup"];
eventExtends(stage_events, Stage);
var httpRequest_event = ["complete", "error", "progress"];
eventExtends(httpRequest_event, HttpRequest);
var Socket_event = ["close", "error", "message", "open"];
eventExtends(Socket_event, Socket);
var Animation_event = ["complete", "label"];
eventExtends(Animation_event, Animation);
var FrameAnimation_event = ["complete"];
eventExtends(FrameAnimation_event, FrameAnimation);
// 由于the3Box的双击存在BUG，暂时还未修复，先使用这个拿去用下
Sprite.prototype.add_DOUBLECLICK = function (onHappen, thisPtr, args) {
    var clickTimes = 0;
    var lastMouseX = null, lastMouseY = null;
    this.__dbclickObj = null;
    var timeF = [];
    var _onClick = function (e) {
        var dPx = Browser.onMobile ? 100 : 5;
        if (lastMouseX != null && (Math.abs(e.stageX - lastMouseX) > dPx || Math.abs(e.stageY - lastMouseY) > dPx)) {
            clickTimes = 0;
            for (var i in timeF) {
                clearTimeout(timeF[i]);
            }
            timeF.length = 0;
        }
        lastMouseX = e.stageX;
        lastMouseY = e.stageY;
        clickTimes++;
        var f = setTimeout(function () {
            clickTimes--;
            timeF.shift();
        }, 250);
        timeF.push(f);
        if (clickTimes == 2) {
            clickTimes = 0;
            for (var i in timeF) {
                clearTimeout(timeF[i]);
            }
            timeF.length = 0;
            e.type = "doubleclick";
            var params = args ? args.concat(e) : [e];
            onHappen.apply(thisPtr, params);
        }
    };
    if (this.__doubleClickFuncs == null) this.__doubleClickFuncs = {};
    this.__doubleClickFuncs[onHappen] = _onClick;
    this.add_CLICK(_onClick);
};
Sprite.prototype.remove_DOUBLECLICK = function (onHappen, thisPtr) {
    if (this.__doubleClickFuncs) {
        var _onClick = this.__doubleClickFuncs[onHappen];
        if (!_onClick) return;
        delete this.__doubleClickFuncs[onHappen];
        this.remove_CLICK(_onClick);
    }
};
var oldSpriteOn = Sprite.prototype.on;
Sprite.prototype.on = function (type, caller, listener, args) {
    if (type == "doubleclick") {
        this.add_DOUBLECLICK(listener, caller, args);
        return;
    }
    return oldSpriteOn.apply(this, arguments);
}
var oldSpriteOff = Sprite.prototype.off;
Sprite.prototype.off = function (type, caller, listener, onceOnly) {
    if (type == "doubleclick") {
        this.remove_DOUBLECLICK(listener, caller);
        return;
    }
    return oldSpriteOff.apply(this, arguments);
}
var ___mouseEvent = [EventObject.RIGHT_MOUSE_DOWN, EventObject.RIGHT_MOUSE_UP, EventObject.RIGHT_CLICK,
EventObject.MOUSE_WHEEL, EventObject.MOUSE_DOWN, EventObject.MOUSE_UP, EventObject.CLICK,
EventObject.DOUBLE_CLICK, EventObject.ROLL_OVER, EventObject.ROLL_OUT, EventObject.MOUSE_OVER,
EventObject.MOUSE_OUT, EventObject.MOUSE_MOVE];
var ___mouseEventStr = JSON.stringify(___mouseEvent);
getset(0, Sprite.prototype, 'hasMouseEvent', function () {
    for (var i in ___mouseEvent) {
        if (this.hasListener(___mouseEvent[i])) {
            return true;
        }
    }
    return false;
});

var component_events = ["resize"];
eventExtends(component_events, Component);
var label_events = ["change"];
eventExtends(label_events, Label);
var textInput_events = ["enter", "input", "blur", "focus"];
eventExtends(textInput_events, TextInput);
var UIGroup_events = ["change"];
eventExtends(UIGroup_events, UIGroup);
var clip_events = ["change", "loaded"];
var scroll_events = ["change", "end", "start"]
eventExtends(clip_events, Clip);
eventExtends(label_events, Button);
eventExtends(UIGroup_events, ComboBox);
eventExtends(scroll_events, ScrollBar);
eventExtends(UIGroup_events, List);
// 获取选中的列表以及设置为选中
getset(0, List.prototype, 'selectedItemList', function () {
    var arr = [];
    for (var i in this.array) {
        var item = this.array[i];
        if (item.selected) arr.push(item);
    }
    return arr;
}, function (arr) {
    for (var i in arr) {
        var item = arr[i];
        if (this.array.indexOf(item) != -1) item.selected = true;
    }
});
// 获取未选中的的列表以及设置为未选中
getset(0, List.prototype, 'unSelectedItemList', function () {
    var arr = [];
    for (var i in this.array) {
        var item = this.array[i];
        if (!item.selected) arr.push(item);
    }
    return arr;
}, function (arr) {
    for (var i in arr) {
        var item = arr[i];
        if (this.array.indexOf(item) != -1) item.selected = false;
    }
});
// Handler
Handler.prototype.delayRun = function (delay) {
    return setTimeout(function (handler) {
        handler.run();
    }, delay, this);
};
Handler.prototype.delayRunConver = function (delay) {
    if (this.delayRunSign) {
        clearTimeout(this.delayRunSign);
    }
    this.delayRunSign = this.delayRun(delay);
};
// utils Browser
getset(0, Browser, 'onMac', function () {
    return os.detectOS() == "Mac";
});
// Point
Point.interpolate = function (to, from, per) {
    var p = new Point();
    p.x = (to.x - from.x) * per + from.x;
    p.y = (to.y - from.y) * per + from.y;
    return p;
}
Point.distance = function (from, to) {
    return from.distance(to.x, to.y);
}
// 
Keyboard.keyNames = [];
for (var i in Keyboard) {
    var v = Keyboard[i];
    if (!isNaN(v)) {
        Keyboard.keyNames[v] = i;
    }
}
Keyboard.getKeyName = function (keyCode) {
    return Keyboard.keyNames[keyCode];
}
//------------------------------------------------------------------------------------------------------
// 追加的事件类型
//------------------------------------------------------------------------------------------------------
UIEventObject.DATA_CHANGE = "DATA_CHANGE";














var ListItemData = (function (_super) {
    __extends(ListItemData, _super);
    function ListItemData() {
        var _this_1 = _super.call(this) || this;
        _this_1._selected = false;
        _this_1._group = null;
        _this_1._label = "";
        return _this_1;
    }
    Object.defineProperty(ListItemData.prototype, "selected", {
        get: function () { return this._selected; },
        set: function (v) {
            if (v != this._selected) {
                this._selected = v;
                this.happen_SELECTE_CHANGED();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ListItemData.prototype, "label", {
        get: function () { return this._label; },
        set: function (v) { this._label = v; },
        enumerable: false,
        configurable: true
    });
    ListItemData.prototype.add_SELECTE_CHANGED = function (onHappen, thisPtr, args) {
        if (args === void 0) { args = null; }
        this.on("SELECTE_CHANGED", thisPtr, onHappen, args);
    };
    ListItemData.prototype.remove_SELECTE_CHANGED = function (onHappen, thisPtr) {
        this.off("SELECTE_CHANGED", thisPtr, onHappen);
    };
    ListItemData.prototype.happen_SELECTE_CHANGED = function (data) {
        if (data === void 0) { data = null; }
        this.event("SELECTE_CHANGED", data);
    };
    ListItemData.prototype.has_SELECTE_CHANGED = function () {
        return this.hasListener("SELECTE_CHANGED");
    };
    return ListItemData;
}(EventDispatcher));















var TreeItemData = (function (_super) {
    __extends(TreeItemData, _super);
    function TreeItemData() {
        var _this_1 = _super.call(this) || this;
        _this_1._visible = false;
        _this_1._isOpen = true;
        _this_1.isDirectory = false;
        _this_1._children = [];
        _this_1._parent = null;
        _this_1._visible = true;
        return _this_1;
    }
    Object.defineProperty(TreeItemData.prototype, "isOpen", {
        get: function () { return this._isOpen; },
        set: function (v) { this._isOpen = v; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TreeItemData.prototype, "visible", {
        get: function () { return this._visible; },
        set: function (v) { this._visible = v; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TreeItemData.prototype, "parent", {
        get: function () { return this._parent; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TreeItemData.prototype, "nodeParent", {
        get: function () { return this._parent; },
        enumerable: false,
        configurable: true
    });
    TreeItemData.prototype.addChild = function (item) { this._children.push(item); item._parent = this; };
    TreeItemData.prototype.addChildAt = function (item, index) { this._children.splice(index, 0, item); item._parent = this; };
    TreeItemData.prototype.removeChild = function (item) { this._children.splice(this._children.indexOf(item), 1); item._parent = null; };
    TreeItemData.prototype.removeChildAt = function (index) { var item = this._children.splice(index, 1)[0]; item._parent = null; };
    TreeItemData.prototype.removeAll = function () { for (var i in this._children) {
        this._children[i]._parent = null;
    } ; this._children.length = 0; };
    TreeItemData.prototype.getChildAt = function (index) { return this._children[index]; };
    TreeItemData.prototype.getChildIndex = function (item) { return this._children.indexOf(item); };
    TreeItemData.prototype.getChildByName = function (name) { for (var i in this._children) {
        if (this._children[i].label == name)
            return this._children[i];
    } ; return null; };
    Object.defineProperty(TreeItemData.prototype, "numChildren", {
        get: function () { return this._children.length; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TreeItemData.prototype, "children", {
        get: function () { return this._children; },
        enumerable: false,
        configurable: true
    });
    TreeItemData.prototype.getAllChildren = function (data, arr) {
        if (data === void 0) { data = this._children; }
        if (arr === void 0) { arr = []; }
        for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
            var item = data_1[_i];
            arr.push(item);
            if (item._children && item._children.length)
                this.getAllChildren(item.children, arr);
        }
        return arr;
    };
    TreeItemData.prototype.isInherit = function (data) {
        var p = this.parent;
        while (p) {
            if (p == data)
                return true;
            p = p._parent;
        }
        return false;
    };
    TreeItemData.prototype.getList = function (arr, deleteParent) {
        if (deleteParent === void 0) { deleteParent = false; }
        if (!deleteParent)
            arr.push(this);
        var len = this.numChildren;
        for (var i = 0; i < len; i++) {
            this.getChildAt(i).getList(arr);
        }
    };
    Object.defineProperty(TreeItemData.prototype, "root", {
        get: function () {
            var p = this;
            while (true) {
                if (p._parent) {
                    p = p._parent;
                }
                else {
                    break;
                }
            }
            return p;
        },
        enumerable: false,
        configurable: true
    });
    TreeItemData.removeExistChild = function (list) {
        for (var i = list.length - 1; i >= 0; i--) {
            for (var s in list) {
                if (list[i].isInherit(list[s])) {
                    list.splice(i, 1);
                    break;
                }
            }
        }
    };
    TreeItemData.searchByKeyResult = function (node, key, firstCheck) {
        if (firstCheck === void 0) { firstCheck = true; }
        if (firstCheck) {
            key = key.toLocaleLowerCase();
        }
        node.keyState = null;
        if (node.label && node.label.toLocaleLowerCase().indexOf(key) != -1) {
            node.keyState = 1;
        }
        if (node.children.length > 0) {
            for (var i_1 = 0; i_1 < node.children.length; i_1++) {
                var childNode = node.children[i_1];
                TreeItemData.searchByKeyResult(childNode, key, false);
            }
        }
        else {
            var p = node;
            var startRetain = false;
            while (1) {
                var parentNode = p.parent;
                startRetain = setNodeState(p, startRetain);
                if (!parentNode)
                    break;
                p = parentNode;
            }
        }
        if (firstCheck) {
            var listArr = [];
            node.getList(listArr);
            for (var i_2 = 0; i_2 < listArr.length; i_2++) {
                var targetNode = listArr[i_2];
                if (targetNode.keyState == null) {
                    listArr.splice(i_2, 1);
                    i_2--;
                }
            }
            for (var i_3 = 0; i_3 < listArr.length; i_3++) {
                var targetNode = listArr[i_3];
                if (targetNode.numChildren > 0)
                    targetNode.isOpen = true;
            }
            return listArr;
        }
        function setNodeState(p, startRetain) {
            if (p.keyState == 1) {
                startRetain = true;
            }
            else if (startRetain && p.keyState != 1) {
                p.keyState = 0;
            }
            return startRetain;
        }
    };
    return TreeItemData;
}(ListItemData));
(function () {
    var blendFunType = [0x0, 0x1, 0x0300, 0x0301, 0x0306, 0x0307, 0x0302, 0x0303, 0x0304, 0x0305, 0x8001, 0x8002, 0x8003, 0x8004, 0x0308];
    var start = 8;
    var BlendModeCls = eval("BlendMode");
    var fns = [];
    var targetFns = [];
    for (var x in blendFunType) {
        for (var y in blendFunType) {
            BlendModeCls.TOINT["blend" + x + "-" + y] = start++;
            var blendF = fnsFunc(x, y);
            fns.push(blendF);
            targetFns.push(blendF);
        }
    }
    var oldBlendInit = BlendModeCls._init_;
    BlendModeCls._init_ = function (gl) {
        oldBlendInit.call(BlendModeCls, gl);
        BlendModeCls.fns = BlendModeCls.fns.concat(fns);
        BlendModeCls.targetFns = BlendModeCls.targetFns.concat(targetFns);
    };
    function fnsFunc(x, y) {
        var f = function (gl) {
            gl.blendFunc(blendFunType[x], blendFunType[y]);
        };
        return f;
    }
})();















var HueFilter = (function (_super) {
    __extends(HueFilter, _super);
    function HueFilter(hue) {
        if (hue === void 0) { hue = 0; }
        var _this_1 = this;
        if (hue < -180)
            hue = -180;
        if (hue > 180)
            hue = 180;
        var colorArr, toColor;
        if (hue == 0) {
            colorArr = HueFilter.normal;
        }
        else {
            colorArr = [];
            var fromColor;
            var per;
            if (hue < 0 && hue >= -60) {
                fromColor = HueFilter.normal;
                toColor = HueFilter.redblue;
                per = hue / -60;
            }
            else if (hue < -60 && hue >= -120) {
                fromColor = HueFilter.redblue;
                toColor = HueFilter.blue;
                per = (hue + 60) / -60;
            }
            else if (hue < -120) {
                fromColor = HueFilter.blue;
                toColor = HueFilter.bluegreen;
                per = (hue + 120) / -60;
            }
            else if (hue > 0 && hue <= 60) {
                fromColor = HueFilter.normal;
                toColor = HueFilter.redgreen;
                per = hue / 60;
            }
            else if (hue > 60 && hue <= 120) {
                fromColor = HueFilter.redgreen;
                toColor = HueFilter.green;
                per = (hue - 60) / 60;
            }
            else {
                fromColor = HueFilter.green;
                toColor = HueFilter.bluegreen;
                per = (hue - 120) / 60;
            }
            for (var s = 0; s < fromColor.length; s++) {
                colorArr[s] = (toColor[s] - fromColor[s]) * per + fromColor[s];
            }
        }
        _this_1 = _super.call(this, colorArr) || this;
        _this_1.colorMat = colorArr;
        return _this_1;
    }
    HueFilter.normal = [
        1, 0, 0, 0, 0,
        0, 1, 0, 0, 0,
        0, 0, 1, 0, 0,
        0, 0, 0, 1, 0
    ];
    HueFilter.redblue = [
        1, 0, 0, 0, 0,
        0, 1, 0, 0, 0,
        1, 0, 0, 0, 0,
        0, 0, 0, 1, 0
    ];
    HueFilter.blue = [
        0, 1, 0, 0, 0,
        0, 1, 0, 0, 0,
        1, 0, 0, 0, 0,
        0, 0, 0, 1, 0
    ];
    HueFilter.bluegreen = [
        0, 1, 0, 0, 0,
        1, 0, 0, 0, 0,
        1, 0, 0, 0, 0,
        0, 0, 0, 1, 0
    ];
    HueFilter.redgreen = [
        1, 0, 0, 0, 0,
        1, 0, 0, 0, 0,
        0, 1, 0, 0, 0,
        0, 0, 0, 1, 0
    ];
    HueFilter.green = [
        0, 1, 0, 0, 0,
        1, 0, 0, 0, 0,
        0, 1, 0, 0, 0,
        0, 0, 0, 1, 0
    ];
    return HueFilter;
}(ColorFilter));















var ListRender = (function (_super) {
    __extends(ListRender, _super);
    function ListRender() {
        var _this_1 = _super.call(this) || this;
        new Handler(_this_1, _this_1._init).delayRun(0);
        return _this_1;
    }
    ListRender.prototype._init = function () {
        this.initEvent();
        this.updateAppearance();
    };
    Object.defineProperty(ListRender.prototype, "mainComp", {
        get: function () {
            if (this._mainComp)
                return this._mainComp;
            if (this.parent == null) {
                return null;
            }
            this._mainComp = this.parent.parent;
            return this._mainComp;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ListRender.prototype, "dataList", {
        get: function () {
            return this.mainComp.array;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ListRender.prototype, "lastSelected", {
        get: function () {
            return this.mainComp ? this.mainComp.selectedItem : null;
        },
        set: function (v) {
            if (this.mainComp) {
                this.mainComp.selectedItem = v;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ListRender.prototype, "dataSource", {
        get: function () {
            return this.data;
        },
        set: function (v) {
            var needUpdate = false;
            if (this.data != v) {
                if (this.data) {
                    this.data.remove_SELECTE_CHANGED(this._onDataSelectChange, this);
                }
                this.data = v;
                if (this.data) {
                    this.data.add_SELECTE_CHANGED(this._onDataSelectChange, this);
                    this._onDataSelectChange();
                }
                this.happen_DATACHANGE();
                needUpdate = true;
            }
            else if (v && this.lastLabel != v.label) {
                needUpdate = true;
            }
            this.lastLabel = v ? v.label : null;
            if (needUpdate) {
                this.updateAppearance();
            }
        },
        enumerable: false,
        configurable: true
    });
    ListRender.prototype.addChild = function (node) {
        this[node.name] = node;
        if (node.name == "overImg" || node.name == "selectImg") {
            node.visible = false;
        }
        return _super.prototype.addChild.call(this, node);
    };
    ListRender.prototype.initEvent = function () {
        this.add_MOUSEOVER(this._onMouseOver, this);
        this.add_MOUSEOUT(this._onMouseOut, this);
        this.add_CLICK(this._onMouseDown, this);
        this.add_RIGHTMOUSEDOWN(this._onMouseDown, this);
        this.add_DOUBLECLICK(this._onDBClick, this);
    };
    ListRender.prototype._onMouseOver = function () {
        if (this.mainComp["__overImg"])
            this.mainComp["__overImg"].visible = false;
        this.overImg.visible = true;
        this.mainComp["__overImg"] = this.overImg;
    };
    ListRender.prototype._onMouseOut = function () {
        this.overImg.visible = false;
    };
    ListRender.prototype._onMouseDown = function (e) {
        if (this.data == null)
            return;
        var mainComp = this.mainComp;
        if (mainComp.disabled)
            return;
        var dataList = this.dataList;
        if (e.type == "rightmousedown" && this.data.selected) {
            return;
        }
        if (mainComp.supportMultiSelect) {
            this.isMultiSelect = e.ctrlKey || e.shiftKey || mainComp.supportMultiSelectSimulationCtrk;
            if (e.shiftKey) {
                if (this.lastSelected) {
                    var lastSelected = this.lastSelected;
                    var listLen = dataList.length;
                    var lastItemIdx = dataList.indexOf(lastSelected);
                    var thisItemIdx = dataList.indexOf(this.data);
                    if (lastItemIdx != -1 && thisItemIdx != -1) {
                        var formIdx, toIdx;
                        if (lastItemIdx > thisItemIdx) {
                            formIdx = thisItemIdx;
                            toIdx = lastItemIdx;
                        }
                        else {
                            formIdx = lastItemIdx;
                            toIdx = thisItemIdx;
                        }
                        for (var i = formIdx; i <= toIdx; i++) {
                            dataList[i].selected = true;
                        }
                        for (var i = 0; i < formIdx; i++) {
                            dataList[i].selected = false;
                        }
                        for (var i = toIdx + 1; i < listLen; i++) {
                            dataList[i].selected = false;
                        }
                        this.lastSelected = lastSelected;
                        return;
                    }
                }
            }
        }
        var toSelected = !this.data.selected;
        if (mainComp.mustSelectOne && !toSelected) {
            var selectCount = 0;
            var dataListLen = dataList.length;
            for (var i = 0; i < dataListLen; i++) {
                if (dataList[i].selected)
                    selectCount++;
                if (selectCount > 1)
                    break;
            }
            if (selectCount == 1) {
                return;
            }
        }
        if (!this.isMultiSelect) {
            var isCancelElse = false;
            for (var i = 0; i < this.dataList.length; i++) {
                var elseData = this.dataList[i];
                if (elseData != this.data && elseData.selected) {
                    elseData.selected = false;
                    isCancelElse = true;
                }
            }
            this.data.selected = !isCancelElse ? toSelected : true;
        }
        else {
            this.data.selected = toSelected;
        }
        if (this.data.selected)
            this.lastSelected = this.data;
    };
    ListRender.prototype._onDBClick = function (e) {
        this.mainComp.event("itemDoubleClick", this.data);
    };
    ListRender.prototype._onDataSelectChange = function (e) {
        if (e === void 0) { e = null; }
        this.updateAppearance_selected();
        if (this.data.selected) {
            this.lastSelected = this.data;
        }
    };
    ListRender.prototype.updateAppearance_selected = function () {
        if (this.data == null) {
            return;
        }
        this.selectImg.visible = this.data.selected;
        if (this["labelStyle"] && this["labelStyle"].labelColors) {
            var cArr = this["labelStyle"].labelColors.split(",");
            if (this.label)
                this.label.color = this.data.selected ? cArr[0] : cArr[1];
        }
        else {
            if (this.label)
                this.label.color = this.data.selected ? "#ffffff" : "#b8b8b8";
        }
    };
    ListRender.prototype.updateAppearance = function () {
        if (this.data == null)
            return;
        if (this.label) {
            this.label.text = this.data.label;
            this.label.textField.lines;
        }
        this.updateAppearance_selected();
        if (this.data.renderFunc) {
            this.data.renderFunc.apply(this);
        }
    };
    ListRender.prototype.add_DATACHANGE = function (onHappen, thisPtr, args) {
        if (args === void 0) { args = null; }
        this.on(UIEventObject.DATA_CHANGE, thisPtr, onHappen, args);
    };
    ;
    ListRender.prototype.remove_DATACHANGE = function (onHappen, thisPtr) {
        this.off(UIEventObject.DATA_CHANGE, thisPtr, onHappen);
    };
    ;
    ListRender.prototype.happen_DATACHANGE = function (data) {
        if (data === void 0) { data = null; }
        this.event(UIEventObject.DATA_CHANGE, data);
    };
    ;
    ListRender.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        if (this.data && this.data.has_SELECTE_CHANGED()) {
            this.data.remove_SELECTE_CHANGED(this._onDataSelectChange, this);
        }
    };
    return ListRender;
}(Box));
var ComputeTS = (function () {
    function ComputeTS() {
    }
    ComputeTS.init = function (onFin) {
        if (onFin === void 0) { onFin = null; }
        var tsUR = new HttpRequest();
        tsUR.send("http://www.kdsrpg.com/include/getTsTok.php?pid=" + ComputeTS.projectID, "", "post");
        tsUR.add_COMPLETE(function (str) {
            if (str != "error") {
                ComputeTS.kdsrpgTSToken = JSON.parse(str).access_token;
                onFin && onFin(true);
            }
            else {
                onFin && onFin(false);
            }
        }, this);
        tsUR.add_ERROR(function () {
            onFin && onFin(false);
        }, this);
    };
    ComputeTS.play = function (content, per, speed, pit, vol) {
        if (per === void 0) { per = 0; }
        if (speed === void 0) { speed = 7; }
        if (pit === void 0) { pit = 5; }
        if (vol === void 0) { vol = 8; }
        if (!ComputeTS.kdsrpgTSToken)
            return;
        var lan = "zh";
        var ctp = "1";
        var body = "tex=" + content + "&lan=" + lan + "&tok=" + ComputeTS.kdsrpgTSToken + "&ctp=" + ctp + "&cuid=" + ComputeTS.projectID + "&spd=" + speed + "&pit=" + pit + "&vol=" + vol + "&per=" + per;
        var soundURL = "http://tsn.baidu.com/text2audio?" + body;
        SoundManager.playSound(soundURL);
        return soundURL;
    };
    ComputeTS.projectID = 1;
    return ComputeTS;
}());
var globalThis = this;
HttpRequest["requestServer"] = function (_b, succeed, failed) {
    var url = _b.url, _c = _b.data, data = _c === void 0 ? null : _c, method = _b.method, responseType = _b.responseType, _d = _b.gcToken, gcToken = _d === void 0 ? null : _d;
    var urAct = new HttpRequest();
    if (responseType == "json") {
        if (data)
            data = JSON.stringify(data);
    }
    else if (responseType == "text") {
        if (gcToken && data)
            data = JSON.stringify(data);
    }
    urAct.send(url, data, method, responseType, gcToken ? ["token", gcToken, "Content-Type", "application/json"] : (responseType == "json" ? ["Content-Type", "application/json"] : null));
    if (succeed) {
        urAct.on('complete', null, succeed);
    }
    if (failed) {
        urAct.on('error', null, failed);
    }
};
Sprite.prototype["getGlobalBounds"] = function () {
    var min = this.localToGlobal(new Point(0, 0));
    var max = this.localToGlobal(new Point(this.width, this.height));
    var resultRect = new Rectangle();
    resultRect.x = min.x;
    resultRect.y = min.y;
    resultRect.width = max.x - min.x;
    resultRect.height = max.y - min.y;
    return resultRect;
};
Sprite.prototype["getGlobalSelfBounds"] = function () {
    var rect = this.getSelfBounds();
    var min = this.localToGlobal(new Point(rect.x, rect.y));
    var max = this.localToGlobal(new Point(rect.right, rect.bottom));
    var resultRect = new Rectangle();
    resultRect.x = min.x;
    resultRect.y = min.y;
    resultRect.width = max.x - min.x;
    resultRect.height = max.y - min.y;
    return resultRect;
};
Point["distance2"] = function (ax, ay, bx, by) {
    return Math.sqrt((bx - ax) * (bx - ax) + (by - ay) * (by - ay));
};
Point["distanceSquare"] = function (p1, p2) {
    return Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2);
};
Point["distanceSquare2"] = function (ax, ay, bx, by) {
    return Math.pow(bx - ax, 2) + Math.pow(by - ay, 2);
};
Point["interpolate2"] = function (toX, toY, fromX, fromY, per) {
    var x = (toX - fromX) * per + fromX;
    var y = (toY - fromY) * per + fromY;
    return [x, y];
};
var oldsendEvents = TouchManager.prototype["sendEvents"];
TouchManager.prototype["sendEvents"] = function (eles, type, touchID) {
    if (type == "rightmousedown") {
        if (this._event.nativeEvent && this._event.nativeEvent.button == 1) {
            type = "middlemousedown";
        }
    }
    if (type == "rightmouseup") {
        if (this._event.nativeEvent && this._event.nativeEvent.button == 1) {
            type = "middlemouseup";
        }
    }
    oldsendEvents.call(this, eles, type, touchID);
};
((e,t)=>{"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).zip={})})(this,(function(e){"use strict";const{Array:t,Object:n,String:r,Number:s,BigInt:i,Math:a,Date:o,Map:c,Set:l,Response:u,URL:f,Error:d,Uint8Array:w,Uint16Array:h,Uint32Array:p,DataView:g,Blob:m,Promise:y,TextEncoder:b,TextDecoder:S,document:k,crypto:z,btoa:_,TransformStream:v,ReadableStream:C,WritableStream:x,CompressionStream:A,DecompressionStream:D,navigator:W,Worker:R}="undefined"!=typeof globalThis?globalThis:this||self,F=4294967295,E=65535,T=67324752,U=134695760,L=33639248,I=101075792,N=117853008,q=21589,O=2048,M="/",V=new o(2107,11,31),P=new o(1980,0,1),B=void 0,H="undefined",K="function";class Y{constructor(e){return class extends v{constructor(t,n){const r=new e(n);super({transform(e,t){t.enqueue(r.append(e))},flush(e){const t=r.flush();t&&e.enqueue(t)}})}}}}let Z=2;try{typeof W!=H&&W.hardwareConcurrency&&(Z=W.hardwareConcurrency)}catch(e){}const X={chunkSize:524288,maxWorkers:Z,terminateWorkerTimeout:5e3,useWebWorkers:!0,useCompressionStream:!0,workerScripts:B,CompressionStreamNative:typeof A!=H&&A,DecompressionStreamNative:typeof D!=H&&D},j=n.assign({},X);function G(){return j}function J(e){return a.max(e.chunkSize,64)}function $(e){const{baseURL:n,chunkSize:r,maxWorkers:s,terminateWorkerTimeout:i,useCompressionStream:a,useWebWorkers:o,Deflate:c,Inflate:l,CompressionStream:u,DecompressionStream:f,workerScripts:w}=e;if(Q("baseURL",n),Q("chunkSize",r),Q("maxWorkers",s),Q("terminateWorkerTimeout",i),Q("useCompressionStream",a),Q("useWebWorkers",o),c&&(j.CompressionStream=new Y(c)),l&&(j.DecompressionStream=new Y(l)),Q("CompressionStream",u),Q("DecompressionStream",f),w!==B){const{deflate:e,inflate:n}=w;if((e||n)&&(j.workerScripts||(j.workerScripts={})),e){if(!t.isArray(e))throw new d("workerScripts.deflate must be an array");j.workerScripts.deflate=e}if(n){if(!t.isArray(n))throw new d("workerScripts.inflate must be an array");j.workerScripts.inflate=n}}}function Q(e,t){t!==B&&(j[e]=t)}function ee(e,t,r){return class{constructor(s){const i=this;var a,o;a=s,o="level",("function"==typeof n.hasOwn?n.hasOwn(a,o):a.hasOwnProperty(o))&&void 0===s.level&&delete s.level,i.codec=new e(n.assign({},t,s)),r(i.codec,(e=>{if(i.pendingData){const t=i.pendingData;i.pendingData=new w(t.length+e.length);const{pendingData:n}=i;n.set(t,0),n.set(e,t.length)}else i.pendingData=new w(e)}))}append(e){return this.codec.push(e),s(this)}flush(){return this.codec.push(new w,!0),s(this)}};function s(e){if(e.pendingData){const t=e.pendingData;return e.pendingData=null,t}return new w}}const te=[];for(let e=0;256>e;e++){let t=e;for(let e=0;8>e;e++)1&t?t=t>>>1^3988292384:t>>>=1;te[e]=t}class ne{constructor(e){this.crc=e||-1}append(e){let t=0|this.crc;for(let n=0,r=0|e.length;r>n;n++)t=t>>>8^te[255&(t^e[n])];this.crc=t}get(){return~this.crc}}class re extends v{constructor(){let e;const t=new ne;super({transform(e,n){t.append(e),n.enqueue(e)},flush(){const n=new w(4);new g(n.buffer).setUint32(0,t.get()),e.value=n}}),e=this}}function se(e){if(void 0===b){const t=new w((e=unescape(encodeURIComponent(e))).length);for(let n=0;n<t.length;n++)t[n]=e.charCodeAt(n);return t}return(new b).encode(e)}const ie={concat(e,t){if(0===e.length||0===t.length)return e.concat(t);const n=e[e.length-1],r=ie.getPartial(n);return 32===r?e.concat(t):ie._shiftRight(t,r,0|n,e.slice(0,e.length-1))},bitLength(e){const t=e.length;if(0===t)return 0;const n=e[t-1];return 32*(t-1)+ie.getPartial(n)},clamp(e,t){if(32*e.length<t)return e;const n=(e=e.slice(0,a.ceil(t/32))).length;return t&=31,n>0&&t&&(e[n-1]=ie.partial(t,e[n-1]&2147483648>>t-1,1)),e},partial:(e,t,n)=>32===e?t:(n?0|t:t<<32-e)+1099511627776*e,getPartial:e=>a.round(e/1099511627776)||32,_shiftRight(e,t,n,r){for(void 0===r&&(r=[]);t>=32;t-=32)r.push(n),n=0;if(0===t)return r.concat(e);for(let s=0;s<e.length;s++)r.push(n|e[s]>>>t),n=e[s]<<32-t;const s=e.length?e[e.length-1]:0,i=ie.getPartial(s);return r.push(ie.partial(t+i&31,t+i>32?n:r.pop(),1)),r}},ae={bytes:{fromBits(e){const t=ie.bitLength(e)/8,n=new w(t);let r;for(let s=0;t>s;s++)0==(3&s)&&(r=e[s/4]),n[s]=r>>>24,r<<=8;return n},toBits(e){const t=[];let n,r=0;for(n=0;n<e.length;n++)r=r<<8|e[n],3==(3&n)&&(t.push(r),r=0);return 3&n&&t.push(ie.partial(8*(3&n),r)),t}}},oe=class{constructor(e){const t=this;t.blockSize=512,t._init=[1732584193,4023233417,2562383102,271733878,3285377520],t._key=[1518500249,1859775393,2400959708,3395469782],e?(t._h=e._h.slice(0),t._buffer=e._buffer.slice(0),t._length=e._length):t.reset()}reset(){const e=this;return e._h=e._init.slice(0),e._buffer=[],e._length=0,e}update(e){const t=this;"string"==typeof e&&(e=ae.utf8String.toBits(e));const n=t._buffer=ie.concat(t._buffer,e),r=t._length,s=t._length=r+ie.bitLength(e);if(s>9007199254740991)throw new d("Cannot hash more than 2^53 - 1 bits");const i=new p(n);let a=0;for(let e=t.blockSize+r-(t.blockSize+r&t.blockSize-1);s>=e;e+=t.blockSize)t._block(i.subarray(16*a,16*(a+1))),a+=1;return n.splice(0,16*a),t}finalize(){const e=this;let t=e._buffer;const n=e._h;t=ie.concat(t,[ie.partial(1,1)]);for(let e=t.length+2;15&e;e++)t.push(0);for(t.push(a.floor(e._length/4294967296)),t.push(0|e._length);t.length;)e._block(t.splice(0,16));return e.reset(),n}_f(e,t,n,r){return e>19?e>39?e>59?e>79?void 0:t^n^r:t&n|t&r|n&r:t^n^r:t&n|~t&r}_S(e,t){return t<<e|t>>>32-e}_block(e){const n=this,r=n._h,s=t(80);for(let t=0;16>t;t++)s[t]=e[t];let i=r[0],o=r[1],c=r[2],l=r[3],u=r[4];for(let e=0;79>=e;e++){16>e||(s[e]=n._S(1,s[e-3]^s[e-8]^s[e-14]^s[e-16]));const t=n._S(5,i)+n._f(e,o,c,l)+u+s[e]+n._key[a.floor(e/20)]|0;u=l,l=c,c=n._S(30,o),o=i,i=t}r[0]=r[0]+i|0,r[1]=r[1]+o|0,r[2]=r[2]+c|0,r[3]=r[3]+l|0,r[4]=r[4]+u|0}},ce={getRandomValues(e){const t=new p(e.buffer),n=e=>{let t=987654321;const n=4294967295;return()=>(t=36969*(65535&t)+(t>>16)&n,(((t<<16)+(e=18e3*(65535&e)+(e>>16)&n)&n)/4294967296+.5)*(a.random()>.5?1:-1))};for(let r,s=0;s<e.length;s+=4){const e=n(4294967296*(r||a.random()));r=987654071*e(),t[s/4]=4294967296*e()|0}return e}},le={importKey:e=>new le.hmacSha1(ae.bytes.toBits(e)),pbkdf2(e,t,n,r){if(n=n||1e4,0>r||0>n)throw new d("invalid params to pbkdf2");const s=1+(r>>5)<<2;let i,a,o,c,l;const u=new ArrayBuffer(s),f=new g(u);let w=0;const h=ie;for(t=ae.bytes.toBits(t),l=1;(s||1)>w;l++){for(i=a=e.encrypt(h.concat(t,[l])),o=1;n>o;o++)for(a=e.encrypt(a),c=0;c<a.length;c++)i[c]^=a[c];for(o=0;(s||1)>w&&o<i.length;o++)f.setInt32(w,i[o]),w+=4}return u.slice(0,r/8)},hmacSha1:class{constructor(e){const t=this,n=t._hash=oe,r=[[],[]];t._baseHash=[new n,new n];const s=t._baseHash[0].blockSize/32;e.length>s&&(e=(new n).update(e).finalize());for(let t=0;s>t;t++)r[0][t]=909522486^e[t],r[1][t]=1549556828^e[t];t._baseHash[0].update(r[0]),t._baseHash[1].update(r[1]),t._resultHash=new n(t._baseHash[0])}reset(){const e=this;e._resultHash=new e._hash(e._baseHash[0]),e._updated=!1}update(e){this._updated=!0,this._resultHash.update(e)}digest(){const e=this,t=e._resultHash.finalize(),n=new e._hash(e._baseHash[1]).update(t).finalize();return e.reset(),n}encrypt(e){if(this._updated)throw new d("encrypt on already updated hmac called!");return this.update(e),this.digest(e)}}},ue=void 0!==z&&"function"==typeof z.getRandomValues,fe="Invalid password",de="Invalid signature",we="zipjs-abort-check-password";function he(e){return ue?z.getRandomValues(e):ce.getRandomValues(e)}const pe=16,ge={name:"PBKDF2"},me=n.assign({hash:{name:"HMAC"}},ge),ye=n.assign({iterations:1e3,hash:{name:"SHA-1"}},ge),be=["deriveBits"],Se=[8,12,16],ke=[16,24,32],ze=10,_e=[0,0,0,0],ve="undefined",Ce="function",xe=typeof z!=ve,Ae=xe&&z.subtle,De=xe&&typeof Ae!=ve,We=ae.bytes,Re=class{constructor(e){const t=this;t._tables=[[[],[],[],[],[]],[[],[],[],[],[]]],t._tables[0][0][0]||t._precompute();const n=t._tables[0][4],r=t._tables[1],s=e.length;let i,a,o,c=1;if(4!==s&&6!==s&&8!==s)throw new d("invalid aes key size");for(t._key=[a=e.slice(0),o=[]],i=s;4*s+28>i;i++){let e=a[i-1];(i%s==0||8===s&&i%s==4)&&(e=n[e>>>24]<<24^n[e>>16&255]<<16^n[e>>8&255]<<8^n[255&e],i%s==0&&(e=e<<8^e>>>24^c<<24,c=c<<1^283*(c>>7))),a[i]=a[i-s]^e}for(let e=0;i;e++,i--){const t=a[3&e?i:i-4];o[e]=4>=i||4>e?t:r[0][n[t>>>24]]^r[1][n[t>>16&255]]^r[2][n[t>>8&255]]^r[3][n[255&t]]}}encrypt(e){return this._crypt(e,0)}decrypt(e){return this._crypt(e,1)}_precompute(){const e=this._tables[0],t=this._tables[1],n=e[4],r=t[4],s=[],i=[];let a,o,c,l;for(let e=0;256>e;e++)i[(s[e]=e<<1^283*(e>>7))^e]=e;for(let u=a=0;!n[u];u^=o||1,a=i[a]||1){let i=a^a<<1^a<<2^a<<3^a<<4;i=i>>8^255&i^99,n[u]=i,r[i]=u,l=s[c=s[o=s[u]]];let f=16843009*l^65537*c^257*o^16843008*u,d=257*s[i]^16843008*i;for(let n=0;4>n;n++)e[n][u]=d=d<<24^d>>>8,t[n][i]=f=f<<24^f>>>8}for(let n=0;5>n;n++)e[n]=e[n].slice(0),t[n]=t[n].slice(0)}_crypt(e,t){if(4!==e.length)throw new d("invalid aes block size");const n=this._key[t],r=n.length/4-2,s=[0,0,0,0],i=this._tables[t],a=i[0],o=i[1],c=i[2],l=i[3],u=i[4];let f,w,h,p=e[0]^n[0],g=e[t?3:1]^n[1],m=e[2]^n[2],y=e[t?1:3]^n[3],b=4;for(let e=0;r>e;e++)f=a[p>>>24]^o[g>>16&255]^c[m>>8&255]^l[255&y]^n[b],w=a[g>>>24]^o[m>>16&255]^c[y>>8&255]^l[255&p]^n[b+1],h=a[m>>>24]^o[y>>16&255]^c[p>>8&255]^l[255&g]^n[b+2],y=a[y>>>24]^o[p>>16&255]^c[g>>8&255]^l[255&m]^n[b+3],b+=4,p=f,g=w,m=h;for(let e=0;4>e;e++)s[t?3&-e:e]=u[p>>>24]<<24^u[g>>16&255]<<16^u[m>>8&255]<<8^u[255&y]^n[b++],f=p,p=g,g=m,m=y,y=f;return s}},Fe=class{constructor(e,t){this._prf=e,this._initIv=t,this._iv=t}reset(){this._iv=this._initIv}update(e){return this.calculate(this._prf,e,this._iv)}incWord(e){if(255==(e>>24&255)){let t=e>>16&255,n=e>>8&255,r=255&e;255===t?(t=0,255===n?(n=0,255===r?r=0:++r):++n):++t,e=0,e+=t<<16,e+=n<<8,e+=r}else e+=1<<24;return e}incCounter(e){0===(e[0]=this.incWord(e[0]))&&(e[1]=this.incWord(e[1]))}calculate(e,t,n){let r;if(!(r=t.length))return[];const s=ie.bitLength(t);for(let s=0;r>s;s+=4){this.incCounter(n);const r=e.encrypt(n);t[s]^=r[0],t[s+1]^=r[1],t[s+2]^=r[2],t[s+3]^=r[3]}return ie.clamp(t,s)}},Ee=le.hmacSha1;let Te=xe&&De&&typeof Ae.importKey==Ce,Ue=xe&&De&&typeof Ae.deriveBits==Ce;class Le extends v{constructor({password:e,signed:t,encryptionStrength:r,checkPasswordOnly:s}){super({start(){n.assign(this,{ready:new y((e=>this.resolveReady=e)),password:e,signed:t,strength:r-1,pending:new w})},async transform(e,t){const n=this,{password:r,strength:i,resolveReady:a,ready:o}=n;r?(await(async(e,t,n,r)=>{const s=await qe(e,t,n,Me(r,0,Se[t])),i=Me(r,Se[t]);if(s[0]!=i[0]||s[1]!=i[1])throw new d(fe)})(n,i,r,Me(e,0,Se[i]+2)),e=Me(e,Se[i]+2),s?t.error(new d(we)):a()):await o;const c=new w(e.length-ze-(e.length-ze)%pe);t.enqueue(Ne(n,e,c,0,ze,!0))},async flush(e){const{signed:t,ctr:n,hmac:r,pending:s,ready:i}=this;await i;const a=Me(s,0,s.length-ze),o=Me(s,s.length-ze);let c=new w;if(a.length){const e=Pe(We,a);r.update(e);const t=n.update(e);c=Ve(We,t)}if(t){const e=Me(Ve(We,r.digest()),0,ze);for(let t=0;ze>t;t++)if(e[t]!=o[t])throw new d(de)}e.enqueue(c)}})}}class Ie extends v{constructor({password:e,encryptionStrength:t}){let r;super({start(){n.assign(this,{ready:new y((e=>this.resolveReady=e)),password:e,strength:t-1,pending:new w})},async transform(e,t){const n=this,{password:r,strength:s,resolveReady:i,ready:a}=n;let o=new w;r?(o=await(async(e,t,n)=>{const r=he(new w(Se[t]));return Oe(r,await qe(e,t,n,r))})(n,s,r),i()):await a;const c=new w(o.length+e.length-e.length%pe);c.set(o,0),t.enqueue(Ne(n,e,c,o.length,0))},async flush(e){const{ctr:t,hmac:n,pending:s,ready:i}=this;await i;let a=new w;if(s.length){const e=t.update(Pe(We,s));n.update(e),a=Ve(We,e)}r.signature=Ve(We,n.digest()).slice(0,ze),e.enqueue(Oe(a,r.signature))}}),r=this}}function Ne(e,t,n,r,s,i){const{ctr:a,hmac:o,pending:c}=e,l=t.length-s;let u;for(c.length&&(t=Oe(c,t),n=((e,t)=>{if(t&&t>e.length){const n=e;(e=new w(t)).set(n,0)}return e})(n,l-l%pe)),u=0;l-pe>=u;u+=pe){const e=Pe(We,Me(t,u,u+pe));i&&o.update(e);const s=a.update(e);i||o.update(s),n.set(Ve(We,s),u+r)}return e.pending=Me(t,u),n}async function qe(e,r,s,i){e.password=null;const a=se(s),o=await(async(e,t,n,r,s)=>{if(!Te)return le.importKey(t);try{return await Ae.importKey("raw",t,n,!1,s)}catch(e){return Te=!1,le.importKey(t)}})(0,a,me,0,be),c=await(async(e,t,n)=>{if(!Ue)return le.pbkdf2(t,e.salt,ye.iterations,n);try{return await Ae.deriveBits(e,t,n)}catch(r){return Ue=!1,le.pbkdf2(t,e.salt,ye.iterations,n)}})(n.assign({salt:i},ye),o,8*(2*ke[r]+2)),l=new w(c),u=Pe(We,Me(l,0,ke[r])),f=Pe(We,Me(l,ke[r],2*ke[r])),d=Me(l,2*ke[r]);return n.assign(e,{keys:{key:u,authentication:f,passwordVerification:d},ctr:new Fe(new Re(u),t.from(_e)),hmac:new Ee(f)}),d}function Oe(e,t){let n=e;return e.length+t.length&&(n=new w(e.length+t.length),n.set(e,0),n.set(t,e.length)),n}function Me(e,t,n){return e.subarray(t,n)}function Ve(e,t){return e.fromBits(t)}function Pe(e,t){return e.toBits(t)}class Be extends v{constructor({password:e,passwordVerification:t,checkPasswordOnly:r}){super({start(){n.assign(this,{password:e,passwordVerification:t}),Ze(this,e)},transform(e,t){const n=this;if(n.password){const t=Ke(n,e.subarray(0,12));if(n.password=null,t[11]!=n.passwordVerification)throw new d(fe);e=e.subarray(12)}r?t.error(new d(we)):t.enqueue(Ke(n,e))}})}}class He extends v{constructor({password:e,passwordVerification:t}){super({start(){n.assign(this,{password:e,passwordVerification:t}),Ze(this,e)},transform(e,t){const n=this;let r,s;if(n.password){n.password=null;const t=he(new w(12));t[11]=n.passwordVerification,r=new w(e.length+t.length),r.set(Ye(n,t),0),s=12}else r=new w(e.length),s=0;r.set(Ye(n,e),s),t.enqueue(r)}})}}function Ke(e,t){const n=new w(t.length);for(let r=0;r<t.length;r++)n[r]=je(e)^t[r],Xe(e,n[r]);return n}function Ye(e,t){const n=new w(t.length);for(let r=0;r<t.length;r++)n[r]=je(e)^t[r],Xe(e,t[r]);return n}function Ze(e,t){const r=[305419896,591751049,878082192];n.assign(e,{keys:r,crcKey0:new ne(r[0]),crcKey2:new ne(r[2])});for(let n=0;n<t.length;n++)Xe(e,t.charCodeAt(n))}function Xe(e,t){let[n,r,s]=e.keys;e.crcKey0.append([t]),n=~e.crcKey0.get(),r=Je(a.imul(Je(r+Ge(n)),134775813)+1),e.crcKey2.append([r>>>24]),s=~e.crcKey2.get(),e.keys=[n,r,s]}function je(e){const t=2|e.keys[2];return Ge(a.imul(t,1^t)>>>8)}function Ge(e){return 255&e}function Je(e){return 4294967295&e}const $e="deflate-raw";class Qe extends v{constructor(e,{chunkSize:t,CompressionStream:n,CompressionStreamNative:r}){super({});const{compressed:s,encrypted:i,useCompressionStream:a,zipCrypto:o,signed:c,level:l}=e,u=this;let f,d,w=tt(super.readable);i&&!o||!c||(f=new re,w=st(w,f)),s&&(w=rt(w,a,{level:l,chunkSize:t},r,n)),i&&(o?w=st(w,new He(e)):(d=new Ie(e),w=st(w,d))),nt(u,w,(async()=>{let e;i&&!o&&(e=d.signature),i&&!o||!c||(e=new g(f.value.buffer).getUint32(0)),u.signature=e}))}}class et extends v{constructor(e,{chunkSize:t,DecompressionStream:n,DecompressionStreamNative:r}){super({});const{zipCrypto:s,encrypted:i,signed:a,signature:o,compressed:c,useCompressionStream:l}=e;let u,f,w=tt(super.readable);i&&(s?w=st(w,new Be(e)):(f=new Le(e),w=st(w,f))),c&&(w=rt(w,l,{chunkSize:t},r,n)),i&&!s||!a||(u=new re,w=st(w,u)),nt(this,w,(async()=>{if((!i||s)&&a){const e=new g(u.value.buffer);if(o!=e.getUint32(0,!1))throw new d(de)}}))}}function tt(e){return st(e,new v({transform(e,t){e&&e.length&&t.enqueue(e)}}))}function nt(e,t,r){t=st(t,new v({flush:r})),n.defineProperty(e,"readable",{get:()=>t})}function rt(e,t,n,r,s){try{e=st(e,new(t&&r?r:s)($e,n))}catch(r){if(!t)throw r;e=st(e,new s($e,n))}return e}function st(e,t){return e.pipeThrough(t)}const it="data",at="deflate",ot="inflate";class ct extends v{constructor(e,t){super({});const r=this,{codecType:s}=e;let i;s.startsWith(at)?i=Qe:s.startsWith(ot)&&(i=et);let a=0;const o=new i(e,t),c=super.readable,l=new v({transform(e,t){e&&e.length&&(a+=e.length,t.enqueue(e))},flush(){const{signature:e}=o;n.assign(r,{signature:e,size:a})}});n.defineProperty(r,"readable",{get:()=>c.pipeThrough(o).pipeThrough(l)})}}const lt=typeof R!=H;class ut{constructor(e,{readable:t,writable:r},{options:s,config:i,streamOptions:a,useWebWorkers:o,transferStreams:c,scripts:l},u){const{signal:f}=a;return n.assign(e,{busy:!0,readable:t.pipeThrough(new ft(t,a,i),{signal:f}),writable:r,options:n.assign({},s),scripts:l,transferStreams:c,terminate(){const{worker:t,busy:n}=e;t&&!n&&(t.terminate(),e.interface=null)},onTaskFinished(){e.busy=!1,u(e)}}),(o&&lt?ht:wt)(e,i)}}class ft extends v{constructor(e,{onstart:t,onprogress:n,size:r,onend:s},{chunkSize:i}){let a=0;super({start(){t&&dt(t,r)},async transform(e,t){a+=e.length,n&&await dt(n,a,r),t.enqueue(e)},flush(){e.size=a,s&&dt(s,a)}},{highWaterMark:1,size:()=>i})}}async function dt(e,...t){try{await e(...t)}catch(e){}}function wt(e,t){return{run:()=>(async({options:e,readable:t,writable:n,onTaskFinished:r},s)=>{const i=new ct(e,s);try{await t.pipeThrough(i).pipeTo(n,{preventClose:!0,preventAbort:!0});const{signature:e,size:s}=i;return{signature:e,size:s}}finally{r()}})(e,t)}}function ht(e,{baseURL:t,chunkSize:r}){return e.interface||n.assign(e,{worker:mt(e.scripts[0],t,e),interface:{run:()=>(async(e,t)=>{let r,s;const i=new y(((e,t)=>{r=e,s=t}));n.assign(e,{reader:null,writer:null,resolveResult:r,rejectResult:s,result:i});const{readable:a,options:o,scripts:c}=e,{writable:l,closed:u}=(e=>{const t=e.getWriter();let n;const r=new y((e=>n=e));return{writable:new x({async write(e){await t.ready,await t.write(e)},close(){t.releaseLock(),n()},abort:e=>t.abort(e)}),closed:r}})(e.writable);yt({type:"start",scripts:c.slice(1),options:o,config:t,readable:a,writable:l},e)||n.assign(e,{reader:a.getReader(),writer:l.getWriter()});const f=await i;try{await l.getWriter().close()}catch(e){}return await u,f})(e,{chunkSize:r})}}),e.interface}let pt=!0,gt=!0;function mt(e,t,r){const s={type:"module"};let i,a;typeof e==K&&(e=e());try{i=new f(e,t)}catch(t){i=e}if(pt)try{a=new R(i)}catch(e){pt=!1,a=new R(i,s)}else a=new R(i,s);return a.addEventListener("message",(e=>(async({data:e},t)=>{const{type:r,value:s,messageId:i,result:a,error:o}=e,{reader:c,writer:l,resolveResult:u,rejectResult:f,onTaskFinished:h}=t;try{if(o){const{message:e,stack:t,code:r,name:s}=o,i=new d(e);n.assign(i,{stack:t,code:r,name:s}),p(i)}else{if("pull"==r){const{value:e,done:n}=await c.read();yt({type:it,value:e,done:n,messageId:i},t)}r==it&&(await l.ready,await l.write(new w(s)),yt({type:"ack",messageId:i},t)),"close"==r&&p(null,a)}}catch(o){p(o)}function p(e,t){e?f(e):u(t),l&&l.releaseLock(),h()}})(e,r))),a}function yt(e,{worker:t,writer:n,onTaskFinished:r,transferStreams:s}){try{let{value:n,readable:r,writable:i}=e;const a=[];if(n&&(e.value=n.buffer,a.push(e.value)),s&&gt?(r&&a.push(r),i&&a.push(i)):e.readable=e.writable=null,a.length)try{return t.postMessage(e,a),!0}catch(n){gt=!1,e.readable=e.writable=null,t.postMessage(e)}else t.postMessage(e)}catch(e){throw n&&n.releaseLock(),r(),e}}let bt=[];const St=[];let kt=0;async function zt(e,t){const{options:n,config:r}=t,{transferStreams:i,useWebWorkers:a,useCompressionStream:o,codecType:c,compressed:l,signed:u,encrypted:f}=n,{workerScripts:d,maxWorkers:w,terminateWorkerTimeout:h}=r;t.transferStreams=i||i===B;const p=!(l||u||f||t.transferStreams);let g;t.useWebWorkers=!p&&(a||a===B&&r.useWebWorkers),t.scripts=t.useWebWorkers&&d?d[c]:[],n.useCompressionStream=o||o===B&&r.useCompressionStream;const m=bt.find((e=>!e.busy));if(m)_t(m),g=new ut(m,e,t,b);else if(bt.length<w){const n={indexWorker:kt};kt++,bt.push(n),g=new ut(n,e,t,b)}else g=await new y((n=>St.push({resolve:n,stream:e,workerOptions:t})));return g.run();function b(e){if(St.length){const[{resolve:t,stream:n,workerOptions:r}]=St.splice(0,1);t(new ut(e,n,r,b))}else e.worker?(_t(e),s.isFinite(h)&&h>=0&&(e.terminateTimeout=setTimeout((()=>{bt=bt.filter((t=>t!=e)),e.terminate()}),h))):bt=bt.filter((t=>t!=e))}}function _t(e){const{terminateTimeout:t}=e;t&&(clearTimeout(t),e.terminateTimeout=null)}const vt="HTTP error ",Ct="HTTP Range not supported",xt="Writer iterator completed too soon",At="GET",Dt="bytes",Wt=65536,Rt="writable";class Ft{constructor(){this.size=0}init(){this.initialized=!0}}class Et extends Ft{get readable(){const e=this,{chunkSize:t=Wt}=e,n=new C({start(){this.chunkOffset=0},async pull(r){const{offset:s=0,size:i,diskNumberStart:o}=n,{chunkOffset:c}=this;r.enqueue(await tn(e,s+c,a.min(t,i-c),o)),c+t>i?r.close():this.chunkOffset+=t}});return n}}class Tt extends Ft{constructor(){super();const e=this,t=new x({write:t=>e.writeUint8Array(t)});n.defineProperty(e,Rt,{get:()=>t})}writeUint8Array(){}}class Ut extends Et{constructor(e){super(),n.assign(this,{blob:e,size:e.size})}async readUint8Array(e,t){const n=this,r=e+t,s=e||r<n.size?n.blob.slice(e,r):n.blob;let i=await s.arrayBuffer();return i.byteLength>t&&(i=i.slice(e,r)),new w(i)}}class Lt extends Ft{constructor(e){super();const t=new v,r=[];e&&r.push(["Content-Type",e]),n.defineProperty(this,Rt,{get:()=>t.writable}),this.blob=new u(t.readable,{headers:r}).blob()}getData(){return this.blob}}class It extends Et{constructor(e,t){super(),qt(this,e,t)}async init(){await Ot(this,Zt,Bt),super.init()}readUint8Array(e,t){return Mt(this,e,t,Zt,Bt)}}class Nt extends Et{constructor(e,t){super(),qt(this,e,t)}async init(){await Ot(this,Xt,Ht),super.init()}readUint8Array(e,t){return Mt(this,e,t,Xt,Ht)}}function qt(e,t,r){const{preventHeadRequest:s,useRangeHeader:i,forceRangeRequests:a}=r;delete(r=n.assign({},r)).preventHeadRequest,delete r.useRangeHeader,delete r.forceRangeRequests,delete r.useXHR,n.assign(e,{url:t,options:r,preventHeadRequest:s,useRangeHeader:i,forceRangeRequests:a})}async function Ot(e,t,n){const{url:r,useRangeHeader:i,forceRangeRequests:a}=e;if((e=>{const{baseURL:t}=G(),{protocol:n}=new f(e,t);return"http:"==n||"https:"==n})(r)&&(i||a)){const{headers:r}=await t(At,e,Vt(e));if(!a&&r.get("Accept-Ranges")!=Dt)throw new d(Ct);{let i;const a=r.get("Content-Range");if(a){const e=a.trim().split(/\s*\/\s*/);if(e.length){const t=e[1];t&&"*"!=t&&(i=s(t))}}i===B?await Yt(e,t,n):e.size=i}}else await Yt(e,t,n)}async function Mt(e,t,n,r,s){const{useRangeHeader:i,forceRangeRequests:a,options:o}=e;if(i||a){const s=await r(At,e,Vt(e,t,n));if(206!=s.status)throw new d(Ct);return new w(await s.arrayBuffer())}{const{data:r}=e;return r||await s(e,o),new w(e.data.subarray(t,t+n))}}function Vt(e,t=0,r=1){return n.assign({},Pt(e),{Range:Dt+"="+t+"-"+(t+r-1)})}function Pt({options:e}){const{headers:t}=e;if(t)return Symbol.iterator in t?n.fromEntries(t):t}async function Bt(e){await Kt(e,Zt)}async function Ht(e){await Kt(e,Xt)}async function Kt(e,t){const n=await t(At,e,Pt(e));e.data=new w(await n.arrayBuffer()),e.size||(e.size=e.data.length)}async function Yt(e,t,n){if(e.preventHeadRequest)await n(e,e.options);else{const r=(await t("HEAD",e,Pt(e))).headers.get("Content-Length");r?e.size=s(r):await n(e,e.options)}}async function Zt(e,{options:t,url:r},s){const i=await fetch(r,n.assign({},t,{method:e,headers:s}));if(400>i.status)return i;throw 416==i.status?new d(Ct):new d(vt+(i.statusText||i.status))}function Xt(e,{url:t},r){return new y(((s,i)=>{const a=new XMLHttpRequest;if(a.addEventListener("load",(()=>{if(400>a.status){const e=[];a.getAllResponseHeaders().trim().split(/[\r\n]+/).forEach((t=>{const n=t.trim().split(/\s*:\s*/);n[0]=n[0].trim().replace(/^[a-z]|-[a-z]/g,(e=>e.toUpperCase())),e.push(n)})),s({status:a.status,arrayBuffer:()=>a.response,headers:new c(e)})}else i(416==a.status?new d(Ct):new d(vt+(a.statusText||a.status)))}),!1),a.addEventListener("error",(e=>i(e.detail?e.detail.error:new d("Network error"))),!1),a.open(e,t),r)for(const e of n.entries(r))a.setRequestHeader(e[0],e[1]);a.responseType="arraybuffer",a.send()}))}class jt extends Et{constructor(e,t={}){super(),n.assign(this,{url:e,reader:t.useXHR?new Nt(e,t):new It(e,t)})}set size(e){}get size(){return this.reader.size}async init(){await this.reader.init(),super.init()}readUint8Array(e,t){return this.reader.readUint8Array(e,t)}}class Gt extends Et{constructor(e){super(),this.readers=e}async init(){const e=this,{readers:t}=e;e.lastDiskNumber=0,e.lastDiskOffset=0,await y.all(t.map((async(n,r)=>{await n.init(),r!=t.length-1&&(e.lastDiskOffset+=n.size),e.size+=n.size}))),super.init()}async readUint8Array(e,t,n=0){const r=this,{readers:s}=this;let i,o=n;-1==o&&(o=s.length-1);let c=e;for(;c>=s[o].size;)c-=s[o].size,o++;const l=s[o],u=l.size;if(c+t>u){const s=u-c;i=new w(t),i.set(await tn(l,c,s)),i.set(await r.readUint8Array(e+s,t-s,n),s)}else i=await tn(l,c,t);return r.lastDiskNumber=a.max(o,r.lastDiskNumber),i}}class Jt extends Ft{constructor(e,t=4294967295){super();const r=this;let s,i,a;n.assign(r,{diskNumber:0,diskOffset:0,size:0,maxSize:t,availableSize:t});const o=new x({async write(t){const{availableSize:n}=r;if(a)t.length<n?await c(t):(await c(t.slice(0,n)),await l(),r.diskOffset+=s.size,r.diskNumber++,a=null,await this.write(t.slice(n)));else{const{value:n,done:o}=await e.next();if(o&&!n)throw new d(xt);s=n,s.size=0,s.maxSize&&(r.maxSize=s.maxSize),r.availableSize=r.maxSize,await $t(s),i=n.writable,a=i.getWriter(),await this.write(t)}},async close(){await a.ready,await l()}});async function c(e){const t=e.length;t&&(await a.ready,await a.write(e),s.size+=t,r.size+=t,r.availableSize-=t)}async function l(){i.size=s.size,await a.close()}n.defineProperty(r,Rt,{get:()=>o})}}async function $t(e,t){e.init&&!e.initialized&&await e.init(t)}function Qt(e){return t.isArray(e)&&(e=new Gt(e)),e instanceof C&&(e={readable:e}),e}function en(e){e.writable===B&&typeof e.next==K&&(e=new Jt(e)),e instanceof x&&(e={writable:e});const{writable:t}=e;return t.size===B&&(t.size=0),e instanceof Jt||n.assign(e,{diskNumber:0,diskOffset:0,availableSize:1/0,maxSize:1/0}),e}function tn(e,t,n,r){return e.readUint8Array(t,n,r)}const nn=Gt,rn=Jt,sn="\0☺☻♥♦♣♠•◘○◙♂♀♪♫☼►◄↕‼¶§▬↨↑↓→←∟↔▲▼ !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~⌂ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ".split("");function an(e,t){return t&&"cp437"==t.trim().toLowerCase()?(e=>{{let t="";for(let n=0;n<e.length;n++)t+=sn[e[n]];return t}})(e):new S(t).decode(e)}const on="filename",cn="rawFilename",ln="comment",un="rawComment",fn="uncompressedSize",dn="compressedSize",wn="offset",hn="diskNumberStart",pn="lastModDate",gn="rawLastModDate",mn="lastAccessDate",yn="creationDate",bn="internalFileAttribute",Sn="externalFileAttribute",kn="msDosCompatible",zn="zip64",_n=[on,cn,dn,fn,pn,gn,ln,un,mn,yn,wn,hn,hn,bn,Sn,kn,zn,"directory","bitFlag","encrypted","signature","filenameUTF8","commentUTF8","compressionMethod","version","versionMadeBy","extraField","rawExtraField","extraFieldZip64","extraFieldUnicodePath","extraFieldUnicodeComment","extraFieldAES","extraFieldNTFS","extraFieldExtendedTimestamp"];class vn{constructor(e){_n.forEach((t=>this[t]=e[t]))}}const Cn="File format is not recognized",xn="End of central directory not found",An="End of Zip64 central directory not found",Dn="End of Zip64 central directory locator not found",Wn="Central directory header not found",Rn="Local file header not found",Fn="Zip64 extra field not found",En="File contains encrypted entry",Tn="Encryption method not supported",Un="Compression method not supported",Ln="Split zip file",In="utf-8",Nn="cp437",qn=[[fn,F],[dn,F],[wn,F],[hn,E]],On={[E]:{getValue:jn,bytes:4},[F]:{getValue:Gn,bytes:8}};class Mn{constructor(e,t,r){n.assign(this,{reader:e,config:t,options:r})}async getData(e,t,r={}){const s=this,{reader:i,offset:a,diskNumberStart:o,extraFieldAES:c,compressionMethod:l,config:u,bitFlag:f,signature:h,rawLastModDate:p,uncompressedSize:g,compressedSize:m}=s,y=s.localDirectory={},b=Jn(await tn(i,a,30,o));let S=Hn(s,r,"password");if(S=S&&S.length&&S,c&&99!=c.originalCompressionMethod)throw new d(Un);if(0!=l&&8!=l)throw new d(Un);if(jn(b,0)!=T)throw new d(Rn);Vn(y,b,4),y.rawExtraField=y.extraFieldLength?await tn(i,a+30+y.filenameLength,y.extraFieldLength,o):new w,await Pn(s,y,b,4),n.assign(t,{lastAccessDate:y.lastAccessDate,creationDate:y.creationDate});const k=s.encrypted&&y.encrypted,z=k&&!c;if(k){if(!z&&c.strength===B)throw new d(Tn);if(!S)throw new d(En)}const _=a+30+y.filenameLength+y.extraFieldLength,v=m,C=i.readable;n.assign(C,{diskNumberStart:o,offset:_,size:v});const A=Hn(s,r,"signal"),D=Hn(s,r,"checkPasswordOnly");D&&(e=new x),e=en(e),await $t(e,g);const{writable:W}=e,{onstart:R,onprogress:F,onend:E}=r,U={options:{codecType:ot,password:S,zipCrypto:z,encryptionStrength:c&&c.strength,signed:Hn(s,r,"checkSignature"),passwordVerification:z&&(f.dataDescriptor?p>>>8&255:h>>>24&255),signature:h,compressed:0!=l,encrypted:k,useWebWorkers:Hn(s,r,"useWebWorkers"),useCompressionStream:Hn(s,r,"useCompressionStream"),transferStreams:Hn(s,r,"transferStreams"),checkPasswordOnly:D},config:u,streamOptions:{signal:A,size:v,onstart:R,onprogress:F,onend:E}};let L=0;try{({outputSize:L}=await zt({readable:C,writable:W},U))}catch(e){if(!D||e.message!=we)throw e}finally{const e=Hn(s,r,"preventClose");W.size+=L,e||W.locked||await W.getWriter().close()}return D?void 0:e.getData?e.getData():W}}function Vn(e,t,r){const s=e.rawBitFlag=Xn(t,r+2),i=1==(1&s),a=jn(t,r+6);n.assign(e,{encrypted:i,version:Xn(t,r),bitFlag:{level:(6&s)>>1,dataDescriptor:8==(8&s),languageEncodingFlag:(s&O)==O},rawLastModDate:a,lastModDate:Kn(a),filenameLength:Xn(t,r+22),extraFieldLength:Xn(t,r+24)})}async function Pn(e,t,r,s){const{rawExtraField:i}=t,a=t.extraField=new c,l=Jn(new w(i));let u=0;try{for(;u<i.length;){const e=Xn(l,u),t=Xn(l,u+2);a.set(e,{type:e,data:i.slice(u+4,u+4+t)}),u+=4+t}}catch(e){}const f=Xn(r,s+4);n.assign(t,{signature:jn(r,s+10),uncompressedSize:jn(r,s+18),compressedSize:jn(r,s+14)});const h=a.get(1);h&&(((e,t)=>{t.zip64=!0;const n=Jn(e.data),r=qn.filter((([e,n])=>t[e]==n));for(let s=0,i=0;s<r.length;s++){const[a,o]=r[s];if(t[a]==o){const r=On[o];t[a]=e[a]=r.getValue(n,i),i+=r.bytes}else if(e[a])throw new d(Fn)}})(h,t),t.extraFieldZip64=h);const p=a.get(28789);p&&(await Bn(p,on,cn,t,e),t.extraFieldUnicodePath=p);const g=a.get(25461);g&&(await Bn(g,ln,un,t,e),t.extraFieldUnicodeComment=g);const m=a.get(39169);m?(((e,t,r)=>{const s=Jn(e.data),i=Zn(s,4);n.assign(e,{vendorVersion:Zn(s,0),vendorId:Zn(s,2),strength:i,originalCompressionMethod:r,compressionMethod:Xn(s,5)}),t.compressionMethod=e.compressionMethod})(m,t,f),t.extraFieldAES=m):t.compressionMethod=f;const y=a.get(10);y&&(((e,t)=>{const r=Jn(e.data);let s,i=4;try{for(;i<e.data.length&&!s;){const t=Xn(r,i),n=Xn(r,i+2);1==t&&(s=e.data.slice(i+4,i+4+n)),i+=4+n}}catch(e){}try{if(s&&24==s.length){const r=Jn(s),i=r.getBigUint64(0,!0),a=r.getBigUint64(8,!0),o=r.getBigUint64(16,!0);n.assign(e,{rawLastModDate:i,rawLastAccessDate:a,rawCreationDate:o});const c={lastModDate:Yn(i),lastAccessDate:Yn(a),creationDate:Yn(o)};n.assign(e,c),n.assign(t,c)}}catch(e){}})(y,t),t.extraFieldNTFS=y);const b=a.get(q);b&&(((e,t)=>{const n=Jn(e.data),r=Zn(n,0),s=[],i=[];1==(1&r)&&(s.push(pn),i.push(gn)),2==(2&r)&&(s.push(mn),i.push("rawLastAccessDate")),4==(4&r)&&(s.push(yn),i.push("rawCreationDate"));let a=1;s.forEach(((r,s)=>{if(e.data.length>=a+4){const c=jn(n,a);t[r]=e[r]=new o(1e3*c);const l=i[s];e[l]=c}a+=4}))})(b,t),t.extraFieldExtendedTimestamp=b)}async function Bn(e,t,r,s,i){const a=Jn(e.data),o=new ne;o.append(i[r]);const c=Jn(new w(4));c.setUint32(0,o.get(),!0);const l=jn(a,1);n.assign(e,{version:Zn(a,0),[t]:an(e.data.subarray(5)),valid:!i.bitFlag.languageEncodingFlag&&l==jn(c,0)}),e.valid&&(s[t]=e[t],s[t+"UTF8"]=!0)}function Hn(e,t,n){return t[n]===B?e.options[n]:t[n]}function Kn(e){const t=(4294901760&e)>>16,n=65535&e;try{return new o(1980+((65024&t)>>9),((480&t)>>5)-1,31&t,(63488&n)>>11,(2016&n)>>5,2*(31&n),0)}catch(e){}}function Yn(e){return new o(s(e/i(1e4)-i(116444736e5)))}function Zn(e,t){return e.getUint8(t)}function Xn(e,t){return e.getUint16(t,!0)}function jn(e,t){return e.getUint32(t,!0)}function Gn(e,t){return s(e.getBigUint64(t,!0))}function Jn(e){return new g(e.buffer)}const $n="File already exists",Qn="Zip file comment exceeds 64KB",er="File entry comment exceeds 64KB",tr="File entry name exceeds 64KB",nr="Version exceeds 65535",rr="The strength must equal 1, 2, or 3",sr="Extra field type exceeds 65535",ir="Extra field data exceeds 64KB",ar="Zip64 is not supported (make sure 'keepOrder' is set to 'true')",or=new w([7,0,2,0,65,69,3,0,0]);let cr=0;const lr=[];async function ur(e,t){const n=e.getWriter();await n.ready,e.size+=br(t),await n.write(t),n.releaseLock()}function fr(e){if(e)return(i(e.getTime())+i(116444736e5))*i(1e4)}function dr(e,t,n,r){const s=t[n]===B?e.options[n]:t[n];return s===B?r:s}function wr(e,t,n){e.setUint8(t,n)}function hr(e,t,n){e.setUint16(t,n,!0)}function pr(e,t,n){e.setUint32(t,n,!0)}function gr(e,t,n){e.setBigUint64(t,n,!0)}function mr(e,t,n){e.set(t,n)}function yr(e){return new g(e.buffer)}function br(...e){let t=0;return e.forEach((e=>e&&(t+=e.length))),t}let Sr;try{Sr=void 0===k&&"undefined"==typeof location?new(require("url").URL)("file:"+__filename).href:void 0===k?location.href:k.currentScript&&k.currentScript.src||new f("zip.min.js",k.baseURI).href}catch(e){}$({baseURL:Sr}),(e=>{const t=()=>f.createObjectURL(new m(['const{Array:e,Object:t,Number:n,Math:r,Error:s,Uint8Array:i,Uint16Array:o,Uint32Array:c,Int32Array:f,Map:a,DataView:l,Promise:u,TextEncoder:w,crypto:h,postMessage:d,TransformStream:p,ReadableStream:y,WritableStream:m,CompressionStream:b,DecompressionStream:g}=self;class k{constructor(e){return class extends p{constructor(t,n){const r=new e(n);super({transform(e,t){t.enqueue(r.append(e))},flush(e){const t=r.flush();t&&e.enqueue(t)}})}}}}const v=[];for(let e=0;256>e;e++){let t=e;for(let e=0;8>e;e++)1&t?t=t>>>1^3988292384:t>>>=1;v[e]=t}class S{constructor(e){this.t=e||-1}append(e){let t=0|this.t;for(let n=0,r=0|e.length;r>n;n++)t=t>>>8^v[255&(t^e[n])];this.t=t}get(){return~this.t}}class z extends p{constructor(){let e;const t=new S;super({transform(e,n){t.append(e),n.enqueue(e)},flush(){const n=new i(4);new l(n.buffer).setUint32(0,t.get()),e.value=n}}),e=this}}const C={concat(e,t){if(0===e.length||0===t.length)return e.concat(t);const n=e[e.length-1],r=C.i(n);return 32===r?e.concat(t):C.o(t,r,0|n,e.slice(0,e.length-1))},l(e){const t=e.length;if(0===t)return 0;const n=e[t-1];return 32*(t-1)+C.i(n)},u(e,t){if(32*e.length<t)return e;const n=(e=e.slice(0,r.ceil(t/32))).length;return t&=31,n>0&&t&&(e[n-1]=C.h(t,e[n-1]&2147483648>>t-1,1)),e},h:(e,t,n)=>32===e?t:(n?0|t:t<<32-e)+1099511627776*e,i:e=>r.round(e/1099511627776)||32,o(e,t,n,r){for(void 0===r&&(r=[]);t>=32;t-=32)r.push(n),n=0;if(0===t)return r.concat(e);for(let s=0;s<e.length;s++)r.push(n|e[s]>>>t),n=e[s]<<32-t;const s=e.length?e[e.length-1]:0,i=C.i(s);return r.push(C.h(t+i&31,t+i>32?n:r.pop(),1)),r}},x={p:{m(e){const t=C.l(e)/8,n=new i(t);let r;for(let s=0;t>s;s++)0==(3&s)&&(r=e[s/4]),n[s]=r>>>24,r<<=8;return n},g(e){const t=[];let n,r=0;for(n=0;n<e.length;n++)r=r<<8|e[n],3==(3&n)&&(t.push(r),r=0);return 3&n&&t.push(C.h(8*(3&n),r)),t}}},_=class{constructor(e){const t=this;t.blockSize=512,t.k=[1732584193,4023233417,2562383102,271733878,3285377520],t.v=[1518500249,1859775393,2400959708,3395469782],e?(t.S=e.S.slice(0),t.C=e.C.slice(0),t._=e._):t.reset()}reset(){const e=this;return e.S=e.k.slice(0),e.C=[],e._=0,e}update(e){const t=this;"string"==typeof e&&(e=x.A.g(e));const n=t.C=C.concat(t.C,e),r=t._,i=t._=r+C.l(e);if(i>9007199254740991)throw new s("Cannot hash more than 2^53 - 1 bits");const o=new c(n);let f=0;for(let e=t.blockSize+r-(t.blockSize+r&t.blockSize-1);i>=e;e+=t.blockSize)t.I(o.subarray(16*f,16*(f+1))),f+=1;return n.splice(0,16*f),t}D(){const e=this;let t=e.C;const n=e.S;t=C.concat(t,[C.h(1,1)]);for(let e=t.length+2;15&e;e++)t.push(0);for(t.push(r.floor(e._/4294967296)),t.push(0|e._);t.length;)e.I(t.splice(0,16));return e.reset(),n}V(e,t,n,r){return e>19?e>39?e>59?e>79?void 0:t^n^r:t&n|t&r|n&r:t^n^r:t&n|~t&r}P(e,t){return t<<e|t>>>32-e}I(t){const n=this,s=n.S,i=e(80);for(let e=0;16>e;e++)i[e]=t[e];let o=s[0],c=s[1],f=s[2],a=s[3],l=s[4];for(let e=0;79>=e;e++){16>e||(i[e]=n.P(1,i[e-3]^i[e-8]^i[e-14]^i[e-16]));const t=n.P(5,o)+n.V(e,c,f,a)+l+i[e]+n.v[r.floor(e/20)]|0;l=a,a=f,f=n.P(30,c),c=o,o=t}s[0]=s[0]+o|0,s[1]=s[1]+c|0,s[2]=s[2]+f|0,s[3]=s[3]+a|0,s[4]=s[4]+l|0}},A={getRandomValues(e){const t=new c(e.buffer),n=e=>{let t=987654321;const n=4294967295;return()=>(t=36969*(65535&t)+(t>>16)&n,(((t<<16)+(e=18e3*(65535&e)+(e>>16)&n)&n)/4294967296+.5)*(r.random()>.5?1:-1))};for(let s,i=0;i<e.length;i+=4){const e=n(4294967296*(s||r.random()));s=987654071*e(),t[i/4]=4294967296*e()|0}return e}},I={importKey:e=>new I.R(x.p.g(e)),B(e,t,n,r){if(n=n||1e4,0>r||0>n)throw new s("invalid params to pbkdf2");const i=1+(r>>5)<<2;let o,c,f,a,u;const w=new ArrayBuffer(i),h=new l(w);let d=0;const p=C;for(t=x.p.g(t),u=1;(i||1)>d;u++){for(o=c=e.encrypt(p.concat(t,[u])),f=1;n>f;f++)for(c=e.encrypt(c),a=0;a<c.length;a++)o[a]^=c[a];for(f=0;(i||1)>d&&f<o.length;f++)h.setInt32(d,o[f]),d+=4}return w.slice(0,r/8)},R:class{constructor(e){const t=this,n=t.M=_,r=[[],[]];t.U=[new n,new n];const s=t.U[0].blockSize/32;e.length>s&&(e=(new n).update(e).D());for(let t=0;s>t;t++)r[0][t]=909522486^e[t],r[1][t]=1549556828^e[t];t.U[0].update(r[0]),t.U[1].update(r[1]),t.K=new n(t.U[0])}reset(){const e=this;e.K=new e.M(e.U[0]),e.N=!1}update(e){this.N=!0,this.K.update(e)}digest(){const e=this,t=e.K.D(),n=new e.M(e.U[1]).update(t).D();return e.reset(),n}encrypt(e){if(this.N)throw new s("encrypt on already updated hmac called!");return this.update(e),this.digest(e)}}},D=void 0!==h&&"function"==typeof h.getRandomValues,V="Invalid password",P="Invalid signature",R="zipjs-abort-check-password";function B(e){return D?h.getRandomValues(e):A.getRandomValues(e)}const E=16,M={name:"PBKDF2"},U=t.assign({hash:{name:"HMAC"}},M),K=t.assign({iterations:1e3,hash:{name:"SHA-1"}},M),N=["deriveBits"],O=[8,12,16],T=[16,24,32],W=10,j=[0,0,0,0],H="undefined",L="function",F=typeof h!=H,q=F&&h.subtle,G=F&&typeof q!=H,J=x.p,Q=class{constructor(e){const t=this;t.O=[[[],[],[],[],[]],[[],[],[],[],[]]],t.O[0][0][0]||t.T();const n=t.O[0][4],r=t.O[1],i=e.length;let o,c,f,a=1;if(4!==i&&6!==i&&8!==i)throw new s("invalid aes key size");for(t.v=[c=e.slice(0),f=[]],o=i;4*i+28>o;o++){let e=c[o-1];(o%i==0||8===i&&o%i==4)&&(e=n[e>>>24]<<24^n[e>>16&255]<<16^n[e>>8&255]<<8^n[255&e],o%i==0&&(e=e<<8^e>>>24^a<<24,a=a<<1^283*(a>>7))),c[o]=c[o-i]^e}for(let e=0;o;e++,o--){const t=c[3&e?o:o-4];f[e]=4>=o||4>e?t:r[0][n[t>>>24]]^r[1][n[t>>16&255]]^r[2][n[t>>8&255]]^r[3][n[255&t]]}}encrypt(e){return this.W(e,0)}decrypt(e){return this.W(e,1)}T(){const e=this.O[0],t=this.O[1],n=e[4],r=t[4],s=[],i=[];let o,c,f,a;for(let e=0;256>e;e++)i[(s[e]=e<<1^283*(e>>7))^e]=e;for(let l=o=0;!n[l];l^=c||1,o=i[o]||1){let i=o^o<<1^o<<2^o<<3^o<<4;i=i>>8^255&i^99,n[l]=i,r[i]=l,a=s[f=s[c=s[l]]];let u=16843009*a^65537*f^257*c^16843008*l,w=257*s[i]^16843008*i;for(let n=0;4>n;n++)e[n][l]=w=w<<24^w>>>8,t[n][i]=u=u<<24^u>>>8}for(let n=0;5>n;n++)e[n]=e[n].slice(0),t[n]=t[n].slice(0)}W(e,t){if(4!==e.length)throw new s("invalid aes block size");const n=this.v[t],r=n.length/4-2,i=[0,0,0,0],o=this.O[t],c=o[0],f=o[1],a=o[2],l=o[3],u=o[4];let w,h,d,p=e[0]^n[0],y=e[t?3:1]^n[1],m=e[2]^n[2],b=e[t?1:3]^n[3],g=4;for(let e=0;r>e;e++)w=c[p>>>24]^f[y>>16&255]^a[m>>8&255]^l[255&b]^n[g],h=c[y>>>24]^f[m>>16&255]^a[b>>8&255]^l[255&p]^n[g+1],d=c[m>>>24]^f[b>>16&255]^a[p>>8&255]^l[255&y]^n[g+2],b=c[b>>>24]^f[p>>16&255]^a[y>>8&255]^l[255&m]^n[g+3],g+=4,p=w,y=h,m=d;for(let e=0;4>e;e++)i[t?3&-e:e]=u[p>>>24]<<24^u[y>>16&255]<<16^u[m>>8&255]<<8^u[255&b]^n[g++],w=p,p=y,y=m,m=b,b=w;return i}},X=class{constructor(e,t){this.j=e,this.H=t,this.L=t}reset(){this.L=this.H}update(e){return this.F(this.j,e,this.L)}q(e){if(255==(e>>24&255)){let t=e>>16&255,n=e>>8&255,r=255&e;255===t?(t=0,255===n?(n=0,255===r?r=0:++r):++n):++t,e=0,e+=t<<16,e+=n<<8,e+=r}else e+=1<<24;return e}G(e){0===(e[0]=this.q(e[0]))&&(e[1]=this.q(e[1]))}F(e,t,n){let r;if(!(r=t.length))return[];const s=C.l(t);for(let s=0;r>s;s+=4){this.G(n);const r=e.encrypt(n);t[s]^=r[0],t[s+1]^=r[1],t[s+2]^=r[2],t[s+3]^=r[3]}return C.u(t,s)}},Y=I.R;let Z=F&&G&&typeof q.importKey==L,$=F&&G&&typeof q.deriveBits==L;class ee extends p{constructor({password:e,signed:n,encryptionStrength:r,checkPasswordOnly:o}){super({start(){t.assign(this,{ready:new u((e=>this.J=e)),password:e,signed:n,X:r-1,pending:new i})},async transform(e,t){const n=this,{password:r,X:c,J:f,ready:a}=n;r?(await(async(e,t,n,r)=>{const i=await re(e,t,n,ie(r,0,O[t])),o=ie(r,O[t]);if(i[0]!=o[0]||i[1]!=o[1])throw new s(V)})(n,c,r,ie(e,0,O[c]+2)),e=ie(e,O[c]+2),o?t.error(new s(R)):f()):await a;const l=new i(e.length-W-(e.length-W)%E);t.enqueue(ne(n,e,l,0,W,!0))},async flush(e){const{signed:t,Y:n,Z:r,pending:o,ready:c}=this;await c;const f=ie(o,0,o.length-W),a=ie(o,o.length-W);let l=new i;if(f.length){const e=ce(J,f);r.update(e);const t=n.update(e);l=oe(J,t)}if(t){const e=ie(oe(J,r.digest()),0,W);for(let t=0;W>t;t++)if(e[t]!=a[t])throw new s(P)}e.enqueue(l)}})}}class te extends p{constructor({password:e,encryptionStrength:n}){let r;super({start(){t.assign(this,{ready:new u((e=>this.J=e)),password:e,X:n-1,pending:new i})},async transform(e,t){const n=this,{password:r,X:s,J:o,ready:c}=n;let f=new i;r?(f=await(async(e,t,n)=>{const r=B(new i(O[t]));return se(r,await re(e,t,n,r))})(n,s,r),o()):await c;const a=new i(f.length+e.length-e.length%E);a.set(f,0),t.enqueue(ne(n,e,a,f.length,0))},async flush(e){const{Y:t,Z:n,pending:s,ready:o}=this;await o;let c=new i;if(s.length){const e=t.update(ce(J,s));n.update(e),c=oe(J,e)}r.signature=oe(J,n.digest()).slice(0,W),e.enqueue(se(c,r.signature))}}),r=this}}function ne(e,t,n,r,s,o){const{Y:c,Z:f,pending:a}=e,l=t.length-s;let u;for(a.length&&(t=se(a,t),n=((e,t)=>{if(t&&t>e.length){const n=e;(e=new i(t)).set(n,0)}return e})(n,l-l%E)),u=0;l-E>=u;u+=E){const e=ce(J,ie(t,u,u+E));o&&f.update(e);const s=c.update(e);o||f.update(s),n.set(oe(J,s),u+r)}return e.pending=ie(t,u),n}async function re(n,r,s,o){n.password=null;const c=(e=>{if(void 0===w){const t=new i((e=unescape(encodeURIComponent(e))).length);for(let n=0;n<t.length;n++)t[n]=e.charCodeAt(n);return t}return(new w).encode(e)})(s),f=await(async(e,t,n,r,s)=>{if(!Z)return I.importKey(t);try{return await q.importKey("raw",t,n,!1,s)}catch(e){return Z=!1,I.importKey(t)}})(0,c,U,0,N),a=await(async(e,t,n)=>{if(!$)return I.B(t,e.salt,K.iterations,n);try{return await q.deriveBits(e,t,n)}catch(r){return $=!1,I.B(t,e.salt,K.iterations,n)}})(t.assign({salt:o},K),f,8*(2*T[r]+2)),l=new i(a),u=ce(J,ie(l,0,T[r])),h=ce(J,ie(l,T[r],2*T[r])),d=ie(l,2*T[r]);return t.assign(n,{keys:{key:u,$:h,passwordVerification:d},Y:new X(new Q(u),e.from(j)),Z:new Y(h)}),d}function se(e,t){let n=e;return e.length+t.length&&(n=new i(e.length+t.length),n.set(e,0),n.set(t,e.length)),n}function ie(e,t,n){return e.subarray(t,n)}function oe(e,t){return e.m(t)}function ce(e,t){return e.g(t)}class fe extends p{constructor({password:e,passwordVerification:n,checkPasswordOnly:r}){super({start(){t.assign(this,{password:e,passwordVerification:n}),we(this,e)},transform(e,t){const n=this;if(n.password){const t=le(n,e.subarray(0,12));if(n.password=null,t[11]!=n.passwordVerification)throw new s(V);e=e.subarray(12)}r?t.error(new s(R)):t.enqueue(le(n,e))}})}}class ae extends p{constructor({password:e,passwordVerification:n}){super({start(){t.assign(this,{password:e,passwordVerification:n}),we(this,e)},transform(e,t){const n=this;let r,s;if(n.password){n.password=null;const t=B(new i(12));t[11]=n.passwordVerification,r=new i(e.length+t.length),r.set(ue(n,t),0),s=12}else r=new i(e.length),s=0;r.set(ue(n,e),s),t.enqueue(r)}})}}function le(e,t){const n=new i(t.length);for(let r=0;r<t.length;r++)n[r]=de(e)^t[r],he(e,n[r]);return n}function ue(e,t){const n=new i(t.length);for(let r=0;r<t.length;r++)n[r]=de(e)^t[r],he(e,t[r]);return n}function we(e,n){const r=[305419896,591751049,878082192];t.assign(e,{keys:r,ee:new S(r[0]),te:new S(r[2])});for(let t=0;t<n.length;t++)he(e,n.charCodeAt(t))}function he(e,t){let[n,s,i]=e.keys;e.ee.append([t]),n=~e.ee.get(),s=ye(r.imul(ye(s+pe(n)),134775813)+1),e.te.append([s>>>24]),i=~e.te.get(),e.keys=[n,s,i]}function de(e){const t=2|e.keys[2];return pe(r.imul(t,1^t)>>>8)}function pe(e){return 255&e}function ye(e){return 4294967295&e}const me="deflate-raw";class be extends p{constructor(e,{chunkSize:t,CompressionStream:n,CompressionStreamNative:r}){super({});const{compressed:s,encrypted:i,useCompressionStream:o,zipCrypto:c,signed:f,level:a}=e,u=this;let w,h,d=ke(super.readable);i&&!c||!f||(w=new z,d=ze(d,w)),s&&(d=Se(d,o,{level:a,chunkSize:t},r,n)),i&&(c?d=ze(d,new ae(e)):(h=new te(e),d=ze(d,h))),ve(u,d,(async()=>{let e;i&&!c&&(e=h.signature),i&&!c||!f||(e=new l(w.value.buffer).getUint32(0)),u.signature=e}))}}class ge extends p{constructor(e,{chunkSize:t,DecompressionStream:n,DecompressionStreamNative:r}){super({});const{zipCrypto:i,encrypted:o,signed:c,signature:f,compressed:a,useCompressionStream:u}=e;let w,h,d=ke(super.readable);o&&(i?d=ze(d,new fe(e)):(h=new ee(e),d=ze(d,h))),a&&(d=Se(d,u,{chunkSize:t},r,n)),o&&!i||!c||(w=new z,d=ze(d,w)),ve(this,d,(async()=>{if((!o||i)&&c){const e=new l(w.value.buffer);if(f!=e.getUint32(0,!1))throw new s(P)}}))}}function ke(e){return ze(e,new p({transform(e,t){e&&e.length&&t.enqueue(e)}}))}function ve(e,n,r){n=ze(n,new p({flush:r})),t.defineProperty(e,"readable",{get:()=>n})}function Se(e,t,n,r,s){try{e=ze(e,new(t&&r?r:s)(me,n))}catch(r){if(!t)throw r;e=ze(e,new s(me,n))}return e}function ze(e,t){return e.pipeThrough(t)}const Ce="data";class xe extends p{constructor(e,n){super({});const r=this,{codecType:s}=e;let i;s.startsWith("deflate")?i=be:s.startsWith("inflate")&&(i=ge);let o=0;const c=new i(e,n),f=super.readable,a=new p({transform(e,t){e&&e.length&&(o+=e.length,t.enqueue(e))},flush(){const{signature:e}=c;t.assign(r,{signature:e,size:o})}});t.defineProperty(r,"readable",{get:()=>f.pipeThrough(c).pipeThrough(a)})}}const _e=new a,Ae=new a;let Ie=0;async function De(e){try{const{options:t,scripts:r,config:s}=e;r&&r.length&&importScripts.apply(void 0,r),self.initCodec&&self.initCodec(),s.CompressionStreamNative=self.CompressionStream,s.DecompressionStreamNative=self.DecompressionStream,self.Deflate&&(s.CompressionStream=new k(self.Deflate)),self.Inflate&&(s.DecompressionStream=new k(self.Inflate));const i={highWaterMark:1,size:()=>s.chunkSize},o=e.readable||new y({async pull(e){const t=new u((e=>_e.set(Ie,e)));Ve({type:"pull",messageId:Ie}),Ie=(Ie+1)%n.MAX_SAFE_INTEGER;const{value:r,done:s}=await t;e.enqueue(r),s&&e.close()}},i),c=e.writable||new m({async write(e){let t;const r=new u((e=>t=e));Ae.set(Ie,t),Ve({type:Ce,value:e,messageId:Ie}),Ie=(Ie+1)%n.MAX_SAFE_INTEGER,await r}},i),f=new xe(t,s);await o.pipeThrough(f).pipeTo(c,{preventClose:!0,preventAbort:!0});try{await c.getWriter().close()}catch(e){}const{signature:a,size:l}=f;Ve({type:"close",result:{signature:a,size:l}})}catch(e){Pe(e)}}function Ve(e){let{value:t}=e;if(t)if(t.length)try{t=new i(t),e.value=t.buffer,d(e,[e.value])}catch(t){d(e)}else d(e);else d(e)}function Pe(e=new s("Unknown error")){const{message:t,stack:n,code:r,name:i}=e;d({error:{message:t,stack:n,code:r,name:i}})}addEventListener("message",(({data:e})=>{const{type:t,messageId:n,value:r,done:s}=e;try{if("start"==t&&De(e),t==Ce){const e=_e.get(n);_e.delete(n),e({value:new i(r),done:s})}if("ack"==t){const e=Ae.get(n);Ae.delete(n),e()}}catch(e){Pe(e)}}));const Re=-2;function Be(t){return Ee(t.map((([t,n])=>new e(t).fill(n,0,t))))}function Ee(t){return t.reduce(((t,n)=>t.concat(e.isArray(n)?Ee(n):n)),[])}const Me=[0,1,2,3].concat(...Be([[2,4],[2,5],[4,6],[4,7],[8,8],[8,9],[16,10],[16,11],[32,12],[32,13],[64,14],[64,15],[2,0],[1,16],[1,17],[2,18],[2,19],[4,20],[4,21],[8,22],[8,23],[16,24],[16,25],[32,26],[32,27],[64,28],[64,29]]));function Ue(){const e=this;function t(e,t){let n=0;do{n|=1&e,e>>>=1,n<<=1}while(--t>0);return n>>>1}e.ne=n=>{const s=e.re,i=e.ie.se,o=e.ie.oe;let c,f,a,l=-1;for(n.ce=0,n.fe=573,c=0;o>c;c++)0!==s[2*c]?(n.ae[++n.ce]=l=c,n.le[c]=0):s[2*c+1]=0;for(;2>n.ce;)a=n.ae[++n.ce]=2>l?++l:0,s[2*a]=1,n.le[a]=0,n.ue--,i&&(n.we-=i[2*a+1]);for(e.he=l,c=r.floor(n.ce/2);c>=1;c--)n.de(s,c);a=o;do{c=n.ae[1],n.ae[1]=n.ae[n.ce--],n.de(s,1),f=n.ae[1],n.ae[--n.fe]=c,n.ae[--n.fe]=f,s[2*a]=s[2*c]+s[2*f],n.le[a]=r.max(n.le[c],n.le[f])+1,s[2*c+1]=s[2*f+1]=a,n.ae[1]=a++,n.de(s,1)}while(n.ce>=2);n.ae[--n.fe]=n.ae[1],(t=>{const n=e.re,r=e.ie.se,s=e.ie.pe,i=e.ie.ye,o=e.ie.me;let c,f,a,l,u,w,h=0;for(l=0;15>=l;l++)t.be[l]=0;for(n[2*t.ae[t.fe]+1]=0,c=t.fe+1;573>c;c++)f=t.ae[c],l=n[2*n[2*f+1]+1]+1,l>o&&(l=o,h++),n[2*f+1]=l,f>e.he||(t.be[l]++,u=0,i>f||(u=s[f-i]),w=n[2*f],t.ue+=w*(l+u),r&&(t.we+=w*(r[2*f+1]+u)));if(0!==h){do{for(l=o-1;0===t.be[l];)l--;t.be[l]--,t.be[l+1]+=2,t.be[o]--,h-=2}while(h>0);for(l=o;0!==l;l--)for(f=t.be[l];0!==f;)a=t.ae[--c],a>e.he||(n[2*a+1]!=l&&(t.ue+=(l-n[2*a+1])*n[2*a],n[2*a+1]=l),f--)}})(n),((e,n,r)=>{const s=[];let i,o,c,f=0;for(i=1;15>=i;i++)s[i]=f=f+r[i-1]<<1;for(o=0;n>=o;o++)c=e[2*o+1],0!==c&&(e[2*o]=t(s[c]++,c))})(s,e.he,n.be)}}function Ke(e,t,n,r,s){const i=this;i.se=e,i.pe=t,i.ye=n,i.oe=r,i.me=s}Ue.ge=[0,1,2,3,4,5,6,7].concat(...Be([[2,8],[2,9],[2,10],[2,11],[4,12],[4,13],[4,14],[4,15],[8,16],[8,17],[8,18],[8,19],[16,20],[16,21],[16,22],[16,23],[32,24],[32,25],[32,26],[31,27],[1,28]])),Ue.ke=[0,1,2,3,4,5,6,7,8,10,12,14,16,20,24,28,32,40,48,56,64,80,96,112,128,160,192,224,0],Ue.ve=[0,1,2,3,4,6,8,12,16,24,32,48,64,96,128,192,256,384,512,768,1024,1536,2048,3072,4096,6144,8192,12288,16384,24576],Ue.Se=e=>256>e?Me[e]:Me[256+(e>>>7)],Ue.ze=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],Ue.Ce=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],Ue.xe=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],Ue._e=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];const Ne=Be([[144,8],[112,9],[24,7],[8,8]]);Ke.Ae=Ee([12,140,76,204,44,172,108,236,28,156,92,220,60,188,124,252,2,130,66,194,34,162,98,226,18,146,82,210,50,178,114,242,10,138,74,202,42,170,106,234,26,154,90,218,58,186,122,250,6,134,70,198,38,166,102,230,22,150,86,214,54,182,118,246,14,142,78,206,46,174,110,238,30,158,94,222,62,190,126,254,1,129,65,193,33,161,97,225,17,145,81,209,49,177,113,241,9,137,73,201,41,169,105,233,25,153,89,217,57,185,121,249,5,133,69,197,37,165,101,229,21,149,85,213,53,181,117,245,13,141,77,205,45,173,109,237,29,157,93,221,61,189,125,253,19,275,147,403,83,339,211,467,51,307,179,435,115,371,243,499,11,267,139,395,75,331,203,459,43,299,171,427,107,363,235,491,27,283,155,411,91,347,219,475,59,315,187,443,123,379,251,507,7,263,135,391,71,327,199,455,39,295,167,423,103,359,231,487,23,279,151,407,87,343,215,471,55,311,183,439,119,375,247,503,15,271,143,399,79,335,207,463,47,303,175,431,111,367,239,495,31,287,159,415,95,351,223,479,63,319,191,447,127,383,255,511,0,64,32,96,16,80,48,112,8,72,40,104,24,88,56,120,4,68,36,100,20,84,52,116,3,131,67,195,35,163,99,227].map(((e,t)=>[e,Ne[t]])));const Oe=Be([[30,5]]);function Te(e,t,n,r,s){const i=this;i.Ie=e,i.De=t,i.Ve=n,i.Pe=r,i.Re=s}Ke.Be=Ee([0,16,8,24,4,20,12,28,2,18,10,26,6,22,14,30,1,17,9,25,5,21,13,29,3,19,11,27,7,23].map(((e,t)=>[e,Oe[t]]))),Ke.Ee=new Ke(Ke.Ae,Ue.ze,257,286,15),Ke.Me=new Ke(Ke.Be,Ue.Ce,0,30,15),Ke.Ue=new Ke(null,Ue.xe,0,19,7);const We=[new Te(0,0,0,0,0),new Te(4,4,8,4,1),new Te(4,5,16,8,1),new Te(4,6,32,32,1),new Te(4,4,16,16,2),new Te(8,16,32,32,2),new Te(8,16,128,128,2),new Te(8,32,128,256,2),new Te(32,128,258,1024,2),new Te(32,258,258,4096,2)],je=["need dictionary","stream end","","","stream error","data error","","buffer error","",""],He=113,Le=666,Fe=262;function qe(e,t,n,r){const s=e[2*t],i=e[2*n];return i>s||s==i&&r[t]<=r[n]}function Ge(){const e=this;let t,n,s,c,f,a,l,u,w,h,d,p,y,m,b,g,k,v,S,z,C,x,_,A,I,D,V,P,R,B,E,M,U;const K=new Ue,N=new Ue,O=new Ue;let T,W,j,H,L,F;function q(){let t;for(t=0;286>t;t++)E[2*t]=0;for(t=0;30>t;t++)M[2*t]=0;for(t=0;19>t;t++)U[2*t]=0;E[512]=1,e.ue=e.we=0,W=j=0}function G(e,t){let n,r=-1,s=e[1],i=0,o=7,c=4;0===s&&(o=138,c=3),e[2*(t+1)+1]=65535;for(let f=0;t>=f;f++)n=s,s=e[2*(f+1)+1],++i<o&&n==s||(c>i?U[2*n]+=i:0!==n?(n!=r&&U[2*n]++,U[32]++):i>10?U[36]++:U[34]++,i=0,r=n,0===s?(o=138,c=3):n==s?(o=6,c=3):(o=7,c=4))}function J(t){e.Ke[e.pending++]=t}function Q(e){J(255&e),J(e>>>8&255)}function X(e,t){let n;const r=t;F>16-r?(n=e,L|=n<<F&65535,Q(L),L=n>>>16-F,F+=r-16):(L|=e<<F&65535,F+=r)}function Y(e,t){const n=2*e;X(65535&t[n],65535&t[n+1])}function Z(e,t){let n,r,s=-1,i=e[1],o=0,c=7,f=4;for(0===i&&(c=138,f=3),n=0;t>=n;n++)if(r=i,i=e[2*(n+1)+1],++o>=c||r!=i){if(f>o)do{Y(r,U)}while(0!=--o);else 0!==r?(r!=s&&(Y(r,U),o--),Y(16,U),X(o-3,2)):o>10?(Y(18,U),X(o-11,7)):(Y(17,U),X(o-3,3));o=0,s=r,0===i?(c=138,f=3):r==i?(c=6,f=3):(c=7,f=4)}}function $(){16==F?(Q(L),L=0,F=0):8>F||(J(255&L),L>>>=8,F-=8)}function ee(t,n){let s,i,o;if(e.Ne[W]=t,e.Oe[W]=255&n,W++,0===t?E[2*n]++:(j++,t--,E[2*(Ue.ge[n]+256+1)]++,M[2*Ue.Se(t)]++),0==(8191&W)&&V>2){for(s=8*W,i=C-k,o=0;30>o;o++)s+=M[2*o]*(5+Ue.Ce[o]);if(s>>>=3,j<r.floor(W/2)&&s<r.floor(i/2))return!0}return W==T-1}function te(t,n){let r,s,i,o,c=0;if(0!==W)do{r=e.Ne[c],s=e.Oe[c],c++,0===r?Y(s,t):(i=Ue.ge[s],Y(i+256+1,t),o=Ue.ze[i],0!==o&&(s-=Ue.ke[i],X(s,o)),r--,i=Ue.Se(r),Y(i,n),o=Ue.Ce[i],0!==o&&(r-=Ue.ve[i],X(r,o)))}while(W>c);Y(256,t),H=t[513]}function ne(){F>8?Q(L):F>0&&J(255&L),L=0,F=0}function re(t,n,r){X(0+(r?1:0),3),((t,n)=>{ne(),H=8,Q(n),Q(~n),e.Ke.set(u.subarray(t,t+n),e.pending),e.pending+=n})(t,n)}function se(n){((t,n,r)=>{let s,i,o=0;V>0?(K.ne(e),N.ne(e),o=(()=>{let t;for(G(E,K.he),G(M,N.he),O.ne(e),t=18;t>=3&&0===U[2*Ue._e[t]+1];t--);return e.ue+=14+3*(t+1),t})(),s=e.ue+3+7>>>3,i=e.we+3+7>>>3,i>s||(s=i)):s=i=n+5,n+4>s||-1==t?i==s?(X(2+(r?1:0),3),te(Ke.Ae,Ke.Be)):(X(4+(r?1:0),3),((e,t,n)=>{let r;for(X(e-257,5),X(t-1,5),X(n-4,4),r=0;n>r;r++)X(U[2*Ue._e[r]+1],3);Z(E,e-1),Z(M,t-1)})(K.he+1,N.he+1,o+1),te(E,M)):re(t,n,r),q(),r&&ne()})(0>k?-1:k,C-k,n),k=C,t.Te()}function ie(){let e,n,r,s;do{if(s=w-_-C,0===s&&0===C&&0===_)s=f;else if(-1==s)s--;else if(C>=f+f-Fe){u.set(u.subarray(f,f+f),0),x-=f,C-=f,k-=f,e=y,r=e;do{n=65535&d[--r],d[r]=f>n?0:n-f}while(0!=--e);e=f,r=e;do{n=65535&h[--r],h[r]=f>n?0:n-f}while(0!=--e);s+=f}if(0===t.We)return;e=t.je(u,C+_,s),_+=e,3>_||(p=255&u[C],p=(p<<g^255&u[C+1])&b)}while(Fe>_&&0!==t.We)}function oe(e){let t,n,r=I,s=C,i=A;const o=C>f-Fe?C-(f-Fe):0;let c=B;const a=l,w=C+258;let d=u[s+i-1],p=u[s+i];R>A||(r>>=2),c>_&&(c=_);do{if(t=e,u[t+i]==p&&u[t+i-1]==d&&u[t]==u[s]&&u[++t]==u[s+1]){s+=2,t++;do{}while(u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&w>s);if(n=258-(w-s),s=w-258,n>i){if(x=e,i=n,n>=c)break;d=u[s+i-1],p=u[s+i]}}}while((e=65535&h[e&a])>o&&0!=--r);return i>_?_:i}e.le=[],e.be=[],e.ae=[],E=[],M=[],U=[],e.de=(t,n)=>{const r=e.ae,s=r[n];let i=n<<1;for(;i<=e.ce&&(i<e.ce&&qe(t,r[i+1],r[i],e.le)&&i++,!qe(t,s,r[i],e.le));)r[n]=r[i],n=i,i<<=1;r[n]=s},e.He=(t,S,x,W,j,G)=>(W||(W=8),j||(j=8),G||(G=0),t.Le=null,-1==S&&(S=6),1>j||j>9||8!=W||9>x||x>15||0>S||S>9||0>G||G>2?Re:(t.Fe=e,a=x,f=1<<a,l=f-1,m=j+7,y=1<<m,b=y-1,g=r.floor((m+3-1)/3),u=new i(2*f),h=[],d=[],T=1<<j+6,e.Ke=new i(4*T),s=4*T,e.Ne=new o(T),e.Oe=new i(T),V=S,P=G,(t=>(t.qe=t.Ge=0,t.Le=null,e.pending=0,e.Je=0,n=He,c=0,K.re=E,K.ie=Ke.Ee,N.re=M,N.ie=Ke.Me,O.re=U,O.ie=Ke.Ue,L=0,F=0,H=8,q(),(()=>{w=2*f,d[y-1]=0;for(let e=0;y-1>e;e++)d[e]=0;D=We[V].De,R=We[V].Ie,B=We[V].Ve,I=We[V].Pe,C=0,k=0,_=0,v=A=2,z=0,p=0})(),0))(t))),e.Qe=()=>42!=n&&n!=He&&n!=Le?Re:(e.Oe=null,e.Ne=null,e.Ke=null,d=null,h=null,u=null,e.Fe=null,n==He?-3:0),e.Xe=(e,t,n)=>{let r=0;return-1==t&&(t=6),0>t||t>9||0>n||n>2?Re:(We[V].Re!=We[t].Re&&0!==e.qe&&(r=e.Ye(1)),V!=t&&(V=t,D=We[V].De,R=We[V].Ie,B=We[V].Ve,I=We[V].Pe),P=n,r)},e.Ze=(e,t,r)=>{let s,i=r,o=0;if(!t||42!=n)return Re;if(3>i)return 0;for(i>f-Fe&&(i=f-Fe,o=r-i),u.set(t.subarray(o,o+i),0),C=i,k=i,p=255&u[0],p=(p<<g^255&u[1])&b,s=0;i-3>=s;s++)p=(p<<g^255&u[s+2])&b,h[s&l]=d[p],d[p]=s;return 0},e.Ye=(r,i)=>{let o,w,m,I,R;if(i>4||0>i)return Re;if(!r.$e||!r.et&&0!==r.We||n==Le&&4!=i)return r.Le=je[4],Re;if(0===r.tt)return r.Le=je[7],-5;var B;if(t=r,I=c,c=i,42==n&&(w=8+(a-8<<4)<<8,m=(V-1&255)>>1,m>3&&(m=3),w|=m<<6,0!==C&&(w|=32),w+=31-w%31,n=He,J((B=w)>>8&255),J(255&B)),0!==e.pending){if(t.Te(),0===t.tt)return c=-1,0}else if(0===t.We&&I>=i&&4!=i)return t.Le=je[7],-5;if(n==Le&&0!==t.We)return r.Le=je[7],-5;if(0!==t.We||0!==_||0!=i&&n!=Le){switch(R=-1,We[V].Re){case 0:R=(e=>{let n,r=65535;for(r>s-5&&(r=s-5);;){if(1>=_){if(ie(),0===_&&0==e)return 0;if(0===_)break}if(C+=_,_=0,n=k+r,(0===C||C>=n)&&(_=C-n,C=n,se(!1),0===t.tt))return 0;if(C-k>=f-Fe&&(se(!1),0===t.tt))return 0}return se(4==e),0===t.tt?4==e?2:0:4==e?3:1})(i);break;case 1:R=(e=>{let n,r=0;for(;;){if(Fe>_){if(ie(),Fe>_&&0==e)return 0;if(0===_)break}if(3>_||(p=(p<<g^255&u[C+2])&b,r=65535&d[p],h[C&l]=d[p],d[p]=C),0===r||(C-r&65535)>f-Fe||2!=P&&(v=oe(r)),3>v)n=ee(0,255&u[C]),_--,C++;else if(n=ee(C-x,v-3),_-=v,v>D||3>_)C+=v,v=0,p=255&u[C],p=(p<<g^255&u[C+1])&b;else{v--;do{C++,p=(p<<g^255&u[C+2])&b,r=65535&d[p],h[C&l]=d[p],d[p]=C}while(0!=--v);C++}if(n&&(se(!1),0===t.tt))return 0}return se(4==e),0===t.tt?4==e?2:0:4==e?3:1})(i);break;case 2:R=(e=>{let n,r,s=0;for(;;){if(Fe>_){if(ie(),Fe>_&&0==e)return 0;if(0===_)break}if(3>_||(p=(p<<g^255&u[C+2])&b,s=65535&d[p],h[C&l]=d[p],d[p]=C),A=v,S=x,v=2,0!==s&&D>A&&f-Fe>=(C-s&65535)&&(2!=P&&(v=oe(s)),5>=v&&(1==P||3==v&&C-x>4096)&&(v=2)),3>A||v>A)if(0!==z){if(n=ee(0,255&u[C-1]),n&&se(!1),C++,_--,0===t.tt)return 0}else z=1,C++,_--;else{r=C+_-3,n=ee(C-1-S,A-3),_-=A-1,A-=2;do{++C>r||(p=(p<<g^255&u[C+2])&b,s=65535&d[p],h[C&l]=d[p],d[p]=C)}while(0!=--A);if(z=0,v=2,C++,n&&(se(!1),0===t.tt))return 0}}return 0!==z&&(n=ee(0,255&u[C-1]),z=0),se(4==e),0===t.tt?4==e?2:0:4==e?3:1})(i)}if(2!=R&&3!=R||(n=Le),0==R||2==R)return 0===t.tt&&(c=-1),0;if(1==R){if(1==i)X(2,3),Y(256,Ke.Ae),$(),9>1+H+10-F&&(X(2,3),Y(256,Ke.Ae),$()),H=7;else if(re(0,0,!1),3==i)for(o=0;y>o;o++)d[o]=0;if(t.Te(),0===t.tt)return c=-1,0}}return 4!=i?0:1}}function Je(){const e=this;e.nt=0,e.rt=0,e.We=0,e.qe=0,e.tt=0,e.Ge=0}function Qe(e){const t=new Je,n=(o=e&&e.chunkSize?e.chunkSize:65536)+5*(r.floor(o/16383)+1);var o;const c=new i(n);let f=e?e.level:-1;void 0===f&&(f=-1),t.He(f),t.$e=c,this.append=(e,r)=>{let o,f,a=0,l=0,u=0;const w=[];if(e.length){t.nt=0,t.et=e,t.We=e.length;do{if(t.rt=0,t.tt=n,o=t.Ye(0),0!=o)throw new s("deflating: "+t.Le);t.rt&&(t.rt==n?w.push(new i(c)):w.push(c.subarray(0,t.rt))),u+=t.rt,r&&t.nt>0&&t.nt!=a&&(r(t.nt),a=t.nt)}while(t.We>0||0===t.tt);return w.length>1?(f=new i(u),w.forEach((e=>{f.set(e,l),l+=e.length}))):f=w[0]?new i(w[0]):new i,f}},this.flush=()=>{let e,r,o=0,f=0;const a=[];do{if(t.rt=0,t.tt=n,e=t.Ye(4),1!=e&&0!=e)throw new s("deflating: "+t.Le);n-t.tt>0&&a.push(c.slice(0,t.rt)),f+=t.rt}while(t.We>0||0===t.tt);return t.Qe(),r=new i(f),a.forEach((e=>{r.set(e,o),o+=e.length})),r}}Je.prototype={He(e,t){const n=this;return n.Fe=new Ge,t||(t=15),n.Fe.He(n,e,t)},Ye(e){const t=this;return t.Fe?t.Fe.Ye(t,e):Re},Qe(){const e=this;if(!e.Fe)return Re;const t=e.Fe.Qe();return e.Fe=null,t},Xe(e,t){const n=this;return n.Fe?n.Fe.Xe(n,e,t):Re},Ze(e,t){const n=this;return n.Fe?n.Fe.Ze(n,e,t):Re},je(e,t,n){const r=this;let s=r.We;return s>n&&(s=n),0===s?0:(r.We-=s,e.set(r.et.subarray(r.nt,r.nt+s),t),r.nt+=s,r.qe+=s,s)},Te(){const e=this;let t=e.Fe.pending;t>e.tt&&(t=e.tt),0!==t&&(e.$e.set(e.Fe.Ke.subarray(e.Fe.Je,e.Fe.Je+t),e.rt),e.rt+=t,e.Fe.Je+=t,e.Ge+=t,e.tt-=t,e.Fe.pending-=t,0===e.Fe.pending&&(e.Fe.Je=0))}};const Xe=-2,Ye=-3,Ze=-5,$e=[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535],et=[96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,192,80,7,10,0,8,96,0,8,32,0,9,160,0,8,0,0,8,128,0,8,64,0,9,224,80,7,6,0,8,88,0,8,24,0,9,144,83,7,59,0,8,120,0,8,56,0,9,208,81,7,17,0,8,104,0,8,40,0,9,176,0,8,8,0,8,136,0,8,72,0,9,240,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,200,81,7,13,0,8,100,0,8,36,0,9,168,0,8,4,0,8,132,0,8,68,0,9,232,80,7,8,0,8,92,0,8,28,0,9,152,84,7,83,0,8,124,0,8,60,0,9,216,82,7,23,0,8,108,0,8,44,0,9,184,0,8,12,0,8,140,0,8,76,0,9,248,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,196,81,7,11,0,8,98,0,8,34,0,9,164,0,8,2,0,8,130,0,8,66,0,9,228,80,7,7,0,8,90,0,8,26,0,9,148,84,7,67,0,8,122,0,8,58,0,9,212,82,7,19,0,8,106,0,8,42,0,9,180,0,8,10,0,8,138,0,8,74,0,9,244,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,204,81,7,15,0,8,102,0,8,38,0,9,172,0,8,6,0,8,134,0,8,70,0,9,236,80,7,9,0,8,94,0,8,30,0,9,156,84,7,99,0,8,126,0,8,62,0,9,220,82,7,27,0,8,110,0,8,46,0,9,188,0,8,14,0,8,142,0,8,78,0,9,252,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,194,80,7,10,0,8,97,0,8,33,0,9,162,0,8,1,0,8,129,0,8,65,0,9,226,80,7,6,0,8,89,0,8,25,0,9,146,83,7,59,0,8,121,0,8,57,0,9,210,81,7,17,0,8,105,0,8,41,0,9,178,0,8,9,0,8,137,0,8,73,0,9,242,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,202,81,7,13,0,8,101,0,8,37,0,9,170,0,8,5,0,8,133,0,8,69,0,9,234,80,7,8,0,8,93,0,8,29,0,9,154,84,7,83,0,8,125,0,8,61,0,9,218,82,7,23,0,8,109,0,8,45,0,9,186,0,8,13,0,8,141,0,8,77,0,9,250,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,198,81,7,11,0,8,99,0,8,35,0,9,166,0,8,3,0,8,131,0,8,67,0,9,230,80,7,7,0,8,91,0,8,27,0,9,150,84,7,67,0,8,123,0,8,59,0,9,214,82,7,19,0,8,107,0,8,43,0,9,182,0,8,11,0,8,139,0,8,75,0,9,246,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,206,81,7,15,0,8,103,0,8,39,0,9,174,0,8,7,0,8,135,0,8,71,0,9,238,80,7,9,0,8,95,0,8,31,0,9,158,84,7,99,0,8,127,0,8,63,0,9,222,82,7,27,0,8,111,0,8,47,0,9,190,0,8,15,0,8,143,0,8,79,0,9,254,96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,193,80,7,10,0,8,96,0,8,32,0,9,161,0,8,0,0,8,128,0,8,64,0,9,225,80,7,6,0,8,88,0,8,24,0,9,145,83,7,59,0,8,120,0,8,56,0,9,209,81,7,17,0,8,104,0,8,40,0,9,177,0,8,8,0,8,136,0,8,72,0,9,241,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,201,81,7,13,0,8,100,0,8,36,0,9,169,0,8,4,0,8,132,0,8,68,0,9,233,80,7,8,0,8,92,0,8,28,0,9,153,84,7,83,0,8,124,0,8,60,0,9,217,82,7,23,0,8,108,0,8,44,0,9,185,0,8,12,0,8,140,0,8,76,0,9,249,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,197,81,7,11,0,8,98,0,8,34,0,9,165,0,8,2,0,8,130,0,8,66,0,9,229,80,7,7,0,8,90,0,8,26,0,9,149,84,7,67,0,8,122,0,8,58,0,9,213,82,7,19,0,8,106,0,8,42,0,9,181,0,8,10,0,8,138,0,8,74,0,9,245,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,205,81,7,15,0,8,102,0,8,38,0,9,173,0,8,6,0,8,134,0,8,70,0,9,237,80,7,9,0,8,94,0,8,30,0,9,157,84,7,99,0,8,126,0,8,62,0,9,221,82,7,27,0,8,110,0,8,46,0,9,189,0,8,14,0,8,142,0,8,78,0,9,253,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,195,80,7,10,0,8,97,0,8,33,0,9,163,0,8,1,0,8,129,0,8,65,0,9,227,80,7,6,0,8,89,0,8,25,0,9,147,83,7,59,0,8,121,0,8,57,0,9,211,81,7,17,0,8,105,0,8,41,0,9,179,0,8,9,0,8,137,0,8,73,0,9,243,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,203,81,7,13,0,8,101,0,8,37,0,9,171,0,8,5,0,8,133,0,8,69,0,9,235,80,7,8,0,8,93,0,8,29,0,9,155,84,7,83,0,8,125,0,8,61,0,9,219,82,7,23,0,8,109,0,8,45,0,9,187,0,8,13,0,8,141,0,8,77,0,9,251,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,199,81,7,11,0,8,99,0,8,35,0,9,167,0,8,3,0,8,131,0,8,67,0,9,231,80,7,7,0,8,91,0,8,27,0,9,151,84,7,67,0,8,123,0,8,59,0,9,215,82,7,19,0,8,107,0,8,43,0,9,183,0,8,11,0,8,139,0,8,75,0,9,247,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,207,81,7,15,0,8,103,0,8,39,0,9,175,0,8,7,0,8,135,0,8,71,0,9,239,80,7,9,0,8,95,0,8,31,0,9,159,84,7,99,0,8,127,0,8,63,0,9,223,82,7,27,0,8,111,0,8,47,0,9,191,0,8,15,0,8,143,0,8,79,0,9,255],tt=[80,5,1,87,5,257,83,5,17,91,5,4097,81,5,5,89,5,1025,85,5,65,93,5,16385,80,5,3,88,5,513,84,5,33,92,5,8193,82,5,9,90,5,2049,86,5,129,192,5,24577,80,5,2,87,5,385,83,5,25,91,5,6145,81,5,7,89,5,1537,85,5,97,93,5,24577,80,5,4,88,5,769,84,5,49,92,5,12289,82,5,13,90,5,3073,86,5,193,192,5,24577],nt=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],rt=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,112,112],st=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],it=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];function ot(){let e,t,n,r,s,i;function o(e,t,o,c,f,a,l,u,w,h,d){let p,y,m,b,g,k,v,S,z,C,x,_,A,I,D;C=0,g=o;do{n[e[t+C]]++,C++,g--}while(0!==g);if(n[0]==o)return l[0]=-1,u[0]=0,0;for(S=u[0],k=1;15>=k&&0===n[k];k++);for(v=k,k>S&&(S=k),g=15;0!==g&&0===n[g];g--);for(m=g,S>g&&(S=g),u[0]=S,I=1<<k;g>k;k++,I<<=1)if(0>(I-=n[k]))return Ye;if(0>(I-=n[g]))return Ye;for(n[g]+=I,i[1]=k=0,C=1,A=2;0!=--g;)i[A]=k+=n[C],A++,C++;g=0,C=0;do{0!==(k=e[t+C])&&(d[i[k]++]=g),C++}while(++g<o);for(o=i[m],i[0]=g=0,C=0,b=-1,_=-S,s[0]=0,x=0,D=0;m>=v;v++)for(p=n[v];0!=p--;){for(;v>_+S;){if(b++,_+=S,D=m-_,D=D>S?S:D,(y=1<<(k=v-_))>p+1&&(y-=p+1,A=v,D>k))for(;++k<D&&(y<<=1)>n[++A];)y-=n[A];if(D=1<<k,h[0]+D>1440)return Ye;s[b]=x=h[0],h[0]+=D,0!==b?(i[b]=g,r[0]=k,r[1]=S,k=g>>>_-S,r[2]=x-s[b-1]-k,w.set(r,3*(s[b-1]+k))):l[0]=x}for(r[1]=v-_,o>C?d[C]<c?(r[0]=256>d[C]?0:96,r[2]=d[C++]):(r[0]=a[d[C]-c]+16+64,r[2]=f[d[C++]-c]):r[0]=192,y=1<<v-_,k=g>>>_;D>k;k+=y)w.set(r,3*(x+k));for(k=1<<v-1;0!=(g&k);k>>>=1)g^=k;for(g^=k,z=(1<<_)-1;(g&z)!=i[b];)b--,_-=S,z=(1<<_)-1}return 0!==I&&1!=m?Ze:0}function c(o){let c;for(e||(e=[],t=[],n=new f(16),r=[],s=new f(15),i=new f(16)),t.length<o&&(t=[]),c=0;o>c;c++)t[c]=0;for(c=0;16>c;c++)n[c]=0;for(c=0;3>c;c++)r[c]=0;s.set(n.subarray(0,15),0),i.set(n.subarray(0,16),0)}this.st=(n,r,s,i,f)=>{let a;return c(19),e[0]=0,a=o(n,0,19,19,null,null,s,r,i,e,t),a==Ye?f.Le="oversubscribed dynamic bit lengths tree":a!=Ze&&0!==r[0]||(f.Le="incomplete dynamic bit lengths tree",a=Ye),a},this.it=(n,r,s,i,f,a,l,u,w)=>{let h;return c(288),e[0]=0,h=o(s,0,n,257,nt,rt,a,i,u,e,t),0!=h||0===i[0]?(h==Ye?w.Le="oversubscribed literal/length tree":-4!=h&&(w.Le="incomplete literal/length tree",h=Ye),h):(c(288),h=o(s,n,r,0,st,it,l,f,u,e,t),0!=h||0===f[0]&&n>257?(h==Ye?w.Le="oversubscribed distance tree":h==Ze?(w.Le="incomplete distance tree",h=Ye):-4!=h&&(w.Le="empty distance tree with lengths",h=Ye),h):0)}}function ct(){const e=this;let t,n,r,s,i=0,o=0,c=0,f=0,a=0,l=0,u=0,w=0,h=0,d=0;function p(e,t,n,r,s,i,o,c){let f,a,l,u,w,h,d,p,y,m,b,g,k,v,S,z;d=c.nt,p=c.We,w=o.ot,h=o.ct,y=o.write,m=y<o.read?o.read-y-1:o.end-y,b=$e[e],g=$e[t];do{for(;20>h;)p--,w|=(255&c.ft(d++))<<h,h+=8;if(f=w&b,a=n,l=r,z=3*(l+f),0!==(u=a[z]))for(;;){if(w>>=a[z+1],h-=a[z+1],0!=(16&u)){for(u&=15,k=a[z+2]+(w&$e[u]),w>>=u,h-=u;15>h;)p--,w|=(255&c.ft(d++))<<h,h+=8;for(f=w&g,a=s,l=i,z=3*(l+f),u=a[z];;){if(w>>=a[z+1],h-=a[z+1],0!=(16&u)){for(u&=15;u>h;)p--,w|=(255&c.ft(d++))<<h,h+=8;if(v=a[z+2]+(w&$e[u]),w>>=u,h-=u,m-=k,v>y){S=y-v;do{S+=o.end}while(0>S);if(u=o.end-S,k>u){if(k-=u,y-S>0&&u>y-S)do{o.lt[y++]=o.lt[S++]}while(0!=--u);else o.lt.set(o.lt.subarray(S,S+u),y),y+=u,S+=u,u=0;S=0}}else S=y-v,y-S>0&&2>y-S?(o.lt[y++]=o.lt[S++],o.lt[y++]=o.lt[S++],k-=2):(o.lt.set(o.lt.subarray(S,S+2),y),y+=2,S+=2,k-=2);if(y-S>0&&k>y-S)do{o.lt[y++]=o.lt[S++]}while(0!=--k);else o.lt.set(o.lt.subarray(S,S+k),y),y+=k,S+=k,k=0;break}if(0!=(64&u))return c.Le="invalid distance code",k=c.We-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ot=w,o.ct=h,c.We=p,c.qe+=d-c.nt,c.nt=d,o.write=y,Ye;f+=a[z+2],f+=w&$e[u],z=3*(l+f),u=a[z]}break}if(0!=(64&u))return 0!=(32&u)?(k=c.We-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ot=w,o.ct=h,c.We=p,c.qe+=d-c.nt,c.nt=d,o.write=y,1):(c.Le="invalid literal/length code",k=c.We-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ot=w,o.ct=h,c.We=p,c.qe+=d-c.nt,c.nt=d,o.write=y,Ye);if(f+=a[z+2],f+=w&$e[u],z=3*(l+f),0===(u=a[z])){w>>=a[z+1],h-=a[z+1],o.lt[y++]=a[z+2],m--;break}}else w>>=a[z+1],h-=a[z+1],o.lt[y++]=a[z+2],m--}while(m>=258&&p>=10);return k=c.We-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ot=w,o.ct=h,c.We=p,c.qe+=d-c.nt,c.nt=d,o.write=y,0}e.init=(e,i,o,c,f,a)=>{t=0,u=e,w=i,r=o,h=c,s=f,d=a,n=null},e.ut=(e,y,m)=>{let b,g,k,v,S,z,C,x=0,_=0,A=0;for(A=y.nt,v=y.We,x=e.ot,_=e.ct,S=e.write,z=S<e.read?e.read-S-1:e.end-S;;)switch(t){case 0:if(z>=258&&v>=10&&(e.ot=x,e.ct=_,y.We=v,y.qe+=A-y.nt,y.nt=A,e.write=S,m=p(u,w,r,h,s,d,e,y),A=y.nt,v=y.We,x=e.ot,_=e.ct,S=e.write,z=S<e.read?e.read-S-1:e.end-S,0!=m)){t=1==m?7:9;break}c=u,n=r,o=h,t=1;case 1:for(b=c;b>_;){if(0===v)return e.ot=x,e.ct=_,y.We=v,y.qe+=A-y.nt,y.nt=A,e.write=S,e.wt(y,m);m=0,v--,x|=(255&y.ft(A++))<<_,_+=8}if(g=3*(o+(x&$e[b])),x>>>=n[g+1],_-=n[g+1],k=n[g],0===k){f=n[g+2],t=6;break}if(0!=(16&k)){a=15&k,i=n[g+2],t=2;break}if(0==(64&k)){c=k,o=g/3+n[g+2];break}if(0!=(32&k)){t=7;break}return t=9,y.Le="invalid literal/length code",m=Ye,e.ot=x,e.ct=_,y.We=v,y.qe+=A-y.nt,y.nt=A,e.write=S,e.wt(y,m);case 2:for(b=a;b>_;){if(0===v)return e.ot=x,e.ct=_,y.We=v,y.qe+=A-y.nt,y.nt=A,e.write=S,e.wt(y,m);m=0,v--,x|=(255&y.ft(A++))<<_,_+=8}i+=x&$e[b],x>>=b,_-=b,c=w,n=s,o=d,t=3;case 3:for(b=c;b>_;){if(0===v)return e.ot=x,e.ct=_,y.We=v,y.qe+=A-y.nt,y.nt=A,e.write=S,e.wt(y,m);m=0,v--,x|=(255&y.ft(A++))<<_,_+=8}if(g=3*(o+(x&$e[b])),x>>=n[g+1],_-=n[g+1],k=n[g],0!=(16&k)){a=15&k,l=n[g+2],t=4;break}if(0==(64&k)){c=k,o=g/3+n[g+2];break}return t=9,y.Le="invalid distance code",m=Ye,e.ot=x,e.ct=_,y.We=v,y.qe+=A-y.nt,y.nt=A,e.write=S,e.wt(y,m);case 4:for(b=a;b>_;){if(0===v)return e.ot=x,e.ct=_,y.We=v,y.qe+=A-y.nt,y.nt=A,e.write=S,e.wt(y,m);m=0,v--,x|=(255&y.ft(A++))<<_,_+=8}l+=x&$e[b],x>>=b,_-=b,t=5;case 5:for(C=S-l;0>C;)C+=e.end;for(;0!==i;){if(0===z&&(S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z&&(e.write=S,m=e.wt(y,m),S=e.write,z=S<e.read?e.read-S-1:e.end-S,S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z)))return e.ot=x,e.ct=_,y.We=v,y.qe+=A-y.nt,y.nt=A,e.write=S,e.wt(y,m);e.lt[S++]=e.lt[C++],z--,C==e.end&&(C=0),i--}t=0;break;case 6:if(0===z&&(S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z&&(e.write=S,m=e.wt(y,m),S=e.write,z=S<e.read?e.read-S-1:e.end-S,S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z)))return e.ot=x,e.ct=_,y.We=v,y.qe+=A-y.nt,y.nt=A,e.write=S,e.wt(y,m);m=0,e.lt[S++]=f,z--,t=0;break;case 7:if(_>7&&(_-=8,v++,A--),e.write=S,m=e.wt(y,m),S=e.write,z=S<e.read?e.read-S-1:e.end-S,e.read!=e.write)return e.ot=x,e.ct=_,y.We=v,y.qe+=A-y.nt,y.nt=A,e.write=S,e.wt(y,m);t=8;case 8:return m=1,e.ot=x,e.ct=_,y.We=v,y.qe+=A-y.nt,y.nt=A,e.write=S,e.wt(y,m);case 9:return m=Ye,e.ot=x,e.ct=_,y.We=v,y.qe+=A-y.nt,y.nt=A,e.write=S,e.wt(y,m);default:return m=Xe,e.ot=x,e.ct=_,y.We=v,y.qe+=A-y.nt,y.nt=A,e.write=S,e.wt(y,m)}},e.ht=()=>{}}ot.dt=(e,t,n,r)=>(e[0]=9,t[0]=5,n[0]=et,r[0]=tt,0);const ft=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];function at(e,t){const n=this;let r,s=0,o=0,c=0,a=0;const l=[0],u=[0],w=new ct;let h=0,d=new f(4320);const p=new ot;n.ct=0,n.ot=0,n.lt=new i(t),n.end=t,n.read=0,n.write=0,n.reset=(e,t)=>{t&&(t[0]=0),6==s&&w.ht(e),s=0,n.ct=0,n.ot=0,n.read=n.write=0},n.reset(e,null),n.wt=(e,t)=>{let r,s,i;return s=e.rt,i=n.read,r=(i>n.write?n.end:n.write)-i,r>e.tt&&(r=e.tt),0!==r&&t==Ze&&(t=0),e.tt-=r,e.Ge+=r,e.$e.set(n.lt.subarray(i,i+r),s),s+=r,i+=r,i==n.end&&(i=0,n.write==n.end&&(n.write=0),r=n.write-i,r>e.tt&&(r=e.tt),0!==r&&t==Ze&&(t=0),e.tt-=r,e.Ge+=r,e.$e.set(n.lt.subarray(i,i+r),s),s+=r,i+=r),e.rt=s,n.read=i,t},n.ut=(e,t)=>{let i,f,y,m,b,g,k,v;for(m=e.nt,b=e.We,f=n.ot,y=n.ct,g=n.write,k=g<n.read?n.read-g-1:n.end-g;;){let S,z,C,x,_,A,I,D;switch(s){case 0:for(;3>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}switch(i=7&f,h=1&i,i>>>1){case 0:f>>>=3,y-=3,i=7&y,f>>>=i,y-=i,s=1;break;case 1:S=[],z=[],C=[[]],x=[[]],ot.dt(S,z,C,x),w.init(S[0],z[0],C[0],0,x[0],0),f>>>=3,y-=3,s=6;break;case 2:f>>>=3,y-=3,s=3;break;case 3:return f>>>=3,y-=3,s=9,e.Le="invalid block type",t=Ye,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t)}break;case 1:for(;32>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}if((~f>>>16&65535)!=(65535&f))return s=9,e.Le="invalid stored block lengths",t=Ye,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);o=65535&f,f=y=0,s=0!==o?2:0!==h?7:0;break;case 2:if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);if(0===k&&(g==n.end&&0!==n.read&&(g=0,k=g<n.read?n.read-g-1:n.end-g),0===k&&(n.write=g,t=n.wt(e,t),g=n.write,k=g<n.read?n.read-g-1:n.end-g,g==n.end&&0!==n.read&&(g=0,k=g<n.read?n.read-g-1:n.end-g),0===k)))return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);if(t=0,i=o,i>b&&(i=b),i>k&&(i=k),n.lt.set(e.je(m,i),g),m+=i,b-=i,g+=i,k-=i,0!=(o-=i))break;s=0!==h?7:0;break;case 3:for(;14>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}if(c=i=16383&f,(31&i)>29||(i>>5&31)>29)return s=9,e.Le="too many length or distance symbols",t=Ye,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);if(i=258+(31&i)+(i>>5&31),!r||r.length<i)r=[];else for(v=0;i>v;v++)r[v]=0;f>>>=14,y-=14,a=0,s=4;case 4:for(;4+(c>>>10)>a;){for(;3>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}r[ft[a++]]=7&f,f>>>=3,y-=3}for(;19>a;)r[ft[a++]]=0;if(l[0]=7,i=p.st(r,l,u,d,e),0!=i)return(t=i)==Ye&&(r=null,s=9),n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);a=0,s=5;case 5:for(;i=c,258+(31&i)+(i>>5&31)>a;){let o,w;for(i=l[0];i>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}if(i=d[3*(u[0]+(f&$e[i]))+1],w=d[3*(u[0]+(f&$e[i]))+2],16>w)f>>>=i,y-=i,r[a++]=w;else{for(v=18==w?7:w-14,o=18==w?11:3;i+v>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}if(f>>>=i,y-=i,o+=f&$e[v],f>>>=v,y-=v,v=a,i=c,v+o>258+(31&i)+(i>>5&31)||16==w&&1>v)return r=null,s=9,e.Le="invalid bit length repeat",t=Ye,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);w=16==w?r[v-1]:0;do{r[v++]=w}while(0!=--o);a=v}}if(u[0]=-1,_=[],A=[],I=[],D=[],_[0]=9,A[0]=6,i=c,i=p.it(257+(31&i),1+(i>>5&31),r,_,A,I,D,d,e),0!=i)return i==Ye&&(r=null,s=9),t=i,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);w.init(_[0],A[0],d,I[0],d,D[0]),s=6;case 6:if(n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,1!=(t=w.ut(n,e,t)))return n.wt(e,t);if(t=0,w.ht(e),m=e.nt,b=e.We,f=n.ot,y=n.ct,g=n.write,k=g<n.read?n.read-g-1:n.end-g,0===h){s=0;break}s=7;case 7:if(n.write=g,t=n.wt(e,t),g=n.write,k=g<n.read?n.read-g-1:n.end-g,n.read!=n.write)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);s=8;case 8:return t=1,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);case 9:return t=Ye,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);default:return t=Xe,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t)}}},n.ht=e=>{n.reset(e,null),n.lt=null,d=null},n.yt=(e,t,r)=>{n.lt.set(e.subarray(t,t+r),0),n.read=n.write=r},n.bt=()=>1==s?1:0}const lt=13,ut=[0,0,255,255];function wt(){const e=this;function t(e){return e&&e.gt?(e.qe=e.Ge=0,e.Le=null,e.gt.mode=7,e.gt.kt.reset(e,null),0):Xe}e.mode=0,e.method=0,e.vt=[0],e.St=0,e.marker=0,e.zt=0,e.Ct=t=>(e.kt&&e.kt.ht(t),e.kt=null,0),e.xt=(n,r)=>(n.Le=null,e.kt=null,8>r||r>15?(e.Ct(n),Xe):(e.zt=r,n.gt.kt=new at(n,1<<r),t(n),0)),e._t=(e,t)=>{let n,r;if(!e||!e.gt||!e.et)return Xe;const s=e.gt;for(t=4==t?Ze:0,n=Ze;;)switch(s.mode){case 0:if(0===e.We)return n;if(n=t,e.We--,e.qe++,8!=(15&(s.method=e.ft(e.nt++)))){s.mode=lt,e.Le="unknown compression method",s.marker=5;break}if(8+(s.method>>4)>s.zt){s.mode=lt,e.Le="invalid win size",s.marker=5;break}s.mode=1;case 1:if(0===e.We)return n;if(n=t,e.We--,e.qe++,r=255&e.ft(e.nt++),((s.method<<8)+r)%31!=0){s.mode=lt,e.Le="incorrect header check",s.marker=5;break}if(0==(32&r)){s.mode=7;break}s.mode=2;case 2:if(0===e.We)return n;n=t,e.We--,e.qe++,s.St=(255&e.ft(e.nt++))<<24&4278190080,s.mode=3;case 3:if(0===e.We)return n;n=t,e.We--,e.qe++,s.St+=(255&e.ft(e.nt++))<<16&16711680,s.mode=4;case 4:if(0===e.We)return n;n=t,e.We--,e.qe++,s.St+=(255&e.ft(e.nt++))<<8&65280,s.mode=5;case 5:return 0===e.We?n:(n=t,e.We--,e.qe++,s.St+=255&e.ft(e.nt++),s.mode=6,2);case 6:return s.mode=lt,e.Le="need dictionary",s.marker=0,Xe;case 7:if(n=s.kt.ut(e,n),n==Ye){s.mode=lt,s.marker=0;break}if(0==n&&(n=t),1!=n)return n;n=t,s.kt.reset(e,s.vt),s.mode=12;case 12:return e.We=0,1;case lt:return Ye;default:return Xe}},e.At=(e,t,n)=>{let r=0,s=n;if(!e||!e.gt||6!=e.gt.mode)return Xe;const i=e.gt;return s<1<<i.zt||(s=(1<<i.zt)-1,r=n-s),i.kt.yt(t,r,s),i.mode=7,0},e.It=e=>{let n,r,s,i,o;if(!e||!e.gt)return Xe;const c=e.gt;if(c.mode!=lt&&(c.mode=lt,c.marker=0),0===(n=e.We))return Ze;for(r=e.nt,s=c.marker;0!==n&&4>s;)e.ft(r)==ut[s]?s++:s=0!==e.ft(r)?0:4-s,r++,n--;return e.qe+=r-e.nt,e.nt=r,e.We=n,c.marker=s,4!=s?Ye:(i=e.qe,o=e.Ge,t(e),e.qe=i,e.Ge=o,c.mode=7,0)},e.Dt=e=>e&&e.gt&&e.gt.kt?e.gt.kt.bt():Xe}function ht(){}function dt(e){const t=new ht,n=e&&e.chunkSize?r.floor(2*e.chunkSize):131072,o=new i(n);let c=!1;t.xt(),t.$e=o,this.append=(e,r)=>{const f=[];let a,l,u=0,w=0,h=0;if(0!==e.length){t.nt=0,t.et=e,t.We=e.length;do{if(t.rt=0,t.tt=n,0!==t.We||c||(t.nt=0,c=!0),a=t._t(0),c&&a===Ze){if(0!==t.We)throw new s("inflating: bad input")}else if(0!==a&&1!==a)throw new s("inflating: "+t.Le);if((c||1===a)&&t.We===e.length)throw new s("inflating: bad input");t.rt&&(t.rt===n?f.push(new i(o)):f.push(o.subarray(0,t.rt))),h+=t.rt,r&&t.nt>0&&t.nt!=u&&(r(t.nt),u=t.nt)}while(t.We>0||0===t.tt);return f.length>1?(l=new i(h),f.forEach((e=>{l.set(e,w),w+=e.length}))):l=f[0]?new i(f[0]):new i,l}},this.flush=()=>{t.Ct()}}ht.prototype={xt(e){const t=this;return t.gt=new wt,e||(e=15),t.gt.xt(t,e)},_t(e){const t=this;return t.gt?t.gt._t(t,e):Xe},Ct(){const e=this;if(!e.gt)return Xe;const t=e.gt.Ct(e);return e.gt=null,t},It(){const e=this;return e.gt?e.gt.It(e):Xe},At(e,t){const n=this;return n.gt?n.gt.At(n,e,t):Xe},ft(e){return this.et[e]},je(e,t){return this.et.subarray(e,e+t)}},self.initCodec=()=>{self.Deflate=Qe,self.Inflate=dt};\n'],{type:"text/javascript"}));e({workerScripts:{inflate:[t],deflate:[t]}})})($),e.BlobReader=Ut,e.BlobWriter=Lt,e.Data64URIReader=class extends Et{constructor(e){super();let t=e.length;for(;"="==e.charAt(t-1);)t--;const r=e.indexOf(",")+1;n.assign(this,{dataURI:e,dataStart:r,size:a.floor(.75*(t-r))})}readUint8Array(e,t){const{dataStart:n,dataURI:r}=this,s=new w(t),i=4*a.floor(e/3),o=atob(r.substring(i+n,4*a.ceil((e+t)/3)+n)),c=e-3*a.floor(i/4);for(let e=c;c+t>e;e++)s[e-c]=o.charCodeAt(e);return s}},e.Data64URIWriter=class extends Tt{constructor(e){super(),n.assign(this,{data:"data:"+(e||"")+";base64,",pending:[]})}writeUint8Array(e){const t=this;let n=0,s=t.pending;const i=t.pending.length;for(t.pending="",n=0;n<3*a.floor((i+e.length)/3)-i;n++)s+=r.fromCharCode(e[n]);for(;n<e.length;n++)t.pending+=r.fromCharCode(e[n]);s.length>2?t.data+=_(s):t.pending=s}getData(){return this.data+_(this.pending)}},e.ERR_BAD_FORMAT=Cn,e.ERR_CENTRAL_DIRECTORY_NOT_FOUND=Wn,e.ERR_DUPLICATED_NAME=$n,e.ERR_ENCRYPTED=En,e.ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND=Dn,e.ERR_EOCDR_NOT_FOUND=xn,e.ERR_EOCDR_ZIP64_NOT_FOUND=An,e.ERR_EXTRAFIELD_ZIP64_NOT_FOUND=Fn,e.ERR_HTTP_RANGE=Ct,e.ERR_INVALID_COMMENT=Qn,e.ERR_INVALID_ENCRYPTION_STRENGTH=rr,e.ERR_INVALID_ENTRY_COMMENT=er,e.ERR_INVALID_ENTRY_NAME=tr,e.ERR_INVALID_EXTRAFIELD_DATA=ir,e.ERR_INVALID_EXTRAFIELD_TYPE=sr,e.ERR_INVALID_PASSWORD=fe,e.ERR_INVALID_SIGNATURE=de,e.ERR_INVALID_VERSION=nr,e.ERR_ITERATOR_COMPLETED_TOO_SOON=xt,e.ERR_LOCAL_FILE_HEADER_NOT_FOUND=Rn,e.ERR_SPLIT_ZIP_FILE=Ln,e.ERR_UNSUPPORTED_COMPRESSION=Un,e.ERR_UNSUPPORTED_ENCRYPTION=Tn,e.ERR_UNSUPPORTED_FORMAT=ar,e.HttpRangeReader=class extends jt{constructor(e,t={}){t.useRangeHeader=!0,super(e,t)}},e.HttpReader=jt,e.Reader=Et,e.SplitDataReader=Gt,e.SplitDataWriter=Jt,e.SplitZipReader=nn,e.SplitZipWriter=rn,e.TextReader=class extends Ut{constructor(e){super(new m([e],{type:"text/plain"}))}},e.TextWriter=class extends Lt{constructor(e){super(e),n.assign(this,{encoding:e,utf8:!e||"utf-8"==e.toLowerCase()})}async getData(){const{encoding:e,utf8:t}=this,r=await super.getData();if(r.text&&t)return r.text();{const t=new FileReader;return new y(((s,i)=>{n.assign(t,{onload:({target:e})=>s(e.result),onerror:()=>i(t.error)}),t.readAsText(r,e)}))}}},e.Uint8ArrayReader=class extends Et{constructor(e){super(),n.assign(this,{array:e,size:e.length})}readUint8Array(e,t){return this.array.slice(e,e+t)}},e.Uint8ArrayWriter=class extends Tt{init(e=0){n.assign(this,{offset:0,array:new w(e)}),super.init()}writeUint8Array(e){const t=this;if(t.offset+e.length>t.array.length){const n=t.array;t.array=new w(n.length+e.length),t.array.set(n)}t.array.set(e,t.offset),t.offset+=e.length}getData(){return this.array}},e.Writer=Tt,e.ZipReader=class{constructor(e,t={}){n.assign(this,{reader:Qt(e),options:t,config:G()})}async*getEntriesGenerator(e={}){const t=this;let{reader:r}=t;const{config:s}=t;if(await $t(r),r.size!==B&&r.readUint8Array||(r=new Ut(await new u(r.readable).blob()),await $t(r)),22>r.size)throw new d(Cn);r.chunkSize=J(s);const i=await(async(e,t,n)=>{const r=new w(4);return Jn(r).setUint32(0,101010256,!0),await s(22)||await s(a.min(1048582,n));async function s(t){const s=n-t,i=await tn(e,s,t);for(let e=i.length-22;e>=0;e--)if(i[e]==r[0]&&i[e+1]==r[1]&&i[e+2]==r[2]&&i[e+3]==r[3])return{offset:s+e,buffer:i.slice(e,e+22).buffer}}})(r,0,r.size);if(!i)throw jn(Jn(await tn(r,0,4)))==U?new d(Ln):new d(xn);const o=Jn(i);let c=jn(o,12),l=jn(o,16);const f=i.offset,h=Xn(o,20),p=f+22+h;let g=Xn(o,4);const m=r.lastDiskNumber||0;let b=Xn(o,6),S=Xn(o,8),k=0,z=0;if(l==F||c==F||S==E||b==E){const e=Jn(await tn(r,i.offset-20,20));if(jn(e,0)!=N)throw new d(An);l=Gn(e,8);let t=await tn(r,l,56,-1),n=Jn(t);const s=i.offset-20-56;if(jn(n,0)!=I&&l!=s){const e=l;l=s,k=l-e,t=await tn(r,l,56,-1),n=Jn(t)}if(jn(n,0)!=I)throw new d(Dn);g==E&&(g=jn(n,16)),b==E&&(b=jn(n,20)),S==E&&(S=Gn(n,32)),c==F&&(c=Gn(n,40)),l-=c}if(m!=g)throw new d(Ln);if(0>l||l>=r.size)throw new d(Cn);let _=0,v=await tn(r,l,c,b),C=Jn(v);if(c){const e=i.offset-c;if(jn(C,_)!=L&&l!=e){const t=l;l=e,k=l-t,v=await tn(r,l,c,b),C=Jn(v)}}const x=i.offset-l-(r.lastDiskOffset||0);if(c==x||0>x||(c=x,v=await tn(r,l,c,b),C=Jn(v)),0>l||l>=r.size)throw new d(Cn);const A=Hn(t,e,"filenameEncoding"),D=Hn(t,e,"commentEncoding");for(let i=0;S>i;i++){const o=new Mn(r,s,t.options);if(jn(C,_)!=L)throw new d(Wn);Vn(o,C,_+6);const c=!!o.bitFlag.languageEncodingFlag,l=_+46,u=l+o.filenameLength,f=u+o.extraFieldLength,w=Xn(C,_+4),h=0==(0&w),p=v.subarray(l,u),g=Xn(C,_+32),m=f+g,b=v.subarray(f,m),x=c,W=c,R=h&&16==(16&Zn(C,_+38)),F=jn(C,_+42)+k;n.assign(o,{versionMadeBy:w,msDosCompatible:h,compressedSize:0,uncompressedSize:0,commentLength:g,directory:R,offset:F,diskNumberStart:Xn(C,_+34),internalFileAttribute:Xn(C,_+36),externalFileAttribute:jn(C,_+38),rawFilename:p,filenameUTF8:x,commentUTF8:W,rawExtraField:v.subarray(u,f)});const[E,T]=await y.all([an(p,x?In:A||Nn),an(b,W?In:D||Nn)]);n.assign(o,{rawComment:b,filename:E,comment:T,directory:R||E.endsWith(M)}),z=a.max(F,z),await Pn(o,o,C,_+6);const U=new vn(o);U.getData=(e,t)=>o.getData(e,U,t),_=m;const{onprogress:I}=e;if(I)try{await I(i+1,S,new vn(o))}catch(e){}yield U}const W=Hn(t,e,"extractPrependedData"),R=Hn(t,e,"extractAppendedData");return W&&(t.prependedData=z>0?await tn(r,0,z):new w),t.comment=h?await tn(r,f+22,h):new w,R&&(t.appendedData=p<r.size?await tn(r,p,r.size-p):new w),!0}async getEntries(e={}){const t=[];for await(const n of this.getEntriesGenerator(e))t.push(n);return t}async close(){}},e.ZipWriter=class{constructor(e,t={}){e=en(e),n.assign(this,{writer:e,addSplitZipSignature:e instanceof Jt,options:t,config:G(),files:new c,filenames:new l,offset:e.writable.size,pendingEntriesSize:0,pendingAddFileCalls:new l,bufferedWrites:0})}async add(e="",r,s={}){const c=this,{pendingAddFileCalls:l,config:u}=c;let f;cr<u.maxWorkers?cr++:await new y((e=>lr.push(e)));try{if(e=e.trim(),c.filenames.has(e))throw new d($n);return c.filenames.add(e),f=(async(e,r,s,c)=>{r=r.trim(),c.directory&&!r.endsWith(M)?r+=M:c.directory=r.endsWith(M);const l=se(r);if(br(l)>E)throw new d(tr);const u=c.comment||"",f=se(u);if(br(f)>E)throw new d(er);const m=dr(e,c,"version",20);if(m>E)throw new d(nr);const b=dr(e,c,"versionMadeBy",20);if(b>E)throw new d(nr);const S=dr(e,c,pn,new o),k=dr(e,c,mn),z=dr(e,c,yn),_=dr(e,c,kn,!0),v=dr(e,c,bn,0),C=dr(e,c,Sn,0),x=dr(e,c,"password"),A=dr(e,c,"encryptionStrength",3),D=dr(e,c,"zipCrypto"),W=dr(e,c,"extendedTimestamp",!0),R=dr(e,c,"keepOrder",!0),L=dr(e,c,"level"),I=dr(e,c,"useWebWorkers"),N=dr(e,c,"bufferedWrite"),H=dr(e,c,"dataDescriptorSignature",!1),K=dr(e,c,"signal"),Y=dr(e,c,"useCompressionStream");let Z=dr(e,c,"dataDescriptor",!0),X=dr(e,c,zn);if(x!==B&&A!==B&&(1>A||A>3))throw new d(rr);let j=new w;const{extraField:G}=c;if(G){let e=0,t=0;G.forEach((t=>e+=4+br(t))),j=new w(e),G.forEach(((e,n)=>{if(n>E)throw new d(sr);if(br(e)>E)throw new d(ir);mr(j,new h([n]),t),mr(j,new h([br(e)]),t+2),mr(j,e,t+4),t+=4+br(e)}))}let $=0,Q=0,ee=0;const te=!0===X;s&&(s=Qt(s),await $t(s),s.size===B?(Z=!0,(X||X===B)&&(X=!0,ee=$=F)):(ee=s.size,$=(e=>e+5*(a.floor(e/16383)+1))(ee)));const{diskOffset:ne,diskNumber:re,maxSize:ie}=e.writer,ae=te||ee>=F,oe=te||$>=F,ce=te||e.offset+e.pendingEntriesSize-ne>=F,le=dr(e,c,"supportZip64SplitFile",!0)&&te||re+a.ceil(e.pendingEntriesSize/ie)>=E;if(ce||ae||oe||le){if(!1===X||!R)throw new d(ar);X=!0}X=X||!1;const ue=(e=>{const{rawFilename:t,lastModDate:n,lastAccessDate:r,creationDate:s,password:i,level:o,zip64:c,zipCrypto:l,dataDescriptor:u,directory:f,rawExtraField:d,encryptionStrength:h,extendedTimestamp:g}=e,m=0!==o&&!f,y=!(!i||!br(i));let b,S,k,z=e.version;if(y&&!l){b=new w(br(or)+2);const e=yr(b);hr(e,0,39169),mr(b,or,2),wr(e,8,h)}else b=new w;if(g){k=new w(9+(r?4:0)+(s?4:0));const e=yr(k);hr(e,0,q),hr(e,2,br(k)-4),wr(e,4,1+(r?2:0)+(s?4:0)),pr(e,5,a.floor(n.getTime()/1e3)),r&&pr(e,9,a.floor(r.getTime()/1e3)),s&&pr(e,13,a.floor(s.getTime()/1e3));try{S=new w(36);const e=yr(S),t=fr(n);hr(e,0,10),hr(e,2,32),hr(e,8,1),hr(e,10,24),gr(e,12,t),gr(e,20,fr(r)||t),gr(e,28,fr(s)||t)}catch(e){S=new w}}else S=k=new w;let _=O;u&&(_|=8);let v=0;m&&(v=8),c&&(z=z>45?z:45),y&&(_|=1,l||(z=z>51?z:51,v=99,m&&(b[9]=8)));const C=new w(26),x=yr(C);hr(x,0,z),hr(x,2,_),hr(x,4,v);const A=new p(1),D=yr(A);let W;W=P>n?P:n>V?V:n,hr(D,0,(W.getHours()<<6|W.getMinutes())<<5|W.getSeconds()/2),hr(D,2,(W.getFullYear()-1980<<4|W.getMonth()+1)<<5|W.getDate());const R=A[0];pr(x,6,R),hr(x,22,br(t));const F=br(b,k,S,d);hr(x,24,F);const E=new w(30+br(t)+F);return pr(yr(E),0,T),mr(E,C,4),mr(E,t,30),mr(E,b,30+br(t)),mr(E,k,30+br(t,b)),mr(E,S,30+br(t,b,k)),mr(E,d,30+br(t,b,k,S)),{localHeaderArray:E,headerArray:C,headerView:x,lastModDate:n,rawLastModDate:R,encrypted:y,compressed:m,version:z,compressionMethod:v,rawExtraFieldExtendedTimestamp:k,rawExtraFieldNTFS:S,rawExtraFieldAES:b}})(c=n.assign({},c,{rawFilename:l,rawComment:f,version:m,versionMadeBy:b,lastModDate:S,lastAccessDate:k,creationDate:z,rawExtraField:j,zip64:X,zip64UncompressedSize:ae,zip64CompressedSize:oe,zip64Offset:ce,zip64DiskNumberStart:le,password:x,level:L,useWebWorkers:I,encryptionStrength:A,extendedTimestamp:W,zipCrypto:D,bufferedWrite:N,keepOrder:R,dataDescriptor:Z,dataDescriptorSignature:H,signal:K,msDosCompatible:_,internalFileAttribute:v,externalFileAttribute:C,useCompressionStream:Y})),fe=(e=>{const{zip64:t,dataDescriptor:n,dataDescriptorSignature:r}=e;let s,i=new w,a=0;return n&&(i=new w(t?r?24:20:r?16:12),s=yr(i),r&&(a=4,pr(s,0,134695760))),{dataDescriptorArray:i,dataDescriptorView:s,dataDescriptorOffset:a}})(c),de=br(ue.localHeaderArray,fe.dataDescriptorArray);let we;Q=de+$,e.pendingEntriesSize+=Q;try{we=await(async(e,r,s,a,o)=>{const{files:c,writer:l}=e,{keepOrder:u,dataDescriptor:f,signal:h}=o,{headerInfo:p}=a,m=t.from(c.values()).pop();let b,S,k,z,_,v,C={};c.set(r,C);try{let t;u&&(t=m&&m.lock,C.lock=new y((e=>k=e))),o.bufferedWrite||e.writerLocked||e.bufferedWrites&&u||!f?(v=new Lt,v.writable.size=0,b=!0,e.bufferedWrites++,await $t(l)):(v=l,await x()),await $t(v);const{writable:p}=l;let{diskOffset:D}=l;if(e.addSplitZipSignature){delete e.addSplitZipSignature;const t=new w(4);pr(yr(t),0,U),await ur(p,t),e.offset+=4}b||(await t,await A(p));const{diskNumber:W}=l;if(_=!0,C.diskNumberStart=W,C=await(async(e,t,{diskNumberStart:r,lock:s},a,o,c)=>{const{headerInfo:l,dataDescriptorInfo:u,metadataSize:f}=a,{localHeaderArray:d,headerArray:h,lastModDate:p,rawLastModDate:g,encrypted:m,compressed:y,version:b,compressionMethod:S,rawExtraFieldExtendedTimestamp:k,rawExtraFieldNTFS:z,rawExtraFieldAES:_}=l,{dataDescriptorArray:v}=u,{rawFilename:C,lastAccessDate:x,creationDate:A,password:D,level:W,zip64:R,zip64UncompressedSize:E,zip64CompressedSize:T,zip64Offset:U,zip64DiskNumberStart:L,zipCrypto:I,dataDescriptor:N,directory:q,versionMadeBy:O,rawComment:M,rawExtraField:V,useWebWorkers:P,onstart:H,onprogress:K,onend:Y,signal:Z,encryptionStrength:X,extendedTimestamp:j,msDosCompatible:G,internalFileAttribute:$,externalFileAttribute:Q,useCompressionStream:ee}=c,te={lock:s,versionMadeBy:O,zip64:R,directory:!!q,filenameUTF8:!0,rawFilename:C,commentUTF8:!0,rawComment:M,rawExtraFieldExtendedTimestamp:k,rawExtraFieldNTFS:z,rawExtraFieldAES:_,rawExtraField:V,extendedTimestamp:j,msDosCompatible:G,internalFileAttribute:$,externalFileAttribute:Q,diskNumberStart:r};let ne,re=0,se=0;const{writable:ie}=t;if(e){e.chunkSize=J(o),await ur(ie,d);const t=e.readable,n=t.size=e.size,r={options:{codecType:at,level:W,password:D,encryptionStrength:X,zipCrypto:m&&I,passwordVerification:m&&I&&g>>8&255,signed:!0,compressed:y,encrypted:m,useWebWorkers:P,useCompressionStream:ee,transferStreams:!1},config:o,streamOptions:{signal:Z,size:n,onstart:H,onprogress:K,onend:Y}},s=await zt({readable:t,writable:ie},r);ie.size+=s.size,ne=s.signature,se=e.size=t.size,re=s.size}else await ur(ie,d);let ae;if(R){let e=4;E&&(e+=8),T&&(e+=8),U&&(e+=8),L&&(e+=4),ae=new w(e)}else ae=new w;return((e,t)=>{const{signature:n,rawExtraFieldZip64:r,compressedSize:s,uncompressedSize:a,headerInfo:o,dataDescriptorInfo:c}=e,{headerView:l,encrypted:u}=o,{dataDescriptorView:f,dataDescriptorOffset:d}=c,{zip64:w,zip64UncompressedSize:h,zip64CompressedSize:p,zipCrypto:g,dataDescriptor:m}=t;if(u&&!g||n===B||(pr(l,10,n),m&&pr(f,d,n)),w){const e=yr(r);hr(e,0,1),hr(e,2,r.length-4);let t=4;h&&(pr(l,18,F),gr(e,t,i(a)),t+=8),p&&(pr(l,14,F),gr(e,t,i(s))),m&&(gr(f,d+4,i(s)),gr(f,d+12,i(a)))}else pr(l,14,s),pr(l,18,a),m&&(pr(f,d+4,s),pr(f,d+8,a))})({signature:ne,rawExtraFieldZip64:ae,compressedSize:re,uncompressedSize:se,headerInfo:l,dataDescriptorInfo:u},c),N&&await ur(ie,v),n.assign(te,{uncompressedSize:se,compressedSize:re,lastModDate:p,rawLastModDate:g,creationDate:A,lastAccessDate:x,encrypted:m,length:f+re,compressionMethod:S,version:b,headerArray:h,signature:ne,rawExtraFieldZip64:ae,zip64UncompressedSize:E,zip64CompressedSize:T,zip64Offset:U,zip64DiskNumberStart:L}),te})(s,v,C,a,e.config,o),_=!1,c.set(r,C),C.filename=r,b){await v.writable.getWriter().close();let e=await v.getData();await t,await x(),z=!0,f||(e=await(async(e,t,n,{zipCrypto:r})=>{let s;s=await t.slice(0,26).arrayBuffer(),26!=s.byteLength&&(s=s.slice(0,26));const i=new g(s);return e.encrypted&&!r||pr(i,14,e.signature),e.zip64?(pr(i,18,F),pr(i,22,F)):(pr(i,18,e.compressedSize),pr(i,22,e.uncompressedSize)),await ur(n,new w(s)),t.slice(s.byteLength)})(C,e,p,o)),await A(p),C.diskNumberStart=l.diskNumber,D=l.diskOffset,await e.stream().pipeTo(p,{preventClose:!0,preventAbort:!0,signal:h}),p.size+=e.size,z=!1}if(C.offset=e.offset-D,C.zip64)((e,t)=>{const{rawExtraFieldZip64:n,offset:r,diskNumberStart:s}=e,{zip64UncompressedSize:a,zip64CompressedSize:o,zip64Offset:c,zip64DiskNumberStart:l}=t,u=yr(n);let f=4;a&&(f+=8),o&&(f+=8),c&&(gr(u,f,i(r)),f+=8),l&&pr(u,f,s)})(C,o);else if(C.offset>=F)throw new d(ar);return e.offset+=C.length,C}catch(t){if(b&&z||!b&&_){if(e.hasCorruptedEntries=!0,t)try{t.corruptedEntry=!0}catch(e){}b?e.offset+=v.writable.size:e.offset=v.writable.size}throw c.delete(r),t}finally{b&&e.bufferedWrites--,k&&k(),S&&S()}async function x(){e.writerLocked=!0;const{lockWriter:t}=e;e.lockWriter=new y((t=>S=()=>{e.writerLocked=!1,t()})),await t}async function A(e){p.localHeaderArray.length>l.availableSize&&(l.availableSize=0,await ur(e,new w))}})(e,r,s,{headerInfo:ue,dataDescriptorInfo:fe,metadataSize:de},c)}finally{e.pendingEntriesSize-=Q}return n.assign(we,{name:r,comment:u,extraField:G}),new vn(we)})(c,e,r,s),l.add(f),await f}catch(t){throw c.filenames.delete(e),t}finally{l.delete(f);const e=lr.shift();e?e():cr--}}async close(e=new w,n={}){const{pendingAddFileCalls:r,writer:s}=this,{writable:o}=s;for(;r.size;)await y.all(t.from(r));return await(async(e,n,r)=>{const{files:s,writer:o}=e,{diskOffset:c,writable:l}=o;let{diskNumber:u}=o,f=0,h=0,p=e.offset-c,g=s.size;for(const[,{rawFilename:e,rawExtraFieldZip64:t,rawExtraFieldAES:n,rawExtraField:r,rawComment:i,rawExtraFieldExtendedTimestamp:a,rawExtraFieldNTFS:o}]of s)h+=46+br(e,i,t,n,a,o,r);const m=new w(h),y=yr(m);await $t(o);let b=0;for(const[e,n]of t.from(s.values()).entries()){const{offset:t,rawFilename:i,rawExtraFieldZip64:c,rawExtraFieldAES:u,rawExtraFieldNTFS:d,rawExtraField:h,rawComment:p,versionMadeBy:g,headerArray:S,directory:k,zip64:z,zip64UncompressedSize:_,zip64CompressedSize:v,zip64DiskNumberStart:C,zip64Offset:x,msDosCompatible:A,internalFileAttribute:D,externalFileAttribute:W,extendedTimestamp:R,lastModDate:T,diskNumberStart:U,uncompressedSize:I,compressedSize:N}=n;let O;if(R){O=new w(9);const e=yr(O);hr(e,0,q),hr(e,2,br(O)-4),wr(e,4,1),pr(e,5,a.floor(T.getTime()/1e3))}else O=new w;const M=br(c,u,O,d,h);pr(y,f,L),hr(y,f+4,g);const V=yr(S);_||pr(V,18,I),v||pr(V,14,N),mr(m,S,f+6),hr(y,f+30,M),hr(y,f+32,br(p)),hr(y,f+34,z&&C?E:U),hr(y,f+36,D),W?pr(y,f+38,W):k&&A&&wr(y,f+38,16),pr(y,f+42,z&&x?F:t),mr(m,i,f+46),mr(m,c,f+46+br(i)),mr(m,u,f+46+br(i,c)),mr(m,O,f+46+br(i,c,u)),mr(m,d,f+46+br(i,c,u,O)),mr(m,h,f+46+br(i,c,u,O,d)),mr(m,p,f+46+br(i)+M);const P=46+br(i,p)+M;if(f-b>o.availableSize&&(o.availableSize=0,await ur(l,m.slice(b,f)),b=f),f+=P,r.onprogress)try{await r.onprogress(e+1,s.size,new vn(n))}catch(e){}}await ur(l,b?m.slice(b):m);let S=o.diskNumber;const{availableSize:k}=o;22>k&&S++;let z=dr(e,r,"zip64");if(!(F>p&&F>h&&E>g&&E>S)){if(!1===z)throw new d(ar);z=!0}const _=new w(z?98:22),v=yr(_);f=0,z&&(pr(v,0,I),gr(v,4,i(44)),hr(v,12,45),hr(v,14,45),pr(v,16,S),pr(v,20,u),gr(v,24,i(g)),gr(v,32,i(g)),gr(v,40,i(h)),gr(v,48,i(p)),pr(v,56,N),gr(v,64,i(p)+i(h)),pr(v,72,S+1),dr(e,r,"supportZip64SplitFile",!0)&&(S=E,u=E),g=E,p=F,h=F,f+=76),pr(v,f,101010256),hr(v,f+4,S),hr(v,f+6,u),hr(v,f+8,g),hr(v,f+10,g),pr(v,f+12,h),pr(v,f+16,p);const C=br(n);if(C){if(C>E)throw new d(Qn);hr(v,f+20,C)}await ur(l,_),C&&await ur(l,n)})(this,e,n),dr(this,n,"preventClose")||await o.getWriter().close(),s.getData?s.getData():o}},e.configure=$,e.getMimeType=()=>"application/octet-stream",e.initReader=Qt,e.initShimAsyncCodec=(e,t={},n)=>({Deflate:ee(e.Deflate,t.deflate,n),Inflate:ee(e.Inflate,t.inflate,n)}),e.initStream=$t,e.initWriter=en,e.readUint8Array=tn,e.terminateWorkers=()=>{bt.forEach((e=>{_t(e),e.terminate()}))},n.defineProperty(e,"__esModule",{value:!0})}));
var ZipManager = (function () {
    function ZipManager() {
    }
    ZipManager.zipCompress = function (fileName, data, onFin, password) {
        if (password === void 0) { password = "gc_zip"; }
        return __awaiter(this, void 0, void 0, function () {
            var zipFileWriter, zipWriter, textBlob, buffer, e_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!fileName || !data) {
                            onFin && onFin.apply(this, []);
                            return [2];
                        }
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 5, , 6]);
                        zipFileWriter = new zip.BlobWriter("application/zip");
                        zipWriter = new zip.ZipWriter(zipFileWriter);
                        return [4, zipWriter.add(fileName, new zip.TextReader(data), { password: password })];
                    case 2:
                        _b.sent();
                        return [4, zipWriter.close()];
                    case 3:
                        textBlob = _b.sent();
                        return [4, textBlob.arrayBuffer()];
                    case 4:
                        buffer = _b.sent();
                        onFin && onFin.apply(this, [buffer]);
                        return [3, 6];
                    case 5:
                        e_1 = _b.sent();
                        onFin && onFin.apply(this, []);
                        return [3, 6];
                    case 6: return [2];
                }
            });
        });
    };
    ZipManager.zipDeCompress = function (buffer, onFin, password) {
        if (password === void 0) { password = "gc_zip"; }
        return __awaiter(this, void 0, void 0, function () {
            var zipReader, firstEntry, zipUint8Array, zipText, e_2;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!buffer) {
                            onFin && onFin.apply(this, []);
                            return [2];
                        }
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 5, , 6]);
                        zipReader = new zip.ZipReader(new zip.Uint8ArrayReader(new Uint8Array(buffer)), { filenameEncoding: "utf-8" });
                        return [4, zipReader.getEntries()];
                    case 2:
                        firstEntry = (_b.sent()).shift();
                        return [4, firstEntry.getData(new zip.Uint8ArrayWriter(), { password: password })];
                    case 3:
                        zipUint8Array = _b.sent();
                        return [4, zipReader.close()];
                    case 4:
                        _b.sent();
                        zipText = new TextDecoder().decode(zipUint8Array.buffer);
                        onFin && onFin.apply(this, [zipText]);
                        return [3, 6];
                    case 5:
                        e_2 = _b.sent();
                        onFin && onFin.apply(this, []);
                        return [3, 6];
                    case 6: return [2];
                }
            });
        });
    };
    ZipManager.zipDeCompressText = function (text, onFin, password) {
        if (password === void 0) { password = "gc_zip"; }
        return __awaiter(this, void 0, void 0, function () {
            var bufferView, i, len, zipReader, firstEntry, zipUint8Array, zipText, e_3;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!text) {
                            onFin && onFin.apply(this, []);
                            return [2];
                        }
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 5, , 6]);
                        bufferView = new Uint8Array(text.length);
                        for (i = 0, len = text.length; i < len; i++) {
                            bufferView[i] = text.charCodeAt(i);
                        }
                        zipReader = new zip.ZipReader(new zip.Uint8ArrayReader(bufferView), { filenameEncoding: "utf-8" });
                        return [4, zipReader.getEntries()];
                    case 2:
                        firstEntry = (_b.sent()).shift();
                        return [4, firstEntry.getData(new zip.Uint8ArrayWriter(), { password: password })];
                    case 3:
                        zipUint8Array = _b.sent();
                        return [4, zipReader.close()];
                    case 4:
                        _b.sent();
                        zipText = new TextDecoder().decode(zipUint8Array.buffer);
                        onFin && onFin.apply(this, [zipText]);
                        return [3, 6];
                    case 5:
                        e_3 = _b.sent();
                        onFin && onFin.apply(this, []);
                        return [3, 6];
                    case 6: return [2];
                }
            });
        });
    };
    return ZipManager;
}());
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _a;
if (typeof top === "undefined") {
    top = this;
}
var mainDomain_gcide_common = _getAttributeFromParentPages('gcide_common');
var mainDomain_LGConfig = mainDomain_gcide_common === null || mainDomain_gcide_common === void 0 ? void 0 : mainDomain_gcide_common.LGConfig;
var mainDomain_kdsrpg = mainDomain_gcide_common === null || mainDomain_gcide_common === void 0 ? void 0 : mainDomain_gcide_common.kdsrpg;
var mainDomain_gcide = _getAttributeFromParentPages('gcide');
var mainDomain_LGNative = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.LGNative;
var mainDomain_TopCanvas = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.TopCanvas;
var mainDomain_LGPromptSigh = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.LGPromptSigh;
var mainDomain_LGWindow = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.LGWindow;
var mainDomain_LGProjectDevDataManager = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.LGProjectDevDataManager;
var mainDomain_CodeIDE = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.CodeIDE;
var mainDomain_FileObject = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.FileObject;
var mainDomain_LGSystem = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.LGSystem;
var mainDomain_LGQRCode = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.LGQRCode;
var mainDomain_DownloadFile = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.DownloadFile;
var mainDomain_LGProjectList = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.LGProjectList;
var mainDomain_ServerConnUtils = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.ServerConnUtils;
var mainDomain_GlobalEvent = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.GlobalEvent;
var mainDomain_LGUser = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.LGUser;
var mainDomain_LGMainMenu = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.LGMainMenu;
var mainDomain_setStartupWindowText = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.setStartupWindowText;
var mainDomain_closeStartupWindow = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.closeStartupWindow;
var mainDomain_KDSEncode = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.KDSEncode;
var mainDomain_gcide_core = _getAttributeFromParentPages('gcide_core');
var mainDomain_frameRef = mainDomain_gcide_core === null || mainDomain_gcide_core === void 0 ? void 0 : mainDomain_gcide_core.frameRef;
var mainDomain_stage = mainDomain_gcide_core === null || mainDomain_gcide_core === void 0 ? void 0 : mainDomain_gcide_core.stage;
var mainDomain_os = mainDomain_gcide_core === null || mainDomain_gcide_core === void 0 ? void 0 : mainDomain_gcide_core.os;
var mainDomain_DateUtils = mainDomain_gcide_core === null || mainDomain_gcide_core === void 0 ? void 0 : mainDomain_gcide_core.DateUtils;
var mainDomain_require = _getAttributeFromParentPages('require');
var mainDomain_nw_gui = mainDomain_require === null || mainDomain_require === void 0 ? void 0 : mainDomain_require('nw.gui');
var mainDomain_fs = mainDomain_require === null || mainDomain_require === void 0 ? void 0 : mainDomain_require('fs');
var mainDomain_child_process = mainDomain_require === null || mainDomain_require === void 0 ? void 0 : mainDomain_require('child_process');
var mainDomain_process = _getAttributeFromParentPages('process');
var mainDomain_nw = _getAttributeFromParentPages('nw');
var mainDomain_serverapi = _getAttributeFromParentPages('serverapi');
var mainDomain_Buffer = _getAttributeFromParentPages('Buffer');
function _getAttributeFromParentPages(attribute) {
    var result = globalThis[attribute];
    try {
        var _host = top.top;
        while (!result && !!_host) {
            result = _host[attribute];
            if (_host !== _host.top) {
                _host = _host.top;
            }
            else {
                _host = null;
            }
        }
    }
    catch (error) {
    }
    return result;
}
if (typeof top === "undefined") {
    top = this;
}
var mainDomain_gcide_common = _getAttributeFromParentPages('gcide_common');
var mainDomain_LGConfig = mainDomain_gcide_common === null || mainDomain_gcide_common === void 0 ? void 0 : mainDomain_gcide_common.LGConfig;
var mainDomain_kdsrpg = mainDomain_gcide_common === null || mainDomain_gcide_common === void 0 ? void 0 : mainDomain_gcide_common.kdsrpg;
var mainDomain_gcide = _getAttributeFromParentPages('gcide');
var mainDomain_LGNative = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.LGNative;
var mainDomain_TopCanvas = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.TopCanvas;
var mainDomain_LGPromptSigh = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.LGPromptSigh;
var mainDomain_LGWindow = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.LGWindow;
var mainDomain_LGProjectDevDataManager = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.LGProjectDevDataManager;
var mainDomain_CodeIDE = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.CodeIDE;
var mainDomain_FileObject = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.FileObject;
var mainDomain_LGSystem = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.LGSystem;
var mainDomain_LGQRCode = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.LGQRCode;
var mainDomain_DownloadFile = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.DownloadFile;
var mainDomain_LGProjectList = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.LGProjectList;
var mainDomain_ServerConnUtils = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.ServerConnUtils;
var mainDomain_GlobalEvent = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.GlobalEvent;
var mainDomain_LGUser = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.LGUser;
var mainDomain_LGMainMenu = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.LGMainMenu;
var mainDomain_setStartupWindowText = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.setStartupWindowText;
var mainDomain_closeStartupWindow = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.closeStartupWindow;
var mainDomain_KDSEncode = mainDomain_gcide === null || mainDomain_gcide === void 0 ? void 0 : mainDomain_gcide.KDSEncode;
var mainDomain_gcide_core = _getAttributeFromParentPages('gcide_core');
var mainDomain_frameRef = mainDomain_gcide_core === null || mainDomain_gcide_core === void 0 ? void 0 : mainDomain_gcide_core.frameRef;
var mainDomain_stage = mainDomain_gcide_core === null || mainDomain_gcide_core === void 0 ? void 0 : mainDomain_gcide_core.stage;
var mainDomain_os = mainDomain_gcide_core === null || mainDomain_gcide_core === void 0 ? void 0 : mainDomain_gcide_core.os;
var mainDomain_DateUtils = mainDomain_gcide_core === null || mainDomain_gcide_core === void 0 ? void 0 : mainDomain_gcide_core.DateUtils;
var mainDomain_require = _getAttributeFromParentPages('require');
var mainDomain_nw_gui = mainDomain_require === null || mainDomain_require === void 0 ? void 0 : mainDomain_require('nw.gui');
var mainDomain_fs = mainDomain_require === null || mainDomain_require === void 0 ? void 0 : mainDomain_require('fs');
var mainDomain_child_process = mainDomain_require === null || mainDomain_require === void 0 ? void 0 : mainDomain_require('child_process');
var mainDomain_process = _getAttributeFromParentPages('process');
var mainDomain_nw = _getAttributeFromParentPages('nw');
var mainDomain_serverapi = _getAttributeFromParentPages('serverapi');
var mainDomain_Buffer = _getAttributeFromParentPages('Buffer');
function _getAttributeFromParentPages(attribute) {
    var result = globalThis[attribute];
    try {
        var _host = top.top;
        while (!result && !!_host) {
            result = _host[attribute];
            if (_host !== _host.top) {
                _host = _host.top;
            }
            else {
                _host = null;
            }
        }
    }
    catch (error) {
    }
    return result;
}
var CommandExecute;
(function (CommandExecute) {
    var SayData = (function () {
        function SayData() {
        }
        SayData.parse = function (cmdParams) {
            var sayData = new SayData();
            sayData.dialogID = cmdParams[0];
            sayData.headImg = cmdParams[1] ? cmdParams[1] : "";
            sayData.name = cmdParams[2];
            sayData.playSpeed = cmdParams[3];
            sayData.dialogMode = cmdParams[4];
            sayData.content = cmdParams[5];
            sayData.voice = cmdParams[6];
            sayData.standAvatarModeFace = cmdParams[7];
            sayData.dialogModeVariableID = cmdParams[8];
            sayData.nameColor = cmdParams[9];
            sayData.modifyVariableGather = cmdParams[10];
            return sayData;
        };
        return SayData;
    }());
    CommandExecute.SayData = SayData;
})(CommandExecute || (CommandExecute = {}));
var Command = (function () {
    function Command(type, params, id) {
        if (id === void 0) { id = null; }
        this.gotoLine = [];
        this.type = type;
        if (this.type == -1)
            this.empty = true;
        this.params = params;
        if (!id) {
            id = ObjectUtils.getRandID();
        }
        this.id = id;
    }
    Command.prototype.callExecuteFunction = function (triggerLineID, player, params, gameFunc) {
        if (gameFunc === void 0) { gameFunc = null; }
    };
    Object.defineProperty(Command.prototype, "customID", {
        get: function () {
            if (this.type < CommandPage.CUSTOM_COMMAND_START_ID) {
                return null;
            }
            return CommandPage.getCustomCmdDataID(this.type);
        },
        enumerable: false,
        configurable: true
    });
    Command.init = function (gameWorld) {
        Command.gameWorld = gameWorld;
    };
    Command.IDValueToNameValue = function (cmd) {
        var customParams = cmd.params[0];
        var newCustomParams = {};
        if (customParams && typeof customParams == "object") {
            var cmdType = CommandPage.getCustomCmdDataID(MathUtils.int(cmd.type));
            var customCommandTypeData = Common.customCommandTypeList.data[cmdType];
            if (customCommandTypeData) {
                var attrs = CustomCompositeSetting.getAllAttributes(customCommandTypeData, false);
                for (var s = 0; s < attrs.length; s++) {
                    var cusAttr = attrs[s];
                    var paramValue = customParams[cusAttr.id];
                    newCustomParams[cusAttr.varName] = paramValue;
                }
                var typeValues = {};
                for (var s = 0; s < attrs.length; s++) {
                    var cusAttr = attrs[s];
                    typeValues[cusAttr.varName] = CustomAttributeSetting.formatCustomDefaultValue(cusAttr, true);
                }
                var newCustomParams2 = {};
                CustomAttributeSetting.installAttributeFromRecordData(newCustomParams2, newCustomParams, attrs, typeValues, 4);
                return newCustomParams2;
            }
        }
        return {};
    };
    Command.getCMDIDByParam = function (cmdParam) {
        if (!cmdParam)
            return null;
        var cmdType = cmdParam[0];
        if (cmdType < CommandPage.CUSTOM_COMMAND_START_ID) {
            var idInfo = cmdParam[cmdParam.length - 1];
            if (idInfo && typeof idInfo == "object" && idInfo.___cmdID) {
                return idInfo;
            }
        }
        else {
            return { ___cmdID: cmdParam[2], disabled: cmdParam[3] };
        }
    };
    Command.isCMDID = function (value) {
        if (value && typeof value == "object") {
            return value.___cmdID ? true : false;
        }
        return false;
    };
    Command.ifNullSetDefaultValue = function (params, index, defaultValue) {
        var value = params[index];
        if (value == null || Command.isCMDID(value))
            params[index] = defaultValue;
    };
    Command.EVENT_SYSTEM_COMMAND_START = "EVENT_SYSTEM_COMMAND_START";
    return Command;
}());
(function (CommandExecute) {
    function getSceneObject(soIndex, trigger, triggerPlayer) {
        var targetSo;
        if (soIndex == -4) {
            return trigger.trigger;
        }
        if (soIndex == -3) {
            return null;
        }
        else if (soIndex == -2) {
            if (triggerPlayer)
                targetSo = triggerPlayer.sceneObject;
        }
        else if (soIndex == -1) {
            targetSo = trigger.executor;
        }
        else {
            targetSo = trigger.scene.sceneObjects[soIndex];
        }
        return targetSo;
    }
    CommandExecute.getSceneObject = getSceneObject;
})(CommandExecute || (CommandExecute = {}));
(function (CommandExecute) {
    function command_0(commandPage, cmd, trigger, triggerPlayer) {
        var bool;
        var params = cmd.params;
        switch (params[0]) {
            case 0:
                var value1 = getValue(params[1], params[2], params[16]);
                var value2 = getValue(params[4], params[5], params[17]);
                switch (params[3]) {
                    case 0:
                        bool = value1 === value2;
                        break;
                    case 1:
                        bool = value1 >= value2;
                        break;
                    case 2:
                        bool = (value1 > value2);
                        break;
                    case 3:
                        bool = (value1 <= value2);
                        break;
                    case 4:
                        bool = (value1 < value2);
                        break;
                    case 5:
                        bool = (value1 !== value2);
                        break;
                }
                break;
            case 1:
                switch (params[6]) {
                    case 0:
                        bool = Command.gameWorld.getWorldSwitch(params[7][0]) == (params[8] == 0 ? 1 : 0);
                        break;
                    case 1:
                        bool = trigger.triggerPlayer ? trigger.triggerPlayer.variable.getSwitch(params[7][1]) === (params[8] == 0 ? 1 : 0) : false;
                        break;
                    case 2:
                        var soIndex = params[7][2][0];
                        if (soIndex == -5)
                            soIndex = triggerPlayer.variable.getVariable(params[7][2][2]);
                        var targetSo = CommandExecute.getSceneObject(soIndex, trigger, triggerPlayer);
                        bool = targetSo ? (targetSo.getSwitchs(params[7][2][1]) === (params[8] == 0 ? 1 : 0)) : false;
                        break;
                }
                break;
            case 2:
                var str1 = getString(params[9], params[10], params[22]);
                var str2 = getString2(params[21], params[11], params[23]);
                var csymbol = params[20] ? params[20] : 0;
                switch (csymbol) {
                    case 0:
                        bool = str1 === str2;
                        break;
                    case 1:
                        bool = str1.indexOf(str2) !== -1;
                        break;
                    case 2:
                        bool = str1.indexOf(str2) === -1;
                        break;
                }
                break;
            case 3:
                bool = !!eval(params[14]);
                break;
            default:
                var customCommandID = MathUtils.int(params[0]) - 3;
                var customFunc = CustomCondition["f" + customCommandID];
                if (customFunc) {
                    bool = customFunc(trigger, params[15][1]);
                }
        }
        if (!bool) {
            if (cmd.gotoLine[0] != null) {
                trigger.goto(cmd.gotoLine[0]);
            }
            else {
                trigger.goto(cmd.gotoLine[1]);
            }
        }
        return;
        function getValue(valueType, param, customDataDisplay) {
            switch (valueType) {
                case 0:
                    return param[0];
                case 1:
                    return Command.gameWorld.getWorldVariable(param[1]);
                case 2:
                    if (!trigger || !trigger.triggerPlayer)
                        return 0;
                    return trigger.triggerPlayer.variable.getVariable(param[2]);
                case 3:
                    return CustomValueFunction["f" + (param[3] + 1)](trigger, triggerPlayer);
                case 4:
                    return CustomGameNumber["f" + customDataDisplay[0]](trigger, customDataDisplay[1]);
            }
        }
        function getString(strType, param, customParam) {
            switch (strType) {
                case 0:
                    return Command.gameWorld.getWorldString(param[0]);
                case 1:
                    if (!trigger || !trigger.triggerPlayer)
                        return "";
                    return trigger.triggerPlayer.variable.getString(param[1]);
                case 2:
                    if (!trigger || !trigger.triggerPlayer)
                        return "";
                    return CustomGameString["f" + customParam[0]](trigger, customParam[1]);
            }
        }
        function getString2(useGameStr, param, customParam) {
            if (!useGameStr) {
                var compiled = Variable.splitDynamicText(param);
                return Variable.margeDynamicText(compiled, triggerPlayer, trigger);
            }
            else {
                if (!trigger || !trigger.triggerPlayer)
                    return "";
                return CustomGameString["f" + customParam[0]](trigger, customParam[1]);
            }
        }
    }
    CommandExecute.command_0 = command_0;
    function precompile_0(commandPage, cmd, index) {
        var len = commandPage.commands.length;
        var indent = 0;
        var elseCmd;
        for (var i = index + 1; i < len; i++) {
            var targetCmd = commandPage.commands[i];
            if (!targetCmd)
                continue;
            if (targetCmd.type == 0) {
                indent++;
            }
            else if (indent == 0 && targetCmd.type == 1) {
                cmd.gotoLine[0] = (i + 1);
                elseCmd = targetCmd;
                elseCmd.link = elseCmd;
                elseCmd.insertable = true;
            }
            else if (targetCmd.type == 2) {
                if (indent == 0) {
                    if (elseCmd) {
                        elseCmd.gotoLine[0] = (i + 1);
                    }
                    cmd.gotoLine[1] = (i + 1);
                    cmd.link = targetCmd;
                    targetCmd.link = targetCmd;
                    targetCmd.insertable = true;
                    break;
                }
                else {
                    indent--;
                }
            }
        }
    }
    CommandExecute.precompile_0 = precompile_0;
})(CommandExecute || (CommandExecute = {}));
(function (CommandExecute) {
    function command_11(commandPage, cmd, trigger, triggerPlayer) {
        if (triggerPlayer) {
            var cmdIndex = commandPage.commands.indexOf(cmd);
            var nextCmd = commandPage.commands[cmdIndex + 1];
            if (nextCmd && nextCmd.type == 3 && (nextCmd.params[0] == 0 || nextCmd.params[0] == cmd.params[0])) {
            }
            else {
                trigger.pause = true;
                trigger.offset(1);
            }
            EventUtils.happen(triggerPlayer.sceneObject, Command.EVENT_SYSTEM_COMMAND_START, [0]);
            var name = Variable.margeDynamicText(cmd.paramsCompiled[0], triggerPlayer, trigger);
            var content = Variable.margeDynamicText(cmd.paramsCompiled[1], triggerPlayer, trigger);
            var socIndex = -1;
            if (cmd.params[4] != -5) {
                var targetSceneObject = CommandExecute.getSceneObject(cmd.params[4], trigger, triggerPlayer);
                socIndex = targetSceneObject ? targetSceneObject.index : -1;
            }
            else {
                var index = cmd.params[8] ? cmd.params[8] : 0;
                socIndex = triggerPlayer.variable.getVariable(index);
            }
            cmd.callExecuteFunction(trigger.id, trigger.triggerPlayer, [cmd.params[0], cmd.params[1], name, cmd.params[3],
                socIndex, content, cmd.params[6], cmd.params[7], cmd.params[9], cmd.id, cmd.params[10]]);
        }
    }
    CommandExecute.command_11 = command_11;
    function precompile_11(commandPage, cmd, index) {
        cmd.paramsCompiled = [];
        cmd.paramsCompiled[0] = Variable.splitDynamicText(cmd.params[2]);
        cmd.paramsCompiled[1] = Variable.splitDynamicText(cmd.params[5]);
    }
    CommandExecute.precompile_11 = precompile_11;
})(CommandExecute || (CommandExecute = {}));
(function (CommandExecute) {
    function command_12(commandPage, cmd, trigger, triggerPlayer, playerInput) {
        trigger.pause = true;
        trigger.offset(1);
        cmd.callExecuteFunction(trigger.id, trigger.triggerPlayer, []);
    }
    CommandExecute.command_12 = command_12;
})(CommandExecute || (CommandExecute = {}));
(function (CommandExecute) {
    function command_13(commandPage, cmd, trigger, triggerPlayer) {
        cmd.paramsCompiled[0].apply(this, arguments);
    }
    CommandExecute.command_13 = command_13;
    function precompile_13(commandPage, cmd, index) {
        var symbols = [null, "+", "-", "*", "/", "%", "^"];
        var symbolsForArr = ["=", "+=", "-=", "*=", "/=", "%=", "^="];
        var resultSetTypes = [[0, "Command.gameWorld.setWorldVariable"], [0, "Command.gameWorld.setWorldSwitch"], [0, "Command.gameWorld.setWorldString"],
            [0, "triggerPlayer.variable.setVariable"], [0, "triggerPlayer.variable.setSwitch"], [0, "triggerPlayer.variable.setString"], [0, "CommandExecute.setSwitchs"]];
        var resultGetTypes = [[0, "Command.gameWorld.getWorldVariable"], [0, "Command.gameWorld.getWorldSwitch"], [0, "Command.gameWorld.getWorldString"],
            [0, "triggerPlayer.variable.getVariable"], [0, "triggerPlayer.variable.getSwitch"], [0, "triggerPlayer.variable.getString"], [0, "CommandExecute.getSwitchs"]];
        var resultType = cmd.params[0];
        var varID = cmd.params[1];
        var resultVar = resultSetTypes[resultType];
        var symbolType = symbols[cmd.params[2]];
        var valueType = cmd.params[3];
        var valueExpression;
        var value;
        var finalExpression;
        var secondParamCompiled = "";
        if (valueType == 0) {
            if (resultType == 2 || resultType == 5) {
                if (cmd.params[15]) {
                    if (cmd.params[16]) {
                        value = "(CustomGameString.f" + (cmd.params[16][0]) + "(trigger,cmd.params[16][1]))";
                    }
                    else {
                        value = "";
                    }
                }
                else {
                    value = "Variable.margeDynamicText(cmd.paramsCompiled[1],triggerPlayer,trigger)";
                    secondParamCompiled = ",Variable.splitDynamicText(cmd.params[4])";
                }
            }
            else {
                var params4 = cmd.params[4];
                if ((resultType == 1 || resultType == 4 || resultType == 6) && params4 == 2 && cmd.params[14]) {
                    value = "(CustomCondition.f" + (cmd.params[14][0]) + "(trigger,cmd.params[14][1])?1:0)";
                }
                else {
                    value = params4;
                }
            }
        }
        else if (valueType == 1) {
            value = "Command.gameWorld.getWorldVariable(" + cmd.params[5] + ")";
        }
        else if (valueType == 2) {
            if (cmd.params[23])
                value = "triggerPlayer.variable.getVariable(triggerPlayer.variable.getVariable(" + cmd.params[6] + "))";
            else
                value = "triggerPlayer.variable.getVariable(" + cmd.params[6] + ")";
        }
        else if (valueType == 3) {
            var min = "triggerPlayer.variable.getVariable(" + cmd.params[20] + ")";
            var max = "triggerPlayer.variable.getVariable(" + cmd.params[21] + ")";
            if (cmd.params[19] == null || cmd.params[19] == 0) {
                value = "(MathUtils.rand(" + (cmd.params[7][1] - cmd.params[7][0]) + "+1)+" + cmd.params[7][0] + ")";
            }
            else if (cmd.params[19] == 1) {
                value = "(MathUtils.rand(" + max + " - " + min + " +1)+" + min + ")";
            }
            else if (cmd.params[19] == 2) {
                value = "(MathUtils.rand(" + cmd.params[7][1] + " - " + min + " +1)+" + min + ")";
            }
            else {
                value = "(MathUtils.rand(" + max + " - " + cmd.params[7][0] + " +1)+" + cmd.params[7][0] + ")";
            }
        }
        else if (valueType == 4) {
            value = "CustomValueFunction.f" + (cmd.params[8] + 1) + "(trigger,triggerPlayer)";
        }
        else if (valueType == 5) {
            if (cmd.params[10] && cmd.params[10].length > 0)
                value = "CustomGameNumber.f" + (cmd.params[10][0]) + "(trigger,cmd.params[10][1])";
        }
        if (resultVar[0] == 0) {
            if (symbolType) {
                var lastValue = resultGetTypes[resultType][1] + ("(" + varID + ")");
                if (cmd.params[18])
                    lastValue = resultGetTypes[resultType][1] + ("(triggerPlayer.variable.getVariable(" + varID + "))");
                if (symbolType == "^") {
                    valueExpression = "(Math.pow(" + lastValue + "," + value + "))";
                }
                else {
                    valueExpression = lastValue + symbolType + ("(" + value + ")");
                }
            }
            else {
                valueExpression = value;
            }
            if (cmd.params[12])
                valueExpression = "(Math.abs(" + valueExpression + "))";
            if (cmd.params[13])
                valueExpression = "CommandExecute.getSqrtNum(" + valueExpression + ")";
            if (cmd.params[11])
                valueExpression = "(Math.floor(" + valueExpression + "))";
            if (!cmd.params[11] && cmd.params[17]) {
                valueExpression = "CommandExecute.fomatFloat(" + valueExpression + "," + cmd.params[17] + ")";
            }
            if (resultType == 6) {
                finalExpression = resultVar[1] + ("(" + varID + ", " + valueExpression + ", " + cmd.params[9] + "," + cmd.params[22] + ", trigger, triggerPlayer) ");
            }
            else {
                finalExpression = resultVar[1] + ("(" + varID + ", " + valueExpression + ") ");
                if (cmd.params[18])
                    finalExpression = resultVar[1] + ("(triggerPlayer.variable.getVariable(" + varID + "), " + valueExpression + ") ");
            }
        }
        else {
            if (symbolType) {
                valueExpression = value;
            }
            else {
                valueExpression = value;
            }
            if (cmd.params[12])
                valueExpression = "(Math.abs(" + valueExpression + "))";
            if (cmd.params[13])
                valueExpression = "CommandExecute.getSqrtNum(" + valueExpression + ")";
            if (cmd.params[11])
                valueExpression = "(Math.floor(" + valueExpression + "))";
            if (!cmd.params[11] && cmd.params[17]) {
                valueExpression = "CommandExecute.fomatFloat(" + valueExpression + "," + cmd.params[17] + ")";
            }
            finalExpression = resultVar[1] + ("[" + varID + "]" + symbolsForArr[cmd.params[2]] + " " + valueExpression + " ");
            if (cmd.params[2] == 4) {
                finalExpression += "; " + resultVar[1] + " [" + varID + "] = Math.floor(" + resultVar[1] + "[" + varID + "]); ";
            }
        }
        var evalStr = "cmd.paramsCompiled = [function (commandPage, cmd, trigger, triggerPlayer) { " + finalExpression + "; }" + secondParamCompiled + "]";
        eval(evalStr);
    }
    CommandExecute.precompile_13 = precompile_13;
    function getSqrtNum(num) {
        if (num >= 0)
            return Math.sqrt(num);
        else
            return -Math.sqrt(Math.abs(num));
    }
    CommandExecute.getSqrtNum = getSqrtNum;
    function fomatFloat(value, n) {
        var f = value.toFixed(n);
        return parseFloat(f);
    }
    CommandExecute.fomatFloat = fomatFloat;
    function setSwitchs(index, value, id, varIndex, trigger, triggerPlayer) {
        if (id == -5)
            id = triggerPlayer.variable.getVariable(varIndex);
        var targetSo = CommandExecute.getSceneObject(id, trigger, triggerPlayer);
        if (targetSo) {
            targetSo.setSwitchs(index, value);
        }
    }
    CommandExecute.setSwitchs = setSwitchs;
    function getSwitchs(index, id, trigger, triggerPlayer) {
        var targetSo = CommandExecute.getSceneObject(id, trigger, triggerPlayer);
        if (targetSo) {
            return targetSo.getSwitchs(index);
        }
        return null;
    }
    CommandExecute.getSwitchs = getSwitchs;
})(CommandExecute || (CommandExecute = {}));
(function (CommandExecute) {
    function command_14(commandPage, cmd, trigger, triggerPlayer) {
        trigger.cmdReturn = true;
    }
    CommandExecute.command_14 = command_14;
})(CommandExecute || (CommandExecute = {}));
(function (CommandExecute) {
    CommandExecute.fragmentEvents = {};
    function command_15(commandPage, cmd, trigger, triggerPlayer) {
        var realSID = commandPage.id + "_" + commandPage.commands.indexOf(cmd);
        var fragmentPage = CommandExecute.fragmentEvents[realSID];
        if (!fragmentPage)
            fragmentPage = CommandExecute.fragmentEvents[realSID] = new CommandPage(cmd.params[2]);
        if (cmd.params[1]) {
            var newFETrigger = new CommandTrigger(CommandTrigger.COMMAND_MAIN_TYPE_FRAGMENT_EVENT, 0, trigger.scene, trigger.trigger, true, trigger.executor);
            fragmentPage.startTriggerEvent(newFETrigger, trigger.inputMessage, cmd.params[2]);
        }
        else {
            trigger.commandScope.push({ cmdPage: fragmentPage, index: 0, commonEventID: 0, fragmentCommands: cmd.params[2] });
        }
    }
    CommandExecute.command_15 = command_15;
})(CommandExecute || (CommandExecute = {}));
(function (CommandExecute) {
    function command_16(commandPage, cmd, trigger, triggerPlayer) {
        var commonEventID = MathUtils.int(cmd.params[0]);
        if (commonEventID < 0)
            return;
        var cmdPage = Command.gameWorld.commonEventPages[commonEventID];
        if (!cmdPage)
            return;
        if (cmd.params[1]) {
            var newFETrigger = new CommandTrigger(CommandTrigger.COMMAND_MAIN_TYPE_CALL_COMMON_EVENT, commonEventID, trigger.scene, trigger.trigger, true, trigger.executor);
            cmdPage.startTriggerEvent(newFETrigger, trigger.inputMessage, cmd.params[2]);
        }
        else {
            trigger.commandScope.push({ cmdPage: cmdPage, index: 0, commonEventID: commonEventID, fragmentCommands: null });
        }
    }
    CommandExecute.command_16 = command_16;
})(CommandExecute || (CommandExecute = {}));
(function (CommandExecute) {
    function command_17(commandPage, cmd, trigger, triggerPlayer) {
        if (cmd.params[2]) {
            var params = ObjectUtils.depthClone(cmd.params);
            if (cmd.params[3]) {
                params[0] = triggerPlayer.variable.getVariable(cmd.params[0]);
            }
            cmd.callExecuteFunction(trigger.id, triggerPlayer, params);
        }
        else {
            trigger.pause = true;
            trigger.offset(1);
            if (cmd.params[1] == 1) {
                trigger.waitTime(cmd.params[3] ? triggerPlayer.variable.getVariable(cmd.params[0]) : cmd.params[0]);
            }
            else {
                trigger.waitFrame(cmd.params[3] ? triggerPlayer.variable.getVariable(cmd.params[0]) : cmd.params[0]);
            }
        }
    }
    CommandExecute.command_17 = command_17;
    function commandContinue_17() {
    }
    CommandExecute.commandContinue_17 = commandContinue_17;
})(CommandExecute || (CommandExecute = {}));
(function (CommandExecute) {
    function command_19(commandPage, cmd, trigger, triggerPlayer) {
        cmd.paramsCompiled[0].apply(this, arguments);
    }
    CommandExecute.command_19 = command_19;
    function precompile_19(commandPage, cmd, index) {
        if (Config.EDIT_MODE)
            return;
        var evalStr = "cmd.paramsCompiled = [function(commandPage,cmd,trigger,triggerPlayer){" + cmd.params[2] + ";}]";
        eval(evalStr);
    }
    CommandExecute.precompile_19 = precompile_19;
})(CommandExecute || (CommandExecute = {}));
(function (CommandExecute) {
    function command_1(commandPage, cmd, trigger, triggerPlayer) {
        trigger.goto(cmd.gotoLine[0]);
    }
    CommandExecute.command_1 = command_1;
})(CommandExecute || (CommandExecute = {}));
(function (CommandExecute) {
    var serverCallClientCode;
    function command_20(commandPage, cmd, trigger, triggerPlayer, playerInput, customParams) {
        cmd.paramsCompiled[0].apply(this, arguments);
    }
    CommandExecute.command_20 = command_20;
    function precompile_20(commandPage, cmd, index) {
        if (Config.EDIT_MODE)
            return;
        var evalStr;
        if (Config.IS_SERVER) {
            if (serverCallClientCode) {
                cmd.paramsCompiled = serverCallClientCode;
            }
            else {
                evalStr = "cmd.paramsCompiled = [function(commandPage,cmd,trigger,triggerPlayer,playerInput,customParams){if (triggerPlayer)cmd.callExecuteFunction(trigger.id, triggerPlayer, [cmd.params[2]], \"executeScript\");}]";
                eval(evalStr);
                serverCallClientCode = cmd.paramsCompiled;
            }
        }
        else {
            evalStr = "cmd.paramsCompiled = [function(commandPage,cmd,trigger,triggerPlayer,playerInput,customParams){" + cmd.params[2] + ";}]";
            eval(evalStr);
        }
    }
    CommandExecute.precompile_20 = precompile_20;
})(CommandExecute || (CommandExecute = {}));
(function (CommandExecute) {
    function command_21(commandPage, cmd, trigger, triggerPlayer) {
        trigger.cmdReturn = true;
        EventUtils.happen(triggerPlayer.sceneObject, Command.EVENT_SYSTEM_COMMAND_START, [2]);
        if (cmd.params[0]) {
            var point = new Point(triggerPlayer.variable.getVariable(cmd.params[2]), triggerPlayer.variable.getVariable(cmd.params[3]));
            if (cmd.params[4])
                point = Config.gridAlignMode ? GameUtils.getGridBottomByGrid(point) : GameUtils.getGridCenterByGrid(point);
            triggerPlayer.toScene(triggerPlayer.variable.getVariable(cmd.params[1]), point.x, point.y, cmd.params[5]);
        }
        else {
            triggerPlayer.toScene(cmd.params[1], cmd.params[2], cmd.params[3], cmd.params[5]);
        }
    }
    CommandExecute.command_21 = command_21;
})(CommandExecute || (CommandExecute = {}));
(function (CommandExecute) {
    function command_22(commandPage, cmd, trigger, triggerPlayer) {
        var index = cmd.params[0];
        var isVar = cmd.params[5] ? cmd.params[5] : false;
        if (isVar) {
            var varNum = cmd.params[6] ? cmd.params[6] : false;
            index = triggerPlayer.variable.getVariable(varNum);
        }
        var targetSo = CommandExecute.getSceneObject(index, trigger, triggerPlayer);
        if (!targetSo)
            return;
        var loop = cmd.params[1] == 1;
        var cover = cmd.params[3] ? true : false;
        var forceStopLastBehavior = cmd.params[4] ? true : false;
        trigger.addBehavior(targetSo, cmd.params[2], loop, trigger.trigger, cover, 0, true, forceStopLastBehavior, 0, trigger.executor);
    }
    CommandExecute.command_22 = command_22;
})(CommandExecute || (CommandExecute = {}));
(function (CommandExecute) {
    function command_23(commandPage, cmd, trigger, triggerPlayer) {
        if (trigger.hasBehavior) {
            trigger.continueWhenBehaviorOver = true;
            trigger.pause = true;
            trigger.offset(1);
        }
    }
    CommandExecute.command_23 = command_23;
})(CommandExecute || (CommandExecute = {}));
(function (CommandExecute) {
    function command_31(commandPage, cmd, trigger, triggerPlayer) {
        if (triggerPlayer) {
            cmd.callExecuteFunction(trigger.id, trigger.triggerPlayer, cmd.params, "shake");
        }
    }
    CommandExecute.command_31 = command_31;
})(CommandExecute || (CommandExecute = {}));
(function (CommandExecute) {
    function command_32(commandPage, cmd, trigger, triggerPlayer) {
        if (triggerPlayer) {
            cmd.callExecuteFunction(trigger.id, trigger.triggerPlayer, cmd.params, "tonal");
        }
    }
    CommandExecute.command_32 = command_32;
})(CommandExecute || (CommandExecute = {}));
(function (CommandExecute) {
    function command_35(commandPage, cmd, trigger, triggerPlayer) {
        if (triggerPlayer) {
            var tox = cmd.params[1];
            var toy = cmd.params[2];
            if (cmd.params[6] == 1) {
                var xindex = cmd.params[7] ? cmd.params[7] : 0;
                tox = triggerPlayer.variable.getVariable(xindex);
                var yindex = cmd.params[8] ? cmd.params[8] : 0;
                toy = triggerPlayer.variable.getVariable(yindex);
            }
            if (cmd.params[9] == 1) {
                tox *= Config.SCENE_GRID_SIZE;
                toy *= Config.SCENE_GRID_SIZE;
            }
            var socIndex = -1;
            if (cmd.params[3] != -5) {
                var targetSceneObject = CommandExecute.getSceneObject(cmd.params[3], trigger, triggerPlayer);
                socIndex = targetSceneObject ? targetSceneObject.index : -1;
            }
            else {
                var index = cmd.params[10] ? cmd.params[10] : 0;
                socIndex = triggerPlayer.variable.getVariable(index);
            }
            var newParams = [cmd.params[0], tox, toy, socIndex, cmd.params[4], cmd.params[5]];
            cmd.callExecuteFunction(trigger.id, trigger.triggerPlayer, newParams, "cameraMove");
        }
    }
    CommandExecute.command_35 = command_35;
})(CommandExecute || (CommandExecute = {}));
(function (CommandExecute) {
    function command_36(commandPage, cmd, trigger, triggerPlayer) {
        if (triggerPlayer) {
            cmd.callExecuteFunction(trigger.id, trigger.triggerPlayer, cmd.params, "fogSet");
        }
    }
    CommandExecute.command_36 = command_36;
})(CommandExecute || (CommandExecute = {}));
(function (CommandExecute) {
    function command_37(commandPage, cmd, trigger, triggerPlayer) {
        if (triggerPlayer) {
            var imageInfos = cmd.params[0];
            var dialogs = ArrayUtils.matchAttributes(imageInfos, { "0": 9 }, false);
            if (dialogs.length != 0) {
                trigger.pause = true;
                trigger.offset(1);
                for (var i = 0; i < dialogs.length; i++) {
                    var dialogData = dialogs[i];
                    var socIndex = -1;
                    if (dialogData[5] != -5) {
                        var targetSceneObject = CommandExecute.getSceneObject(dialogData[5], trigger, triggerPlayer);
                        socIndex = targetSceneObject ? targetSceneObject.index : -1;
                    }
                    else {
                        var index = cmd.params[10] ? cmd.params[10] : 0;
                        socIndex = triggerPlayer.variable.getVariable(index);
                    }
                    dialogData[7] = socIndex;
                }
            }
            cmd.callExecuteFunction(trigger.id, trigger.triggerPlayer, cmd.params);
        }
    }
    CommandExecute.command_37 = command_37;
})(CommandExecute || (CommandExecute = {}));
(function (CommandExecute) {
    function command_38(commandPage, cmd, trigger, triggerPlayer) {
        if (triggerPlayer) {
            trigger.pause = true;
            trigger.offset(1);
            cmd.callExecuteFunction(trigger.id, trigger.triggerPlayer, cmd.params);
        }
    }
    CommandExecute.command_38 = command_38;
})(CommandExecute || (CommandExecute = {}));
(function (CommandExecute) {
    function command_3(commandPage, cmd, trigger, triggerPlayer, playerInput) {
        if (!triggerPlayer)
            return;
        if (playerInput.length == 0) {
            var selContents = [];
            var selectedIndex = cmd.params[1];
            var cancelIndex = cmd.params[2];
            var hideIndexs = [];
            for (var i = 0; i < cmd.gotoLine.length; i++) {
                var selCmd = commandPage.commands[cmd.gotoLine[i] - 1];
                if (onConditionCheck(triggerPlayer, selCmd.params[5])) {
                    var name = selCmd.params[0];
                    if (selCmd.params[3] != null && selCmd.params[4] != null && selCmd.params[3] == 1) {
                        name = triggerPlayer.variable.getString(selCmd.params[4]);
                    }
                    selContents.push(name);
                }
                else {
                    hideIndexs.push(i);
                }
            }
            if (selContents.length > 0) {
                cmd.callExecuteFunction(trigger.id, trigger.triggerPlayer, [cmd.params[0], selContents, selectedIndex, cancelIndex, hideIndexs]);
                EventUtils.happen(triggerPlayer.sceneObject, Command.EVENT_SYSTEM_COMMAND_START, [1]);
                trigger.pause = true;
            }
            else {
                var next = cmd.paramsCompiled[0];
                trigger.goto(next);
            }
        }
        else {
            var selIndex = playerInput[0];
            if (selIndex < 0 || selIndex >= cmd.gotoLine.length)
                return;
            trigger.goto(cmd.gotoLine[selIndex]);
        }
        function onConditionCheck(triggerPlayer, conditionList) {
            if (!conditionList || conditionList.length <= 0)
                return true;
            var onsure = true;
            for (var i = 0; i < conditionList.length; i++) {
                var condition = conditionList[i];
                var bool = true;
                if (condition.type == 0) {
                    bool = triggerPlayer.variable.getSwitch(condition.varID) == condition.value;
                }
                else if (condition.type == 4) {
                    if (Config.SINGLE_PLAYER_CORE) {
                        bool = ClientWorld.getWorldSwitch(condition.varID) == condition.value;
                    }
                    else {
                        bool = ServerWorld.getWorldSwitch(condition.varID) == condition.value;
                    }
                }
                else {
                    var varValue = condition.type == 1 ? triggerPlayer.variable.getVariable(condition.varID) : (Config.SINGLE_PLAYER_CORE ? ClientWorld.getWorldVariable(condition.varID) : ServerWorld.getWorldVariable(condition.varID));
                    if ((condition.compare == 0 && varValue !== condition.value) ||
                        (condition.compare == 1 && varValue < condition.value) ||
                        (condition.compare == 2 && varValue <= condition.value) ||
                        (condition.compare == 3 && varValue > condition.value) ||
                        (condition.compare == 4 && varValue >= condition.value) ||
                        (condition.compare == 5 && varValue === condition.value)) {
                        bool = false;
                    }
                }
                if (!bool) {
                    onsure = false;
                    break;
                }
            }
            return onsure;
        }
    }
    CommandExecute.command_3 = command_3;
    function precompile_3(commandPage, cmd, index) {
        var len = commandPage.commands.length;
        var indent = 0;
        var selArr = [];
        var firstSel = true;
        for (var i = index + 1; i < len; i++) {
            var targetCmd = commandPage.commands[i];
            if (!targetCmd)
                continue;
            if (targetCmd.type == 3) {
                indent++;
            }
            else if (indent == 0 && targetCmd.type == 4) {
                cmd.gotoLine.push(i + 1);
                selArr.push(targetCmd);
                targetCmd.link = targetCmd;
                if (!firstSel) {
                    targetCmd.insertable = true;
                }
                firstSel = false;
            }
            else if (targetCmd.type == 10) {
                if (indent == 0) {
                    for (var s = 0; s < selArr.length; s++) {
                        selArr[s].gotoLine.push(i + 1);
                    }
                    cmd.link = targetCmd;
                    targetCmd.link = targetCmd;
                    cmd.paramsCompiled = [i + 1];
                    targetCmd.insertable = true;
                    break;
                }
                else {
                    indent--;
                }
            }
        }
    }
    CommandExecute.precompile_3 = precompile_3;
})(CommandExecute || (CommandExecute = {}));
(function (CommandExecute) {
    function command_4(commandPage, cmd, trigger, triggerPlayer) {
        trigger.goto(cmd.gotoLine[0]);
    }
    CommandExecute.command_4 = command_4;
})(CommandExecute || (CommandExecute = {}));
(function (CommandExecute) {
    function command_63(commandPage, cmd, trigger, triggerPlayer) {
        if (triggerPlayer) {
            cmd.callExecuteFunction(trigger.id, trigger.triggerPlayer, cmd.params, "playBGM");
        }
    }
    CommandExecute.command_63 = command_63;
})(CommandExecute || (CommandExecute = {}));
(function (CommandExecute) {
    function command_64(commandPage, cmd, trigger, triggerPlayer) {
        if (triggerPlayer) {
            cmd.callExecuteFunction(trigger.id, trigger.triggerPlayer, cmd.params, "stopBGM");
        }
    }
    CommandExecute.command_64 = command_64;
})(CommandExecute || (CommandExecute = {}));
(function (CommandExecute) {
    function command_65(commandPage, cmd, trigger, triggerPlayer) {
        if (triggerPlayer) {
            cmd.callExecuteFunction(trigger.id, trigger.triggerPlayer, cmd.params, "playBGS");
        }
    }
    CommandExecute.command_65 = command_65;
})(CommandExecute || (CommandExecute = {}));
(function (CommandExecute) {
    function command_66(commandPage, cmd, trigger, triggerPlayer) {
        if (triggerPlayer) {
            cmd.callExecuteFunction(trigger.id, trigger.triggerPlayer, cmd.params, "stopBGS");
        }
    }
    CommandExecute.command_66 = command_66;
})(CommandExecute || (CommandExecute = {}));
(function (CommandExecute) {
    function command_67(commandPage, cmd, trigger, triggerPlayer) {
        if (triggerPlayer) {
            cmd.callExecuteFunction(trigger.id, trigger.triggerPlayer, [-1].concat(cmd.params), "playSE");
        }
    }
    CommandExecute.command_67 = command_67;
})(CommandExecute || (CommandExecute = {}));
(function (CommandExecute) {
    function command_68(commandPage, cmd, trigger, triggerPlayer) {
        if (triggerPlayer) {
            cmd.callExecuteFunction(trigger.id, trigger.triggerPlayer, cmd.params, "stopSE");
        }
    }
    CommandExecute.command_68 = command_68;
})(CommandExecute || (CommandExecute = {}));
(function (CommandExecute) {
    function command_69(commandPage, cmd, trigger, triggerPlayer) {
        if (triggerPlayer) {
            cmd.callExecuteFunction(trigger.id, trigger.triggerPlayer, [-1].concat(cmd.params), "playTS");
        }
    }
    CommandExecute.command_69 = command_69;
})(CommandExecute || (CommandExecute = {}));
(function (CommandExecute) {
    function command_6(commandPage, cmd, trigger, triggerPlayer) {
        trigger.goto(cmd.gotoLine[0]);
    }
    CommandExecute.command_6 = command_6;
    function precompile_6(commandPage, cmd, index) {
        cmd.insertable = true;
        var len = commandPage.commands.length;
        var indent = 0;
        for (var i = index - 1; i >= 0; i--) {
            var targetCmd = commandPage.commands[i];
            if (!targetCmd)
                continue;
            if (targetCmd.type == 6) {
                indent++;
            }
            else if (indent == 0 && targetCmd.type == 7) {
                targetCmd.gotoLine.push(index + 1);
            }
            else if (targetCmd.type == 5) {
                if (indent == 0) {
                    cmd.gotoLine.push(i + 1);
                    targetCmd.link = cmd;
                    cmd.link = cmd;
                    break;
                }
                else {
                    indent--;
                }
            }
        }
    }
    CommandExecute.precompile_6 = precompile_6;
})(CommandExecute || (CommandExecute = {}));
(function (CommandExecute) {
    function command_70(commandPage, cmd, trigger, triggerPlayer) {
        if (triggerPlayer) {
            cmd.callExecuteFunction(trigger.id, trigger.triggerPlayer, cmd.params, "stopTS");
        }
    }
    CommandExecute.command_70 = command_70;
})(CommandExecute || (CommandExecute = {}));
(function (CommandExecute) {
    function command_71(commandPage, cmd, trigger, triggerPlayer) {
        if (triggerPlayer) {
            var imageInfos = [16].concat(cmd.params);
            cmd.callExecuteFunction(trigger.id, trigger.triggerPlayer, [[imageInfos]]);
        }
    }
    CommandExecute.command_71 = command_71;
})(CommandExecute || (CommandExecute = {}));
(function (CommandExecute) {
    function command_72(commandPage, cmd, trigger, triggerPlayer) {
        if (triggerPlayer) {
            cmd.callExecuteFunction(trigger.id, trigger.triggerPlayer, cmd.params, "openUI");
        }
    }
    CommandExecute.command_72 = command_72;
})(CommandExecute || (CommandExecute = {}));
(function (CommandExecute) {
    function command_73(commandPage, cmd, trigger, triggerPlayer) {
        if (triggerPlayer) {
            cmd.callExecuteFunction(trigger.id, trigger.triggerPlayer, cmd.params, "closeUI");
        }
    }
    CommandExecute.command_73 = command_73;
})(CommandExecute || (CommandExecute = {}));
(function (CommandExecute) {
    function command_7(commandPage, cmd, trigger, triggerPlayer) {
        if (cmd.gotoLine[0] != null)
            trigger.goto(cmd.gotoLine[0]);
    }
    CommandExecute.command_7 = command_7;
})(CommandExecute || (CommandExecute = {}));
(function (CommandExecute) {
    function command_9(commandPage, cmd, trigger, triggerPlayer) {
        if (cmd.gotoLine[0] != null)
            trigger.goto(cmd.gotoLine[0]);
    }
    CommandExecute.command_9 = command_9;
    function precompile_9(commandPage, cmd, index) {
        var len = commandPage.commands.length;
        var indent = 0;
        for (var i = 0; i < len; i++) {
            var targetCmd = commandPage.commands[i];
            if (!targetCmd)
                continue;
            if (targetCmd.type == 8 && cmd.params[0] == targetCmd.params[0]) {
                cmd.gotoLine.push(i + 1);
                break;
            }
        }
    }
    CommandExecute.precompile_9 = precompile_9;
})(CommandExecute || (CommandExecute = {}));
var CommandPage = (function () {
    function CommandPage(commandDatas) {
        this.id = ObjectUtils.getInstanceID();
        this.commands = [];
        this.parse(commandDatas);
    }
    CommandPage.getCustomCmdDataID = function (cmdID) {
        var type = Math.floor(cmdID / CommandPage.CUSTOM_COMMAND_START_ID);
        var localID = cmdID - CommandPage.CUSTOM_COMMAND_START_ID * type;
        var id = GameListData.getID(type, localID);
        return id;
    };
    CommandPage.getTypeByCustomCmdID = function (customCmdID) {
        var t = GameListData.getType(customCmdID);
        var s = GameListData.getLocalID(customCmdID);
        return CommandPage.CUSTOM_COMMAND_START_ID * t + s;
    };
    CommandPage.prototype.parse = function (commandDatas) {
        if (!commandDatas || commandDatas.length == 0)
            return;
        var len = commandDatas.length;
        var cmdType;
        for (var i = 0; i < len; i++) {
            var cmdData = commandDatas[i];
            cmdType = cmdData[0];
            if (!Config.EDIT_MODE) {
                if (cmdType == -1) {
                    continue;
                }
            }
            var cmdIDInfo = Command.getCMDIDByParam(cmdData);
            if (!Config.EDIT_MODE && cmdIDInfo && cmdIDInfo.disabled) {
                continue;
            }
            if (cmdType < CommandPage.CUSTOM_COMMAND_START_ID) {
                if (cmdIDInfo && cmdIDInfo.___cmdID) {
                    cmdData = cmdData.concat();
                    cmdData.pop();
                }
            }
            var cmd = new Command(cmdType, cmdData.slice(1), cmdIDInfo ? cmdIDInfo.___cmdID : null);
            if (cmdIDInfo)
                cmd.disabled = cmdIDInfo.disabled;
            this.commands.push(cmd);
        }
        len = this.commands.length;
        for (var i = 0; i < len; i++) {
            var cmd = this.commands[i];
            cmdType = cmd.type;
            var customHead, customPreCompileHead;
            if (cmdType >= CommandPage.CUSTOM_COMMAND_START_ID) {
                customHead = "customCommand_";
                customPreCompileHead = "customCommandPrecompile_";
                cmdType = CommandPage.getCustomCmdDataID(MathUtils.int(cmdType));
                if (!Config.EDIT_MODE) {
                    var customParams = cmd.params[0];
                    var newCustomParams = {};
                    if (customParams && typeof customParams == "object") {
                        var customCommandTypeData = Common.customCommandTypeList.data[cmdType];
                        if (customCommandTypeData) {
                            var attrs = CustomCompositeSetting.getAllAttributes(customCommandTypeData, false);
                            for (var s = 0; s < attrs.length; s++) {
                                var cusAttr = attrs[s];
                                var paramValue = customParams[cusAttr.id];
                                newCustomParams[cusAttr.varName] = paramValue;
                            }
                            var typeValues = CommandPage.cacheCustomCommandTypeValues[cmdType];
                            if (!typeValues) {
                                typeValues = CommandPage.cacheCustomCommandTypeValues[cmdType] = {};
                                for (var s = 0; s < attrs.length; s++) {
                                    var cusAttr = attrs[s];
                                    typeValues[cusAttr.varName] = CustomAttributeSetting.formatCustomDefaultValue(cusAttr, true);
                                }
                            }
                            var newCustomParams2 = {};
                            CustomAttributeSetting.installAttributeFromRecordData(newCustomParams2, newCustomParams, attrs, typeValues, 4);
                            cmd.params[0] = newCustomParams2;
                        }
                    }
                }
            }
            else {
                customHead = "command_";
                customPreCompileHead = "precompile_";
            }
            var executeMethod = CommandExecute[customHead + cmdType];
            if (executeMethod) {
                cmd.exeFunc = executeMethod;
            }
            else {
                cmd.exeFunc = CommandPage.blankMethod;
            }
            var precompileMethod = CommandExecute[customPreCompileHead + cmdType];
            if (precompileMethod)
                precompileMethod(this, cmd, i, cmd.params[0]);
        }
    };
    CommandPage.prototype.refreshPrecompile = function () {
        for (var i = 0; i < this.commands.length; i++) {
            var cmd = this.commands[i];
            if (!cmd)
                continue;
            cmd.gotoLine.length = 0;
            var precompileMethod = CommandExecute["precompile_" + cmd.type];
            if (precompileMethod)
                precompileMethod(this, cmd, i, cmd.params[0]);
        }
    };
    CommandPage.startTriggerFragmentEvent = function (feData, trigger, execute, onCommandExecuteOver) {
        if (onCommandExecuteOver === void 0) { onCommandExecuteOver = null; }
        var feCmdInfo = CommandPage.getFormatFeData(feData);
        if (feCmdInfo) {
            var scene = Config.IS_SERVER ? trigger.scene : Game.currentScene;
            var newFETrigger = new CommandTrigger(CommandTrigger.COMMAND_MAIN_TYPE_FRAGMENT_EVENT, 0, scene, trigger, true, execute);
            if (onCommandExecuteOver)
                EventUtils.addEventListener(newFETrigger, CommandTrigger.EVENT_OVER, onCommandExecuteOver, true);
            feCmdInfo.feCmdPage.startTriggerEvent(newFETrigger, [], feCmdInfo.feCommands);
            return newFETrigger;
        }
        else {
            if (onCommandExecuteOver)
                onCommandExecuteOver.run();
        }
        return null;
    };
    CommandPage.getFormatFeData = function (feData) {
        if (feData || typeof feData == "string") {
            var startIdx = feData.indexOf(String.fromCharCode(5));
            var feName = feData.substr(0, startIdx);
            var startIdx2 = feData.indexOf(String.fromCharCode(5), startIdx + 1);
            if (startIdx2 == -1)
                return null;
            var feSID = feData.substr(startIdx + 1, startIdx2 - startIdx - 1);
            var feCmdPage = CommandPage.cacheCustomFragmentPage[feSID];
            try {
                var feCommands = JSON.parse(feData.substr(startIdx2 + 1));
            }
            catch (e) { }
            if (!feCmdPage) {
                feCmdPage = CommandPage.cacheCustomFragmentPage[feSID] = new CommandPage(feCommands);
            }
            return { feCmdPage: feCmdPage, feCommands: feCommands };
        }
        return null;
    };
    CommandPage.getFeDataName = function (feData) {
        if (feData && typeof feData == "string") {
            var startIdx = feData.indexOf(String.fromCharCode(5));
            if (startIdx == -1)
                return "";
            var feName = feData.substr(0, startIdx);
            return feName;
        }
        return "[#GAME_UNNAMED_FRAGMENT]";
    };
    CommandPage.prototype.startTriggerEvent = function (trigger, playerInput, fragmentCommands) {
        if (playerInput === void 0) { playerInput = []; }
        if (fragmentCommands === void 0) { fragmentCommands = null; }
        if (trigger.isExecuteing)
            return;
        trigger.initFrom(this);
        trigger.isExecuteing = true;
        trigger.commandScope.push({ cmdPage: this, index: 0, commonEventID: 0, fragmentCommands: fragmentCommands });
        EventUtils.happen(trigger, CommandTrigger.EVENT_START);
        CommandPage.executeEvent(trigger, playerInput);
    };
    CommandPage.executeEvent = function (trigger, playerInput) {
        if (playerInput === void 0) { playerInput = []; }
        trigger.inputMessage = playerInput;
        var triggerPlayer = Config.IS_SERVER ? trigger.triggerPlayer : Game.player;
        if (trigger.trigger && trigger.trigger.playerUID && !triggerPlayer) {
            EventUtils.happen(trigger, CommandTrigger.EVENT_OVER);
            trigger.dispose();
            return;
        }
        trigger.pause = false;
        var loopTimes = 0;
        var loopStartTime = Date.now();
        var loopTimeout = !Config.IS_SERVER && os.inGC(false) ? 5000 : 10000;
        while (1) {
            loopTimes++;
            if (loopTimes > 10000) {
                loopTimes = 0;
                var d = Date.now() - loopStartTime;
                if (d >= loopTimeout) {
                    var msg = CommandPage.tips[Config.language];
                    alert(msg ? msg : CommandPage.tips[2]);
                    break;
                }
            }
            var len = trigger.commandScope.length;
            if (len == 0 || trigger.isDisposed) {
                trigger.isExecuteing = false;
                EventUtils.happen(trigger, CommandTrigger.EVENT_OVER);
                if (trigger.multiline) {
                    trigger.dispose();
                }
                break;
            }
            var commandScope = trigger.commandScope[len - 1];
            var cmdPage = commandScope.cmdPage;
            if (commandScope.index == cmdPage.commands.length) {
                trigger.commandScope.pop();
                continue;
            }
            if (trigger.executor.isDisposed) {
                trigger.commandScope.length = 0;
                continue;
            }
            var cmd = cmdPage.commands[commandScope.index];
            cmd.exeFunc(cmdPage, cmd, trigger, triggerPlayer, playerInput, cmd.params[0]);
            playerInput = [];
            if (trigger.pause) {
                break;
            }
            if (trigger.cmdReturn) {
                trigger.cmdReturn = false;
                trigger.commandScope.pop();
                continue;
            }
            commandScope.index++;
        }
    };
    CommandPage.CUSTOM_COMMAND_START_ID = 10000;
    CommandPage.blankMethod = new Function();
    CommandPage.cacheCustomCommandTypeValues = [];
    CommandPage.cacheCustomFragmentPage = {};
    CommandPage.tips = ["事件执行循环卡死，已强制跳出。", "事件執行循環卡死，已強制跳出。", "the event loop is stuck and has been forced to break."];
    return CommandPage;
}());
var Condition = (function () {
    function Condition() {
    }
    return Condition;
}());
var CustomCompData = (function () {
    function CustomCompData() {
        this.type = 0;
        this.moduleID = 1;
        this.dataID = 1;
        this.dataIsUseVar = false;
        this.dataVarID = 1;
        this.varID = "";
        this.varName = "";
        this.valueType = 0;
        this.value = {};
        this.isCustomModule = false;
        this.operationType = 0;
        this.compInfo = { uiID: 1, type: 0, compName: "", compID: 0, attrs: [], varName: "" };
        this.selectMode = 0;
        this.inputModeInfo = { mode: 0, constName: "", varNameIndex: 1, typeIndex: 0 };
    }
    CustomCompData.setData = function (target, data, soc) {
        if (!target || !data)
            return;
        var varName;
        if (data.selectMode == 1) {
            var mode = data.inputModeInfo.mode;
            var constName = data.inputModeInfo.constName;
            var varNameIndex = data.inputModeInfo.varNameIndex;
            varName = mode == 0 ? constName : Game.player.variable.getString(varNameIndex);
        }
        else {
            varName = data.varName;
        }
        if (data.compAttrEnable) {
            var cmdParam = data.value.value[1];
            if (!cmdParam)
                return;
            var atts = cmdParam[2];
            if (!atts || !atts.uiID)
                return;
            var ui = void 0;
            var list = soc["getCustomDisplayLayers"]();
            for (var i_4 = 0; i_4 < list.length; i_4++) {
                var customDisplay = list[i_4];
                if (!customDisplay || !(customDisplay instanceof UIComponent.GUI_BASE) || customDisplay.guiID != atts.uiID)
                    continue;
                ui = customDisplay;
            }
            if (!ui)
                return;
            var passageID = 2000000 + atts.uiID;
            var sign = "gcUICompMove" + ObjectUtils.getRandID();
            if (cmdParam[5] == 0) {
                var comps = GameUI.getAllCompChildren(ui, true);
                for (var compID in atts.atts) {
                    var uiComp = comps.keyValue[compID];
                    if (uiComp) {
                        var attsValues = atts.atts[compID][1];
                        var useVarAndTransitionAttrs = atts.atts[compID][2];
                        for (var attName in attsValues) {
                            var attValue = attsValues[attName];
                            if (attName == "materialData") {
                                refreshCompMaterials.apply({}, [attValue, uiComp]);
                            }
                            else {
                                if (useVarAndTransitionAttrs && useVarAndTransitionAttrs[attName].type != null) {
                                    if (useVarAndTransitionAttrs[attName].type == 0) {
                                        attValue = Game.player.variable.getVariable(useVarAndTransitionAttrs[attName].index);
                                    }
                                    else if (useVarAndTransitionAttrs[attName].type == 1) {
                                        attValue = Game.player.variable.getString(useVarAndTransitionAttrs[attName].index);
                                    }
                                    else if (useVarAndTransitionAttrs[attName].type == 2) {
                                        attValue = Game.player.variable.getSwitch(useVarAndTransitionAttrs[attName].index) ? true : false;
                                    }
                                }
                                uiComp[attName] = attValue;
                            }
                        }
                    }
                }
            }
            else {
                var m = {
                    time: cmdParam[0],
                    curTime: 1,
                    transData: GameUtils.getTransData(cmdParam[1]),
                    attrInfos: []
                };
                var comps = GameUI.getAllCompChildren(ui, true);
                for (var compID in atts.atts) {
                    var uiComp = comps.keyValue[compID];
                    if (uiComp) {
                        var attsValues = atts.atts[compID][1];
                        var useVarAndTransitionAttrs = atts.atts[compID][2];
                        for (var attName in attsValues) {
                            var oldValue = uiComp[attName];
                            var needTween = typeof oldValue == "number";
                            if (attName == "materialData")
                                needTween = true;
                            var useVarAndTransition = useVarAndTransitionAttrs[attName];
                            if (useVarAndTransition) {
                                if (!useVarAndTransition.change) {
                                    needTween = false;
                                }
                            }
                            var newValue = attsValues[attName];
                            if (useVarAndTransitionAttrs && useVarAndTransitionAttrs[attName].type != null) {
                                if (useVarAndTransitionAttrs[attName].type == 0) {
                                    newValue = Game.player.variable.getVariable(useVarAndTransitionAttrs[attName].index);
                                }
                                else if (useVarAndTransitionAttrs[attName].type == 1) {
                                    newValue = Game.player.variable.getString(useVarAndTransitionAttrs[attName].index);
                                }
                                else if (useVarAndTransitionAttrs[attName].type == 2) {
                                    newValue = Game.player.variable.getSwitch(useVarAndTransitionAttrs[attName].index) ? true : false;
                                }
                            }
                            var attrInfo = { uiComp: uiComp, uiCompID: uiComp.id, attName: attName, oldValue: oldValue, needTween: needTween, newValue: newValue };
                            m.attrInfos.push(attrInfo);
                        }
                    }
                }
            }
        }
        else {
            if (target[varName] == undefined)
                return;
            var setAttr = function (value) {
                if (target[varName] instanceof GCAnimation && typeof value == "number")
                    target[varName].id = value;
                else if (target[varName] instanceof UIComponent.UIBase && typeof value == "number") {
                    var p = target[varName].parent;
                    var index = p.getChildIndex(target[varName]);
                    p.removeChild(target[varName]);
                    var gui = GameUI.load(value, true);
                    target[varName] = gui;
                    p.addChildAt(target[varName], index);
                }
                else
                    target[varName] = count_1(target[varName], value);
            };
            var count_1 = function (oldValue, value) {
                if (typeof oldValue != "number" || typeof value != "number")
                    return value;
                var v;
                if (!data.operationType)
                    v = value;
                switch (data.operationType) {
                    case 1:
                        v = oldValue + value;
                        break;
                    case 2:
                        v = oldValue - value;
                        break;
                    case 3:
                        v = oldValue * value;
                        break;
                    case 4:
                        v = oldValue / value;
                        break;
                    case 5:
                        v = oldValue % value;
                        break;
                    case 6:
                        v = Math.pow(oldValue, value);
                        break;
                }
                return data.isRounded ? MathUtils.int(v) : v;
            };
            if (data.valueType == 0) {
                var v = data.value;
                if (v) {
                    if (data.selectMode == 1 && data.inputModeInfo.typeIndex == 3) {
                        try {
                            v.value = JSON.parse(v.value);
                        }
                        catch (e) {
                            v.value = {};
                        }
                    }
                    setAttr(v.value);
                }
            }
            else {
                var v = data.value;
                if (v && v.value) {
                    var varID = v.value;
                    switch (v.varType) {
                        case 0:
                            setAttr(Game.player.variable.getVariable(varID));
                            break;
                        case 1:
                            setAttr(Game.player.variable.getString(varID));
                            break;
                        case 2:
                            setAttr(Game.player.variable.getSwitch(varID));
                            break;
                    }
                }
            }
        }
    };
    CustomCompData.getData = function (target, data, isModule) {
        if (!data)
            return null;
        var t;
        if (isModule) {
            var moduleID = data.moduleID;
            var dataID = void 0;
            if (data.dataIsUseVar)
                dataID = Game.player.variable.getVariable(data.dataVarID);
            else
                dataID = data.dataID;
            t = GameData.getModuleData(moduleID, dataID);
        }
        if (target instanceof ClientSceneObject) {
            if (data.type == 0)
                return target.name;
            if (data.type == 2)
                t = target.getModule(data.moduleID);
        }
        if (t == null)
            t = target;
        if (!t)
            return null;
        var varName;
        if (data.selectMode == 1) {
            var mode = data.inputModeInfo.mode;
            var constName = data.inputModeInfo.constName;
            var varNameIndex = data.inputModeInfo.varNameIndex;
            varName = mode == 0 ? constName : Game.player.variable.getString(varNameIndex);
        }
        else {
            varName = data.varName;
        }
        if (t[varName] == undefined || t[varName] == null)
            return null;
        if (data.compAttrEnable) {
            var ui = target[varName];
            if (!ui || !(ui instanceof UIComponent.GUI_BASE))
                return "";
            var comp = ui.compsIDInfo[data.compInfo.compID];
            if (!comp)
                return "";
            return typeof comp[data.compInfo.varName] == "number" ? MathUtils.float(comp[data.compInfo.varName]) : comp[data.compInfo.varName];
        }
        if (data.isCustomModule)
            return t[varName].id;
        if (typeof t[varName] == "number")
            return MathUtils.float(t[varName]);
        else
            return t[varName];
    };
    return CustomCompData;
}());
var Scene = (function () {
    function Scene() {
        this.preloadMapAsset = true;
        this.preloadSceneObjectAsset = true;
        this.preloadSceneCommandAsset = true;
        this.dataLayers = [];
        this.sceneObjects = [];
        this.customCommandPages = [];
    }
    Scene.prototype.parse = function (jsonObj, gameData) {
        if (!Config.EDIT_MODE && !Config.BEHAVIOR_EDIT_MODE) {
            var jsonObjClone = ObjectUtils.depthClone(jsonObj);
            ObjectUtils.clone(jsonObjClone, this);
        }
        else {
            ObjectUtils.clone(jsonObj, this);
        }
        this.gridWidth = Math.floor(this.width / Config.SCENE_GRID_SIZE);
        this.gridHeight = Math.floor(this.height / Config.SCENE_GRID_SIZE);
    };
    Scene.prototype.getDataGridState = function (index, gridX, gridY) {
        var xyData = this.dataLayers[index];
        if (!xyData)
            return 0;
        var xData = xyData[gridX];
        if (!xData)
            return 0;
        return xData[gridY];
    };
    Scene.prototype.setDataGridState = function (index, gridX, gridY, state) {
        var xyData = this.dataLayers[index];
        var xData = xyData[gridX];
        if (!xData)
            xData = xyData[gridX] = [];
        xData[gridY] = state;
    };
    Scene.getRealWidth = function (scene) {
        return { width: scene.gridWidth * Config.SCENE_GRID_SIZE, height: scene.gridHeight * Config.SCENE_GRID_SIZE };
    };
    return Scene;
}());
var SceneLayerGridData = (function () {
    function SceneLayerGridData() {
        this.name = "";
        this.color = "#FF0000";
        this.tips = "";
        this.mode = 0;
        this.dataType = true;
        this.dataLock = false;
    }
    SceneLayerGridData.InitColor = function (index) {
        var spectrumColors = [
            '#FF6666',
            '#b38e68',
            '#aeb367',
            '#66CC66',
            '#2348ff',
            '#9999FF',
            '#B266B2',
        ];
        if (index >= 10000)
            return "#cdcdcd";
        var color = spectrumColors[((index) % 7)];
        return color;
    };
    SceneLayerGridData.initDirTexture = function () {
        if (Object.keys(SceneLayerGridData.dirTexture).length != 0)
            return;
        var _loop_1 = function (i_5) {
            loader.load("comp/gI_accessible_" + (i_5 + 1) + ".png", Handler.create(this_1, function () {
                SceneLayerGridData.dirTexture[SceneLayerGridData.dirData[i_5]] = loader.getRes("comp/gI_accessible_" + (i_5 + 1) + ".png");
            }, []));
        };
        var this_1 = this;
        for (var i_5 = 0; i_5 < 16; i_5++) {
            _loop_1(i_5);
        }
    };
    SceneLayerGridData.setSwitchModeShow = function (graphics, x, y, color) {
        graphics.drawRect(x * Config.SCENE_GRID_SIZE, y * Config.SCENE_GRID_SIZE, Config.SCENE_GRID_SIZE, Config.SCENE_GRID_SIZE, color);
    };
    SceneLayerGridData.setNumModeShow = function (graphics, x, y, num, colorBlocks) {
        var _b;
        var n = (_b = Number(num)) !== null && _b !== void 0 ? _b : 1;
        var color = SceneLayerGridData.InitColor(n - 1);
        graphics.drawRect(x * Config.SCENE_GRID_SIZE, y * Config.SCENE_GRID_SIZE, Config.SCENE_GRID_SIZE, Config.SCENE_GRID_SIZE, color);
        var text = n > 10000 ? "XX" : (colorBlocks[n - 1] && colorBlocks[n - 1].tips ? colorBlocks[n - 1].tips[0] : n);
        graphics.strokeText(String(text), x * Config.SCENE_GRID_SIZE + Config.SCENE_GRID_SIZE / 2, y * Config.SCENE_GRID_SIZE + Config.SCENE_GRID_SIZE / 3, '20px 宋体', "#ffffff", 0.5, "center");
    };
    SceneLayerGridData.setDirMOdeShow = function (graphics, x, y, num) {
        var _b;
        var dirTexture = !num ? SceneLayerGridData.dirTexture[11111] : ((_b = SceneLayerGridData.dirTexture[Number(num)]) !== null && _b !== void 0 ? _b : SceneLayerGridData.dirTexture[10000]);
        graphics.drawTexture(dirTexture, x * Config.SCENE_GRID_SIZE, y * Config.SCENE_GRID_SIZE, Config.SCENE_GRID_SIZE, Config.SCENE_GRID_SIZE);
    };
    SceneLayerGridData.getClickNum = function (orData, mouseX, mouseY) {
        var isPointInTriangle = function (a, b, c, p) {
            var detT = (b.y - c.y) * (a.x - c.x) + (c.x - b.x) * (a.y - c.y);
            var alpha = ((b.y - c.y) * (p.x - c.x) + (c.x - b.x) * (p.y - c.y)) / detT;
            var beta = ((c.y - a.y) * (p.x - c.x) + (a.x - c.x) * (p.y - c.y)) / detT;
            var gamma = 1 - alpha - beta;
            return alpha > 0 && beta > 0 && gamma > 0;
        };
        var a = new Point(0, 0);
        var b = new Point(Config.SCENE_GRID_SIZE, 0);
        var c = new Point(0, Config.SCENE_GRID_SIZE);
        var d = new Point(Config.SCENE_GRID_SIZE, Config.SCENE_GRID_SIZE);
        var o = new Point(Config.SCENE_GRID_SIZE / 2, Config.SCENE_GRID_SIZE / 2);
        if (isPointInTriangle(a, b, o, new Point(mouseX, mouseY))) {
            return orData.substring(0, 1) + (orData[1] == "1" ? "0" : "1") + orData.substring(2);
        }
        else if (isPointInTriangle(a, c, o, new Point(mouseX, mouseY))) {
            return orData.substring(0, 3) + (orData[3] == "1" ? "0" : "1") + orData.substring(4);
        }
        else if (isPointInTriangle(b, d, o, new Point(mouseX, mouseY))) {
            return orData.substring(0, 4) + (orData[4] == "1" ? "0" : "1");
        }
        else {
            return orData.substring(0, 2) + (orData[2] == "1" ? "0" : "1") + orData.substring(3);
        }
    };
    SceneLayerGridData.dirTexture = {};
    SceneLayerGridData.dirData = {
        0: 11111,
        1: 11101,
        2: 11110,
        3: 10111,
        4: 11011,
        5: 11001,
        6: 11010,
        7: 10101,
        8: 10110,
        9: 11100,
        10: 10011,
        11: 10010,
        12: 10001,
        13: 11000,
        14: 10100,
        15: 10000
    };
    SceneLayerGridData.selectBlocksIndex = 0;
    SceneLayerGridData.isClearMode = false;
    return SceneLayerGridData;
}());
var SceneObject = (function () {
    function SceneObject() {
        this.modelID = 1;
        this.index = 0;
        this.name = "";
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.materialData = [{ materials: [] }];
        this.avatarID = 0;
        this.avatarOri = 2;
        this.avatarAct = 1;
        this.avatarFPS = 12;
        this.avatarFrame = 1;
        this.avatarAlpha = 1;
        this.avatarHue = 0;
        this.shadowEnable = false;
        this.shadowWidth = 30;
        this.shadowHeight = 15;
        this.shadowAlpha = 0.5;
        this.displayList = {};
        this.moduleDisplayList = [];
        this.layerLevel = 1;
        this.autoPlayEnable = true;
        this.scale = 1;
        this.playerUID = 0;
        this.hasCommand = [];
    }
    Object.defineProperty(SceneObject, "self", {
        get: function () {
            if (SceneObject.____self)
                return SceneObject.____self;
            SceneObject.____self = new SceneObject();
            return SceneObject.____self;
        },
        enumerable: false,
        configurable: true
    });
    SceneObject.installCustomData = function (so, presetCustomAttrs, recordModelData) {
        if (presetCustomAttrs === void 0) { presetCustomAttrs = null; }
        if (recordModelData === void 0) { recordModelData = true; }
        var modelData = Common.sceneObjectModelList.data[so.modelID];
        if (recordModelData)
            so.modelData = modelData;
        if (modelData) {
            if (Config.useNewSceneObjectModel) {
                var fixModelData = Common.sceneObjectModelList.data[0];
            }
            else {
                fixModelData = modelData;
            }
            var attrSettings = fixModelData.varAttributes;
            if (!presetCustomAttrs) {
                presetCustomAttrs = CustomAttributeSetting.formatCustomData(null, fixModelData.varAttributes);
            }
            CustomAttributeSetting.installAttributeFromEditorSet(so, presetCustomAttrs, attrSettings, false, false, GameData.CUSTOM_ATTR_SCENE_OBJECT_DATA);
        }
    };
    SceneObject.installModuleAttributesBeforeConstructor = function (soe, moduleID, moduleName, moduleData, presetData, soModule) {
        soModule.id = moduleID;
        soModule.name = moduleName;
        soModule.so = soe;
        if (Config.EDIT_MODE) {
            soModule.owner = soe;
            soModule.soModule = soModule;
        }
        var attrSettings = moduleData.varAttributes;
        var editorSetAttrs = {};
        CustomAttributeSetting.formatCustomData(editorSetAttrs, attrSettings);
        CustomAttributeSetting.installAttributeFromEditorSet(soModule, editorSetAttrs, attrSettings, false, false, GameData.CUSTOM_ATTR_SCENE_OBJECT_MODULE_DATA);
        for (var i = 0; i < moduleData.preLayer.length; i++) {
            var p = moduleData.preLayer[i];
            if (p["__dragPresetID"]) {
                soModule[p.varName] = p["__dragPresetID"];
                delete p["__dragPresetID"];
            }
            else {
                soModule[p.varName] = p.id;
            }
        }
        if (presetData)
            ObjectUtils.clone(presetData, soModule);
    };
    SceneObject.createModule = function (moduleID, soe, presetData) {
        if (presetData === void 0) { presetData = null; }
        var moduleData = Common.sceneObjectModuleList.data[moduleID];
        if (moduleData) {
            var moduleName = GameListData.getName(Common.sceneObjectModuleList, moduleID);
            var installCB = Callback.New(this.installModuleAttributesBeforeConstructor, this, [soe, moduleID, moduleName, moduleData, presetData]);
            var soModule;
            if (Config.EDIT_MODE && !Config.BEHAVIOR_EDIT_MODE) {
                soModule = SceneObject.editorSceneObjectModule(installCB, moduleID);
            }
            else {
                var cls;
                if (Config.IS_SERVER) {
                    if (moduleData.serverInstanceClassName) {
                        cls = globalThis[moduleData.serverInstanceClassName];
                    }
                }
                else {
                    if (moduleData.clientInstanceClassName) {
                        cls = globalThis[moduleData.clientInstanceClassName];
                    }
                }
                if (!cls)
                    cls = SceneObjectModule.moduleClassArr[moduleID];
                if (cls) {
                    soModule = new cls(installCB);
                }
                else {
                    soModule = new SceneObjectModule(installCB);
                }
            }
            if (soModule) {
                return soModule;
            }
        }
        return null;
    };
    SceneObject.editorSceneObjectModule = function (installCB, moduleID) {
        return null;
    };
    SceneObject.__gcClone = function (so) {
        var soData = new SceneObject();
        for (var i in soData) {
            soData[i] = so[i];
        }
        for (var i in SceneObject.compoundAttributes) {
            var attrName = SceneObject.compoundAttributes[i];
            soData[attrName] = ObjectUtils.depthClone(so[attrName]);
        }
        return soData;
    };
    SceneObject.__gcClones = function (sos) {
        var len = sos.length;
        var arr = [];
        for (var i = 0; i < len; i++) {
            var so = sos[i];
            if (!so)
                continue;
            var soData = SceneObject.__gcClone(sos[i]);
            arr[i] = soData;
        }
        return arr;
    };
    SceneObject.compoundAttributes = ["displayList", "hasCommand", "materialData", "moduleIDs", "moduleDisplayList", "hideOriBox"];
    SceneObject.statusCommonAttributes = {
        x: true,
        y: true,
        z: true,
        name: true,
        index: true,
        playerUID: true,
        modelID: true
    };
    return SceneObject;
}());















var SceneObjectEntity = (function (_super) {
    __extends(SceneObjectEntity, _super);
    function SceneObjectEntity(persetData) {
        if (persetData === void 0) { persetData = null; }
        var _this_1 = _super.call(this) || this;
        _this_1.inScene = false;
        _this_1._modules = [];
        _this_1.customCommandPagesCache = [];
        _this_1.hasCommandCache = [];
        if (persetData) {
            _this_1.____beforeInstallAttributeInit();
            for (var s in SceneObject.statusCommonAttributes) {
                if (persetData.recordData)
                    _this_1[s] = persetData.recordData[s];
                else
                    _this_1[s] = persetData.soData[s];
            }
            _this_1.index = persetData.soIndex;
            _this_1.installSwitchs(persetData.soSwitchs, false);
            _this_1.installStatusPageData(persetData.sceneObjectData, persetData.fromSceneObjectindex, persetData.soData, persetData.customAttr, persetData.eventData, persetData.recordData, persetData.moduleCustomAttrs);
            _this_1.____afterInstallAttributeInit();
        }
        return _this_1;
    }
    Object.defineProperty(SceneObjectEntity.prototype, "isCopy", {
        get: function () { return this._isCopy; },
        enumerable: false,
        configurable: true
    });
    ;
    Object.defineProperty(SceneObjectEntity.prototype, "copyFrom", {
        get: function () {
            return this._copyFrom;
        },
        enumerable: false,
        configurable: true
    });
    SceneObjectEntity.prototype.____beforeInstallAttributeInit = function () {
    };
    SceneObjectEntity.prototype.____afterInstallAttributeInit = function () {
    };
    SceneObjectEntity.prototype.installStatusPageData = function (sceneObjectData, fromSceneObjectindex, soData, customAttr, eventData, recordData, moduleCustomAttrs) {
        if (recordData === void 0) { recordData = null; }
        if (moduleCustomAttrs === void 0) { moduleCustomAttrs = null; }
        this.sceneObjectData = sceneObjectData;
        this.fromSceneObjectindex = fromSceneObjectindex;
        var statusPages = sceneObjectData.statusPages[fromSceneObjectindex];
        if (!statusPages)
            statusPages = sceneObjectData.statusPages[fromSceneObjectindex] = [];
        this.statusPages = statusPages.concat();
        var customAttributesCache = sceneObjectData.customAttributesCaches[fromSceneObjectindex];
        var modulesCustomAttributesCaches = sceneObjectData.modulesCustomAttributesCaches[fromSceneObjectindex];
        this.statusPages.unshift({
            so: soData,
            customAttribute: customAttr,
            event: eventData,
            customAttributesCache: customAttributesCache,
            modulesCustomAttribute: moduleCustomAttrs,
            modulesCustomAttributesCaches: modulesCustomAttributesCaches
        });
        var st = this.refreshDisappearStatus("rd", recordData);
        if (!st.changeStatusPage) {
            this.initCondition();
        }
    };
    SceneObjectEntity.prototype.getCustomAttributeCache = function (stpIndex) {
        var stp = this.statusPages[stpIndex];
        var customAttributesCache = stp.customAttributesCache;
        if (!customAttributesCache) {
            if (stpIndex == 0) {
                customAttributesCache = this.sceneObjectData.customAttributesCaches[this.fromSceneObjectindex] = SceneObject.__gcClone(stp.so);
            }
            else {
                customAttributesCache = this.sceneObjectData.statusPages[this.fromSceneObjectindex][stpIndex - 1].customAttributesCache = SceneObject.__gcClone(stp.so);
            }
            SceneObject.installCustomData(customAttributesCache, stp.customAttribute);
            for (var i in SceneObject.self) {
                delete customAttributesCache[i];
            }
            stp.customAttributesCache = customAttributesCache;
        }
        return customAttributesCache;
    };
    SceneObjectEntity.prototype.getModuleCustomAttributeCache = function (stpIndex, moduleIndex) {
        var stp = this.statusPages[stpIndex];
        var moduleCacheArr = stp.modulesCustomAttributesCaches;
        var stpSceneObjectData;
        if (stpIndex == 0) {
            if (!moduleCacheArr)
                moduleCacheArr = stp.modulesCustomAttributesCaches = this.sceneObjectData.modulesCustomAttributesCaches[this.fromSceneObjectindex] = [];
        }
        else {
            if (!moduleCacheArr)
                moduleCacheArr = stp.modulesCustomAttributesCaches = this.sceneObjectData.statusPages[this.fromSceneObjectindex][stpIndex - 1].modulesCustomAttributesCaches = [];
        }
        var moduleCache = moduleCacheArr[moduleIndex];
        if (!moduleCache) {
            var moduleID = stp.so.moduleIDs[moduleIndex];
            var moduleData = Common.sceneObjectModuleList.data[moduleID];
            if (!moduleData)
                return null;
            var virtualModule = {};
            if (stpIndex == 0) {
                moduleCache = this.sceneObjectData.modulesCustomAttributesCaches[this.fromSceneObjectindex][moduleIndex] = virtualModule;
            }
            else {
                moduleCache = this.sceneObjectData.statusPages[this.fromSceneObjectindex][stpIndex - 1].modulesCustomAttributesCaches[moduleIndex] = virtualModule;
            }
            CustomAttributeSetting.installAttributeFromEditorSet(virtualModule, stp.modulesCustomAttribute[moduleIndex], moduleData.varAttributes, false, false, GameData.CUSTOM_ATTR_SCENE_OBJECT_MODULE_DATA);
            moduleCacheArr[moduleIndex] = moduleCache;
            for (var i = 0; i < moduleData.preLayer.length; i++) {
                var p = moduleData.preLayer[i];
                var displayInfos = stp.so.moduleDisplayList[moduleIndex];
                if (displayInfos) {
                    var displayInfo = displayInfos[p.varName];
                    if (displayInfo != null) {
                        moduleCache[p.varName] = displayInfo.id;
                    }
                    else {
                        moduleCache[p.varName] = 0;
                    }
                }
            }
        }
        return moduleCache;
    };
    SceneObjectEntity.prototype.getSwitchs = function (index) {
        return this.switchs[index];
    };
    SceneObjectEntity.prototype.setSwitchs = function (varID, value) {
        this.switchs[varID] = value;
    };
    SceneObjectEntity.prototype.getSwitch = function (index) {
        return this.switchs[index];
    };
    SceneObjectEntity.prototype.setSwitch = function (varID, value) {
        this.setSwitchs(varID, value);
    };
    SceneObjectEntity.prototype.installSwitchs = function (switchs, refreshDisappearStatus) {
        if (refreshDisappearStatus === void 0) { refreshDisappearStatus = true; }
        if (!switchs)
            switchs = [0, 0, 0, 0, 0, 0, 0];
        this.switchs = switchs;
        if (refreshDisappearStatus)
            this.refreshDisappearStatus();
    };
    SceneObjectEntity.prototype.getCustomAttrs = function () {
        var modelData = Common.sceneObjectModelList.data[this.modelID];
        if (!modelData)
            return null;
        var len = modelData.varAttributes.length;
        var varNames = [];
        for (var i = 0; i < len; i++) {
            varNames.push(modelData.varAttributes[i].varName);
        }
        return varNames;
    };
    SceneObjectEntity.prototype.addBehavior = function (behaviorData, loop, targetPlayerSceneObject, onOver, cover, startIndex, Immediate, forceStopLastBehavior, delayFrame, executor) {
        if (startIndex === void 0) { startIndex = 0; }
        if (Immediate === void 0) { Immediate = true; }
        if (forceStopLastBehavior === void 0) { forceStopLastBehavior = false; }
        if (delayFrame === void 0) { delayFrame = 0; }
        if (executor === void 0) { executor = null; }
        return null;
    };
    SceneObjectEntity.prototype.getBehaviorIndex = function (behavior) {
        return this.behaviors ? this.behaviors.indexOf(behavior) : -1;
    };
    SceneObjectEntity.prototype.getBehaviors = function () {
        return this.behaviors;
    };
    SceneObjectEntity.prototype.clearBehaviors = function () {
        if (this.behaviors)
            this.behaviors.length = 0;
    };
    SceneObjectEntity.prototype.getCommandTrigger = function (mainType, indexType, scene, executor, uiCompID) {
        if (uiCompID === void 0) { uiCompID = null; }
        if (mainType < 0 || indexType < 0)
            return null;
        if (executor == null)
            executor = this;
        var trigger;
        if (mainType == CommandTrigger.COMMAND_MAIN_TYPE_CALL_COMMON_EVENT) {
            return new CommandTrigger(mainType, indexType, scene, this, true, this);
        }
        if (mainType == CommandTrigger.COMMAND_MAIN_TYPE_FRAGMENT_EVENT) {
            return new CommandTrigger(mainType, indexType, scene, this, true, executor);
        }
        var typeCmd = [Common.customSceneEventTypeList, Common.customObjectEventTypeList, Common.customUIEventTypeList][mainType].data[indexType + 1];
        if (typeCmd) {
            if (mainType == CommandTrigger.COMMAND_MAIN_TYPE_UI) {
                if (typeCmd.multiline) {
                    return new CommandTrigger(mainType, indexType, scene, this, typeCmd.multiline, executor);
                }
                else {
                    var lineSign = uiCompID + "_" + indexType;
                    var trigger = this.triggerSingleLines[lineSign];
                    if (!trigger)
                        trigger = this.triggerSingleLines[lineSign] = new CommandTrigger(mainType, indexType, scene, this, typeCmd.multiline, executor);
                }
            }
            else {
                if (typeCmd.multiline) {
                    return new CommandTrigger(mainType, indexType, scene, this, typeCmd.multiline, executor);
                }
                else {
                    var triggerID = mainType * 1000000 + indexType * 10000 + executor.index;
                    var trigger = this.triggerSingleLines[triggerID];
                    if (!trigger)
                        trigger = this.triggerSingleLines[triggerID] = new CommandTrigger(mainType, indexType, scene, this, typeCmd.multiline, executor);
                }
            }
        }
        return trigger;
    };
    SceneObjectEntity.getModulesSaveData = function (soc, depthClone) {
        if (depthClone === void 0) { depthClone = true; }
        var soModuleArr = [];
        for (var i = 0; i < soc._modules.length; i++) {
            var soModule = soc._modules[i];
            var soModuleData;
            if (Config.IS_SERVER) {
                soModuleData = ObjectUtils.depthClone(soModule);
            }
            else {
                soModuleData = {};
                var moduleData = Game.data.sceneObjectModuleList.data[soModule.id];
                for (var s = 0; s < moduleData.varAttributes.length; s++) {
                    var attrSetting = moduleData.varAttributes[s];
                    soModuleData[attrSetting.varName] = soModule[attrSetting.varName];
                }
                for (var s = 0; s < moduleData.preLayer.length; s++) {
                    var preLayer = moduleData.preLayer[s];
                    if (preLayer.type == 2 || preLayer.type == 4) {
                        soModuleData[preLayer.varName] = preLayer.id;
                    }
                    else if (preLayer.type == 3) {
                        var uiRoot = soModule[preLayer.varName];
                        soModuleData[preLayer.varName] = uiRoot ? uiRoot.guiID : 0;
                    }
                    else if (preLayer.type == 5) {
                        var ani = soModule[preLayer.varName];
                        soModuleData[preLayer.varName] = ani ? ani.id : 0;
                    }
                }
                if (depthClone)
                    soModuleData = ObjectUtils.depthClone(soModuleData);
            }
            soModuleArr.push(soModuleData);
        }
        return soModuleArr;
    };
    SceneObjectEntity.prototype.installModulesByTypeValue = function (moduleIDs, moduleDisplayList, modulesCustomAttribute, presetDatas) {
        if (presetDatas === void 0) { presetDatas = null; }
        this.removeAllModules();
        this.moduleIDs = [];
        this.moduleDisplayList = [];
        for (var i = 0; i < moduleIDs.length; i++) {
            var moduleID = moduleIDs[i];
            var soModulePresetData = {};
            var moduleData = Game.data.sceneObjectModuleList.data[moduleID];
            if (moduleData) {
                CustomAttributeSetting.installAttributeFromEditorSet(soModulePresetData, modulesCustomAttribute[i], moduleData.varAttributes, false, false, GameData.CUSTOM_ATTR_SCENE_OBJECT_MODULE_DATA);
                for (var s = 0; s < moduleData.preLayer.length; s++) {
                    var p = moduleData.preLayer[s];
                    var displayInfos = moduleDisplayList[i];
                    if (displayInfos) {
                        var displayInfo = displayInfos[p.varName];
                        if (displayInfo != null) {
                            soModulePresetData[p.varName] = displayInfo.id;
                        }
                        else {
                            soModulePresetData[p.varName] = 0;
                        }
                    }
                }
                if (presetDatas) {
                    var presetData = presetDatas[i];
                    if (presetData) {
                        ObjectUtils.clone(presetData, soModulePresetData);
                    }
                }
                var soModule = SceneObject.createModule(moduleID, this, soModulePresetData);
                if (soModule)
                    this.addModule(soModule);
            }
        }
    };
    SceneObjectEntity.prototype.addModule = function (soModule, sendEvent) {
        if (sendEvent === void 0) { sendEvent = true; }
        if (ArrayUtils.matchAttributes(this._modules, { id: soModule.id }, true).length == 1)
            return false;
        var moduleData = Common.sceneObjectModuleList.data[soModule.id];
        if (moduleData) {
            this._modules.push(soModule);
            this.moduleIDs.push(soModule.id);
            var moduleDisplayInfo = {};
            this.moduleDisplayList.push(moduleDisplayInfo);
            for (var i = 0; i < moduleData.preLayer.length; i++) {
                var p = moduleData.preLayer[i];
                var id;
                var attributeValue = soModule[p.varName];
                if (attributeValue != null) {
                    if (p.type == SceneObjectModelData.TYPE_UI_DESIGNATION || p.type == SceneObjectModelData.TYPE_UI_TYPE) {
                        id = typeof attributeValue == "number" ? attributeValue : attributeValue.guiID;
                    }
                    else {
                        id = typeof attributeValue == "number" ? attributeValue : attributeValue.id;
                    }
                }
                else {
                    id = p.id;
                }
                moduleDisplayInfo[p.varName] = { type: p.type, id: id };
            }
            soModule.so = this;
            if (sendEvent)
                EventUtils.happen(SceneObjectEntity, SceneObjectEntity.EVENT_ON_ADD_MODULE, [this, soModule]);
            return true;
        }
        return false;
    };
    SceneObjectEntity.prototype.addModuleAt = function (soModule, index, sendEvent) {
        if (sendEvent === void 0) { sendEvent = true; }
        if (index < 0 || index > this._modules.length)
            return false;
        if (ArrayUtils.matchAttributes(this._modules, { id: soModule.id }, true).length == 1)
            return false;
        var bool = this.addModule(soModule, false);
        if (bool) {
            var fromIndex = this._modules.length - 1;
            bool = this.setModuleIndexByIndex(fromIndex, index);
            if (sendEvent)
                EventUtils.happen(SceneObjectEntity, SceneObjectEntity.EVENT_ON_ADD_MODULE, [this, soModule]);
            return bool;
        }
        return false;
    };
    SceneObjectEntity.prototype.addModuleByID = function (moduleID, sendEvent) {
        if (sendEvent === void 0) { sendEvent = true; }
        if (ArrayUtils.matchAttributes(this._modules, { id: moduleID }, true).length == 1)
            return null;
        var soModule = SceneObject.createModule(moduleID, this);
        if (!soModule)
            return null;
        var bool = this.addModule(soModule, sendEvent);
        if (bool)
            return soModule;
    };
    SceneObjectEntity.prototype.addModuleByIDAt = function (moduleID, index, sendEvent) {
        if (sendEvent === void 0) { sendEvent = true; }
        var soModule = this.addModuleByID(moduleID, sendEvent);
        if (soModule) {
            var fromIndex = this._modules.length - 1;
            var bool = this.setModuleIndexByIndex(fromIndex, index);
            if (bool)
                return soModule;
        }
        return null;
    };
    SceneObjectEntity.prototype.removeAllModules = function (isDispose, sendEvent) {
        if (isDispose === void 0) { isDispose = true; }
        if (sendEvent === void 0) { sendEvent = true; }
        if (this._modules) {
            var removeModuleArr = this._modules.concat();
        }
        if (this.moduleDisplayList)
            this.moduleDisplayList.length = 0;
        this._modules.length = 0;
        if (this.moduleIDs)
            this.moduleIDs.length = 0;
        if (removeModuleArr) {
            for (var i = 0; i < removeModuleArr.length; i++) {
                var soModule = removeModuleArr[i];
                soModule.onRemoved();
                if (sendEvent) {
                    EventUtils.happen(SceneObjectEntity, SceneObjectEntity.EVENT_ON_REMOVE_MODULE, [this, soModule]);
                }
                if (isDispose) {
                    soModule.dispose && soModule.dispose();
                }
            }
        }
    };
    SceneObjectEntity.prototype.removeModuleByID = function (moduleID, isDispose, sendEvent) {
        if (isDispose === void 0) { isDispose = true; }
        if (sendEvent === void 0) { sendEvent = true; }
        var index = ArrayUtils.matchAttributes(this._modules, { id: moduleID }, true, "==", true)[0];
        if (index != null) {
            this.moduleDisplayList.splice(index, 1);
            this.moduleIDs.splice(index, 1);
            var soModule = this._modules.splice(index, 1)[0];
            if (soModule) {
                soModule.onRemoved();
                if (sendEvent) {
                    EventUtils.happen(SceneObjectEntity, SceneObjectEntity.EVENT_ON_REMOVE_MODULE, [this, soModule]);
                }
                if (isDispose) {
                    soModule.dispose && soModule.dispose();
                }
            }
            return soModule;
        }
        return null;
    };
    SceneObjectEntity.prototype.removeModule = function (soModule, isDispose, sendEvent) {
        if (isDispose === void 0) { isDispose = true; }
        if (sendEvent === void 0) { sendEvent = true; }
        var index = this._modules.indexOf(soModule);
        if (index != -1) {
            this.moduleDisplayList.splice(index, 1);
            this.moduleIDs.splice(index, 1);
            this._modules.splice(index, 1);
            soModule.onRemoved();
            if (sendEvent) {
                EventUtils.happen(SceneObjectEntity, SceneObjectEntity.EVENT_ON_REMOVE_MODULE, [this, soModule]);
            }
            if (isDispose) {
                soModule.dispose && soModule.dispose();
            }
            return true;
        }
        return false;
    };
    SceneObjectEntity.prototype.removeModuleAt = function (index, isDispose, sendEvent) {
        if (isDispose === void 0) { isDispose = true; }
        if (sendEvent === void 0) { sendEvent = true; }
        if (index < 0 || index >= this._modules.length)
            return false;
        if (index != null) {
            var soModule = this._modules[index];
            this.moduleDisplayList.splice(index, 1);
            this.moduleIDs.splice(index, 1);
            this._modules.splice(index, 1);
            soModule.onRemoved();
            if (sendEvent) {
                EventUtils.happen(SceneObjectEntity, SceneObjectEntity.EVENT_ON_REMOVE_MODULE, [this, soModule]);
            }
            if (isDispose) {
                soModule.dispose && soModule.dispose();
            }
            return true;
        }
        return false;
    };
    SceneObjectEntity.prototype.setModuleIndex = function (soModule, toIndex) {
        var index = this._modules.indexOf(soModule);
        if (index != -1)
            return this.setModuleIndexByIndex(index, toIndex);
        return false;
    };
    SceneObjectEntity.prototype.setModuleIndexByID = function (moduleID, toIndex) {
        var index = ArrayUtils.matchAttributes(this._modules, { id: moduleID }, true, "==", true)[0];
        if (index != null)
            return this.setModuleIndexByIndex(index, toIndex);
        return false;
    };
    SceneObjectEntity.prototype.setModuleIndexByIndex = function (fromIndex, toIndex) {
        if (fromIndex < 0 || fromIndex >= this._modules.length)
            return false;
        if (toIndex < 0 || toIndex >= this._modules.length)
            return false;
        var fromObj = this._modules.splice(fromIndex, 1)[0];
        this._modules.splice(toIndex, 0, fromObj);
        fromObj = this.moduleIDs.splice(fromIndex, 1)[0];
        this.moduleIDs.splice(toIndex, 0, fromObj);
        fromObj = this.moduleDisplayList.splice(fromIndex, 1)[0];
        this.moduleDisplayList.splice(toIndex, 0, fromObj);
        return true;
    };
    SceneObjectEntity.prototype.getModule = function (moduleID) {
        return ArrayUtils.matchAttributes(this._modules, { id: moduleID }, true)[0];
    };
    SceneObjectEntity.prototype.getModuleByName = function (moduleName) {
        return ArrayUtils.matchAttributes(this._modules, { name: moduleName }, true)[0];
    };
    SceneObjectEntity.prototype.getModuleAt = function (index) {
        if (index >= 0 && index < this._modules.length) {
            return this._modules[index];
        }
    };
    SceneObjectEntity.prototype.getModuleIndex = function (soModule) {
        return this._modules.indexOf(soModule);
    };
    SceneObjectEntity.prototype.getModuleIndexByID = function (moduleID) {
        var index = ArrayUtils.matchAttributes(this._modules, { id: moduleID }, true, "==", true)[0];
        if (index == null)
            return -1;
        return index;
    };
    Object.defineProperty(SceneObjectEntity.prototype, "moduleLength", {
        get: function () {
            return this._modules.length;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneObjectEntity.prototype, "world", {
        get: function () {
            return Config.IS_SERVER ? ServerWorld : ClientWorld;
        },
        enumerable: false,
        configurable: true
    });
    SceneObjectEntity.prototype.clearCondition = function () {
        for (var id in this.conditionWorldVars) {
            var varID = parseInt(id);
            this.world.removeListenerVariable(0, varID, this.conditionChangeRefreshCB);
        }
        for (var id in this.conditionWorldSwitchs) {
            var varID = parseInt(id);
            this.world.removeListenerVariable(1, varID, this.conditionChangeRefreshCB);
        }
        for (var id in this.conditionPlayerVars) {
            var varID = parseInt(id);
            if (!Config.IS_SERVER)
                Game.player.removeListenerPlayerVariable(0, varID, this.conditionChangeRefreshCB);
        }
        for (var id in this.conditionPlayerSwitchs) {
            var varID = parseInt(id);
            if (!Config.IS_SERVER)
                Game.player.removeListenerPlayerVariable(1, varID, this.conditionChangeRefreshCB);
        }
        this.conditionPlayerVars = {};
        this.conditionPlayerSwitchs = {};
        this.conditionMySwitchs = {};
        this.conditionWorldSwitchs = {};
        this.conditionWorldVars = {};
    };
    SceneObjectEntity.prototype.____getConditions = function () {
        this.condition;
    };
    SceneObjectEntity.prototype.initCondition = function () {
        this.clearCondition();
        var startStpIndedx = MathUtils.int(this.currentStatusPageIndex);
        var stpLen = this.statusPages.length;
        for (var i = startStpIndedx; i < stpLen; i++) {
            var stp = this.statusPages[i];
            var conditions = stp.event.condition;
            for (var s = 0; s < conditions.length; s++) {
                var condition = conditions[s];
                if (condition.type != 2 && !this.conditionChangeRefreshCB) {
                    this.conditionChangeRefreshCB = Callback.New(this.refreshDisappearStatus, this);
                }
                if (condition.type == 1) {
                    if (!this.conditionPlayerVars[condition.varID]) {
                        this.conditionPlayerVars[condition.varID] = true;
                        if (!Config.IS_SERVER)
                            Game.player.addListenerPlayerVariable(0, condition.varID, this.conditionChangeRefreshCB, false, false);
                    }
                }
                if (condition.type == 0) {
                    if (!this.conditionPlayerVars[condition.varID]) {
                        this.conditionPlayerSwitchs[condition.varID] = true;
                        if (!Config.IS_SERVER)
                            Game.player.addListenerPlayerVariable(1, condition.varID, this.conditionChangeRefreshCB, false, false);
                    }
                }
                if (condition.type == 3) {
                    if (!this.conditionWorldVars[condition.varID]) {
                        this.conditionWorldVars[condition.varID] = true;
                        this.world.addListenerVariable(0, condition.varID, this.conditionChangeRefreshCB);
                    }
                }
                if (condition.type == 4) {
                    if (!this.conditionWorldSwitchs[condition.varID]) {
                        this.conditionWorldSwitchs[condition.varID] = true;
                        this.world.addListenerVariable(1, condition.varID, this.conditionChangeRefreshCB);
                    }
                }
                if (condition.type == 2)
                    this.conditionMySwitchs[condition.varID] = true;
            }
        }
        return;
    };
    SceneObjectEntity.prototype.refreshDisappearStatus = function (sign, recordData) {
        if (sign === void 0) { sign = null; }
        if (recordData === void 0) { recordData = null; }
        if (!this.statusPages)
            return;
        var stpLen = this.statusPages.length;
        var stpIndex = null;
        var lastInScene = this.inScene;
        var changeStatusPage = false;
        if (sign != "rd")
            recordData = null;
        for (var s = stpLen - 1; s >= 0; s--) {
            var stp = this.statusPages[s];
            var conditions = stp.event.condition;
            if (!conditions)
                continue;
            var len = conditions.length;
            var curStpInScene = true;
            for (var i = 0; i < len; i++) {
                var condition = conditions[i];
                if (Config.IS_SERVER && condition.type <= 1) {
                    continue;
                }
                if (condition.type == 3 || condition.type == 1) {
                    var varValue = condition.type == 3 ? this.world.getWorldVariable(condition.varID) : Game.player.variable.getVariable(condition.varID);
                    if ((condition.compare == 0 && varValue !== condition.value) ||
                        (condition.compare == 1 && varValue < condition.value) ||
                        (condition.compare == 2 && varValue <= condition.value) ||
                        (condition.compare == 3 && varValue > condition.value) ||
                        (condition.compare == 4 && varValue >= condition.value) ||
                        (condition.compare == 5 && varValue === condition.value)) {
                        curStpInScene = false;
                        break;
                    }
                }
                else if ((condition.type == 2 && this.switchs[condition.varID] !== condition.value) ||
                    (condition.type == 4 && this.world.getWorldSwitch(condition.varID) !== MathUtils.int(condition.value)) ||
                    (condition.type == 0 && !Config.IS_SERVER && Game.player.variable.getSwitch(condition.varID) !== MathUtils.int(condition.value))) {
                    curStpInScene = false;
                    break;
                }
            }
            if (!curStpInScene)
                continue;
            stpIndex = s;
            if (this.currentStatusPageIndex !== stpIndex) {
                if (this.currentStatusPageIndex != null) {
                    EventUtils.happen(SceneObjectEntity, SceneObjectEntity.EVENT_BEFORE_CHANGE_STATUS_PAGE, [this]);
                    EventUtils.happen(this, SceneObjectEntity.EVENT_BEFORE_CHANGE_STATUS_PAGE_FOR_INSTANCE, [this]);
                }
                if (recordData) {
                    var modelData = Common.sceneObjectModelList.data[recordData.modelID];
                    if (modelData) {
                        for (var o in SceneObject.self) {
                            if (SceneObject.statusCommonAttributes[o])
                                continue;
                            this[o] = recordData[o];
                        }
                        for (var o in SceneObject.compoundAttributes) {
                            var attrName = SceneObject.compoundAttributes[o];
                            this[attrName] = ObjectUtils.depthClone(recordData[attrName]);
                        }
                        SceneObject.installCustomData(this, stp.customAttribute);
                        var fixModelData;
                        if (Config.useNewSceneObjectModel) {
                            fixModelData = Common.sceneObjectModelList.data[0];
                        }
                        else {
                            fixModelData = modelData;
                        }
                        CustomAttributeSetting.installAttributeFromRecordData(this, recordData, fixModelData.varAttributes, null, 3);
                        var recoveryModulesData = SceneObjectEntity.recoveryModulesData[this.index];
                        if (recoveryModulesData) {
                            if (recoveryModulesData.needCheckModulesCustomAttributes) {
                                var sceneData = Common.sceneList.data[Game.currentScene.id];
                                var sceneObjDatas = sceneData.sceneObjectData;
                                if (stpIndex == 0) {
                                    var modulesCustomAttributes = sceneObjDatas.modulesCustomAttributes[this.index];
                                }
                                else {
                                    var stps = sceneObjDatas.statusPages[this.index];
                                    if (stps) {
                                        var stp = stps[stpIndex - 1];
                                        modulesCustomAttributes = stp.modulesCustomAttribute;
                                    }
                                }
                            }
                            var moduleIDs = this.moduleIDs.concat();
                            var moduleDisplayList = this.moduleDisplayList.concat();
                            if (!modulesCustomAttributes) {
                                modulesCustomAttributes = [];
                                for (var i = 0; i < moduleIDs.length; i++) {
                                    var moduleID = moduleIDs[i];
                                    var moduleData = Common.sceneObjectModuleList.data[moduleID];
                                    if (!moduleData) {
                                        moduleIDs.splice(i, 1);
                                        moduleDisplayList.splice(i, 1);
                                        i--;
                                    }
                                    modulesCustomAttributes.push(CustomAttributeSetting.formatCustomData(null, moduleData.varAttributes));
                                }
                            }
                            this.installModulesByTypeValue(moduleIDs, moduleDisplayList, modulesCustomAttributes, recoveryModulesData.presetData);
                        }
                    }
                }
                else {
                    for (var o in stp.so) {
                        if (SceneObject.statusCommonAttributes[o])
                            continue;
                        if (o == "moduleIDs" || o == "moduleDisplayList")
                            continue;
                        this[o] = stp.so[o];
                    }
                    for (var o in SceneObject.compoundAttributes) {
                        var attrName = SceneObject.compoundAttributes[o];
                        if (attrName == "moduleIDs" || attrName == "moduleDisplayList")
                            continue;
                        this[attrName] = ObjectUtils.depthClone(stp.so[attrName]);
                    }
                    var customAttributesCache = ObjectUtils.depthClone(this.getCustomAttributeCache(stpIndex));
                    ObjectUtils.clone(customAttributesCache, this);
                    if (Config.useNewSceneObjectModel) {
                        if (stp.so.moduleIDs == null)
                            stp.so.moduleIDs = [];
                        if (this.moduleIDs == null)
                            this.moduleIDs = [];
                        this.removeAllModules();
                        for (var i = 0; i < stp.so.moduleIDs.length; i++) {
                            var moduleID = stp.so.moduleIDs[i];
                            var soModulePresetData = ObjectUtils.depthClone(this.getModuleCustomAttributeCache(stpIndex, i));
                            var soModule = SceneObject.createModule(moduleID, this, soModulePresetData);
                            if (soModule)
                                this.addModule(soModule);
                        }
                    }
                }
                this.hasCommand = this.hasCommandCache[stpIndex];
                this.customCommandPages = this.customCommandPagesCache[stpIndex];
                if (!this.hasCommand) {
                    this.hasCommand = this.hasCommandCache[stpIndex] = [];
                    this.customCommandPages = this.customCommandPagesCache[stpIndex] = [];
                    for (var o in stp.event.customCommands) {
                        var customCmd = stp.event.customCommands[o];
                        if (!customCmd || customCmd.length <= 0 || (customCmd.length == 1 && Array.isArray(customCmd[0]) && customCmd[0][0] == -1))
                            continue;
                        this.customCommandPages[o] = new CommandPage(customCmd);
                        this.hasCommand[o] = true;
                    }
                }
                this.currentStatusPageIndex = stpIndex;
                this.initCondition();
                changeStatusPage = true;
            }
            break;
        }
        var curInScene;
        if (stpIndex == null) {
            curInScene = false;
            if (!Config.IS_SERVER && Config.compatibleOldProgram) {
                SceneObject.installCustomData(this, this.statusPages[0].customAttribute);
            }
            if (this.currentStatusPageIndex != null) {
                this.currentStatusPageIndex = null;
                this.initCondition();
                changeStatusPage = true;
            }
        }
        else {
            curInScene = true;
        }
        var state = 0;
        this.inScene = curInScene;
        if (lastInScene != curInScene) {
            if (curInScene) {
                state = 1;
            }
            else {
                state = 2;
            }
        }
        return { state: state, changeStatusPage: changeStatusPage };
    };
    SceneObjectEntity.EVENT_BEFORE_CHANGE_STATUS_PAGE = "SceneObjectEVENT_BEFORE_CHANGE_STATUS_PAGE";
    SceneObjectEntity.EVENT_BEFORE_CHANGE_STATUS_PAGE_FOR_INSTANCE = "SceneObjectEntityEVENT_BEFORE_CHANGE_STATUS_PAGE_FOR_INSTANCE";
    SceneObjectEntity.EVENT_CHANGE_STATUS_PAGE = "SceneObjectEVENT_ENABLED_CHANGE";
    SceneObjectEntity.EVENT_CHANGE_STATUS_PAGE_FOR_INSTANCE = "SceneObjectEntityEVENT_CHANGE_STATUS_PAGE_FOR_INSTANCE";
    SceneObjectEntity.EVENT_ON_ADD_MODULE = "SceneObjectEntityEVENT_ON_ADD_MODULE";
    SceneObjectEntity.EVENT_ON_REMOVE_MODULE = "SceneObjectEntityEVENT_ON_REMOVE_MODULE";
    SceneObjectEntity.recoveryModulesData = [];
    return SceneObjectEntity;
}(SceneObject));
var SceneObjectOneData = (function () {
    function SceneObjectOneData() {
        this.sid = ObjectUtils.getRandID();
        this.soPages = [];
    }
    SceneObjectOneData.sceneObjectData2PresetData = function (sceneSoData, soIndex, screenshotName, soName) {
        var soData = sceneSoData.sceneObjects[soIndex];
        if (soData) {
            var oneData = new SceneObjectOneData;
            var page1 = new SceneObjectStatusPageData;
            page1.so = ObjectUtils.depthClone(soData);
            page1.customAttribute = ObjectUtils.depthClone(sceneSoData.customAttributes[soIndex]);
            page1.event = ObjectUtils.depthClone(sceneSoData.events[soIndex]);
            page1.customAttributesCache = ObjectUtils.depthClone(sceneSoData.customAttributesCaches[soIndex]);
            page1.modulesCustomAttribute = ObjectUtils.depthClone(sceneSoData.modulesCustomAttributes[soIndex]);
            page1.modulesCustomAttributesCaches = ObjectUtils.depthClone(sceneSoData.modulesCustomAttributesCaches[soIndex]);
            oneData.soPages.push(page1);
            var otherPages = ObjectUtils.depthClone(sceneSoData.statusPages[soIndex]);
            oneData.soPages = oneData.soPages.concat(otherPages);
            oneData.screenshotName = screenshotName;
            oneData.soName = soName;
            return oneData;
        }
        return null;
    };
    SceneObjectOneData.presetData2SceneObjectData = function (sceneSoData, presetData, soIndex) {
        var soPages = presetData.soPages.concat();
        var page1 = ObjectUtils.depthClone(soPages.shift());
        var so = sceneSoData.sceneObjects[soIndex] = page1.so;
        so.index = soIndex;
        sceneSoData.events[soIndex] = page1.event;
        sceneSoData.customAttributes[soIndex] = page1.customAttribute;
        sceneSoData.modulesCustomAttributes[soIndex] = page1.modulesCustomAttribute;
        sceneSoData.statusPages[soIndex] = ObjectUtils.depthClone(soPages);
        return so;
    };
    SceneObjectOneData.screenshotSaveUrl = "gcUserData/soPresetImage/";
    return SceneObjectOneData;
}());
var SceneObjectStatusPageData = (function () {
    function SceneObjectStatusPageData() {
    }
    return SceneObjectStatusPageData;
}());
var SelectedSenceData = (function () {
    function SelectedSenceData() {
        this.isVer = false;
        this.id = 0;
        this.x = 0;
        this.y = 0;
        this.isCell = true;
        this.ori = 0;
    }
    return SelectedSenceData;
}());
var Variable = (function () {
    function Variable(listener) {
        if (listener === void 0) { listener = null; }
        this.variables = [];
        this.switchs = [];
        this.strings = [];
        this.listener = listener;
    }
    Variable.prototype.getVariable = function (varID) {
        var v = this.variables[varID];
        return v == null ? 0 : v;
    };
    Variable.prototype.setVariable = function (varID, v) {
        this.variables[varID] = v;
        this.listener && this.listener.onVarChange(0, varID, v);
    };
    Variable.prototype.getSwitch = function (varID) {
        var v = this.switchs[varID];
        return v == null ? 0 : v;
    };
    Variable.prototype.setSwitch = function (varID, v) {
        this.switchs[varID] = v;
        this.listener && this.listener.onVarChange(1, varID, v);
    };
    Variable.prototype.getString = function (varID) {
        var v = this.strings[varID];
        return v == null ? "" : v;
    };
    Variable.prototype.setString = function (varID, v) {
        this.strings[varID] = v;
        this.listener && this.listener.onVarChange(2, varID, v);
    };
    Variable.splitDynamicText = function (str) {
        var reg = /\[\${1,2}(v|s|w)\d+\]|\[\@{1,2}(v|s|w|p|f)\d+\]/g;
        var m = str.match(reg);
        if (!m)
            return [[0, str]];
        var startIndex = 0;
        var arr = [];
        for (var i = 0; i < m.length; i++) {
            var keyWord = m[i];
            var keyWordIndex = str.indexOf(keyWord, startIndex);
            if (startIndex != keyWordIndex) {
                arr.push([0, str.substr(startIndex, keyWordIndex - startIndex)]);
            }
            startIndex = keyWordIndex + keyWord.length;
            var firstKey = keyWord[1];
            var second = keyWord[2];
            var third = keyWord[3];
            var num = keyWord.substr(3, keyWord.length - 4);
            var num1 = keyWord.substr(4, keyWord.length - 5);
            if (firstKey == "$") {
                if (second == "v") {
                    arr.push([1, num]);
                }
                else if (second == "w") {
                    arr.push([2, num]);
                }
                else if (second == "s") {
                    arr.push([3, num]);
                }
                else if (second == "$") {
                    if (third == "v") {
                        arr.push([9, num1]);
                    }
                    else {
                        arr.push([10, num1]);
                    }
                }
            }
            else if (firstKey == "@") {
                if (second == "v") {
                    arr.push([4, num]);
                }
                else if (second == "w") {
                    arr.push([5, num]);
                }
                else if (second == "p") {
                    arr.push([7, num]);
                }
                else if (second == "f") {
                    arr.push([8, num]);
                }
                else if (second == "s") {
                    arr.push([6, num]);
                }
                else if (second == "@") {
                    if (third == "v") {
                        arr.push([11, num1]);
                    }
                    else {
                        arr.push([12, num1]);
                    }
                }
            }
        }
        if (startIndex != str.length) {
            arr.push([0, str.substr(startIndex)]);
        }
        return arr;
    };
    Variable.margeDynamicText = function (texts, player, trigger) {
        if (player === void 0) { player = null; }
        if (trigger === void 0) { trigger = null; }
        var len = texts.length;
        var str = "";
        for (var i = 0; i < len; i++) {
            var text = texts[i];
            var type = text[0];
            if (type >= 4 && !player)
                continue;
            if (type == 0) {
                str += text[1];
            }
            else if (type == 1) {
                str += Command.gameWorld.getWorldVariable(text[1]);
            }
            else if (type == 2) {
                str += Command.gameWorld.getWorldSwitch(text[1]);
            }
            else if (type == 3) {
                str += Command.gameWorld.getWorldString(text[1]);
            }
            else if (type == 4) {
                str += player.variable.getVariable(text[1]);
            }
            else if (type == 5) {
                str += player.variable.getSwitch(text[1]);
            }
            else if (type == 6) {
                str += player.variable.getString(text[1]);
            }
            else if (type == 7) {
                str += trigger.inputMessage[text[1]];
            }
            else if (type == 8) {
                var value = CustomValueFunction["f" + (text[1])](trigger, player);
                str += value;
            }
            else if (type == 9) {
                str += Command.gameWorld.getWorldVariable(player.variable.getVariable(text[1]));
            }
            else if (type == 10) {
                str += Command.gameWorld.getWorldString(player.variable.getVariable(text[1]));
            }
            else if (type == 11) {
                str += player.variable.getVariable(player.variable.getVariable(text[1]));
            }
            else if (type == 12) {
                str += player.variable.getString(player.variable.getVariable(text[1]));
            }
        }
        return str;
    };
    Variable.prototype.getTransportableData = function () {
        var o = {};
        o.variables = this.variables;
        o.switchs = this.switchs;
        o.strings = this.strings;
        return o;
    };
    return Variable;
}());
var CustomAttributeSetting = (function () {
    function CustomAttributeSetting() {
    }
    CustomAttributeSetting.getChangeUIAttrsData = function (d, uiID) {
        if (uiID === void 0) { uiID = 1; }
        if (!Array.isArray(d) || d[0] != CustomAttributeSetting.DATA_TYPE_UI_CHANGE_ATTRIBUTES)
            return [CustomAttributeSetting.DATA_TYPE_UI_CHANGE_ATTRIBUTES, [30, null, { uiID: uiID, atts: [] }, 0, 1, 0]];
        return d;
    };
    CustomAttributeSetting.getShaderUniformType = function (attr) {
        if (attr.varType == 0 || attr.compData.compType == 41)
            return "float";
        if (attr.compData.compType == 12)
            return "vec3";
        if (attr.compData.compType == 13 || attr.compData.compType == 22 || attr.compData.compType == 14)
            return "sampler2D";
        return null;
    };
    CustomAttributeSetting.getShaderTSType = function (attr) {
        if (attr.varType == 0)
            return "number";
        if (attr.compData.compType == 12)
            return "string";
        if (attr.compData.compType == 13 || attr.compData.compType == 22 || attr.compData.compType == 14)
            return "string";
        return null;
    };
    CustomAttributeSetting.getPreShaderTSType = function (attr) {
        if (attr.varType == 0)
            return "number";
        if (attr.compData.compType == 12)
            return "number[]";
        return null;
    };
    CustomAttributeSetting.compName = function (attr) {
        return attr.alias ? attr.alias : attr.varName;
    };
    CustomAttributeSetting.compNameTitleWidth = function (attr) {
        var compName = CustomAttributeSetting.compName(attr);
        if (attr.compData.compType == 15) {
            return 0;
        }
        var titleWidth = StringUtils.getRealLength(compName) * 7;
        return titleWidth;
    };
    CustomAttributeSetting.isHideComp = function (attr) {
        if (attr.hideMode)
            return true;
        if (Config.EDIT_MODE) {
            if (attr.varType == 5) {
                return EditorDataUICompAttribute.itemVarTypeMapping[attr.compData.compType] != 5;
            }
        }
        return false;
    };
    CustomAttributeSetting.init = function (data) {
        data.id = ObjectUtils.getRandID();
        data.varName = mainDomain_gcide.LanguageManager.parseIDE("[#GAME_UNNAMED_VARIABLE]");
        data.varType = 0;
        data.compData = { compType: 0, compParam: {} };
        data.defaultValue = "";
        data.hideMode = false;
        data.useCommand = false;
        data.onlyPointTo = false;
        data.moduleID = 1;
        data.dataStructureID = 1;
        data.arrayMode = false;
        data.arrayLength = 100;
        data.arrayAllowDelete = false;
        data.arrayAllowSwap = false;
        data.arrayAllowUpdate = false;
        data.accessMode = 1;
        data.syncMode = 0;
        data.attrTips = "";
        data.alias = "";
        data.onlyConfig = false;
        data.preview = false;
        data.autoTitleWidth = true;
        data.titleWidth = 100;
        data.eyeShow = true;
        data.lockBlock = false;
        data.enumEnable_get = true;
        data.enumEnable_set = true;
    };
    CustomAttributeSetting.getAPIRuntimes = function (varAttrs, jurisdictionRestriction, indent) {
        if (jurisdictionRestriction === void 0) { jurisdictionRestriction = false; }
        if (indent === void 0) { indent = "    "; }
        var code = "";
        for (var i in varAttrs) {
            var attr = varAttrs[i];
            if (jurisdictionRestriction && attr.accessMode == 0)
                continue;
            if (CustomAttributeSetting.ONLY_DISPLAY.indexOf(attr.compData.compType) != -1)
                continue;
            code += indent + this.getAPIRuntime(attr) + "\n";
        }
        return code;
    };
    CustomAttributeSetting.getAPIRuntime = function (attr, isStatic, needCreateComboboxItemAPI) {
        if (isStatic === void 0) { isStatic = false; }
        if (needCreateComboboxItemAPI === void 0) { needCreateComboboxItemAPI = false; }
        var str = "";
        var varTypeStr = "";
        if (needCreateComboboxItemAPI) {
            if (attr.varType < 3 && attr.compData.compType == 2) {
                var compParam = attr.compData.compParam;
                var items = compParam.items;
                if (items) {
                    str += attr.varName + "Items:string[]; // " + items + "\n    ";
                }
            }
        }
        switch (attr.varType) {
            case 0:
                varTypeStr = "number";
                break;
            case 1:
                varTypeStr = "string";
                break;
            case 2:
                varTypeStr = "boolean";
                break;
            case 3:
                varTypeStr = CustomCompositeSetting.getVarTypeInEditorCode(0, attr.dataStructureID);
                break;
            case 4:
                if (attr.onlyPointTo) {
                    varTypeStr = "number";
                }
                else {
                    varTypeStr = CustomCompositeSetting.getVarTypeInEditorCode(1, attr.moduleID);
                }
                break;
            case 5:
                if (attr.compData.compType == 49) {
                    varTypeStr = "{ size: number, gridData: number[][] }";
                }
                else if (attr.compData.compType == 46) {
                    varTypeStr = "{ uiID: number, compName:string, compID:string, varName:string }";
                }
                else if (attr.compData.compType == 43) {
                    varTypeStr = "{ materials: MaterialData[] }[]";
                }
                else if (attr.compData.compType == 54 || attr.compData.compType == 55 || attr.compData.compType == 56 || attr.compData.compType == 57 || attr.compData.compType == 58) {
                    varTypeStr = "CustomCompData";
                }
                else if (attr.compData.compType == 59) {
                    varTypeStr = "SelectedSenceData";
                }
                else {
                    varTypeStr = "any";
                }
                break;
        }
        if (attr.arrayMode) {
            varTypeStr += "[]; // = [];";
        }
        else {
            if (attr.varType == 0) {
                varTypeStr += "; // = " + MathUtils.float(attr.defaultValue) + ";";
            }
            else if (attr.varType == 1) {
                varTypeStr += "; // = \"" + attr.defaultValue + "\";";
            }
            else if (attr.varType == 2) {
                varTypeStr += "; // = " + (attr.defaultValue.toLocaleLowerCase() == "true" || MathUtils.int(attr.defaultValue) ? "true" : "false") + ";";
            }
            else {
                if (attr.varType == 4) {
                    varTypeStr += "; // = " + MathUtils.float(attr.defaultValue) + ";";
                }
                else {
                    varTypeStr += ";";
                }
            }
            if (attr.alias) {
                if (varTypeStr.indexOf("//") == -1)
                    varTypeStr += " //";
                varTypeStr += " " + attr.alias;
            }
        }
        return str + ("" + (isStatic ? "static " : "") + (attr.onlyConfig ? "readonly " : "") + attr.varName + ": " + varTypeStr);
    };
    CustomAttributeSetting.getTypeName = function (data) {
        var arr = ["[#GAME_NUMBER]", "[#GAME_STRING]", "[#GAME_BOOLEAN]", "{[#GAME_CUSTOM_DATA_STRUCTURES]}", "{[#GAME_CUSTOM_MODULES]}", "[#GAME_OBJECT]"];
        var str = arr[data.varType];
        if (data.varType == 3) {
            var datastructure = Common.dataStructureList.data[data.dataStructureID];
            if (datastructure) {
                var name = GameListData.getName(Common.dataStructureList, data.dataStructureID);
                str = "<" + data.dataStructureID + "-" + name + ">";
            }
            else {
                str = "<--/-->";
            }
        }
        else if (data.varType == 4) {
            var customModule = Common.customModuleList.data[data.moduleID];
            if (customModule) {
                var name = GameListData.getName(Common.customModuleList, data.moduleID);
                if (data.onlyPointTo) {
                    str = arr[0] + ("[" + data.moduleID + "-" + name + "]");
                }
                else {
                    str = "[" + data.moduleID + "-" + name + "]";
                }
            }
            else {
                if (data.onlyPointTo) {
                    str = arr[0] + "[--/--]";
                }
                else {
                    str = "[--/--]";
                }
            }
        }
        if (data.arrayMode) {
            str += "[]";
        }
        return str;
    };
    CustomAttributeSetting.getSerializeAttrType = function (data, arrayEnabled) {
        if (arrayEnabled === void 0) { arrayEnabled = true; }
        var serializeAttrType = data.varType;
        if (serializeAttrType == 5) {
            return data.arrayMode ? CustomAttributeSetting.ATTR_TYPE_OBJECT_ARRAY : CustomAttributeSetting.ATTR_TYPE_OBJECT;
        }
        if (serializeAttrType == 4) {
            if (data.onlyPointTo) {
                serializeAttrType = 0;
            }
            else {
                serializeAttrType += 1;
            }
        }
        if (data.arrayMode && arrayEnabled)
            serializeAttrType += 6;
        return serializeAttrType;
    };
    CustomAttributeSetting.formatCustomData = function (myCustomAttributes, attrPerSettings) {
        if (!(Array.isArray(attrPerSettings))) {
            attrPerSettings = CustomCompositeSetting.getAllAttributes(attrPerSettings, false);
        }
        var newestDataStructureList = Common.dataStructureList;
        var newestCustomModuleList = Common.customModuleList;
        if (!myCustomAttributes)
            myCustomAttributes = {};
        for (var i in attrPerSettings) {
            var attrPerSetting = attrPerSettings[i];
            if (CustomAttributeSetting.ONLY_DISPLAY.indexOf(attrPerSetting.compData.compType) != -1)
                continue;
            var perVarName = attrPerSetting.varName;
            if (myCustomAttributes[perVarName] == null) {
                myCustomAttributes[perVarName] = CustomAttributeSetting.formatCustomDefaultValue(attrPerSetting, true);
            }
        }
        for (var myVarName in myCustomAttributes) {
            var m = ArrayUtils.matchAttributes(attrPerSettings, { varName: myVarName }, true);
            var perAttr = m[0];
            if (!perAttr) {
                delete myCustomAttributes[myVarName];
                continue;
            }
            if (CustomAttributeSetting.ONLY_DISPLAY.indexOf(perAttr.compData.compType) != -1)
                continue;
            var myAttr = myCustomAttributes[myVarName];
            if (!myAttr) {
                continue;
            }
            var mySerializeAttrType = myAttr.varType;
            var perSerializeAttrType = CustomAttributeSetting.getSerializeAttrType(perAttr);
            if (perSerializeAttrType != mySerializeAttrType) {
                myCustomAttributes[myVarName] = CustomAttributeSetting.formatCustomDefaultValue(perAttr, true);
            }
            else {
                if (mySerializeAttrType == CustomAttributeSetting.ATTR_TYPE_STRUCTURE || mySerializeAttrType == CustomAttributeSetting.ATTR_TYPE_STRUCTURE_ID_ARRAY) {
                    var dataStructure = newestDataStructureList.data[perAttr.dataStructureID];
                    if (!dataStructure) {
                        delete myCustomAttributes[myVarName];
                        continue;
                    }
                    var _attrPerSettings = CustomCompositeSetting.getAllAttributes(dataStructure, false);
                    var myAttrValue;
                    if (mySerializeAttrType == CustomAttributeSetting.ATTR_TYPE_STRUCTURE_ID_ARRAY) {
                        var valueArr = myAttr.value;
                        for (var i in valueArr) {
                            myAttrValue = valueArr[i];
                            CustomAttributeSetting.formatCustomData(myAttrValue, _attrPerSettings);
                        }
                    }
                    else {
                        myAttrValue = myAttr.value;
                        CustomAttributeSetting.formatCustomData(myAttrValue, _attrPerSettings);
                    }
                }
                else if (mySerializeAttrType == CustomAttributeSetting.ATTR_TYPE_MODULE_CLONE || mySerializeAttrType == CustomAttributeSetting.ATTR_TYPE_MODULE_CLONE_ARRAY) {
                    var customModule = newestCustomModuleList.data[perAttr.moduleID];
                    if (!customModule) {
                        delete myCustomAttributes[myVarName];
                        continue;
                    }
                    var _attrPerSettings = CustomCompositeSetting.getAllAttributes(customModule, false);
                    var myAttrValue;
                    if (mySerializeAttrType == CustomAttributeSetting.ATTR_TYPE_MODULE_CLONE_ARRAY) {
                        var valueDataArr = myAttr.value;
                        for (var i in valueDataArr) {
                            myAttrValue = valueDataArr[i].data;
                            CustomAttributeSetting.formatCustomData(myAttrValue, _attrPerSettings);
                        }
                    }
                    else {
                        myAttrValue = myAttr.value.data;
                        CustomAttributeSetting.formatCustomData(myAttrValue, _attrPerSettings);
                    }
                }
            }
        }
        return myCustomAttributes;
    };
    CustomAttributeSetting.formatCustomDefaultValue = function (varAttrSetting, arrayEnabled) {
        var newestDataStructureList = Common.dataStructureList;
        var newestCustomModuleList = Common.customModuleList;
        var perSerializeAttrType = CustomAttributeSetting.getSerializeAttrType(varAttrSetting, arrayEnabled);
        if (perSerializeAttrType == CustomAttributeSetting.ATTR_TYPE_OBJECT) {
            return { varType: perSerializeAttrType, value: {}, copy: false };
        }
        if (perSerializeAttrType >= CustomAttributeSetting.ATTR_TYPE_NUMBER_ARRAY) {
            return { varType: perSerializeAttrType, value: [], copy: false };
        }
        else {
            if (perSerializeAttrType == CustomAttributeSetting.ATTR_TYPE_NUMBER || perSerializeAttrType == CustomAttributeSetting.ATTR_TYPE_MODULE_ID) {
                return { varType: perSerializeAttrType, value: MathUtils.float(varAttrSetting.defaultValue), copy: false };
            }
            else if (perSerializeAttrType == CustomAttributeSetting.ATTR_TYPE_STRING) {
                return { varType: perSerializeAttrType, value: varAttrSetting.defaultValue, copy: false };
            }
            else if (perSerializeAttrType == CustomAttributeSetting.ATTR_TYPE_BOOLEAN) {
                return { varType: perSerializeAttrType, value: (varAttrSetting.defaultValue.toLocaleLowerCase() == "true" || MathUtils.int(varAttrSetting.defaultValue)) ? true : false, copy: false };
            }
            else if (perSerializeAttrType == CustomAttributeSetting.ATTR_TYPE_STRUCTURE) {
                var dataStructureID = varAttrSetting.dataStructureID;
                if (dataStructureID > 0) {
                    var dataSreucture = newestDataStructureList ? newestDataStructureList.data[dataStructureID] : null;
                    if (dataSreucture) {
                        var attrObjs = {};
                        var dsAttrs = CustomCompositeSetting.getAllAttributes(dataSreucture);
                        for (var i in dsAttrs) {
                            var dsAttr = dsAttrs[i];
                            var typeValue = CustomAttributeSetting.formatCustomDefaultValue(dsAttr.attr, true);
                            if (typeValue) {
                                attrObjs[dsAttr.attr.varName] = typeValue;
                            }
                        }
                        return { varType: perSerializeAttrType, value: attrObjs, copy: false };
                    }
                }
                return null;
            }
            else {
                if (varAttrSetting.onlyPointTo) {
                    return { varType: perSerializeAttrType, value: varAttrSetting.defaultValue, copy: false };
                }
                else {
                    var moduleID = varAttrSetting.moduleID;
                    if (moduleID > 0) {
                        var moduleSetting = newestCustomModuleList.data[moduleID];
                        if (moduleSetting) {
                            var mAttrObjs = { varType: perSerializeAttrType, value: { id: varAttrSetting.moduleID, data: {} }, copy: false };
                            var dsAttrs = CustomCompositeSetting.getAllAttributes(moduleSetting);
                            for (var i in dsAttrs) {
                                var dsAttr = dsAttrs[i];
                                var moduleDataID = MathUtils.int(varAttrSetting.defaultValue);
                                if (moduleDataID == 0)
                                    moduleDataID = 1;
                                mAttrObjs.value.id = moduleDataID;
                                var moduleDataList = Common.getCustomModuleDataList(moduleID);
                                var moduleData = moduleDataList ? moduleDataList.data[moduleDataID] : null;
                                if (moduleData) {
                                    CustomAttributeSetting.formatCustomModuleFromDataBasePereset(moduleData, mAttrObjs.value);
                                }
                                else {
                                    var typeValue = CustomAttributeSetting.formatCustomDefaultValue(dsAttr.attr, true);
                                    if (typeValue) {
                                        mAttrObjs.value.data[dsAttr.attr.varName] = typeValue;
                                    }
                                }
                            }
                            return mAttrObjs;
                        }
                    }
                    return null;
                }
            }
        }
    };
    CustomAttributeSetting.formatCustomModuleFromDataBasePereset = function (moduleData, myValue) {
        if (!moduleData) {
            myValue.data = null;
            return;
        }
        myValue.data = ObjectUtils.depthClone(moduleData.attrs);
    };
    CustomAttributeSetting.serializeCustomData = function (typeValue, attrPerSettings) {
        if (!typeValue)
            typeValue = {};
        this.formatCustomData(typeValue, attrPerSettings);
        if (!(attrPerSettings instanceof Array)) {
            attrPerSettings = CustomCompositeSetting.getAllAttributes(attrPerSettings, false);
        }
        var attrSettings = attrPerSettings;
        var target = {};
        this.installAttributeFromEditorSet(target, typeValue, attrSettings);
        var arr = [];
        for (var i in attrSettings) {
            var cusAttr = attrSettings[i];
            if (CustomAttributeSetting.ONLY_DISPLAY.indexOf(cusAttr.compData.compType) != -1)
                continue;
            var varName = cusAttr.varName;
            arr.push(target[varName]);
        }
        return arr;
    };
    CustomAttributeSetting.serializeCustomData2 = function (typeValue, attrPerSettings) {
        if (!typeValue)
            typeValue = {};
        this.formatCustomData(typeValue, attrPerSettings);
        if (!(attrPerSettings instanceof Array)) {
            attrPerSettings = CustomCompositeSetting.getAllAttributes(attrPerSettings, false);
        }
        var attrSettings = attrPerSettings;
        var target = {};
        this.installAttributeFromEditorSet(target, typeValue, attrSettings);
        var obj = {};
        for (var i in attrSettings) {
            var cusAttr = attrSettings[i];
            if (CustomAttributeSetting.ONLY_DISPLAY.indexOf(cusAttr.compData.compType) != -1)
                continue;
            obj[cusAttr.id] = target[cusAttr.varName];
        }
        return [obj];
    };
    CustomAttributeSetting.installAttributeFromEditorSet = function (target, editorSetAttrs, attrSettings, readOnly, jurisdictionRestriction, customAttrMode) {
        if (readOnly === void 0) { readOnly = false; }
        if (jurisdictionRestriction === void 0) { jurisdictionRestriction = false; }
        if (customAttrMode === void 0) { customAttrMode = -1; }
        for (var s in attrSettings) {
            var attrSetting = attrSettings[s];
            if (CustomAttributeSetting.ONLY_DISPLAY.indexOf(attrSetting.compData.compType) != -1)
                continue;
            var varName = attrSetting.varName;
            var editorSetAttr = editorSetAttrs[varName];
            if (jurisdictionRestriction && attrSetting.accessMode == 0) {
                continue;
            }
            this.typeValue2RealValue(target, attrSetting, editorSetAttr, readOnly, jurisdictionRestriction, customAttrMode);
        }
    };
    CustomAttributeSetting.typeValue2RealValue = function (target, attrSetting, editorSetAttr, readOnly, jurisdictionRestriction, customAttrMode) {
        if (readOnly === void 0) { readOnly = false; }
        if (jurisdictionRestriction === void 0) { jurisdictionRestriction = false; }
        if (customAttrMode === void 0) { customAttrMode = -1; }
        if (!editorSetAttr) {
            editorSetAttr = CustomAttributeSetting.formatCustomDefaultValue(attrSetting, true);
            if (!editorSetAttr) {
                return;
            }
        }
        var customModuleList = Common.customModuleList;
        var varName = attrSetting.varName;
        var value = attrSetting.arrayMode && Array.isArray(editorSetAttr.value) ? editorSetAttr.value.concat() : editorSetAttr.value;
        if (attrSetting.varType == 0 || (attrSetting.varType == 4 && attrSetting.onlyPointTo)) {
            setTargetAttr(target, varName, value, attrSetting);
        }
        else if (attrSetting.varType == 1) {
            setTargetAttr(target, varName, value, attrSetting);
        }
        else if (attrSetting.varType == 2) {
            setTargetAttr(target, varName, value, attrSetting);
        }
        else if (attrSetting.varType == 5) {
            setTargetAttr(target, varName, value, attrSetting);
        }
        else if (attrSetting.varType == 3) {
            var ds = Common.dataStructureList.data[attrSetting.dataStructureID];
            if (ds) {
                var dsAttrSettings = CustomCompositeSetting.getAllAttributes(ds, false);
                if (attrSetting.arrayMode) {
                    var dsArrObj = [];
                    setTargetAttr(target, varName, dsArrObj, attrSetting, true);
                    for (var i = 0; i < value.length; i++) {
                        var dsObj = {};
                        dsArrObj[i] = dsObj;
                        this.installAttributeFromEditorSet(dsObj, value[i], dsAttrSettings, readOnly, jurisdictionRestriction, customAttrMode);
                    }
                }
                else {
                    var dsObj = {};
                    setTargetAttr(target, varName, dsObj, attrSetting, true);
                    this.installAttributeFromEditorSet(dsObj, editorSetAttr.value, dsAttrSettings, readOnly, jurisdictionRestriction, customAttrMode);
                }
            }
        }
        else if (attrSetting.varType == 4) {
            var customModuleSetting = customModuleList.data[attrSetting.moduleID];
            var customModule = Common.getCustomModuleDataList(attrSetting.moduleID);
            if (customModuleSetting && customModule) {
                var mdAttrSettings = CustomCompositeSetting.getAllAttributes(customModuleSetting, false);
                if (attrSetting.arrayMode) {
                    var mdArrObj = [];
                    setTargetAttr(target, varName, mdArrObj, attrSetting, true);
                    for (var i = 0; i < value.length; i++) {
                        var preSetValue = value[i];
                        var moduleData = customModule.data[preSetValue.id];
                        if (moduleData) {
                            var mdObj;
                            if (!preSetValue.copy) {
                                var mdObj = {};
                                mdArrObj[i] = mdObj;
                                mdObj.id = preSetValue.id;
                                mdObj.name = GameListData.getName(customModule, mdObj.id);
                                var customModuleTypeData = Common.getCustomModuleDataList(attrSetting.moduleID);
                                if (customModuleTypeData) {
                                    var customModuleData = customModuleTypeData.data[preSetValue.id];
                                    if (customModuleData) {
                                        this.installAttributeFromEditorSet(mdObj, customModuleData.attrs, mdAttrSettings, readOnly, jurisdictionRestriction, customAttrMode);
                                    }
                                }
                            }
                            else {
                                var mdObj = {};
                                mdArrObj[i] = mdObj;
                                mdObj.id = preSetValue.id;
                                mdObj.name = GameListData.getName(customModule, mdObj.id);
                                this.installAttributeFromEditorSet(mdObj, preSetValue.data, mdAttrSettings, readOnly, jurisdictionRestriction, customAttrMode);
                            }
                        }
                    }
                }
                else {
                    var moduleData = customModule.data[editorSetAttr.value.id];
                    if (moduleData) {
                        if (!editorSetAttr.copy) {
                            var mdObj = {};
                            setTargetAttr(target, varName, mdObj, attrSetting, true);
                            mdObj.id = editorSetAttr.value.id;
                            mdObj.name = GameListData.getName(customModule, mdObj.id);
                            var customModuleTypeData = Common.getCustomModuleDataList(attrSetting.moduleID);
                            if (customModuleTypeData) {
                                var customModuleData = customModuleTypeData.data[editorSetAttr.value.id];
                                if (customModuleData) {
                                    this.installAttributeFromEditorSet(mdObj, customModuleData.attrs, mdAttrSettings, readOnly, jurisdictionRestriction, customAttrMode);
                                }
                            }
                        }
                        else {
                            var mdObj = {};
                            setTargetAttr(target, varName, mdObj, attrSetting, true);
                            mdObj.id = editorSetAttr.value.id;
                            mdObj.name = GameListData.getName(customModule, mdObj.id);
                            this.installAttributeFromEditorSet(mdObj, editorSetAttr.value.data, mdAttrSettings, readOnly, jurisdictionRestriction, customAttrMode);
                        }
                    }
                }
            }
        }
        function setTargetAttr(target, varName, value, attrSetting, dataStructorMode) {
            if (dataStructorMode === void 0) { dataStructorMode = false; }
            target[varName] = value;
        }
    };
    CustomAttributeSetting.installAttributeFromRecordData = function (target, recordDataAttrs, attrSettings, cfgs, customAttrMode, editorCfgs) {
        if (customAttrMode === void 0) { customAttrMode = -1; }
        if (editorCfgs === void 0) { editorCfgs = null; }
        if (recordDataAttrs == null)
            return;
        var varTypeMapping = ["number", "string", "boolean", null, "number"];
        for (var i in attrSettings) {
            var attrSetting = attrSettings[i];
            if (CustomAttributeSetting.ONLY_DISPLAY.indexOf(attrSetting.compData.compType) != -1)
                continue;
            var varName = attrSetting.varName;
            var recordValue = recordDataAttrs[varName];
            var recordValueType = typeof recordValue;
            var cfg = cfgs ? cfgs[varName] : null;
            var editorCfg = editorCfgs ? editorCfgs[varName] : null;
            if (recordValue == null) {
                this.typeValue2RealValue(target, attrSetting, cfg, false, false, customAttrMode);
                continue;
            }
            if (attrSetting.varType == 5) {
                target[varName] = recordValue;
            }
            else if (attrSetting.varType <= 2 || (attrSetting.varType == 4 && attrSetting.onlyPointTo)) {
                var varTypeOf = varTypeMapping[attrSetting.varType];
                if (attrSetting.arrayMode) {
                    if (attrSetting.onlyConfig && editorCfg) {
                        target[varName] = editorCfg.value.concat();
                        continue;
                    }
                    else {
                        if (recordValue instanceof Array) {
                            var targetArr = target[varName] = [];
                            for (var s in recordValue) {
                                var recordArrValue = recordValue[s];
                                if (recordArrValue == null)
                                    continue;
                                if (typeof recordArrValue == varTypeOf) {
                                    targetArr[s] = recordValue[s];
                                }
                            }
                        }
                    }
                }
                else {
                    if (attrSetting.onlyConfig && editorCfg) {
                        this.typeValue2RealValue(target, attrSetting, editorCfg, false, !Config.IS_SERVER, customAttrMode);
                        continue;
                    }
                    else {
                        if (recordValueType == varTypeOf) {
                            target[varName] = recordValue;
                        }
                    }
                }
            }
            else if (attrSetting.varType == 3) {
                var ds = Common.dataStructureList.data[attrSetting.dataStructureID];
                if (ds) {
                    var dsAttrSettings = CustomCompositeSetting.getAllAttributes(ds, false);
                    if (attrSetting.arrayMode) {
                        if (attrSetting.onlyConfig && editorCfg) {
                            var targetArr = target[varName] = [];
                            for (var i_6 = 0; i_6 < editorCfg.value.length; i_6++) {
                                var targetArrObs = targetArr[i_6] = {};
                                this.installAttributeFromEditorSet(targetArrObs, editorCfg.value[i_6], dsAttrSettings, false, !Config.IS_SERVER, customAttrMode);
                            }
                            continue;
                        }
                        else {
                            if (recordValue instanceof Array) {
                                var targetArr = target[varName] = [];
                                for (var s in recordValue) {
                                    var recordArrValue = recordValue[s];
                                    if (recordArrValue == null) {
                                        targetArr[s] = null;
                                    }
                                    else if (!(recordArrValue instanceof Array || !(recordArrValue instanceof Object))) {
                                        var newObj = targetArr[s] = {};
                                        var cfgValues = cfg ? cfg.value[s] : null;
                                        var editorCfgValues = editorCfg ? editorCfg.value[s] : null;
                                        this.installAttributeFromRecordData(newObj, recordArrValue, dsAttrSettings, cfgValues, -1, editorCfgValues);
                                    }
                                }
                            }
                        }
                    }
                    else {
                        if (!(recordValue instanceof Array || !(recordValue instanceof Object))) {
                            if (attrSetting.onlyConfig) {
                                this.installAttributeFromEditorSet(target[varName], customModuleData.attrs, mdAttrSettings, false, !Config.IS_SERVER, customAttrMode);
                            }
                            var cfgValues = cfg ? cfg.value[s] : null;
                            if (target[varName] == null)
                                target[varName] = {};
                            if (attrSetting.onlyConfig && editorCfg) {
                                this.installAttributeFromEditorSet(target[varName], editorCfg.value, dsAttrSettings, false, !Config.IS_SERVER, customAttrMode);
                                continue;
                            }
                            else {
                                this.installAttributeFromRecordData(target[varName], recordValue, dsAttrSettings, cfgValues, -1, editorCfg === null || editorCfg === void 0 ? void 0 : editorCfg.value);
                            }
                        }
                    }
                }
            }
            else if (attrSetting.varType == 4) {
                var customModuleSetting = Common.customModuleList.data[attrSetting.moduleID];
                var customModule = Common.getCustomModuleDataList(attrSetting.moduleID);
                if (customModuleSetting && customModule) {
                    var mdAttrSettings = CustomCompositeSetting.getAllAttributes(customModuleSetting, false);
                    if (attrSetting.arrayMode) {
                        if (attrSetting.onlyConfig && editorCfg) {
                            var targetArr = target[varName] = [];
                            for (var i_7 = 0; i_7 < editorCfg.value.length; i_7++) {
                                var mdObj = targetArr[i_7] = { id: editorCfg.value[i_7].id };
                                mdObj.name = GameListData.getName(customModule, mdObj.id);
                                var customModuleTypeData = Common.getCustomModuleDataList(attrSetting.moduleID);
                                if (customModuleTypeData) {
                                    var customModuleData = customModuleTypeData.data[mdObj.id];
                                    if (customModuleData) {
                                        this.installAttributeFromEditorSet(mdObj, customModuleData.attrs, mdAttrSettings, false, !Config.IS_SERVER, customAttrMode);
                                    }
                                }
                            }
                            continue;
                        }
                        else {
                            if (recordValue instanceof Array) {
                                var targetArr = target[varName] = [];
                                for (var s in recordValue) {
                                    var recordArrValue = recordValue[s];
                                    if (recordArrValue == null) {
                                        targetArr[s] = null;
                                    }
                                    else {
                                        var cfgValue = cfg ? cfg.value : null;
                                        var cfgValueS = cfgValue ? cfgValue[s] : null;
                                        if (attrSetting.onlyConfig) {
                                            var mdObj = targetArr[s] = { id: recordArrValue.id };
                                            if (recordArrValue.gcsysref) {
                                                mdObj.gcsysref = recordArrValue.gcsysref;
                                            }
                                            mdObj.name = GameListData.getName(customModule, mdObj.id);
                                            var customModuleTypeData = Common.getCustomModuleDataList(attrSetting.moduleID);
                                            if (customModuleTypeData) {
                                                var customModuleData = customModuleTypeData.data[mdObj.id];
                                                if (customModuleData) {
                                                    this.installAttributeFromEditorSet(mdObj, customModuleData.attrs, mdAttrSettings, false, !Config.IS_SERVER, customAttrMode);
                                                }
                                            }
                                        }
                                        else {
                                            var moduleData = customModule.data[recordArrValue.id];
                                            if (moduleData) {
                                                var newCfgs = cfgValueS ? cfgValueS.data : null;
                                                var mdObj = targetArr[s] = { id: recordArrValue.id };
                                                mdObj.name = recordArrValue.name != null ? recordArrValue.name : GameListData.getName(customModule, mdObj.id);
                                                this.installAttributeFromRecordData(mdObj, recordArrValue, mdAttrSettings, newCfgs, -1, moduleData.attrs);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    else {
                        if (attrSetting.onlyConfig) {
                            var mdObj = {};
                            target[varName] = mdObj;
                            if (recordValue.gcsysref) {
                                mdObj.gcsysref = recordValue.gcsysref;
                            }
                            mdObj.id = recordValue.id;
                            mdObj.name = GameListData.getName(customModule, mdObj.id);
                            var customModuleTypeData = Common.getCustomModuleDataList(attrSetting.moduleID);
                            if (customModuleTypeData) {
                                var customModuleData = customModuleTypeData.data[recordValue.id];
                                if (customModuleData) {
                                    this.installAttributeFromEditorSet(mdObj, customModuleData.attrs, mdAttrSettings, false, !Config.IS_SERVER, customAttrMode);
                                }
                            }
                        }
                        else {
                            var moduleData = customModule.data[recordValue.id];
                            if (moduleData) {
                                var targetAttr = target[varName];
                                if (targetAttr == null) {
                                    var name = recordValue.name != null ? recordValue.name : GameListData.getName(customModule, recordValue.id);
                                    targetAttr = target[varName] = { id: recordValue.id, name: name };
                                }
                                var newCfgs = cfg ? cfg.value.data : null;
                                this.installAttributeFromRecordData(target[varName], recordValue, mdAttrSettings, newCfgs, -1, moduleData.attrs);
                            }
                        }
                    }
                }
            }
        }
    };
    CustomAttributeSetting.createVarTypeAttrsByValue = function (attrSetting, values, useVarName) {
        if (useVarName === void 0) { useVarName = false; }
        var editAttrSetting = {};
        CustomAttributeSetting.formatCustomData(editAttrSetting, attrSetting);
        docreateVarTypeAttrsByValue(editAttrSetting, values, attrSetting, useVarName);
        function docreateVarTypeAttrsByValue(editAttrSetting, values, attrSetting, useVarName) {
            if (useVarName === void 0) { useVarName = false; }
            var orderAttrs = CustomCompositeSetting.getAllAttributes(attrSetting, false);
            var dIndex = 0;
            for (var i = 0; i < orderAttrs.length; i++) {
                var cusAttr = orderAttrs[i];
                if (CustomAttributeSetting.ONLY_DISPLAY.indexOf(cusAttr.compData.compType) != -1) {
                    dIndex--;
                    continue;
                }
                var varName = cusAttr.varName;
                var value = (!values ? null : (useVarName ? values[varName] : values[i + dIndex]));
                if (value == null)
                    continue;
                var typeValue = editAttrSetting[varName];
                if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_OBJECT || typeValue.varType == CustomAttributeSetting.ATTR_TYPE_OBJECT_ARRAY) {
                    typeValue.value = value;
                    continue;
                }
                if (typeValue.varType >= CustomAttributeSetting.ATTR_TYPE_NUMBER_ARRAY && !Array.isArray(value))
                    continue;
                if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_NUMBER) {
                    typeValue.value = MathUtils.float(value);
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_STRING) {
                    typeValue.value = String(value);
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_BOOLEAN) {
                    typeValue.value = value ? true : false;
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_STRUCTURE) {
                    var typeValueV = typeValue.value;
                    var ds = Common.dataStructureList.data[cusAttr.dataStructureID];
                    if (ds)
                        docreateVarTypeAttrsByValue(typeValueV, value, ds, true);
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_MODULE_ID) {
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_MODULE_CLONE) {
                    var typeValueV = typeValue.value ? typeValue.value.data : null;
                    if (typeValue.value && value) {
                        typeValue.value.id = value.id;
                    }
                    var customModuleSetting = Common.customModuleList.data[cusAttr.moduleID];
                    var customModule = Common.getCustomModuleDataList(cusAttr.moduleID);
                    if (customModuleSetting && customModule) {
                        docreateVarTypeAttrsByValue(typeValueV, value, customModuleSetting, true);
                    }
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_NUMBER_ARRAY) {
                    var onlyPointTo = (cusAttr.varType == 4 && cusAttr.onlyPointTo && cusAttr.arrayMode) ? true : false;
                    if (onlyPointTo) {
                        if (Array.isArray(value)) {
                            if (!typeValue.value)
                                typeValue.value = [];
                            for (var s in value) {
                                typeValue.value[s] = MathUtils.float(value[s]);
                            }
                        }
                    }
                    else {
                        if (!Array.isArray(typeValue.value))
                            typeValue.value = [];
                        for (var s in value) {
                            typeValue.value[s] = MathUtils.float(value[s]);
                        }
                    }
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_STRING_ARRAY) {
                    if (!Array.isArray(typeValue.value))
                        typeValue.value = [];
                    for (var s in value) {
                        typeValue.value[s] = String(value[s]);
                    }
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_BOOLEAN_ARRAY) {
                    if (!Array.isArray(typeValue.value))
                        typeValue.value = [];
                    for (var s in value) {
                        typeValue.value[s] = value[s] ? true : false;
                    }
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_STRUCTURE_ID_ARRAY) {
                    var typeArr = typeValue.value;
                    var ds = Common.dataStructureList.data[cusAttr.dataStructureID];
                    if (ds) {
                        typeArr = typeValue.value = [];
                        for (var s in value) {
                            var typeValueV = {};
                            CustomAttributeSetting.formatCustomData(typeValueV, ds);
                            typeArr.push(typeValueV);
                            docreateVarTypeAttrsByValue(typeValueV, value[s], ds, true);
                        }
                    }
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_MODULE_ID_ARRAY) {
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_MODULE_CLONE_ARRAY) {
                    var typeArr = typeValue.value;
                    var customModuleSetting = Common.customModuleList.data[cusAttr.moduleID];
                    var customModule = Common.getCustomModuleDataList(cusAttr.moduleID);
                    if (customModuleSetting && customModule) {
                        typeArr = typeValue.value = [];
                        for (var s in value) {
                            var typeValueVM = { id: value[s].id, data: {} };
                            CustomAttributeSetting.formatCustomData(typeValueVM.data, customModuleSetting);
                            typeArr.push(typeValueVM);
                            docreateVarTypeAttrsByValue(typeValueVM.data, value[s], customModuleSetting, true);
                        }
                    }
                }
            }
        }
        return editAttrSetting;
    };
    CustomAttributeSetting.createVarTypeAttrsByValue2 = function (attrSetting, values) {
        var editAttrSetting = {};
        CustomAttributeSetting.formatCustomData(editAttrSetting, attrSetting);
        var idAttrs = values[0];
        docreateVarTypeAttrsByValue(editAttrSetting, idAttrs, attrSetting);
        function docreateVarTypeAttrsByValue(editAttrSetting, values, attrSetting, useVarName) {
            if (useVarName === void 0) { useVarName = false; }
            var orderAttrs = CustomCompositeSetting.getAllAttributes(attrSetting, false);
            var dIndex = 0;
            for (var i = 0; i < orderAttrs.length; i++) {
                var cusAttr = orderAttrs[i];
                if (CustomAttributeSetting.ONLY_DISPLAY.indexOf(cusAttr.compData.compType) != -1) {
                    dIndex--;
                    continue;
                }
                var varName = cusAttr.varName;
                var value = (!values ? null : (useVarName ? values[varName] : values[cusAttr.id]));
                if (value == null)
                    continue;
                var typeValue = editAttrSetting[varName];
                if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_OBJECT || typeValue.varType == CustomAttributeSetting.ATTR_TYPE_OBJECT_ARRAY) {
                    typeValue.value = value;
                    continue;
                }
                if (typeValue.varType >= CustomAttributeSetting.ATTR_TYPE_NUMBER_ARRAY && !Array.isArray(value))
                    continue;
                if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_NUMBER) {
                    typeValue.value = MathUtils.float(value);
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_STRING) {
                    typeValue.value = String(value);
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_BOOLEAN) {
                    typeValue.value = value ? true : false;
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_STRUCTURE) {
                    var typeValueV = typeValue.value;
                    var ds = Common.dataStructureList.data[cusAttr.dataStructureID];
                    if (ds)
                        docreateVarTypeAttrsByValue(typeValueV, value, ds, true);
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_MODULE_ID) {
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_MODULE_CLONE) {
                    var typeValueV = typeValue.value ? typeValue.value.data : null;
                    if (typeValue.value && value) {
                        typeValue.value.id = value.id;
                    }
                    var customModuleSetting = Common.customModuleList.data[cusAttr.moduleID];
                    var customModule = Common.getCustomModuleDataList(cusAttr.moduleID);
                    if (customModuleSetting && customModule) {
                        docreateVarTypeAttrsByValue(typeValueV, value, customModuleSetting, true);
                    }
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_NUMBER_ARRAY) {
                    var onlyPointTo = (cusAttr.varType == 4 && cusAttr.onlyPointTo && cusAttr.arrayMode) ? true : false;
                    if (onlyPointTo) {
                        if (Array.isArray(value)) {
                            if (!typeValue.value)
                                typeValue.value = [];
                            for (var s in value) {
                                typeValue.value[s] = MathUtils.float(value[s]);
                            }
                        }
                    }
                    else {
                        if (!Array.isArray(typeValue.value))
                            typeValue.value = [];
                        for (var s in value) {
                            typeValue.value[s] = MathUtils.float(value[s]);
                        }
                    }
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_STRING_ARRAY) {
                    if (!Array.isArray(typeValue.value))
                        typeValue.value = [];
                    for (var s in value) {
                        typeValue.value[s] = String(value[s]);
                    }
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_BOOLEAN_ARRAY) {
                    if (!Array.isArray(typeValue.value))
                        typeValue.value = [];
                    for (var s in value) {
                        typeValue.value[s] = value[s] ? true : false;
                    }
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_STRUCTURE_ID_ARRAY) {
                    var typeArr = typeValue.value;
                    var ds = Common.dataStructureList.data[cusAttr.dataStructureID];
                    if (ds) {
                        typeArr = typeValue.value = [];
                        for (var s in value) {
                            var typeValueV = {};
                            CustomAttributeSetting.formatCustomData(typeValueV, ds);
                            typeArr.push(typeValueV);
                            docreateVarTypeAttrsByValue(typeValueV, value[s], ds, true);
                        }
                    }
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_MODULE_ID_ARRAY) {
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_MODULE_CLONE_ARRAY) {
                    var typeArr = typeValue.value;
                    var customModuleSetting = Common.customModuleList.data[cusAttr.moduleID];
                    var customModule = Common.getCustomModuleDataList(cusAttr.moduleID);
                    if (customModuleSetting && customModule) {
                        typeArr = typeValue.value = [];
                        for (var s in value) {
                            var typeValueVM = { id: value[s].id, data: {} };
                            CustomAttributeSetting.formatCustomData(typeValueVM.data, customModuleSetting);
                            typeArr.push(typeValueVM);
                            docreateVarTypeAttrsByValue(typeValueVM.data, value[s], customModuleSetting, true);
                        }
                    }
                }
            }
        }
        return editAttrSetting;
    };
    CustomAttributeSetting.ATTR_TYPE_NUMBER = 0;
    CustomAttributeSetting.ATTR_TYPE_STRING = 1;
    CustomAttributeSetting.ATTR_TYPE_BOOLEAN = 2;
    CustomAttributeSetting.ATTR_TYPE_STRUCTURE = 3;
    CustomAttributeSetting.ATTR_TYPE_MODULE_ID = 4;
    CustomAttributeSetting.ATTR_TYPE_MODULE_CLONE = 5;
    CustomAttributeSetting.ATTR_TYPE_NUMBER_ARRAY = 6;
    CustomAttributeSetting.ATTR_TYPE_STRING_ARRAY = 7;
    CustomAttributeSetting.ATTR_TYPE_BOOLEAN_ARRAY = 8;
    CustomAttributeSetting.ATTR_TYPE_STRUCTURE_ID_ARRAY = 9;
    CustomAttributeSetting.ATTR_TYPE_MODULE_ID_ARRAY = 10;
    CustomAttributeSetting.ATTR_TYPE_MODULE_CLONE_ARRAY = 11;
    CustomAttributeSetting.ATTR_TYPE_OBJECT = 12;
    CustomAttributeSetting.ATTR_TYPE_OBJECT_ARRAY = 13;
    CustomAttributeSetting.DATA_TYPE_UI_CHANGE_ATTRIBUTES = 10000001;
    CustomAttributeSetting.ONLY_DISPLAY = [32, 33];
    CustomAttributeSetting.shaderFloatUniform = [];
    return CustomAttributeSetting;
}());
var CustomGameAttribute = (function () {
    function CustomGameAttribute() {
    }
    CustomGameAttribute.getWorldSyncDataAttrNames = function (gameAttr) {
        if (!CustomGameAttribute.cacheWorldDataSyncAttrNames) {
            var attrs = CustomCompositeSetting.getAllAttributes(gameAttr.worldAttributeSetting, false);
            CustomGameAttribute.cacheWorldDataSyncAttrNames = [];
            for (var i in attrs) {
                var attrSetting = attrs[i];
                if (attrSetting.syncMode == 1) {
                    CustomGameAttribute.cacheWorldDataSyncAttrNames.push(attrSetting.varName);
                }
            }
        }
        return CustomGameAttribute.cacheWorldDataSyncAttrNames;
    };
    return CustomGameAttribute;
}());















var MapData = (function (_super) {
    __extends(MapData, _super);
    function MapData() {
        var _this_1 = _super !== null && _super.apply(this, arguments) || this;
        _this_1.preLoadAssets = [];
        _this_1.serverInstanceClassName = MapData.SERVER_SCENE_CORE_CLASS;
        _this_1.clientInstanceClassName = MapData.CLIENT_SCENE_CORE_CLASS;
        return _this_1;
    }
    MapData.SERVER_SCENE_CORE_CLASS = "GameServerScene";
    MapData.CLIENT_SCENE_CORE_CLASS = "GameClientScene";
    return MapData;
}(Scene));
var MultiversionData = (function () {
    function MultiversionData() {
        this.versionDataList = [];
        this.bringSource = true;
    }
    return MultiversionData;
}());
var versionSouceData = (function () {
    function versionSouceData() {
        this.classType = 0;
        this.ruleType = 0;
    }
    return versionSouceData;
}());
var OriginalData = (function () {
    function OriginalData() {
    }
    return OriginalData;
}());
var TypeTreeNode = (function () {
    function TypeTreeNode() {
    }
    return TypeTreeNode;
}());















var SceneData = (function (_super) {
    __extends(SceneData, _super);
    function SceneData() {
        var _this_1 = _super !== null && _super.apply(this, arguments) || this;
        _this_1.mapData = new MapData();
        _this_1.sceneObjectData = new SceneObjectData();
        return _this_1;
    }
    return SceneData;
}(OriginalData));















var SceneLayerData = (function (_super) {
    __extends(SceneLayerData, _super);
    function SceneLayerData() {
        var _this_1 = _super !== null && _super.apply(this, arguments) || this;
        _this_1.dx = 0;
        _this_1.dy = 0;
        _this_1.scaleX = 1;
        _this_1.scaleY = 1;
        _this_1.skewX = 0;
        _this_1.skewY = 0;
        _this_1.rotation = 0;
        _this_1.xMove = 0;
        _this_1.yMove = 0;
        _this_1.prospectsPerX = 1;
        _this_1.prospectsPerY = 1;
        _this_1.xLoop = false;
        _this_1.yLoop = false;
        _this_1.opacity = 1;
        _this_1.blendMode = null;
        _this_1.drawMode = false;
        _this_1.tileData = [];
        _this_1.autoTileDataCache = [];
        _this_1.img = null;
        _this_1.modeType = true;
        _this_1.modeLock = false;
        return _this_1;
    }
    return SceneLayerData;
}(OriginalData));
var SceneObjectData = (function () {
    function SceneObjectData() {
        this.sceneObjects = [];
        this.customCommands = [];
        this.customAttributes = [];
        this.modulesCustomAttributes = [];
        this.customAttributesCaches = [];
        this.modulesCustomAttributesCaches = [];
        this.events = [];
        this.statusPages = [];
        this.statusPagesSelectedIndexs = [];
    }
    SceneObjectData.clone = function (soIndex, sceneSoData) {
        var so = sceneSoData.sceneObjects[soIndex];
        var newData = {
            so: new SceneObject(),
            event: null,
            customAttribute: null,
            modulesCustomAttribute: null,
            statusPage: [],
            statusPagesSelectedIndex: 0
        };
        newData.so = SceneObject.__gcClone(so);
        newData.event = ObjectUtils.depthClone(sceneSoData.events[so.index]);
        newData.customAttribute = ObjectUtils.depthClone(sceneSoData.customAttributes[so.index]);
        newData.modulesCustomAttribute = ObjectUtils.depthClone(sceneSoData.modulesCustomAttributes[so.index]);
        var statusPages = sceneSoData.statusPages[so.index];
        if (statusPages && statusPages.length > 0) {
            for (var s = 0; s < statusPages.length; s++) {
                var statusPage = statusPages[s];
                var newStatusData = {
                    so: new SceneObject(),
                    event: null,
                    customAttribute: null,
                    modulesCustomAttribute: null
                };
                newStatusData.so = SceneObject.__gcClone(statusPage.so);
                newStatusData.event = ObjectUtils.depthClone(statusPage.event);
                newStatusData.customAttribute = ObjectUtils.depthClone(statusPage.customAttribute);
                newStatusData.modulesCustomAttribute = ObjectUtils.depthClone(statusPage.modulesCustomAttribute);
                newData.statusPage.push(newStatusData);
            }
        }
        newData.statusPagesSelectedIndex = sceneSoData.statusPagesSelectedIndexs[so.index];
        return newData;
    };
    SceneObjectData.init = function (sceneObjectData, index) {
        sceneObjectData.events[index] = {
            condition: [],
            customCommands: []
        };
        sceneObjectData.customAttributes[index] = {};
        sceneObjectData.statusPages[index] = [];
        this.formatOneStatusPageModuleCustomData(sceneObjectData, index, 1);
    };
    SceneObjectData.prototype.addByPresetData = function (presetData, soIndex) {
    };
    SceneObjectData.getStatusPagesSelectedIndex = function (sceneObjectData, soIndex) {
        var soData = sceneObjectData.sceneObjects[soIndex];
        if (soData) {
            var modelData = Game.data.sceneObjectModelList.data[soData.modelID];
            ;
            if (!modelData || !modelData.supportStatusPage)
                return 0;
            var _statusPagesSelectedIndex = MathUtils.int(sceneObjectData.statusPagesSelectedIndexs[soIndex]);
            if (_statusPagesSelectedIndex < 0)
                _statusPagesSelectedIndex = 0;
            var statusPages = sceneObjectData.statusPages[soIndex];
            if (!statusPages)
                return 0;
            var len = statusPages.length + 1;
            if (_statusPagesSelectedIndex >= len - 1)
                _statusPagesSelectedIndex = len - 1;
            return _statusPagesSelectedIndex;
        }
        return 0;
    };
    SceneObjectData.getStatusPageInfo = function (sceneID, soIndex, stpIndex) {
        var bornSceneID = EUISceneMain_SO.bornScene ? EUISceneMain_SO.bornScene.id : Config.BORN.sceneID;
        var bornSoIndex = EUISceneMain_SO.bornSo ? EUISceneMain_SO.bornSo.index : Config.BORN.so.index;
        if (bornSceneID == sceneID && soIndex == bornSoIndex) {
            return {
                so: Config.BORN.so,
                customAttribute: Config.BORN.customAttribute,
                event: null,
                modulesCustomAttribute: Config.BORN.bornModulesCustomAttribute
            };
        }
        else {
            var sceneData = Game.data.sceneList.data[sceneID];
            if (sceneData) {
                var sceneObjectData = sceneData.sceneObjectData;
                if (stpIndex == 0) {
                    return {
                        so: sceneObjectData.sceneObjects[soIndex],
                        customAttribute: sceneObjectData.customAttributes[soIndex],
                        event: sceneObjectData.events[soIndex],
                        modulesCustomAttribute: sceneObjectData.modulesCustomAttributes[soIndex]
                    };
                }
                else {
                    var statusPages = sceneObjectData.statusPages[soIndex];
                    return statusPages ? statusPages[stpIndex - 1] : null;
                }
            }
        }
        return null;
    };
    SceneObjectData.formatAllStatusPageCommonModule = function (sceneObjectData, soIndex) {
        var fixModelData;
        if (Config.useNewSceneObjectModel) {
            fixModelData = Game.data.sceneObjectModelList.data[0];
        }
        var soData = sceneObjectData.sceneObjects[soIndex];
        if (soData) {
            if (!Config.useNewSceneObjectModel) {
                fixModelData = Game.data.sceneObjectModelList.data[soData.modelID];
            }
            if (fixModelData) {
                this.formatDisplayList(soData, fixModelData, soData.displayList);
                var customAttributes = sceneObjectData.customAttributes[soIndex];
                if (!customAttributes)
                    customAttributes = sceneObjectData.customAttributes[soIndex] = {};
                sceneObjectData.customAttributes[soIndex] = CustomAttributeSetting.formatCustomData(customAttributes, fixModelData.varAttributes);
            }
        }
        var statusPage = sceneObjectData.statusPages[soIndex];
        if (statusPage) {
            for (var stIndex = 0; stIndex < statusPage.length; stIndex++) {
                var stp = statusPage[stIndex];
                if (!Config.useNewSceneObjectModel) {
                    fixModelData = Game.data.sceneObjectModelList.data[soData.modelID];
                }
                if (fixModelData) {
                    this.formatDisplayList(stp.so, fixModelData, stp.so.displayList);
                    var customAttributes = stp.customAttribute;
                    if (!customAttributes)
                        customAttributes = stp.customAttribute = {};
                    stp.customAttribute = CustomAttributeSetting.formatCustomData(customAttributes, fixModelData.varAttributes);
                }
            }
        }
    };
    SceneObjectData.formatOneStatusPageCommonModuleDisplayList = function (soData, refModelData, displayList) {
        this.formatDisplayList(soData, refModelData, displayList);
    };
    SceneObjectData.formatEntityModules = function (soData, soc, modulesCustomAttributes) {
        if (!Config.useNewSceneObjectModel)
            return;
        if (!soData.moduleIDs) {
            var modelData = Common.sceneObjectModelList.data[soData.modelID];
            if (!modelData)
                return;
            soData.moduleIDs = modelData.presetModules.concat();
        }
        if (!soc.moduleIDs) {
            soc.moduleIDs = [];
            soc.moduleDisplayList = [];
            soc.removeAllModules();
            for (var i = 0; i < soData.moduleIDs.length; i++) {
                var moduleID = soData.moduleIDs[i];
                var moduleData = Common.sceneObjectModuleList.data[moduleID];
                if (moduleData) {
                    var modulesCustomAttribute = modulesCustomAttributes ? modulesCustomAttributes[i] : null;
                    var presetData = {};
                    if (!modulesCustomAttribute) {
                        modulesCustomAttribute = {};
                        CustomAttributeSetting.formatCustomData(modulesCustomAttribute, moduleData.varAttributes);
                        modulesCustomAttributes[i] = modulesCustomAttribute;
                    }
                    CustomAttributeSetting.installAttributeFromEditorSet(presetData, modulesCustomAttribute, moduleData.varAttributes, false, false, GameData.CUSTOM_ATTR_SCENE_OBJECT_MODULE_DATA);
                    for (var s = 0; s < moduleData.preLayer.length; s++) {
                        var p = moduleData.preLayer[s];
                        if (!soData.moduleDisplayList)
                            soData.moduleDisplayList = [];
                        var displayInfos = soData.moduleDisplayList[i];
                        if (displayInfos) {
                            var displayInfo = displayInfos[p.varName];
                            if (displayInfo != null) {
                                presetData[p.varName] = displayInfo.id;
                            }
                            else {
                                presetData[p.varName] = 0;
                            }
                        }
                    }
                    var soModule = SceneObject.createModule(moduleID, soc, presetData);
                    if (soModule) {
                        soc.addModule(soModule);
                    }
                }
            }
        }
        for (var m = 0; m < soc.moduleIDs.length; m++) {
            var moduleID = soc.moduleIDs[m];
            var modlueData = Common.sceneObjectModuleList.data[moduleID];
            if (modlueData) {
                if (!soc.moduleDisplayList)
                    soc.moduleDisplayList = [];
                var displayList = soc.moduleDisplayList[m];
                if (!displayList)
                    displayList = soc.moduleDisplayList[m] = {};
                this.formatDisplayList(soc, modlueData, displayList);
            }
            else {
                var soModuleDisplay = soc.moduleDisplayList[m];
                if (soModuleDisplay) {
                    soc.moduleDisplayList.splice(m, 1);
                }
                soc.moduleIDs.splice(m, 1);
                m--;
            }
        }
    };
    SceneObjectData.installEntityCommonData = function (soc, customAttribute) {
        if (!Config.useNewSceneObjectModel)
            return;
        var commonModuleData = Game.data.sceneObjectModelList.data[0];
        for (var i = 0; i < commonModuleData.varAttributes.length; i++) {
            var varAttribute = commonModuleData.varAttributes[i];
            var typeValue = customAttribute[varAttribute.varName];
            CustomAttributeSetting.typeValue2RealValue(soc, commonModuleData.varAttributes[i], typeValue, false, false, GameData.CUSTOM_ATTR_SCENE_OBJECT_DATA);
        }
    };
    SceneObjectData.resetBornDefaultModules = function () {
        var modelData = Common.sceneObjectModelList.data[Config.BORN.so.modelID];
        Config.BORN.so.moduleIDs = modelData.presetModules.concat();
        Config.BORN.bornModulesCustomAttribute = [];
        for (var i = 0; i < Config.BORN.so.moduleIDs.length; i++) {
            var moduleID = Config.BORN.so.moduleIDs[i];
            var moduleData = Game.data.sceneObjectModuleList.data[moduleID];
            if (!moduleData) {
                Config.BORN.so.moduleIDs.splice(i, 1);
                i--;
            }
            Config.BORN.bornModulesCustomAttribute.push(CustomAttributeSetting.formatCustomData(null, moduleData.varAttributes));
        }
        SceneObjectData.formatBornModuleCustomData(Config.BORN.so, Config.BORN.bornModulesCustomAttribute);
        EditorData.updateNeedSaveFile(EditorData.NEED_SAVE_CONFIG);
    };
    SceneObjectData.resetDefaultModules = function (sceneID, sceneObjectData, sceneObjectIndex) {
        if (!Config.useNewSceneObjectModel)
            return;
        var mainStatusPageSoData = sceneObjectData.sceneObjects[sceneObjectIndex];
        if (!mainStatusPageSoData)
            return;
        var modelData = Common.sceneObjectModelList.data[mainStatusPageSoData.modelID];
        if (!modelData)
            return;
        mainStatusPageSoData.moduleIDs = modelData.presetModules.concat();
        var modulesCustomAttributes = sceneObjectData.modulesCustomAttributes[sceneObjectIndex] = [];
        for (var i = 0; i < mainStatusPageSoData.moduleIDs.length; i++) {
            var moduleID = mainStatusPageSoData.moduleIDs[i];
            var moduleData = Game.data.sceneObjectModuleList.data[moduleID];
            if (!moduleData) {
                mainStatusPageSoData.moduleIDs.splice(i, 1);
                i--;
            }
            modulesCustomAttributes.push(CustomAttributeSetting.formatCustomData(null, moduleData.varAttributes));
        }
        this.formatOneStatusPageModuleCustomData(sceneObjectData, sceneObjectIndex, 1);
        var statusPage = sceneObjectData.statusPages[sceneObjectIndex];
        if (statusPage) {
            for (var stIndex = 0; stIndex < statusPage.length; stIndex++) {
                var stpSo = statusPage[stIndex].so;
                var modulesCustomAttributes = statusPage[stIndex].modulesCustomAttribute = [];
                stpSo.moduleIDs = modelData.presetModules.concat();
                for (var i = 0; i < stpSo.moduleIDs.length; i++) {
                    var moduleID = stpSo.moduleIDs[i];
                    var moduleData = Game.data.sceneObjectModuleList.data[moduleID];
                    if (!moduleData) {
                        stpSo.moduleIDs.splice(i, 1);
                        i--;
                    }
                    modulesCustomAttributes.push(CustomAttributeSetting.formatCustomData(null, moduleData.varAttributes));
                }
                this.formatOneStatusPageModuleCustomData(sceneObjectData, sceneObjectIndex, stIndex + 2);
            }
        }
        EditorData.updateNeedSaveFile(EditorData.NEED_SAVE_SCENE_OBJECTS, false, sceneID);
    };
    SceneObjectData.formatAllStatusPageModuleCustomData = function (sceneObjectData, sceneObjectIndex) {
        if (!Config.useNewSceneObjectModel)
            return;
        this.formatOneStatusPageModuleCustomData(sceneObjectData, sceneObjectIndex, 1);
        var statusPage = sceneObjectData.statusPages[sceneObjectIndex];
        if (statusPage) {
            for (var stIndex = 0; stIndex < statusPage.length; stIndex++) {
                this.formatOneStatusPageModuleCustomData(sceneObjectData, sceneObjectIndex, stIndex + 2);
            }
        }
    };
    SceneObjectData.formatOneStatusPageModuleCustomData = function (sceneObjectData, sceneObjectIndex, stPageID) {
        if (!Config.useNewSceneObjectModel)
            return;
        if (stPageID == 1) {
            SceneObjectData.initModuleData(sceneObjectData, sceneObjectIndex, 1);
            var soData = sceneObjectData.sceneObjects[sceneObjectIndex];
            if (soData) {
                var customAttributesArr = sceneObjectData.modulesCustomAttributes[sceneObjectIndex];
                if (!customAttributesArr)
                    customAttributesArr = sceneObjectData.modulesCustomAttributes[sceneObjectIndex] = [];
                this.doFormatOneStatusPageModuleCustomData(soData, customAttributesArr);
            }
        }
        else {
            var statusPage = sceneObjectData.statusPages[sceneObjectIndex];
            if (statusPage) {
                SceneObjectData.initModuleData(sceneObjectData, sceneObjectIndex, stPageID);
                var stIndex = stPageID - 2;
                var stPage = statusPage[stIndex];
                var customAttributesArr = stPage.modulesCustomAttribute;
                if (!customAttributesArr)
                    customAttributesArr = stPage.modulesCustomAttribute = [];
                this.doFormatOneStatusPageModuleCustomData(stPage.so, customAttributesArr);
            }
        }
    };
    SceneObjectData.formatBornModuleCustomData = function (soData, customAttributesArr) {
        if (!soData)
            return;
        SceneObjectData.initModuleDataBySceneObjectData(soData);
        this.doFormatOneStatusPageModuleCustomData(soData, customAttributesArr);
    };
    SceneObjectData.removeModule = function (sceneObjectData, sceneObjectIndex, stPageIndex, moduleIndex) {
        if (stPageIndex == 0) {
            var soData = sceneObjectData.sceneObjects[sceneObjectIndex];
            var modulesCustomAttribute = sceneObjectData.modulesCustomAttributes[sceneObjectIndex];
        }
        else {
            var stpInfo = sceneObjectData.statusPages[sceneObjectIndex];
            if (!stpInfo)
                return;
            var stp = stpInfo[stPageIndex - 1];
            if (!stp)
                return;
            var soData = stp.so;
            var modulesCustomAttribute = stp.modulesCustomAttribute;
        }
        this.removeModuleData(soData, moduleIndex, modulesCustomAttribute);
    };
    SceneObjectData.removeModuleData = function (soData, moduleIndex, modulesCustomAttribute) {
        if (modulesCustomAttribute) {
            modulesCustomAttribute.splice(moduleIndex, 1);
        }
        if (soData.moduleIDs) {
            soData.moduleIDs.splice(moduleIndex, 1);
        }
        if (soData.moduleDisplayList) {
            soData.moduleDisplayList.splice(moduleIndex, 1);
        }
    };
    SceneObjectData.addModule = function (sceneObjectData, sceneObjectIndex, stPageIndex, moduleIndex, moduleID) {
        if (stPageIndex == 0) {
            var soData = sceneObjectData.sceneObjects[sceneObjectIndex];
            var modulesCustomAttribute = sceneObjectData.modulesCustomAttributes[sceneObjectIndex];
        }
        else {
            var stpInfo = sceneObjectData.statusPages[sceneObjectIndex];
            if (!stpInfo)
                return;
            var stp = stpInfo[stPageIndex - 1];
            if (!stp)
                return;
            var soData = stp.so;
            var modulesCustomAttribute = stp.modulesCustomAttribute;
        }
        this.addModuleData(soData, moduleIndex, moduleID, modulesCustomAttribute);
    };
    SceneObjectData.addModuleData = function (soData, moduleIndex, moduleID, modulesCustomAttribute) {
        if (!soData.moduleDisplayList)
            soData.moduleDisplayList = [];
        if (!soData.moduleIDs)
            soData.moduleIDs = [];
        soData.moduleIDs.splice(moduleIndex, 0, moduleID);
        soData.moduleDisplayList.splice(moduleIndex, 0, {});
        modulesCustomAttribute.splice(moduleIndex, 0, {});
        this.doFormatOneStatusPageModuleCustomData(soData, modulesCustomAttribute);
    };
    SceneObjectData.setModuleIndexByIndex = function (sceneObjectData, sceneObjectIndex, stPageIndex, moduleIndex, toIndex) {
        if (stPageIndex == 0) {
            var soData = sceneObjectData.sceneObjects[sceneObjectIndex];
            var modulesCustomAttribute = sceneObjectData.modulesCustomAttributes[sceneObjectIndex];
        }
        else {
            var stpInfo = sceneObjectData.statusPages[sceneObjectIndex];
            if (!stpInfo)
                return;
            var stp = stpInfo[stPageIndex - 1];
            if (!stp)
                return;
            var soData = stp.so;
            var modulesCustomAttribute = stp.modulesCustomAttribute;
        }
        this.setModuleDataIndexByIndex(soData, moduleIndex, toIndex, modulesCustomAttribute);
    };
    SceneObjectData.setModuleDataIndexByIndex = function (soData, moduleIndex, toIndex, modulesCustomAttribute) {
        if (modulesCustomAttribute) {
            var m = modulesCustomAttribute.splice(moduleIndex, 1)[0];
            modulesCustomAttribute.splice(toIndex, 0, m);
        }
        if (soData.moduleIDs) {
            var m = soData.moduleIDs.splice(moduleIndex, 1)[0];
            soData.moduleIDs.splice(toIndex, 0, m);
        }
        if (soData.moduleDisplayList) {
            var m = soData.moduleDisplayList.splice(moduleIndex, 1)[0];
            soData.moduleDisplayList.splice(toIndex, 0, m);
        }
    };
    SceneObjectData.newStatusPage = function (sceneObjectData, soIndex, stpID, stpData) {
        if (stpData === void 0) { stpData = null; }
        if (stpID < 1)
            return;
        var statusPages = sceneObjectData.statusPages[soIndex];
        if (!statusPages)
            statusPages = sceneObjectData.statusPages[soIndex] = [];
        var statusPageData = stpData ? stpData : {
            so: new SceneObject,
            customAttribute: {},
            event: {
                condition: [],
                customCommands: []
            }
        };
        statusPages.splice(stpID - 1, 0, statusPageData);
        this.formatOneStatusPageModuleCustomData(sceneObjectData, soIndex, stpID + 1);
    };
    SceneObjectData.delStatusPage = function (sceneObjectData, soIndex, stpID) {
        if (stpID < 0)
            return;
        var statusPages = sceneObjectData.statusPages[soIndex];
        if (!statusPages || statusPages.length == 0)
            return;
        if (stpID == 0) {
            var stp = statusPages.splice(0, 1)[0];
            sceneObjectData.sceneObjects[soIndex] = stp.so;
            sceneObjectData.events[soIndex] = stp.event;
            sceneObjectData.customAttributes[soIndex] = stp.customAttribute;
            sceneObjectData.modulesCustomAttributes[soIndex] = stp.modulesCustomAttribute;
        }
        else {
            statusPages.splice(stpID - 1, 1);
        }
    };
    SceneObjectData.clearStatusPage = function (sceneObjectData, soIndex, stpID) {
        if (stpID < 0)
            return;
        var statusPageData = {
            so: new SceneObject,
            customAttribute: {},
            event: {
                condition: [],
                customCommands: []
            },
            customAttributesCache: null,
            modulesCustomAttribute: [],
            modulesCustomAttributesCaches: null
        };
        if (stpID == 0) {
            sceneObjectData.sceneObjects[soIndex] = statusPageData.so;
            sceneObjectData.events[soIndex] = statusPageData.event;
            sceneObjectData.customAttributes[soIndex] = statusPageData.customAttribute;
            sceneObjectData.modulesCustomAttributes[soIndex] = statusPageData.modulesCustomAttribute;
        }
        else {
            var statusPages = sceneObjectData.statusPages[soIndex];
            statusPages[stpID - 1] = statusPageData;
        }
    };
    SceneObjectData.getStatusPageCloneData = function (sceneObjectData, soIndex, stpID, cloneSceneObject, cloneBehavior, cloneCustomAttribute, cloneEvent) {
        if (cloneSceneObject === void 0) { cloneSceneObject = true; }
        if (cloneBehavior === void 0) { cloneBehavior = true; }
        if (cloneCustomAttribute === void 0) { cloneCustomAttribute = true; }
        if (cloneEvent === void 0) { cloneEvent = true; }
        if (stpID == 0) {
            statusPageData = {
                so: SceneObject.__gcClone(sceneObjectData.sceneObjects[soIndex]),
                customAttribute: ObjectUtils.depthClone(sceneObjectData.customAttributes[soIndex]),
                event: ObjectUtils.depthClone(sceneObjectData.events[soIndex]),
                modulesCustomAttribute: ObjectUtils.depthClone(sceneObjectData.modulesCustomAttributes[soIndex])
            };
        }
        else if (stpID >= 1) {
            var statusPages = sceneObjectData.statusPages[soIndex];
            var refStp = statusPages[stpID - 1];
            var statusPageData = {
                so: SceneObject.__gcClone(refStp.so),
                customAttribute: ObjectUtils.depthClone(refStp.customAttribute),
                event: ObjectUtils.depthClone(refStp.event),
                modulesCustomAttribute: ObjectUtils.depthClone(refStp.modulesCustomAttribute)
            };
        }
        return statusPageData;
    };
    SceneObjectData.initModuleData = function (sceneObjectData, sceneObjectIndex, statusPageID) {
        if (Config.useNewSceneObjectModel) {
            if (statusPageID == 1) {
                var soData = sceneObjectData.sceneObjects[sceneObjectIndex];
            }
            else {
                var statusPages = sceneObjectData.statusPages[sceneObjectIndex];
                if (statusPages) {
                    var page = statusPages[statusPageID - 2];
                    if (page)
                        soData = page.so;
                }
            }
            if (soData) {
                this.initModuleDataBySceneObjectData(soData);
            }
        }
        return false;
    };
    SceneObjectData.initModuleDataBySceneObjectData = function (soData) {
        if (soData.moduleIDs == null) {
            var sceneObjectModelList = Common.sceneObjectModelList;
            if (sceneObjectModelList) {
                var modelData = sceneObjectModelList.data[soData.modelID];
                if (modelData) {
                    soData.moduleIDs = modelData.presetModules.concat();
                }
                else {
                    soData.moduleIDs = [];
                }
            }
        }
    };
    SceneObjectData.formatDisplayList = function (soData, refModelData, displayList) {
        for (var varName in displayList) {
            var m = ArrayUtils.matchAttributes(refModelData.preLayer, { varName: varName }, true);
            if (m.length == 0) {
                delete displayList[varName];
            }
        }
        for (var i = 0; i < refModelData.preLayer.length; i++) {
            var p = refModelData.preLayer[i];
            var displayInfo = displayList[p.varName];
            if (displayInfo == null || displayInfo.type != p.type || p.type == 2 || p.type == 4) {
                var valueID = (p.type == SceneObjectModelData.TYPE_UI_TYPE || p.type == SceneObjectModelData.TYPE_ANIMATION_TYPE) ? 0 : p.id;
                displayList[p.varName] = { type: p.type, id: valueID };
            }
        }
    };
    SceneObjectData.doFormatOneStatusPageModuleCustomData = function (soData, customAttributesArr) {
        if (!Config.useNewSceneObjectModel)
            return;
        for (var m = 0; m < soData.moduleIDs.length; m++) {
            var moduleID = soData.moduleIDs[m];
            var modlueData = Common.sceneObjectModuleList.data[moduleID];
            if (modlueData) {
                var customAttributes = customAttributesArr[m];
                if (!customAttributes)
                    customAttributes = customAttributesArr[m] = {};
                CustomAttributeSetting.formatCustomData(customAttributes, modlueData.varAttributes);
                if (!soData.moduleDisplayList)
                    soData.moduleDisplayList = [];
                var displayList = soData.moduleDisplayList[m];
                if (!displayList)
                    displayList = soData.moduleDisplayList[m] = {};
                this.formatDisplayList(soData, modlueData, displayList);
            }
            else {
                var customAttributes = customAttributesArr[m];
                if (customAttributes) {
                    customAttributesArr.splice(m, 1);
                }
                var soModuleDisplay = soData.moduleDisplayList[m];
                if (soModuleDisplay) {
                    soData.moduleDisplayList.splice(m, 1);
                }
                soData.moduleIDs.splice(m, 1);
                m--;
            }
        }
    };
    return SceneObjectData;
}());















var ScriptData = (function (_super) {
    __extends(ScriptData, _super);
    function ScriptData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ScriptData;
}(OriginalData));















var TileData = (function (_super) {
    __extends(TileData, _super);
    function TileData() {
        var _this_1 = _super.call(this) || this;
        _this_1.url = "";
        _this_1.dataLayers = [];
        _this_1.width = 0;
        _this_1.height = 0;
        return _this_1;
    }
    TileData.getTileData = function (texID) {
        if (Config.IS_SERVER)
            return ServerWorld.gameData.tileList.data[texID];
        return Game.data.tileList.data[texID];
    };
    TileData.isEmpty = function (data, plugType) {
        var tileName = GameListData.getName(Game.data.tileList, data.id, true);
        if (tileName)
            return false;
        return !data.url;
    };
    return TileData;
}(OriginalData));
var TransData = (function () {
    function TransData() {
        this.transType = 0;
        this.loopType = 0;
        this.timeType = 0;
        this.timeUnit = 1;
        this.totalTime = 2;
        this.tweenType = 0;
        this.tweenTypeName = "linearNone";
        this.curveData = [[0, 0, 0, 99, 1, 1, 1, 3], [0, 100, 100]];
        this.refreshInterval = 16;
    }
    TransData.isLoop = function (transData) {
        return transData.loopType == 1 || transData.loopType == 4 || transData.loopType == 5;
    };
    TransData.isUseFrame = function (transData) {
        return transData.timeType == 1 || (transData.timeType == 3 && transData.timeUnit == 0);
    };
    TransData.isUseTime = function (transData) {
        return transData.timeType == 2 || (transData.timeType == 3 && transData.timeUnit == 1);
    };
    return TransData;
}());















var UICommandData = (function (_super) {
    __extends(UICommandData, _super);
    function UICommandData() {
        var _this_1 = _super !== null && _super.apply(this, arguments) || this;
        _this_1.condition = [];
        _this_1.click = [];
        return _this_1;
    }
    return UICommandData;
}(OriginalData));















var UIData = (function (_super) {
    __extends(UIData, _super);
    function UIData() {
        var _this_1 = _super !== null && _super.apply(this, arguments) || this;
        _this_1.uiDisplayData = new UIDisplayData();
        _this_1.uiCommandData = new OriginalData();
        return _this_1;
    }
    UIData.init = function (item) {
        item.uiDisplayData.id = item.id;
    };
    UIData.isEmpty = function (data) {
        var uiName = GameListData.getName(Game.data.uiList, data.id, true);
        if (uiName)
            return false;
        var hasUiCommandData;
        for (var i in data.uiCommandData) {
            if (i == "id")
                continue;
            hasUiCommandData = true;
            break;
        }
        if (hasUiCommandData)
            return false;
        return (!data.uiDisplayData.instanceClassName && data.uiDisplayData.root.children.length == 0);
    };
    return UIData;
}(OriginalData));















var UIDisplayData = (function (_super) {
    __extends(UIDisplayData, _super);
    function UIDisplayData() {
        var _this_1 = _super !== null && _super.apply(this, arguments) || this;
        _this_1.root = {
            children: []
        };
        return _this_1;
    }
    UIDisplayData.init = function (data, runScriptDomain) {
        if (!data)
            return;
        var baseCode = "var GUI_" + data.id + " = window[\"GUI_" + data.id + "\"] = (function (_super) {__extends(GUI_" + data.id + ", _super);function GUI_" + data.id + "(isRoot) {if (isRoot === void 0) { isRoot = true; };_super.apply(this, [isRoot," + data.id + "]);\n        var data = Game.data.uiList.data[" + data.id + "];if(!data)return;GameUI.parse(data.uiDisplayData,false,null," + data.id + ",this);}return GUI_" + data.id + ";}(UIComponent.UIRoot));";
        baseCode += "var ListItem_" + data.id + " = (function (_super) {__extends(ListItem_" + data.id + ", _super);function ListItem_" + data.id + "() {_super.apply(this);}return ListItem_" + data.id + ";}(UIListItemData));";
        try {
            runScriptDomain.eval(baseCode);
        }
        catch (e) {
            alert("Initialization ui-" + data.id + " base code error!");
        }
    };
    UIDisplayData.getAllBaseCode = function (uiList) {
        var allLen = GameListData.getAllLength(uiList);
        if (allLen == 0)
            return "";
        var tips = mainDomain_gcide.LanguageManager.parseIDE("[#GAME_SYSTEM_GENERATED_FILES_BY_GAMECREATOR]");
        var runtimeCode = "/**\n * " + tips + "\n */\n";
        for (var typeID = 1; typeID <= 16; typeID++) {
            var len = GameListData.getLength(uiList, typeID);
            for (var s = 1; s <= len; s++) {
                var uiData = GameListData.getItem(uiList, typeID, s);
                if (!uiData)
                    continue;
                uiData.uiDisplayData.id = GameListData.getID(typeID, s);
                runtimeCode += UIDisplayData.getBaseCode(uiData.uiDisplayData, uiList) + "\n";
            }
        }
        var uicompCustomAttrs = {};
        for (var i = 0; i < Editor.data.editorUIComp.length; i++) {
            var compData = Editor.data.editorUIComp[i];
            var compObj = uicompCustomAttrs[compData.class] = [];
            for (var s = 0; s < compData.attributes.length; s++) {
                var a = compData.attributes[s];
                if (a.enable)
                    compObj.push(a.attribute);
            }
        }
        runtimeCode += "GameUI[\"__compCustomAttributes\"] = " + JSON.stringify(uicompCustomAttrs) + ";\n";
        return runtimeCode;
    };
    UIDisplayData.getBaseCode = function (data, uiList) {
        var varAttributes = "";
        var listItemVarAttributes = "";
        var nameMapping = {};
        var compItemList = ArrayUtils.getTreeNodeArray(data.root, "children");
        compItemList.shift();
        var listItemTypeMapping = {
            UIBitmap: "string",
            UIString: "string",
            UIVariable: "number",
            UIAvatar: "number",
            UIStandAvatar: "number",
            UIAnimation: "number",
            UIInput: "string",
            UICheckBox: "boolean",
            UISwitch: "number",
            UITabBox: "string",
            UISlider: "number",
            UIGUI: "number",
            UIList: "UIListItemData[]"
        };
        for (var i = 0; i < compItemList.length; i++) {
            var compItem = compItemList[i];
            if (nameMapping[compItem.name])
                continue;
            nameMapping[compItem.name] = true;
            var type = compItem.type;
            if (type == "UIGUI") {
                var guiData = uiList.data[compItem.guiID];
                if (!guiData)
                    continue;
                if (compItem.instanceClassName) {
                    type = compItem.instanceClassName;
                }
                else if (guiData.uiDisplayData.instanceClassName) {
                    type = guiData.uiDisplayData.instanceClassName;
                }
                else {
                    type = "GUI_" + compItem.guiID;
                }
            }
            else {
                type = "" + type;
            }
            if (type == "UICustomGameNumber" || type == "UICustomGameString") {
                type = "UIString";
            }
            varAttributes += "   " + compItem.name + ":" + type + ";";
            var listItemType = listItemTypeMapping[compItem.type];
            if (listItemType) {
                listItemVarAttributes += "   " + compItem.name + ":" + listItemType + ";";
                if (compItem.type == "UIList") {
                    varAttributes += " // Item=" + compItem.itemModelGUI;
                }
                if (i != compItemList.length - 1)
                    listItemVarAttributes += "\n";
            }
            if (i != compItemList.length - 1)
                varAttributes += "\n";
        }
        var name = GameListData.getName(uiList, data.id);
        var runtimeCode = "\n/**\n * " + data.id + "-" + name + " [BASE]\n */\nclass GUI_" + data.id + " extends GUI_BASE {\n" + varAttributes + "\n   constructor(){\n      super(" + data.id + ");\n   }\n}";
        runtimeCode += "\nclass ListItem_" + data.id + " extends UIListItemData {\n" + listItemVarAttributes + "\n}";
        return runtimeCode;
    };
    return UIDisplayData;
}(OriginalData));
var GameListData = (function () {
    function GameListData(folder, listName, listData, listType, arrayModeIndex) {
        if (arrayModeIndex === void 0) { arrayModeIndex = null; }
        this.listData = {};
        this.data = [];
        this.folder = folder;
        this.listName = listName;
        this.listData = listData;
        this.listType = listType;
        this.arrayModeIndex = arrayModeIndex;
    }
    GameListData.getID = function (typeID, index) {
        return (typeID - 1) * 1000 + index;
    };
    GameListData.getType = function (id) {
        if (id == 0)
            return 1;
        return Math.floor((id - 1) / 1000) + 1;
    };
    GameListData.getLocalID = function (id) {
        return (id - 1) % 1000 + 1;
    };
    GameListData.getItem = function (gameListData, typeID, localID) {
        var id = GameListData.getID(typeID, localID);
        return gameListData.data[id];
    };
    GameListData.getItems = function (gameListData) {
        var arr = [];
        for (var i in gameListData.data) {
            var d = gameListData.data[i];
            if (d)
                arr.push(d);
        }
        return arr;
    };
    GameListData.getIDRange = function (typeID, isOnlyModuleType, gameListData) {
        if (isOnlyModuleType === void 0) { isOnlyModuleType = false; }
        if (gameListData === void 0) { gameListData = null; }
        if (isOnlyModuleType && GameListData)
            return { from: (typeID - 1) * 1000 + 1, to: this.getLength(gameListData, typeID) };
        return { from: (typeID - 1) * 1000 + 1, to: (typeID - 1) * 1000 + 1000 };
    };
    GameListData.getName = function (gameListData, id, emptyName) {
        if (emptyName === void 0) { emptyName = false; }
        if (!gameListData.listData)
            return null;
        var name;
        if (gameListData.hasType) {
            var typeID = GameListData.getType(id);
            var typeArr = gameListData.listData.list[typeID];
            if (!typeArr)
                return "";
            name = typeArr[GameListData.getLocalID(id)];
        }
        else {
            name = gameListData.listData.list[id];
        }
        return name != null ? name : (emptyName ? "" : "--/--");
    };
    GameListData.getNames = function (gameListData, includeID) {
        if (includeID === void 0) { includeID = true; }
        if (gameListData.hasType)
            return null;
        var len = GameListData.getLength(gameListData, 1);
        var list = gameListData.listData.list.concat();
        list.shift();
        if (includeID) {
            for (var i = 0; i < list.length; i++) {
                var name = list[i];
                list[i] = (i + 1) + "-" + name;
            }
        }
        return list;
    };
    GameListData.hasSameName = function (gameListData, name) {
        if (gameListData.hasType) {
            for (var i = 0; i < 16; i++) {
                var typeArr = gameListData.listData.list[i];
                if (typeArr && typeArr.indexOf) {
                    if (typeArr.indexOf(name) != -1)
                        return true;
                }
            }
        }
        else {
            var len = GameListData.getLength(gameListData, 1);
            var list = gameListData.listData.list.concat();
            list.shift();
            return list.indexOf(name) != -1;
        }
        return false;
    };
    GameListData.setName = function (gameListData, id, name) {
        if (!gameListData.listData)
            return null;
        if (gameListData.hasType) {
            var typeID = Math.floor((id - 1) / 1000) + 1;
            if (gameListData.listData.list[typeID])
                gameListData.listData.list[typeID][GameListData.getLocalID(id)] = name;
        }
        else {
            gameListData.listData.list[id] = name;
        }
    };
    GameListData.changeMaximum = function (cls, gameListData, typeID, currentListMaximum, setMaximum) {
        if (currentListMaximum < setMaximum) {
            if (gameListData.hasType) {
                if (!gameListData.listData.list[typeID])
                    gameListData.listData.list[typeID] = [];
            }
            var startID = GameListData.getID(typeID, currentListMaximum) + 1;
            var len = setMaximum - currentListMaximum;
            for (var i = 0; i < len; i++) {
                var itemData = new cls();
                var id = itemData.id = startID + i;
                gameListData.data[id] = itemData;
                if (gameListData.hasType) {
                    gameListData.listData.list[typeID][currentListMaximum + 1 + i] = "";
                }
                else {
                    gameListData.listData.list[currentListMaximum + 1 + i] = "";
                }
            }
        }
        else if (currentListMaximum > setMaximum) {
            var range = GameListData.getIDRange(typeID);
            var startID = range.from + setMaximum;
            for (var i = startID; i < range.to; i++) {
                gameListData.data[i] = null;
                if (gameListData.hasType) {
                    if (gameListData.listData.list[typeID]) {
                        gameListData.listData.list[typeID].length = setMaximum + 1;
                    }
                }
                else {
                    gameListData.listData.list.length = setMaximum + 1;
                }
            }
        }
    };
    GameListData.insertNewData = function (cls, gameListData, newName, dataType) {
        if (dataType === void 0) { dataType = null; }
        var newItemData = new cls();
        var len = dataType == null ? gameListData.data.length : 16 * 1000;
        var insertID = -1;
        var startIndex = dataType == null ? 1 : ((dataType - 1) * 1000 + 1);
        for (var i = startIndex; i < len; i++) {
            if (!GameListData.getName(gameListData, i, true)) {
                insertID = i;
                break;
            }
        }
        if (insertID == -1) {
            insertID = len == 0 ? 1 : len;
        }
        gameListData.data[insertID] = newItemData;
        newItemData.id = insertID;
        var typeID = GameListData.getType(insertID);
        if (gameListData.hasType) {
            if (!gameListData.listData.list[typeID])
                gameListData.listData.list[typeID] = [];
            var localID = GameListData.getLocalID(insertID);
            gameListData.listData.list[typeID][localID] = newName;
        }
        else {
            gameListData.listData.list[insertID] = newName;
        }
        return insertID;
    };
    GameListData.getLength = function (gameListData, typeID) {
        if (typeID === void 0) { typeID = null; }
        if (gameListData.hasType) {
            var list = gameListData.listData.list[typeID];
            return list ? list.length - 1 : 0;
        }
        else {
            return gameListData.listData.list.length - 1;
        }
    };
    GameListData.getAllLength = function (gameListData) {
        if (gameListData.hasType) {
            var allLen = 0;
            for (var typeID = 1; typeID <= 16; typeID++) {
                var list = gameListData.listData.list[typeID];
                allLen += list ? list.length - 1 : 0;
            }
            return allLen;
        }
        else {
            return gameListData.listData.list.length - 1;
        }
    };
    GameListData.changeTypName = function (gameListData, typeID, name) {
        gameListData.listData.type[typeID] = name;
    };
    GameListData.getTypName = function (gameListData, typeID) {
        return gameListData.listData.type ? gameListData.listData.type[typeID] : null;
    };
    GameListData.setNewData = function (cls, gameListData, id, name) {
        if (id === void 0) { id = 0; }
        if (name === void 0) { name = ""; }
        var itemData = new cls();
        if (id == 0) {
            if (gameListData.hasType)
                return;
            var list = gameListData.listData.list;
            id = list.length;
        }
        itemData.id = id;
        this.setData(gameListData, id, itemData, name);
        return itemData;
    };
    GameListData.setData = function (gameListData, id, itemData, name) {
        if (id === void 0) { id = 0; }
        if (id == 0) {
            var list = gameListData.hasType ? gameListData.listData.list[typeID] : gameListData.listData.list;
            id = list.length;
        }
        if (gameListData.hasType) {
            var typeID = GameListData.getType(id);
            if (gameListData.listData.list[typeID])
                gameListData.listData.list[typeID][GameListData.getLocalID(id)] = name;
        }
        else {
            gameListData.listData.list[id] = name;
        }
        gameListData.data[id] = itemData;
    };
    GameListData.disposeData = function (gameListData, id) {
        if (gameListData.hasType) {
            var typeID = GameListData.getType(id);
            if (gameListData.listData.list[typeID])
                gameListData.listData.list[typeID][GameListData.getLocalID(id)] = null;
        }
        else {
            gameListData.listData.list[id] = null;
        }
        gameListData.data[id] = null;
    };
    GameListData.remove = function (gameListData, id, autoOrder) {
        if (autoOrder === void 0) { autoOrder = false; }
        var list;
        var index;
        if (gameListData.hasType) {
            var typeID = GameListData.getType(id);
            list = gameListData.listData.list[typeID];
            index = GameListData.getLocalID(id);
        }
        else {
            list = gameListData.listData.list;
            index = id;
        }
        list[index] = null;
        if (!autoOrder)
            return;
        list.splice(index, 1);
        gameListData.data.splice(index, 1);
        for (var i = id; i < gameListData.data.length; i++) {
            var data = gameListData.data[i];
            if (data)
                data.id = i;
        }
    };
    return GameListData;
}());
var UIListItemData = (function () {
    function UIListItemData() {
        this._children = [];
        this._isOpen = true;
    }
    UIListItemData.prototype.getSaveData = function (includeData) {
        if (includeData === void 0) { includeData = false; }
        var dData = {};
        for (var i in this.uiNames) {
            dData[i] = this[i];
        }
        if (includeData)
            dData.data = this.data;
        var len = this._children.length;
        if (len > 0) {
            dData.children = [];
            for (var s = 0; s < this._children.length; s++) {
                var item = this._children[s];
                dData.children.push(item.getSaveData(includeData));
            }
        }
        dData.isOpen = this.isOpen;
        return dData;
    };
    UIListItemData.recoverySaveData = function (saveData) {
        var d = new UIListItemData();
        for (var i in saveData) {
            if (i == "children")
                continue;
            d[i] = saveData[i];
        }
        for (var i in saveData.children) {
            var saveDataChild = saveData.children[i];
            var dChild = UIListItemData.recoverySaveData(saveDataChild);
            d.addChild(dChild);
        }
        return d;
    };
    Object.defineProperty(UIListItemData.prototype, "isOpen", {
        get: function () { return this._isOpen; },
        set: function (v) {
            if (v != this._isOpen) {
                this._isOpen = v;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(UIListItemData.prototype, "uiNames", {
        get: function () {
            var _uiNames = [];
            var _attrs = [];
            for (var s in UIListItemData.uiListItemDataHelper) {
                _attrs.push(s);
            }
            for (var i in this) {
                if (_attrs.indexOf(i) != -1)
                    continue;
                _uiNames.push(i);
            }
            return _uiNames;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(UIListItemData.prototype, "parent", {
        get: function () { return this._parent; },
        enumerable: false,
        configurable: true
    });
    UIListItemData.prototype.addChild = function (item) { this._children.push(item); item._parent = this; };
    UIListItemData.prototype.addChildAt = function (item, index) { this._children.splice(index, 0, item); item._parent = this; };
    UIListItemData.prototype.removeChild = function (item) { this._children.splice(this._children.indexOf(item), 1); item._parent = null; };
    UIListItemData.prototype.removeChildAt = function (index) { var item = this._children.splice(index, 1)[0]; item._parent = null; };
    UIListItemData.prototype.removeAll = function () { for (var i in this._children) {
        this._children[i]._parent = null;
    } ; this._children.length = 0; };
    UIListItemData.prototype.getChildAt = function (index) { return this._children[index]; };
    UIListItemData.prototype.getChildIndex = function (item) { return this._children.indexOf(item); };
    Object.defineProperty(UIListItemData.prototype, "numChildren", {
        get: function () { return this._children.length; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(UIListItemData.prototype, "children", {
        get: function () { return this._children; },
        enumerable: false,
        configurable: true
    });
    UIListItemData.prototype.isInherit = function (data) {
        var p = this.parent;
        while (p) {
            if (p == data)
                return true;
            p = p._parent;
        }
        return false;
    };
    UIListItemData.prototype.getList = function (arr) {
        if (arr === void 0) { arr = null; }
        return ArrayUtils.getTreeNodeArray(this, "_children", arr);
    };
    Object.defineProperty(UIListItemData.prototype, "root", {
        get: function () {
            var p = this;
            while (true) {
                if (p._parent) {
                    p = p._parent;
                }
                else {
                    break;
                }
            }
            return p;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(UIListItemData.prototype, "depth", {
        get: function () {
            var p = this;
            var d = 0;
            while (1) {
                if (!p.parent)
                    break;
                d++;
                p = p.parent;
            }
            return d;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(UIListItemData.prototype, "isHideNode", {
        get: function () {
            var p = this.parent;
            while (1) {
                if (!p)
                    break;
                if (!p.isOpen)
                    return true;
                p = p.parent;
            }
            return false;
        },
        enumerable: false,
        configurable: true
    });
    UIListItemData.uiListItemDataHelper = new UIListItemData();
    return UIListItemData;
}());
var GameData = (function () {
    function GameData() {
        this.customModuleDataList = [];
    }
    GameData.getModuleData = function (moduleID, dataID) {
        if (moduleID <= 0)
            return null;
        var moduleData = GameData.customModulePresetDatas[moduleID];
        return moduleData ? moduleData[dataID] : null;
    };
    GameData.newModuleData = function (moduleID, dataID, isCopy) {
        if (isCopy === void 0) { isCopy = false; }
        var modelData = GameData.getModuleData(moduleID, dataID);
        var oriDataCopy = modelData ? ObjectUtils.depthClone(modelData) : null;
        if (oriDataCopy) {
            if (!isCopy) {
                oriDataCopy["gcsysref"] = [moduleID, dataID];
            }
            else {
                oriDataCopy["gcsyscopy"] = [moduleID, dataID];
            }
        }
        return oriDataCopy;
    };
    GameData.changeModuleDataToCopyMode = function (data, moduleID) {
        if (!data || !data.id)
            return;
        delete data["gcsysref"];
        data["gcsyscopy"] = [moduleID, data.id];
    };
    GameData.isCopyModeData = function (data) {
        if (!data || !data.id)
            return false;
        return data["gcsyscopy"] != null;
    };
    GameData.getLength = function (moduleID, typeID) {
        if (typeID === void 0) { typeID = 1; }
        var list = Common.getCustomModuleDataList(moduleID);
        if (!list)
            return 0;
        return GameListData.getLength(list, typeID);
    };
    GameData.isOnlyModuleType = function (data) {
        return CustomCompositeSetting.getAllAttributes(data).length == 0;
    };
    GameData.prototype.loadVariableList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_VARIABLE, OriginalData, [], "asset/json/variable/", "variable.json", onFin);
    };
    GameData.prototype.loadSwitchList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_SWITCH, OriginalData, [], "asset/json/variable/", "switch.json", onFin);
    };
    GameData.prototype.loadStringList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_STRING, OriginalData, [], "asset/json/variable/", "string.json", onFin);
    };
    GameData.prototype.loadPlayerVariableList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_PLAYER_VARIABLE, OriginalData, [], "asset/json/server/variable/", "variable.json", onFin);
    };
    GameData.prototype.loadPlayerSwitchList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_PLAYER_SWITCH, OriginalData, [], "asset/json/server/variable/", "switch.json", onFin);
    };
    GameData.prototype.loadPlayerStringList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_PLAYER_STRING, OriginalData, [], "asset/json/server/variable/", "string.json", onFin);
    };
    GameData.prototype.loadSceneList = function (onFin, itemNeedMethod) {
        if (itemNeedMethod === void 0) { itemNeedMethod = null; }
        this.onLoadList(GameData.LIST_TYPE_SCENE, SceneData, [
            { childAttribute: "mapData", path: "asset/json/scene/data/scene" },
            { childAttribute: "sceneObjectData", path: "asset/json/server/scene/s" }
        ], "asset/json/scene/", "sceneList.json", onFin, false, itemNeedMethod);
    };
    GameData.prototype.loadSceneObjectModelList = function (onFin, isServer) {
        var _this_1 = this;
        if (isServer === void 0) { isServer = false; }
        var onRealFin = Callback.New(function () {
            if (Config.useNewSceneObjectModel) {
                var taskRD_1 = ObjectUtils.getRandID();
                _this_1.onLoadOne(0, GameData.LIST_TYPE_SCENE_OBJECT_MODEL, SceneObjectModelData, [
                    { childAttribute: null, path: "asset/json/scene/model/som" }
                ], "asset/json/scene/", "sceneObjectModelList.json", false, null, null, true, false, taskRD_1);
                new SyncTask(GameData.loadDataTask + taskRD_1, function () {
                    var commonModelData = _this_1.sceneObjectModelList.data[0];
                    SceneObjectModelData.initCommonModelData(commonModelData);
                    onFin.run();
                    SyncTask.taskOver(GameData.loadDataTask + taskRD_1);
                });
            }
            else {
                onFin.run();
            }
        }, this);
        this.onLoadList(GameData.LIST_TYPE_SCENE_OBJECT_MODEL, SceneObjectModelData, [
            { childAttribute: null, path: "asset/json/scene/model/som" }
        ], "asset/json/scene/", "sceneObjectModelList.json", onRealFin, false);
    };
    GameData.prototype.loadSceneObjectModuleList = function (onFin) {
        if (!Config.useNewSceneObjectModel) {
            onFin.delayRun(0);
            return;
        }
        this.onLoadList(GameData.LIST_TYPE_SCENE_OBJECT_MODULE, SceneObjectModelData, [
            { childAttribute: null, path: "asset/json/scene/sceneObjectModule/soModule" }
        ], "asset/json/scene/", "sceneObjectModuleList.json", onFin, false, null, false, null, true);
    };
    GameData.prototype.loadTileList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_TILE, TileData, [
            { childAttribute: null, path: "asset/json/scene/tile/tile" }
        ], "asset/json/scene/", "tileList.json", onFin, false);
    };
    GameData.prototype.loadAutoTileList = function (onFin) {
        var childItems = Config.fragmentFileVersion ? [{ childAttribute: null, path: "asset/json/scene/autoTile/autoTile" }] : [];
        this.onLoadList(GameData.LIST_TYPE_AUTO_TILE, AutoTileData, childItems, "asset/json/scene/", "autoTileList.json", onFin, false, null, false, null, true);
    };
    GameData.prototype.loadAvatarList = function (onFin) {
        var _this_1 = this;
        this.onLoadList(GameData.LIST_TYPE_AVATAR, AvatarData, [
            { childAttribute: null, path: "asset/json/avatar/data/avatar" }
        ], "asset/json/avatar/", "avatarList.json", Callback.New(function () {
            EditorData.avatarJsonVersionUpgrade1(_this_1, false);
            onFin.run();
        }, this), true, null, true);
    };
    GameData.prototype.loadAvatarActList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_AVATAR_ACT, OriginalData, [], "asset/json/avatar/", "avatarActList.json", onFin, false);
    };
    GameData.prototype.loadAvatarPartList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_AVATAR_PART, OriginalData, [], "asset/json/avatar/", "avatarPartList.json", onFin, false, null, false, null, true);
    };
    GameData.prototype.loadAvatarRefObjList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_AVATAR_REF_OBJ, AvatarRefObjData, [], "asset/json/avatar/", "avatarRefObjList.json", onFin, false);
    };
    GameData.prototype.loadAnimationRefObjList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_ANIMATION_REF_OBJ, AvatarRefObjData, [], "asset/json/animation/", "animationRefObjList.json", onFin, false, null, false, null, true);
    };
    GameData.prototype.loadStandingList = function (onFin) {
        var _this_1 = this;
        this.onLoadList(GameData.LIST_TYPE_STANDING, AvatarData, [
            { childAttribute: null, path: "asset/json/standAvatar/data/standAvatar" }
        ], "asset/json/standAvatar/", "standAvatarList.json", Callback.New(function () {
            EditorData.avatarJsonVersionUpgrade1(_this_1, true);
            onFin.run();
        }, this), true, null, false);
    };
    GameData.prototype.loadStandingExpressionList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_STANDING_EXPRESSION, OriginalData, [], "asset/json/standAvatar/", "expressionList.json", onFin, false);
    };
    GameData.prototype.loadStandingPartList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_STAND_AVATAR_PART, OriginalData, [], "asset/json/standAvatar/", "standAvatarPartList.json", onFin, false, null, false, null, true);
    };
    GameData.prototype.loadCommonEventList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_COMMON_EVENT, CommonEventData, [
            { childAttribute: null, path: "asset/json/server/command/data/ws" }
        ], "asset/json/server/command/", "worldCommand.json", onFin);
    };
    GameData.prototype.loadDialogList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_DIALOG, DialogData, [
            { childAttribute: null, path: "asset/json/dialog/data/dialog" }
        ], "asset/json/dialog/", "dialogList.json", onFin, false);
    };
    GameData.prototype.loadAnimationList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_ANIMATION, AnimationData, [
            { childAttribute: null, path: "asset/json/animation/data/ani" }
        ], "asset/json/animation/", "animationList.json", onFin);
    };
    GameData.prototype.loadAnimationSignalList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_ANIMATION_SIGNAL, OriginalData, [], "asset/json/animation/", "animationSignalList.json", onFin, false);
    };
    GameData.prototype.loadUIList = function (onFin) {
        var childData = [{ childAttribute: "uiCommandData", path: "asset/json/server/ui/sui" }];
        childData.unshift({ childAttribute: "uiDisplayData", path: "asset/json/ui/data/ui" });
        this.onLoadList(GameData.LIST_TYPE_UI, UIData, childData, "asset/json/ui/", "uiList.json", onFin);
    };
    GameData.prototype.loadProjectUICompSetting = function (onFin) {
        var _this_1 = this;
        if (FileUtils.hasFileOperationJurisdiction) {
            FileUtils.exists("asset/json/ui/uiCompSetting.json", Callback.New(function (isExists) {
                if (!isExists) {
                    Callback.CallLaterBeforeRender(function () { onFin.run(); }, _this_1);
                    return;
                }
                doLoadProjectUICompSetting.apply(_this_1);
            }, this));
        }
        else {
            Callback.CallLaterBeforeRender(function () { onFin.run(); }, this);
        }
        function doLoadProjectUICompSetting() {
            AssetManager.loadJson("asset/json/ui/uiCompSetting.json", Callback.New(function (uiCompSetting) {
                if (uiCompSetting)
                    GameUI.uiCompSetting = uiCompSetting;
                onFin.run();
            }, this), false, true, false);
        }
    };
    GameData.prototype.loadDataStructureList = function (onFin) {
        var childItems = Config.fragmentFileVersion ? [{ childAttribute: null, path: "asset/json/custom/dataStructure/ds" }] : [];
        this.onLoadList(GameData.LIST_TYPE_DATA_STRUCTURE, CustomCompositeSetting, childItems, "asset/json/custom/", "dataStructure.json", onFin, true);
    };
    GameData.prototype.loadCustomModuleList = function (onFin) {
        var _this_1 = this;
        var childItems = Config.fragmentFileVersion ? [{ childAttribute: null, path: "asset/json/custom/customModuleSetting/cmSetting" }] : [];
        this.onLoadList(GameData.LIST_TYPE_CUSTOM_MODULE, CustomCompositeSetting, childItems, "asset/json/custom/", "customModuleList.json", Callback.New(function () {
            var customSettingList = _this_1.customModuleList;
            var len = GameListData.getLength(customSettingList);
            var loadCount = len;
            if (loadCount == 0)
                onFin.run();
            for (var i = 1; i <= len; i++) {
                if (!customSettingList.data[i] || !customSettingList.listData.list[i]) {
                    loadCount--;
                    if (loadCount == 0) {
                        onFin.run();
                    }
                    continue;
                }
                var moduleData = customSettingList.data[i];
                var notLoadOneData = GameData.isOnlyModuleType(moduleData);
                _this_1.onLoadList(GameData.LIST_TYPE_CUSTOM_MODULE_DATA, CustomData, [
                    { childAttribute: null, path: "asset/json/custom/customModule/" + i + "/cm" }
                ], "asset/json/custom/customModule/", "customModuleDataList" + i + ".json", Callback.New(function () {
                    loadCount--;
                    if (loadCount == 0) {
                        onFin.run();
                    }
                }, _this_1), true, null, false, i, true, notLoadOneData);
            }
        }, this), false);
    };
    GameData.newCustomModuleDataList = function (index) {
        var gameListData = new GameListData("asset/json/custom/customModule/", "customModuleDataList" + index + ".json", { list: {}, type: {} }, GameData.LIST_TYPE_CUSTOM_MODULE_DATA, index);
        gameListData.hasType = true;
        return gameListData;
    };
    GameData.prototype.loadGameAttributeConfig = function (onFin) {
        var _this_1 = this;
        if (Config.fragmentFileVersion) {
            FileUtils.loadJsonFile("asset/json/custom/customWorldSetting.json", Callback.New(function (worldSetting) {
                FileUtils.loadJsonFile("asset/json/custom/customPlayerSetting.json", Callback.New(function (playerSetting) {
                    FileUtils.loadJsonFile("asset/json/custom/customWorldData.json", Callback.New(function (worldData) {
                        FileUtils.loadJsonFile("asset/json/custom/customPlayerData.json", Callback.New(function (playerData) {
                            worldSetting = GameData.parseTemplateLanguage(worldSetting);
                            playerSetting = GameData.parseTemplateLanguage(playerSetting);
                            worldData = GameData.parseTemplateLanguage(worldData);
                            playerData = GameData.parseTemplateLanguage(playerData);
                            _this_1.customGameAttribute = new CustomGameAttribute();
                            _this_1.customGameAttribute.worldAttributeSetting = worldSetting;
                            _this_1.customGameAttribute.playerAttributeSetting = playerSetting;
                            _this_1.customGameAttribute.worldAttributeConfig = worldData;
                            _this_1.customGameAttribute.playerAttributeConfig = playerData;
                            onFin.run();
                        }, _this_1));
                    }, _this_1));
                }, _this_1));
            }, this));
        }
        else {
            FileUtils.loadJsonFile("asset/json/custom/customGameAttribute.json", Callback.New(function (jsonObj) {
                jsonObj = GameData.parseTemplateLanguage(jsonObj);
                _this_1.customGameAttribute = new CustomGameAttribute();
                ObjectUtils.clone(jsonObj, _this_1.customGameAttribute);
                onFin.run();
            }, this));
        }
    };
    GameData.prototype.loadCustomEventType = function (onFin) {
        var _this_1 = this;
        this.onLoadList(GameData.LIST_TYPE_CUSTOM_OBJECT_EVENT_TYPE, CustomEventType, [], "asset/json/custom/", "customObjectEventType.json", Callback.New(function () {
            _this_1.onLoadList(GameData.LIST_TYPE_CUSTOM_UI_EVENT_TYPE, CustomEventType, [], "asset/json/custom/", "customUIEventType.json", Callback.New(function () {
                this.onLoadList(GameData.LIST_TYPE_CUSTOM_SCENE_EVENT_TYPE, CustomEventType, [], "asset/json/custom/", "customSceneEventType.json", onFin, false);
            }, _this_1), false);
        }, this), false);
    };
    GameData.prototype.loadCustomCommandType = function (onFin) {
        var childItems = Config.fragmentFileVersion ? [{ childAttribute: null, path: "asset/json/custom/cmd/cmd" }] : [];
        this.onLoadList(GameData.LIST_TYPE_CUSTOM_COMMAND_TYPE, CustomCompositeSetting, childItems, "asset/json/custom/", "customCommandType.json", onFin, true);
    };
    GameData.prototype.loadCustomBehaviorType = function (onFin) {
        var childItems = Config.fragmentFileVersion ? [{ childAttribute: null, path: "asset/json/custom/behavior/behavior" }] : [];
        this.onLoadList(GameData.LIST_TYPE_CUSTOM_BEHAVIOR_TYPE, CustomCompositeSetting, childItems, "asset/json/custom/", "customBehaviorType.json", onFin, false);
    };
    GameData.prototype.loadCustomCondition = function (onFin) {
        var conditonJSONName = Config.fragmentFileVersion ? "customCondition.json" : "cumtomCondition.json";
        var childItems = Config.fragmentFileVersion ? [{ childAttribute: null, path: "asset/json/custom/condition/condition" }] : [];
        this.onLoadList(GameData.LIST_TYPE_CUSTOM_CONDITION, CustomCompositeSetting, childItems, "asset/json/custom/", conditonJSONName, onFin, false, null, false, null, true);
    };
    GameData.prototype.loadCustomDataDisplayInUI = function (onFin) {
        if (Config.fragmentFileVersion) {
            var childItems = [{ childAttribute: null, path: "asset/json/custom/gameNumber/num" }];
            var listName = "customGameNumberList.json";
        }
        else {
            childItems = [];
            var listName = "customDataDisplayList.json";
        }
        this.onLoadList(GameData.LIST_TYPE_CUSTOM_DATA_DISPLAY, CustomCompositeSetting, childItems, "asset/json/custom/", listName, onFin, false, null, false, null, true);
    };
    GameData.prototype.loadCustomGameString = function (onFin) {
        var childItems = Config.fragmentFileVersion ? [{ childAttribute: null, path: "asset/json/custom/gameString/str" }] : [];
        this.onLoadList(GameData.LIST_TYPE_CUSTOM_GAME_STRING, CustomCompositeSetting, childItems, "asset/json/custom/", "customGameStringList.json", onFin, false, null, false, null, true);
    };
    GameData.prototype.loadMaterialList = function (onFin) {
        var childItems = Config.fragmentFileVersion ? [{ childAttribute: null, path: "asset/json/custom/material/material" }] : [];
        this.onLoadList(GameData.LIST_TYPE_MATERIAL, CustomCompositeSetting, childItems, "asset/json/custom/", "customMaterialList.json", onFin, false, null, false, null, true);
    };
    GameData.prototype.loadCustomValueFunction = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_CUSTOM_VALUE_FUNCTION, OriginalData, [], "asset/json/custom/", "customValueFunction.json", onFin, false);
    };
    GameData.prototype.loadScene = function (id, onFin) {
        var sceneData = this.sceneList ? this.sceneList.data[id] : null;
        if (sceneData) {
            onFin.delayRun(0);
            return;
        }
        var taskRD = ObjectUtils.getRandID();
        this.onLoadOne(id, "sceneList", SceneData, [
            { childAttribute: "mapData", path: "asset/json/scene/data/scene" },
            { childAttribute: "sceneObjectData", path: "asset/json/server/scene/s" }
        ], "asset/json/scene/", "sceneList.json", false, null, null, false, false, taskRD);
        this.onLoadOneOver(id, onFin, "sceneList", taskRD);
    };
    GameData.prototype.loadTile = function (id, onFin) {
        var taskRD = ObjectUtils.getRandID();
        this.onLoadOne(id, "tileList", TileData, [
            { childAttribute: null, path: "asset/json/scene/tile/tile" }
        ], "asset/json/scene/", "tileList.json", true, null, null, false, false, taskRD);
        this.onLoadOneOver(id, onFin, "tileList", taskRD);
    };
    GameData.prototype.loadAvatar = function (id, onFin) {
        var taskRD = ObjectUtils.getRandID();
        this.onLoadOne(id, "avatarList", AvatarData, [
            { childAttribute: null, path: "asset/json/avatar/data/avatar" }
        ], "asset/json/avatar/", "avatarList.json", true, null, null, false, false, taskRD);
        this.onLoadOneOver(id, onFin, "avatarList", taskRD);
    };
    GameData.prototype.loadStanding = function (id, onFin) {
        var taskRD = ObjectUtils.getRandID();
        this.onLoadOne(id, "standAvatarList", AvatarData, [
            { childAttribute: null, path: "asset/json/standing/data/standAvatar" }
        ], "asset/json/standAvatar/", "standAvatarList.json", true, null, null, false, false, taskRD);
        this.onLoadOneOver(id, onFin, "standAvatarList", taskRD);
    };
    GameData.prototype.onLoadList = function (saveAttribute, childCls, childItems, folder, listName, onFin, hasType, itemNeedMethod, loadZero, arrayModeIndex, allowNoFiles, notLoadOneData) {
        var _this_1 = this;
        if (hasType === void 0) { hasType = true; }
        if (itemNeedMethod === void 0) { itemNeedMethod = null; }
        if (loadZero === void 0) { loadZero = false; }
        if (arrayModeIndex === void 0) { arrayModeIndex = null; }
        if (allowNoFiles === void 0) { allowNoFiles = false; }
        if (notLoadOneData === void 0) { notLoadOneData = false; }
        FileUtils.loadJsonFile(folder + listName, new Callback(function (listData) {
            var taskRD = ObjectUtils.getRandID();
            if (!listData) {
                if (!allowNoFiles) {
                    console.log("[#GAME_FAILED_TO_LOAD_FILE]" + folder + listName);
                    onFin.run();
                    return;
                }
                else {
                    if (hasType) {
                        gameListData = new GameListData(folder, listName, { list: {}, type: {} }, saveAttribute, arrayModeIndex);
                    }
                    else {
                        gameListData = new GameListData(folder, listName, { list: {} }, saveAttribute, arrayModeIndex);
                        gameListData.listData.list = [null];
                    }
                    if (arrayModeIndex == null) {
                        _this_1[saveAttribute] = GameData.parseTemplateLanguage(gameListData);
                    }
                    else {
                        _this_1[saveAttribute][arrayModeIndex] = GameData.parseTemplateLanguage(gameListData);
                    }
                    gameListData.hasType = hasType;
                    new SyncTask(GameData.loadDataTask + taskRD, function () {
                        onFin.run();
                        SyncTask.taskOver(GameData.loadDataTask + taskRD);
                    });
                    return;
                }
            }
            var gameListData = new GameListData(folder, listName, listData, saveAttribute, arrayModeIndex);
            if (arrayModeIndex == null) {
                _this_1[saveAttribute] = GameData.parseTemplateLanguage(gameListData);
            }
            else {
                _this_1[saveAttribute][arrayModeIndex] = GameData.parseTemplateLanguage(gameListData);
            }
            gameListData.hasType = hasType;
            var typeList = hasType ? listData.list : { 1: listData.list };
            for (var typeID in typeList) {
                var typeDatas = typeList[typeID];
                for (var i = 0; i < typeDatas.length; i++) {
                    var dataName = typeDatas[i];
                    if (loadZero && i == 0 && typeID == "1") { }
                    else if (dataName == null) {
                        continue;
                    }
                    var id = GameListData.getID(parseInt(typeID), i);
                    if (itemNeedMethod && !itemNeedMethod(id))
                        continue;
                    _this_1.onLoadOne(id, saveAttribute, childCls, childItems, folder, listName, hasType, listData, arrayModeIndex, allowNoFiles, notLoadOneData, taskRD);
                }
            }
            new SyncTask(GameData.loadDataTask + taskRD, function () {
                onFin.run();
                SyncTask.taskOver(GameData.loadDataTask + taskRD);
            });
        }, this), !allowNoFiles);
    };
    GameData.prototype.onLoadOne = function (id, saveAttribute, childCls, childItems, folder, listName, hasType, listData, arrayModeIndex, allowNoFiles, notLoadOneData, taskRD) {
        if (hasType === void 0) { hasType = true; }
        if (listData === void 0) { listData = null; }
        if (arrayModeIndex === void 0) { arrayModeIndex = null; }
        if (allowNoFiles === void 0) { allowNoFiles = false; }
        if (notLoadOneData === void 0) { notLoadOneData = false; }
        if (taskRD === void 0) { taskRD = ""; }
        var gameListData = this[saveAttribute];
        if (arrayModeIndex == null) {
            gameListData = this[saveAttribute];
        }
        else {
            gameListData = this[saveAttribute][arrayModeIndex];
        }
        if (gameListData == null) {
            if (hasType) {
                gameListData = new GameListData(folder, listName, { list: {}, type: {} }, saveAttribute, arrayModeIndex);
            }
            else {
                gameListData = new GameListData(folder, listName, { list: [null] }, saveAttribute, arrayModeIndex);
            }
            gameListData.hasType = hasType;
            if (arrayModeIndex == null) {
                this[saveAttribute] = GameData.parseTemplateLanguage(gameListData);
            }
            else {
                this[saveAttribute][arrayModeIndex] = GameData.parseTemplateLanguage(gameListData);
            }
        }
        if (gameListData.data[id])
            return;
        var gameData = gameListData.data[id] = new childCls();
        gameData.id = id;
        if (listData && listData.data) {
            var attrData = listData.data[id];
            ObjectUtils.clone(attrData, gameData);
        }
        for (var c = 0; c < childItems.length; c++) {
            var childItem = childItems[c];
            if (notLoadOneData) {
                var itemData = {};
                ObjectUtils.clone(itemData, childItem.childAttribute ? gameData[childItem.childAttribute] : gameData);
                childItem.childAttribute ? gameData[childItem.childAttribute].id = id : gameData.id = id;
                continue;
            }
            new SyncTask(GameData.loadDataTask + taskRD);
            FileUtils.loadJsonFile(childItem.path + id + ".json", new Callback(function (gameData, id, childAttribute, itemData) {
                if (!itemData && allowNoFiles) {
                    itemData = {};
                }
                if (!itemData) {
                    delete gameListData.data[id];
                    if (gameListData.hasType) {
                        gameListData.listData.list[GameListData.getType(id)][GameListData.getLocalID(id)] = null;
                    }
                    else {
                        gameListData.listData.list[id] = null;
                    }
                }
                else {
                    ObjectUtils.clone(itemData, childAttribute ? gameData[childAttribute] : gameData);
                    childAttribute ? gameData[childAttribute].id = id : gameData.id = id;
                    gameData = GameData.parseTemplateLanguage(gameData, saveAttribute);
                }
                SyncTask.taskOver(GameData.loadDataTask + taskRD);
            }, this, [gameData, id, childItem.childAttribute]));
        }
    };
    GameData.prototype.onLoadOneOver = function (id, onFin, saveAttribute, taskRD) {
        new SyncTask(GameData.loadDataTask + taskRD, function () {
            onFin.runWith([this[saveAttribute].data[id]]);
            SyncTask.taskOver(GameData.loadDataTask + taskRD);
        }, [], this);
    };
    GameData.prototype.loadTemplateLanguage = function (onFin) {
        var index = Config.language ? Config.language : 0;
        if (index <= 0) {
            if (!this.temPlateLanguagePack)
                this.temPlateLanguagePack = {};
            onFin.run();
            return;
        }
        var languages = Config.languages ? Config.languages : "简体中文,繁体中文,English";
        var name = languages.split(',')[index];
        var path = 'asset/language/' + name + '.json';
        FileUtils.loadJsonFile(path, Callback.New(function (jsonObj) {
            this.temPlateLanguagePack = jsonObj;
            if (!this.temPlateLanguagePack)
                this.temPlateLanguagePack = {};
            onFin.run();
        }, this));
    };
    GameData.parseTemplateLanguage = function (targetJson, saveAttribute) {
        if (saveAttribute === void 0) { saveAttribute = null; }
        if (!targetJson || Config.language == 0 || !Game.data.temPlateLanguagePack)
            return targetJson;
        for (var key in targetJson) {
            if (Common.excludeTranslates.indexOf(key) >= 0)
                continue;
            var value = targetJson[key];
            if (!value)
                continue;
            if (Common.systeamTranslates[value]) {
                targetJson[key] = Common.systeamTranslates[value];
                continue;
            }
            if (typeof value == "object" || Array.isArray(value)) {
                GameData.parseTemplateLanguage(value, saveAttribute);
            }
            else if (typeof value == "string") {
                if (Common.otherTranslates.indexOf(key) >= 0) {
                    value = targetJson[key] = value.replace(/(\\u)(\w{1,4})/gi, function ($0) {
                        return (String.fromCharCode(parseInt((encodeURI($0).replace(/(%5Cu)(\w{1,4})/g, "$2")), 16)));
                    });
                }
                value = StringUtils.clearHeadNotes(value);
                var matchs = value.match(/[\u4e00-\u9fa5]+/g);
                if (!matchs)
                    continue;
                matchs.forEach(function (v) {
                    var vx = Game.data.temPlateLanguagePack[v];
                    if (saveAttribute == GameData.LIST_TYPE_UI && key == "name" && vx)
                        vx = vx.replace(/\s/g, "_");
                    if (saveAttribute != GameData.LIST_TYPE_UI && v == "开始游戏" && vx == "Start")
                        vx = "Start Game";
                    if (vx)
                        targetJson[key] = targetJson[key].replace(v, vx);
                });
            }
        }
        return targetJson;
    };
    GameData.LIST_TYPE_VARIABLE = "variableNameList";
    GameData.LIST_TYPE_SWITCH = "switchNameList";
    GameData.LIST_TYPE_STRING = "stringNameList";
    GameData.LIST_TYPE_PLAYER_VARIABLE = "playerVariableNameList";
    GameData.LIST_TYPE_PLAYER_SWITCH = "playerSwitchNameList";
    GameData.LIST_TYPE_PLAYER_STRING = "playerStringNameList";
    GameData.LIST_TYPE_SCENE = "sceneList";
    GameData.LIST_TYPE_SCENE_OBJECT_MODEL = "sceneObjectModelList";
    GameData.LIST_TYPE_SCENE_OBJECT_MODULE = "sceneObjectModuleList";
    GameData.LIST_TYPE_TILE = "tileList";
    GameData.LIST_TYPE_AVATAR = "avatarList";
    GameData.LIST_TYPE_AVATAR_ACT = "avatarActList";
    GameData.LIST_TYPE_AVATAR_REF_OBJ = "avatarRefObjList";
    GameData.LIST_TYPE_STANDING = "standingList";
    GameData.LIST_TYPE_STANDING_EXPRESSION = "standingExpressionList";
    GameData.LIST_TYPE_COMMON_EVENT = "commonEventList";
    GameData.LIST_TYPE_DIALOG = "dialogList";
    GameData.LIST_TYPE_ANIMATION = "animationList";
    GameData.LIST_TYPE_ANIMATION_SIGNAL = "animationSignalList";
    GameData.LIST_TYPE_ANIMATION_REF_OBJ = "animationRefObjList";
    GameData.LIST_TYPE_UI = "uiList";
    GameData.LIST_TYPE_DATA_STRUCTURE = "dataStructureList";
    GameData.LIST_TYPE_CUSTOM_MODULE = "customModuleList";
    GameData.LIST_TYPE_CUSTOM_MODULE_DATA = "customModuleDataList";
    GameData.LIST_TYPE_CUSTOM_OBJECT_EVENT_TYPE = "customObjectEventTypeList";
    GameData.LIST_TYPE_CUSTOM_UI_EVENT_TYPE = "customUIEventTypeList";
    GameData.LIST_TYPE_CUSTOM_SCENE_EVENT_TYPE = "customSceneEventTypeList";
    GameData.LIST_TYPE_CUSTOM_COMMAND_TYPE = "customCommandTypeList";
    GameData.LIST_TYPE_CUSTOM_BEHAVIOR_TYPE = "customBehaviorTypeList";
    GameData.LIST_TYPE_CUSTOM_CONDITION = "customConditionList";
    GameData.LIST_TYPE_CUSTOM_VALUE_FUNCTION = "customValueFunctionList";
    GameData.LIST_TYPE_AUTO_TILE = "autoTileList";
    GameData.LIST_TYPE_CUSTOM_DATA_DISPLAY = "customDataDisplayList";
    GameData.LIST_TYPE_AVATAR_PART = "avatarPartList";
    GameData.LIST_TYPE_STAND_AVATAR_PART = "standAvatarPartList";
    GameData.LIST_TYPE_MATERIAL = "materialList";
    GameData.LIST_TYPE_CUSTOM_GAME_STRING = "customGameStringList";
    GameData.CUSTOM_ATTR_WORLD_DATA = 0;
    GameData.CUSTOM_ATTR_PLAYER_DATA = 1;
    GameData.CUSTOM_ATTR_SCENE_DATA = 2;
    GameData.CUSTOM_ATTR_SCENE_OBJECT_DATA = 3;
    GameData.CUSTOM_ATTR_SCENE_OBJECT_MODULE_DATA = 4;
    GameData.loadDataTask = "GameData_loadDataTask";
    GameData.customModulePresetDatas = [];
    GameData.dataSystemAttributeInfo = [
        ["asset/json/config.json", false],
        ["asset/json/server/serverConfig.json", false],
        ["asset/json/scene/sceneList.json", false],
        ["asset/json/scene/data/scene\\d+.json", false],
        ["asset/json/server/scene/s\\d+.json", false],
        ["asset/json/scene/tileList.json", false],
        ["asset/json/scene/tile/tile\\d+.json", false],
        ["asset/json/scene/autoTileList.json", false],
        ["asset/json/scene/autoTile/autoTile\\d+.json", false],
        ["asset/json/avatar/avatarList.json", false],
        ["asset/json/avatar/data/avatar\\d+.json", false],
        ["asset/json/avatar/avatarRefObjList.json", false],
        ["asset/json/standAvatar/standAvatarList.json", false],
        ["asset/json/standAvatar/data/standAvatar\\d+.json", false],
        ["asset/json/dialog/dialogList.json", false],
        ["asset/json/dialog/data/dialog\\d+.json", false],
        ["asset/json/animation/animationList.json", false],
        ["asset/json/animation/data/ani\\d+.json", false],
        ["asset/json/custom/customModule/customModuleDataList\\d+.json", false],
        ["asset/json/custom/customModule/${1~N}/cm\\d+.json", false],
        ["asset/json/custom/customWorldData.json", false],
        ["asset/json/custom/customPlayerData.json", false],
        ["asset/json/custom/customObjectEventType.json", true, "[#GAME_SCENE_OBJECT_EVENT_CATEGORY]"],
        ["asset/json/custom/customUIEventType.json", true, "[#GAME_INTERFACE_EVENT_CATEGORY]"],
        ["asset/json/custom/customSceneEventType.json", true, "[#GAME_SCENE_EVENT_CATEGORY]"],
        ["asset/json/variable/variable.json", true, "[#GAME_(PLAYER)_NUMBER_VARIABLE]"],
        ["asset/json/variable/switch.json", true, "[#GAME_(PLAYER)_SWITCH_VARIABLE]"],
        ["asset/json/variable/string.json ", true, "[#GAME_(PLAYER)_STRING_VARIABLE]"],
        ["asset/json/server/variable/variable.json", true, "[#GAME_(WORLD_NG+)_NUMBER_VARIABLE]"],
        ["asset/json/server/variable/switch.json", true, "[#GAME_(WORLD_NG+)_SWITCH_VARIABLE]"],
        ["asset/json/server/variable/string.json", true, "[#GAME_(WORLD_NG+)_STRING_VARIABLE]"],
        ["asset/json/scene/sceneObjectModelList.json", true, "[#GAME_SCENE_OBJECT_PROTOTYPE_CATEGORY_LIST]"],
        ["asset/json/scene/model/som0.json", true, "[#GAME_THE_SCENE_OBJECT_PUBLIC_MODULE]"],
        ["asset/json/scene/model/som\\d+.json", true, "[#GAME_SCENE_OBJECT_PROTOTYPE_DATA]"],
        ["asset/json/scene/sceneObjectModuleList.json", true, "[#GAME_SCENE_OBJECT_MODULE_CATEGORY_LIST]"],
        ["asset/json/scene/sceneObjectModule/soModule\\d+.json", true, "[#GAME_SCENE_OBJECT_MODULE_DATA]"],
        ["asset/json/avatar/avatarActList.json", true, "[#GAME_AVATAR_ACTION_LIST]"],
        ["asset/json/avatar/avatarPartList.json", true, "[#GAME_AVATAR_PARTS_LIST]"],
        ["asset/json/standAvatar/standAvatarPartList.json", true, "[#GAME_STANDING_AVATAR_PARTS_LIST]"],
        ["asset/json/standAvatar/expressionList.json", true, "[#GAME_STANDING_AVATAR_EXPRESSION_LIST]"],
        ["asset/json/server/command/worldCommand.json", true, "[#GAME_COMMON_EVENT_LIST]"],
        ["asset/json/server/command/data/ws\\d+.json", true, "[#GAME_EVENT_OF_THE_COMMON_EVENT]"],
        ["asset/json/animation/animationSignalList.json", true, "[#GAME_ANIMATION_SIGNAL_LIST]"],
        ["asset/json/ui/uiList.json", true, "[#GAME_INTERFACE_LIST]"],
        ["asset/json/ui/data/ui\\d+.json", true, "[#GAME_INTERFACE_COMPONENTS_DATA]"],
        ["asset/json/server/ui/sui\\d+.json", true, "[#GAME_INTERFACE_COMPONENTS_EVENT_DATA]"],
        ["asset/json/custom/dataStructure.json", true, "[#GAME_DATA_STRUCTURE_LIST]"],
        ["asset/json/custom/dataStructure/ds\\d+.json", true, "[#GAME_DATA_STRUCTURE_DATA]"],
        ["asset/json/custom/customModuleList.json", true, "[#GAME_CUSTOM_MODULE_CATEGORY_LIST]"],
        ["asset/json/custom/customModuleSetting/cmSetting\\d+.json", true, "[#GAME_CUSTOM_MODULE_CATEGORY_DATA]"],
        ["asset/json/custom/customWorldSetting.json", true, "[#GAME_WORLD_ATTRIBUTE_SETTING]"],
        ["asset/json/custom/customPlayerSetting.json", true, "[#GAME_PLAYER_ATTRIBUTE_SETTING]"],
        ["asset/json/custom/customCommandType.json", true, "[#GAME_CUSTOM_INSTRUCTION]"],
        ["asset/json/custom/cmd/cmd\\d+.json", true, "[#GAME_COMMAND]"],
        ["asset/json/custom/customBehaviorType.json", true, "[#GAME_OBJECT_BEHAVIOR_LIST]"],
        ["asset/json/custom/behavior/behavior\\d+.json", true, "[#GAME_OBJECT_BEHAVIOR_N]"],
        ["asset/json/custom/customCondition.json", true, "[#GAME_CUSTOM_CONDITIONS_LIST]"],
        ["asset/json/custom/condition/condition\\d+.json", true, "[#GAME_CUSTOM_CONDITIONS]"],
        ["asset/json/custom/customDataDisplayList.json", true, "[#GAME_GAME_NUMBER_VALUE_LIST]"],
        ["asset/json/custom/gameNumber/num\\d+.json", true, "[#GAME_THE_GAME_OF_NUMERICAL_SHORT]"],
        ["asset/json/custom/customGameStringList.json", true, "[#GAME_GAME_STRING_LIST]"],
        ["asset/json/custom/gameString/str\\d+.json", true, "[#GAME_GAME_STRING]"],
        ["asset/json/custom/customMaterialList.json", true, "[#GAME_MATERIAL_LIST]"],
        ["asset/json/custom/material/material\\d+.json", true, "[#GAME_THE_MATERIAL]"],
    ];
    return GameData;
}());
var FileUtils = (function () {
    function FileUtils() {
    }
    Object.defineProperty(FileUtils, "hasFileOperationJurisdiction", {
        get: function () {
            return Config.IS_SERVER || os.platform == 2 || Config.INDIA_APPLICATION_GAME_INFO != null;
        },
        enumerable: false,
        configurable: true
    });
    FileUtils.init = function () {
        if (Common.runPlatform == 2) {
            FileUtils.loader = window["loader"];
            FileUtils.Handler = window["Handler"];
            if (os.inGC(false))
                FileUtils.nativePath = mainDomain_LGConfig.WORK_PATH;
            else if (typeof process != "undefined")
                FileUtils.nativePath = (process.cwd()).replace(/[\\\/]{1,999}/g, "/");
        }
        else {
            FileUtils.readFile = eval("readFile");
            FileUtils.nativePath = eval("nativePath");
        }
    };
    FileUtils.exists = function (localURL, onFin) {
        localURL = localURL.split("?")[0];
        if (FileUtils.hasFileOperationJurisdiction) {
            var indiaAppGameInfo = Config.INDIA_APPLICATION_GAME_INFO;
            if (indiaAppGameInfo) {
                var rq = new HttpRequest();
                var data = JSON.stringify({ mode: 6, localURL: localURL });
                var IDEHttpServerURL = "http://127.0.0.1:" + indiaAppGameInfo.gcDebugPort + "/kdsrpg_http_indieapp.js?cmd=3";
                rq.send(IDEHttpServerURL, data, "post");
                rq.add_ERROR(function () {
                    onFin.runWith([false]);
                }, this);
                rq.add_COMPLETE(function (str) {
                    onFin.runWith([str == "ok"]);
                }, this);
                return;
            }
            if (typeof mainDomain_fs != "undefined") {
                var fs = mainDomain_fs;
                var isExists = fs.existsSync(FileUtils.nativePath + "/" + localURL);
                onFin.runWith([isExists]);
                return;
            }
        }
        onFin.runWith([true]);
    };
    FileUtils.loadJsonFile = function (localURL, onFin, onErrorTips, forceNotCache) {
        if (onErrorTips === void 0) { onErrorTips = true; }
        if (forceNotCache === void 0) { forceNotCache = false; }
        var tail = (Common.inGC) ? "?r=" + Math.random() : "";
        FileUtils.loadFile(localURL + tail, new Callback(function (text) {
            if (!text) {
                onFin.runWith([null]);
                return;
            }
            if (Common.runPlatform == 2 && typeof text != "string") {
                onFin.runWith([text]);
                return;
            }
            try {
                text = text.replace(/(\n|^)[ \t]*\/\/.*/g, "");
                var jsonObj = JSON.parse(text);
                if (Common.runPlatform == 2 && !forceNotCache) {
                    loader.cacheRes(localURL, jsonObj);
                }
            }
            catch (e) {
                trace(localURL + " parse error.");
                jsonObj = null;
            }
            onFin.runWith([jsonObj]);
        }, this), true, onErrorTips, forceNotCache);
    };
    FileUtils.loadFile = function (localURL, onFin, isJson, onErrorTips, forceNotCache) {
        if (isJson === void 0) { isJson = false; }
        if (onErrorTips === void 0) { onErrorTips = true; }
        if (forceNotCache === void 0) { forceNotCache = false; }
        function onloaded(onFin, txt, localURL) {
            if (!txt) {
                if (onErrorTips)
                    trace(localURL + " not exist.");
            }
            onFin.runWith([txt]);
        }
        if (!onErrorTips && !Config.IS_SERVER) {
            FileUtils.exists(localURL, Callback.New(doLoadFile, this));
        }
        else {
            doLoadFile.call(this, true);
        }
        function doLoadFile(isExists) {
            if (!isExists) {
                onloaded(onFin, null, localURL);
                return;
            }
            if (Common.runPlatform == 2) {
                loader.load(localURL, Handler.create(this, function (onFin, localURL, txt) {
                    onloaded(onFin, txt, localURL);
                }, [onFin, localURL]), null, Loader.TEXT, 0, isJson || forceNotCache ? false : true);
            }
            else {
                var txt = FileUtils.readFile(this.nativePath + localURL);
                if (txt == "[no exist]")
                    txt = null;
                onloaded(onFin, txt, localURL);
            }
        }
    };
    FileUtils.cloneFile = function (fromLocalURL, toLocalURL, onFin, onProgress) {
        var _this_1 = this;
        if (onProgress === void 0) { onProgress = null; }
        new SyncTask(FileUtils.TASK_MODIFY_FILE, function () {
            var onCloneFileFin = Callback.New(function (success, fromLocalURL, toLocalURL) {
                onFin.runWith([success, fromLocalURL, toLocalURL]);
                SyncTask.taskOver(FileUtils.TASK_MODIFY_FILE);
            }, _this_1);
            var indiaAppGameInfo = Config.INDIA_APPLICATION_GAME_INFO;
            if (indiaAppGameInfo) {
                var rq = new HttpRequest();
                var data = JSON.stringify({ mode: 1, fromLocalURL: fromLocalURL, toLocalURL: toLocalURL });
                var IDEHttpServerURL = "http://127.0.0.1:" + indiaAppGameInfo.gcDebugPort + "/kdsrpg_http_indieapp.js?cmd=3";
                rq.send(IDEHttpServerURL, data, "post");
                rq.add_ERROR(function () {
                    onCloneFileFin.delayRun(0, null, [false, fromLocalURL, toLocalURL]);
                }, _this_1);
                rq.add_COMPLETE(function (str) {
                    onCloneFileFin.delayRun(0, null, [str == "ok", fromLocalURL, toLocalURL]);
                }, _this_1);
                return;
            }
            if (!Config.EDIT_MODE && (os.platform != 2)) {
                if (IndexedDBManager.support && IndexedDBManager.used) {
                    IndexedDBManager.getIndexDBJson(fromLocalURL, function (value) {
                        if (value) {
                            IndexedDBManager.setIndexDBJson(toLocalURL, value, function (success) {
                                onCloneFileFin.delayRun(0, null, [success, fromLocalURL, toLocalURL]);
                            });
                        }
                        else {
                            onCloneFileFin.delayRun(0, null, [false, fromLocalURL, toLocalURL]);
                        }
                    });
                }
                else {
                    var isCloneFileSuccess = false;
                    try {
                        var fromDataObj = LocalStorage.getJSON(fromLocalURL);
                        if (fromDataObj) {
                            LocalStorage.setJSON(toLocalURL, fromDataObj);
                            isCloneFileSuccess = true;
                        }
                    }
                    catch (e) {
                        isCloneFileSuccess = false;
                        trace("can not clone file [" + fromLocalURL + "] to [" + toLocalURL + "]");
                    }
                    onCloneFileFin.delayRun(0, null, [isCloneFileSuccess, fromLocalURL, toLocalURL]);
                }
                return;
            }
            if (os.inGC(false)) {
                new mainDomain_FileObject(fromLocalURL, function (fromFo) {
                    if (!fromFo.exists) {
                        onCloneFileFin.delayRun(0, null, [false, fromLocalURL, toLocalURL]);
                        return;
                    }
                    fromFo.clone(toLocalURL, function () {
                        onCloneFileFin.delayRun(0, null, [true, fromLocalURL, toLocalURL]);
                    }, function () {
                        onCloneFileFin.delayRun(0, null, [false, fromLocalURL, toLocalURL]);
                    }, _this_1);
                }, _this_1, function () {
                    onCloneFileFin.delayRun(0, null, [false, fromLocalURL, toLocalURL]);
                });
                return;
            }
            if (typeof mainDomain_fs != "undefined") {
                var fs = mainDomain_fs;
                var fromFullPath = FileUtils.nativePath + "/" + fromLocalURL;
                var toFullPath = FileUtils.nativePath + "/" + toLocalURL;
                var fromExist = fs.existsSync(fromFullPath);
                if (!fromExist) {
                    onCloneFileFin.delayRun(0, null, [false, fromLocalURL, toLocalURL]);
                    return;
                }
                var stat = fs.statSync(fromFullPath);
                var fromIsDirectory = stat.isDirectory();
                if (!fromIsDirectory) {
                    FileUtils.doClone(fromLocalURL, toLocalURL, onCloneFileFin, 1);
                }
                else {
                    var _this = _this_1;
                    FileUtils.getAllChildFiles(fromLocalURL, Callback.New(function (fos) {
                        if (!fos) {
                            onCloneFileFin.delayRun(0, null, [false, fromLocalURL, toLocalURL]);
                            return;
                        }
                        FileUtils.doClone(fromLocalURL, toLocalURL, onCloneFileFin, fos.length, onProgress, stat);
                    }, _this_1), stat);
                }
            }
        });
    };
    FileUtils.doClone = function (fromLocalURL, toLocalURL, onFin, copyTotalCount, onProgress, fromStat) {
        if (onProgress === void 0) { onProgress = null; }
        if (fromStat === void 0) { fromStat = null; }
        var _this = this;
        var fs = mainDomain_fs;
        var copyCount = 0;
        function checkCloneOver() {
            copyCount++;
            onProgress && onProgress.runWith([copyCount, copyTotalCount]);
            if (copyCount == copyTotalCount) {
                onFin.runWith([true, fromLocalURL, toLocalURL]);
            }
        }
        var newPath = toLocalURL;
        var newFullPath;
        if (newPath.search(/[A-za-z]:[\\\/]/g) == 0 || (os.detectOS() == "Mac" && newPath.search("/") == 0)) {
            newFullPath = newPath;
            onFin.runWith([false, fromLocalURL, toLocalURL]);
            return;
        }
        else {
            newFullPath = FileUtils.nativePath + "/" + newPath;
        }
        var copy = function (src, dst) {
            try {
                var paths = fs.readdirSync(src);
            }
            catch (e) {
                onFin.runWith([false, fromLocalURL, toLocalURL]);
                return;
            }
            paths.forEach(function (path) {
                new SyncTask("plCopyFile", function (path) {
                    var _src = src + '/' + path, _dst = dst + '/' + path, readable, writable;
                    try {
                        var stat = fs.statSync(_src);
                    }
                    catch (e) {
                        onFin.runWith([false, fromLocalURL, toLocalURL]);
                        return;
                    }
                    if (stat.isFile()) {
                        readable = fs.createReadStream(_src);
                        writable = fs.createWriteStream(_dst);
                        readable.pipe(writable);
                        writable.on('close', function () {
                            checkCloneOver();
                            SyncTask.taskOver("plCopyFile");
                        });
                    }
                    else if (stat.isDirectory()) {
                        exists(_src, _dst, copy);
                        checkCloneOver();
                        SyncTask.taskOver("plCopyFile");
                    }
                    else {
                        checkCloneOver();
                        SyncTask.taskOver("plCopyFile");
                    }
                }, [path], this);
            });
        };
        var exists = function (src, dst, callback) {
            if (fs.existsSync(dst)) {
                callback(src, dst);
            }
            else {
                try {
                    fs.mkdirSync(dst);
                    callback(src, dst);
                }
                catch (e) {
                    trace("[#GAME_FAILED_TO_CREATE_FOLDER]", dst);
                }
            }
        };
        var fromFullPath = FileUtils.nativePath + "/" + fromLocalURL;
        var stat = fs.statSync(fromFullPath);
        var isDirectory = stat.isDirectory();
        if (isDirectory) {
            exists(fromFullPath, newFullPath, copy);
        }
        else {
            var readable = fs.createReadStream(fromFullPath);
            var writable = fs.createWriteStream(newFullPath);
            readable.pipe(writable);
            try {
                writable.on('close', function () {
                    checkCloneOver();
                });
            }
            catch (e) {
                console.log("error:" + e);
            }
        }
    };
    FileUtils.getDirectoryListing = function (directoryLocalPath, onFin, stat) {
        var _this_1 = this;
        if (stat === void 0) { stat = null; }
        var indiaAppGameInfo = Config.INDIA_APPLICATION_GAME_INFO;
        if (os.platform != 2 && indiaAppGameInfo == null) {
            onFin.delayRun(0, null, [null]);
            return;
        }
        if (indiaAppGameInfo) {
            var rq = new HttpRequest();
            var data = JSON.stringify({ mode: 2, directoryLocalPath: directoryLocalPath });
            var IDEHttpServerURL = "http://127.0.0.1:" + indiaAppGameInfo.gcDebugPort + "/kdsrpg_http_indieapp.js?cmd=3";
            rq.send(IDEHttpServerURL, data, "post");
            rq.add_ERROR(function () {
                onFin.delayRun(0, null, [null]);
            }, this);
            rq.add_COMPLETE(function (str) {
                try {
                    var localPaths = JSON.parse(str);
                    for (var i = 0; i < localPaths.length; i++) {
                        var f = localPaths[i];
                        f.lastModifyDate = new Date(f.lastModifyDate);
                    }
                    onFin.delayRun(0, null, [localPaths]);
                }
                catch (e) {
                    onFin.delayRun(0, null, [null]);
                }
            }, this);
            return;
        }
        if (os.inGC(false)) {
            new mainDomain_FileObject(directoryLocalPath, function (directoryLocalFo) {
                if (!directoryLocalFo.exists) {
                    onFin.delayRun(0, null, [null]);
                    return;
                }
                directoryLocalFo.getDirectoryListing(function (directoryLocalFo, fos) {
                    if (!fos) {
                        onFin.delayRun(0, null, [null]);
                    }
                    else {
                        var localPaths = [];
                        for (var i = 0; i < fos.length; i++) {
                            var childFo = fos[i];
                            var localPath = childFo.path;
                            var lastModifyDate = childFo.lastModifyDate;
                            localPaths.push({ lastModifyDate: lastModifyDate, localPath: localPath, fileName: childFo.fileName, isDirectory: childFo.isDirectory });
                        }
                        onFin.delayRun(0, null, [localPaths]);
                    }
                }, function () {
                    onFin.delayRun(0, null, [null]);
                }, _this_1);
            }, this, function () {
                onFin.delayRun(0, null, [null]);
            });
            return;
        }
        var fs = mainDomain_fs;
        if (!stat) {
            var directoryLocalExist = fs.existsSync(directoryLocalPath);
            if (!directoryLocalExist) {
                onFin.delayRun(0, null, [null]);
                return;
            }
            stat = fs.statSync(directoryLocalPath);
            var isDirectory = stat.isDirectory();
            if (!isDirectory) {
                onFin.delayRun(0, null, [null]);
                return;
            }
        }
        var realFullPath = FileUtils.nativePath + "/" + directoryLocalPath;
        var fileObjectList = [];
        var fsList = fs.readdirSync(realFullPath);
        for (var f in fsList) {
            var file = {};
            file.fileName = fsList[f];
            var fsstat = fs.statSync(realFullPath + "/" + file.fileName);
            file.isDirectory = fsstat.isDirectory();
            file.localPath = directoryLocalPath + "/" + file.fileName;
            file.stat = fsstat;
            file.lastModifyDate = new Date(fsstat.mtimeMs);
            fileObjectList.push(file);
        }
        onFin.delayRun(0, null, [fileObjectList]);
    };
    FileUtils.getAllChildFiles = function (directoryLocalPath, onFin, stat) {
        var _this_1 = this;
        if (stat === void 0) { stat = null; }
        var indiaAppGameInfo = Config.INDIA_APPLICATION_GAME_INFO;
        if (os.platform != 2 && indiaAppGameInfo == null) {
            onFin.delayRun(0, null, [null]);
            return;
        }
        if (indiaAppGameInfo) {
            var rq = new HttpRequest();
            var data = JSON.stringify({ mode: 3, directoryLocalPath: directoryLocalPath });
            var IDEHttpServerURL = "http://127.0.0.1:" + indiaAppGameInfo.gcDebugPort + "/kdsrpg_http_indieapp.js?cmd=3";
            rq.send(IDEHttpServerURL, data, "post");
            rq.add_ERROR(function () {
                onFin.delayRun(0, null, [null]);
            }, this);
            rq.add_COMPLETE(function (str) {
                try {
                    var localPaths = JSON.parse(str);
                    onFin.delayRun(0, null, [localPaths]);
                }
                catch (e) {
                    onFin.delayRun(0, null, [null]);
                }
            }, this);
            return;
        }
        if (os.inGC(false)) {
            new mainDomain_FileObject(directoryLocalPath, function (directoryLocalFo) {
                if (!directoryLocalFo.exists) {
                    onFin.delayRun(0, null, [null]);
                    return;
                }
                directoryLocalFo.getAllChildFiles(function (directoryLocalFo, fos) {
                    if (!fos) {
                        onFin.delayRun(0, null, [null]);
                    }
                    else {
                        var localPaths = [];
                        for (var i = 0; i < fos.length; i++) {
                            var childFo = fos[i];
                            var localPath = childFo.path;
                            localPaths.push({ localPath: localPath, fileName: childFo.fileName, isDirectory: childFo.isDirectory });
                        }
                        onFin.delayRun(0, null, [localPaths]);
                    }
                }, function () {
                    onFin.delayRun(0, null, [null]);
                }, _this_1);
            }, this, function () {
                onFin.delayRun(0, null, [null]);
            });
            return;
        }
        var _this = this;
        var taskCount = 1;
        var childFiles = [];
        function getChildFiles(directoryLocalPath, stat) {
            FileUtils.getDirectoryListing(directoryLocalPath, Callback.New(function (childFos) {
                if (childFos) {
                    childFiles = childFiles.concat(childFos);
                    for (var i in childFos) {
                        var childFo = childFos[i];
                        if (childFo.isDirectory) {
                            taskCount++;
                            getChildFiles.call(_this, childFo.localPath, childFo.stat);
                        }
                    }
                }
                checkOver();
            }, this), stat);
        }
        function checkOver() {
            taskCount--;
            if (taskCount == 0) {
                onFin.runWith([childFiles]);
            }
        }
        getChildFiles.call(this, directoryLocalPath, stat);
    };
    FileUtils.save = function (dataObject, localURL, onFin, format, isJson, forceCreateFolder, isZip) {
        var _this_1 = this;
        if (format === void 0) { format = true; }
        if (isJson === void 0) { isJson = true; }
        if (forceCreateFolder === void 0) { forceCreateFolder = false; }
        if (isZip === void 0) { isZip = false; }
        new SyncTask(FileUtils.TASK_MODIFY_FILE, function () {
            var onSaveFin = Callback.New(function (success, localURL) {
                onFin && onFin.runWith([success, localURL]);
                SyncTask.taskOver(FileUtils.TASK_MODIFY_FILE);
            }, _this_1);
            var indiaAppGameInfo = Config.INDIA_APPLICATION_GAME_INFO;
            if (indiaAppGameInfo) {
                if (isZip) {
                    ZipManager.zipCompress("gcdata", dataObject, function (buffer) {
                        var uint8Array = new Uint8Array(buffer);
                        ObjectUtils.jsonSerialize({ isJson: false, format: false, localURL: localURL, dataObject: uint8Array }, toHttpRqquest, 4, !Config.EDIT_MODE);
                    }, Config.z1);
                    var buffer;
                    var text = JSON.stringify({ localURL: localURL, dataObject: buffer });
                }
                else {
                    ObjectUtils.jsonSerialize({ isJson: isJson, format: format, localURL: localURL, dataObject: dataObject }, toHttpRqquest, 1, !Config.EDIT_MODE);
                }
                function toHttpRqquest(data) {
                    var rq = new HttpRequest();
                    var IDEHttpServerURL = "http://127.0.0.1:" + indiaAppGameInfo.gcDebugPort + "/kdsrpg_http_indieapp.js?cmd=3";
                    rq.send(IDEHttpServerURL, data, "post");
                    rq.add_ERROR(function () {
                        onSaveFin && onSaveFin.delayRun(0, null, [false, localURL]);
                    }, this);
                    rq.add_COMPLETE(function (str) {
                        onSaveFin && onSaveFin.delayRun(0, null, [str == "ok", localURL]);
                    }, this);
                }
                return;
            }
            if (!Config.EDIT_MODE && (os.platform != 2)) {
                if (IndexedDBManager.support && IndexedDBManager.used) {
                    if (isJson) {
                        IndexedDBManager.setIndexDBJson(localURL, dataObject, function (success) {
                            onSaveFin && onSaveFin.delayRun(0, null, [success, localURL]);
                        });
                    }
                    else if (isZip) {
                        ZipManager.zipCompress("gcdata", dataObject, function (buffer) {
                            var bufferArray = new Uint8Array(buffer);
                            var bufferText = '';
                            for (var i = 0; i < bufferArray.length; i++) {
                                bufferText += String.fromCharCode(bufferArray[i]);
                            }
                            IndexedDBManager.setIndexDB(localURL, bufferText, function (success) {
                                onSaveFin && onSaveFin.delayRun(0, null, [success, localURL]);
                            });
                        }, Config.z1);
                    }
                    else {
                        IndexedDBManager.setIndexDB(localURL, dataObject, function (success) {
                            onSaveFin && onSaveFin.delayRun(0, null, [success, localURL]);
                        });
                    }
                }
                else {
                    if (isJson) {
                        LocalStorage.setJSON(localURL, dataObject);
                    }
                    else if (isZip) {
                        ZipManager.zipCompress("gcdata", dataObject, function (buffer) {
                            var bufferArray = new Uint8Array(buffer);
                            var bufferText = '';
                            for (var i = 0; i < bufferArray.length; i++) {
                                bufferText += String.fromCharCode(bufferArray[i]);
                            }
                            LocalStorage.setItem(localURL, bufferText);
                        }, Config.z1);
                    }
                    else {
                        LocalStorage.setItem(localURL, dataObject);
                    }
                    onSaveFin && onSaveFin.delayRun(0, null, [true, localURL]);
                }
                return;
            }
            function onSaveOver(onSaveFin, args) {
                try {
                    onSaveFin && onSaveFin.runWith(args);
                }
                catch (e) {
                    trace(e);
                }
            }
            var paths = localURL.split("/");
            if (paths.length > 1)
                paths.pop();
            var folderURL = paths.join("/");
            FileUtils.createDirectoryForce(folderURL, Callback.New(function (success) {
                if (!success) {
                    onSaveOver(onSaveFin, [false, localURL]);
                    return;
                }
                try {
                    if (isJson) {
                        ObjectUtils.jsonSerialize({ isJson: isJson, format: format, dataObject: dataObject }, toSaveDataString, 3, !Config.EDIT_MODE);
                    }
                    else if (isZip) {
                        ZipManager.zipCompress("gcdata", dataObject, function (buffer) {
                            var bufferData = mainDomain_Buffer.from(buffer, 'binary');
                            toSaveDataString(bufferData);
                        }, Config.z1);
                    }
                    else {
                        toSaveDataString(dataObject);
                    }
                }
                catch (e) {
                    trace("[#GAME_FAILED_TO_PACKAGE_DATA]", localURL, e);
                }
                function toSaveDataString(data) {
                    if (typeof mainDomain_FileObject != "undefined") {
                        new mainDomain_FileObject(localURL, function (fo) {
                            if (FileUtils.saveFileExt)
                                data = FileUtils.saveFileExt(fo.fullPath, data);
                            fo[fo.exists ? "saveFile" : "createFile"](data, function () {
                                onSaveOver(onSaveFin, [true, fo.path]);
                            }, function () {
                                onSaveOver(onSaveFin, [false, fo.path]);
                            }, this);
                        }, this, function () {
                            onSaveOver(onSaveFin, [false, localURL]);
                        });
                    }
                    else if (Browser.onPC) {
                        var head = (typeof mainDomain_LGConfig !== "undefined") ? mainDomain_LGConfig.WORK_PATH + "/" : "";
                        var fullURL = head + localURL;
                        if (mainDomain_fs) {
                            mainDomain_fs.writeFile(fullURL, data, function (err) {
                                if (err) {
                                    onSaveOver(onSaveFin, [false, localURL]);
                                    return;
                                }
                                onSaveOver(onSaveFin, [true, localURL]);
                            });
                        }
                    }
                }
            }, _this_1), false, forceCreateFolder ? false : true);
        });
    };
    FileUtils.createDirectoryForce = function (localURL, onFin, taskLock, inEditorIgnore, isFullPath) {
        var _this_1 = this;
        if (taskLock === void 0) { taskLock = true; }
        if (inEditorIgnore === void 0) { inEditorIgnore = false; }
        if (isFullPath === void 0) { isFullPath = false; }
        var taskF = function () {
            var localURLLen = localURL.length - 1;
            if (localURL[localURLLen] == "/") {
                localURL = localURL.substr(0, localURLLen);
            }
            var onCreateDirectoryFin = Callback.New(function (success, localURL) {
                onFin && onFin.runWith([success, localURL]);
                if (taskLock)
                    SyncTask.taskOver(FileUtils.TASK_MODIFY_FILE);
            }, _this_1);
            var indiaAppGameInfo = Config.INDIA_APPLICATION_GAME_INFO;
            if (indiaAppGameInfo) {
                var rq = new HttpRequest();
                var data = JSON.stringify({ mode: 4, localURL: localURL });
                var IDEHttpServerURL = "http://127.0.0.1:" + indiaAppGameInfo.gcDebugPort + "/kdsrpg_http_indieapp.js?cmd=3";
                rq.send(IDEHttpServerURL, data, "post");
                rq.add_ERROR(function () {
                    onCreateDirectoryFin.runWith([false, localURL]);
                }, _this_1);
                rq.add_COMPLETE(function (str) {
                    onCreateDirectoryFin.runWith([str == "ok", localURL]);
                }, _this_1);
                return;
            }
            if (Config.EDIT_MODE && inEditorIgnore) {
                onCreateDirectoryFin.runWith([true, localURL]);
                return;
            }
            if (localURL[localURL.length - 1] != "/") {
                localURL += "/";
            }
            var head = "";
            if (Browser.onPC) {
                head = (typeof mainDomain_LGConfig != "undefined") ? mainDomain_LGConfig.WORK_PATH + "/" : "";
                var fullURL = head + localURL;
                if (isFullPath)
                    fullURL = localURL;
                if (mainDomain_fs) {
                    createDirectoryForce(fullURL, function () {
                        onCreateDirectoryFin.runWith([true, localURL]);
                    }, function () {
                        onCreateDirectoryFin.runWith([false, localURL]);
                    }, _this_1);
                }
            }
            function createDirectoryForce(realFullPath, onComplete, onError, thisPtr) {
                var realFullPathArr = realFullPath.split("/");
                realFullPathArr.pop();
                realFullPath = realFullPathArr.join("/");
                if (this._exists) {
                    onError.call(thisPtr, this, null);
                    return;
                }
                var _this = this;
                realFullPathArr = realFullPath.split("/");
                for (var i = 0; i < realFullPathArr.length; i++) {
                    var path = "";
                    for (var s = 0; s <= i; s++) {
                        path += realFullPathArr[s];
                        if (s != i)
                            path += "/";
                    }
                    if (path == "")
                        continue;
                    var statInfo = mainDomain_fs.existsSync(path);
                    if (!statInfo) {
                        mainDomain_fs.mkdirSync(path);
                    }
                }
                setTimeout(function () {
                    onComplete && onComplete.call(thisPtr, this);
                }, 0);
            }
        };
        if (taskLock) {
            new SyncTask(FileUtils.TASK_MODIFY_FILE, taskF);
        }
        else {
            taskF.apply(this);
        }
    };
    FileUtils.deleteFile = function (localURL, onFin, isFullPath) {
        var _this_1 = this;
        if (onFin === void 0) { onFin = null; }
        if (isFullPath === void 0) { isFullPath = false; }
        new SyncTask(FileUtils.TASK_MODIFY_FILE, function () {
            var onDeleteFileFin = Callback.New(function (success, localURL) {
                onFin && onFin.runWith([success, localURL]);
                SyncTask.taskOver(FileUtils.TASK_MODIFY_FILE);
            }, _this_1);
            var indiaAppGameInfo = Config.INDIA_APPLICATION_GAME_INFO;
            if (indiaAppGameInfo) {
                var rq = new HttpRequest();
                var data = JSON.stringify({ mode: 5, localURL: localURL });
                var IDEHttpServerURL = "http://127.0.0.1:" + indiaAppGameInfo.gcDebugPort + "/kdsrpg_http_indieapp.js?cmd=3";
                rq.send(IDEHttpServerURL, data, "post");
                rq.add_ERROR(function () {
                    onDeleteFileFin.runWith([false, localURL]);
                }, _this_1);
                rq.add_COMPLETE(function (str) {
                    onDeleteFileFin.runWith([str == "ok", localURL]);
                }, _this_1);
                return;
            }
            if (!Config.EDIT_MODE && (os.platform != 2)) {
                if (IndexedDBManager.support && IndexedDBManager.used) {
                    IndexedDBManager.removeIndexDBItem(localURL, function (success) {
                        onDeleteFileFin && onDeleteFileFin.delayRun(0, null, [success, localURL]);
                    });
                }
                else {
                    LocalStorage.removeItem(localURL);
                    onDeleteFileFin && onDeleteFileFin.delayRun(0, null, [true, localURL]);
                }
                return;
            }
            if (mainDomain_fs) {
                var head = (typeof mainDomain_LGConfig !== "undefined") ? mainDomain_LGConfig.WORK_PATH + "/" : "";
                var fullURL = isFullPath ? localURL : (head + localURL);
                if (!mainDomain_fs.existsSync(fullURL)) {
                    onDeleteFileFin && onDeleteFileFin.delayRun(0, null, [false, localURL]);
                    return;
                }
                var stat = mainDomain_fs.statSync(fullURL);
                if (stat.isDirectory()) {
                    deleteall(fullURL);
                }
                else {
                    mainDomain_fs.unlinkSync(fullURL);
                }
                function deleteall(path) {
                    var files = [];
                    if (mainDomain_fs.existsSync(path)) {
                        files = mainDomain_fs.readdirSync(path);
                        files.forEach(function (file, index) {
                            var curPath = path + "/" + file;
                            if (mainDomain_fs.statSync(curPath).isDirectory()) {
                                deleteall(curPath);
                            }
                            else {
                                mainDomain_fs.unlinkSync(curPath);
                            }
                        });
                        mainDomain_fs.rmdirSync(path);
                    }
                }
            }
            onDeleteFileFin && onDeleteFileFin.delayRun(0, null, [true, localURL]);
        });
    };
    FileUtils.TASK_MODIFY_FILE = "__FileUtils__TASK_MODIFY_FILE";
    return FileUtils;
}());
var GameUtils = (function () {
    function GameUtils() {
    }
    GameUtils.getOriByIndex = function (index, oriMode) {
        if (oriMode === void 0) { oriMode = 8; }
        var oriMapping;
        switch (oriMode) {
            case 1:
                oriMapping = { 0: 4 };
                break;
            case 2:
                oriMapping = { 0: 4, 1: 6 };
                break;
            case 3:
                oriMapping = { 0: 4, 1: 2, 2: 8 };
                break;
            case 4:
                oriMapping = { 0: 2, 1: 4, 2: 6, 3: 8 };
                break;
            case 5:
                oriMapping = { 0: 2, 1: 1, 2: 4, 3: 7, 4: 8 };
                break;
            case 8:
                oriMapping = { 0: 4, 1: 7, 2: 8, 3: 9, 4: 6, 5: 3, 6: 2, 7: 1 };
                break;
        }
        return oriMapping[index];
    };
    GameUtils.getIndexByOri = function (ori, oriMode) {
        if (oriMode === void 0) { oriMode = 8; }
        var oriMapping;
        switch (oriMode) {
            case 1:
                oriMapping = { 4: 0 };
                break;
            case 2:
                oriMapping = { 4: 0, 6: 1 };
                break;
            case 3:
                oriMapping = { 2: 1, 4: 0, 8: 2 };
                break;
            case 4:
                oriMapping = { 2: 0, 4: 1, 6: 2, 8: 3 };
                break;
            case 5:
                oriMapping = { 2: 0, 1: 1, 4: 2, 7: 3, 8: 4 };
                break;
            case 8:
                oriMapping = { 4: 0, 7: 1, 8: 2, 9: 3, 6: 4, 3: 5, 2: 6, 1: 7 };
                break;
        }
        return oriMapping[ori];
    };
    GameUtils.getAssetOri = function (ori, oriMode) {
        if (oriMode === void 0) { oriMode = 8; }
        var oriMapping;
        switch (oriMode) {
            case 1:
                oriMapping = { 1: 4, 2: 4, 3: 4, 4: 4, 6: 4, 7: 4, 8: 4, 9: 4 };
                break;
            case 2:
                oriMapping = { 1: 4, 2: 6, 3: 6, 4: 4, 6: 6, 7: 4, 8: 6, 9: 6 };
                break;
            case 3:
                oriMapping = { 1: 4, 2: 2, 3: 4, 4: 4, 6: 4, 7: 4, 8: 8, 9: 4 };
                break;
            case 4:
                oriMapping = { 1: 4, 2: 2, 3: 6, 4: 4, 6: 6, 7: 4, 8: 8, 9: 6 };
                break;
            case 5:
                oriMapping = { 1: 1, 2: 2, 3: 1, 4: 4, 6: 4, 7: 7, 8: 8, 9: 7 };
                break;
            case 8:
                oriMapping = { 1: 1, 2: 2, 3: 3, 4: 4, 6: 6, 7: 7, 8: 8, 9: 9 };
                break;
        }
        return oriMapping[ori];
    };
    GameUtils.getRealOriByOriMode = function (ori, oriMode) {
        if (oriMode === void 0) { oriMode = 8; }
        var oriMapping = [];
        switch (oriMode) {
            case 1:
                oriMapping = [4];
                break;
            case 2:
                oriMapping = [4, 6];
                break;
            case 3:
                oriMapping = [4, 2, 8];
                break;
            case 4:
                oriMapping = [4, 2, 6, 8];
                break;
            case 5:
                oriMapping = [4, 1, 2, 7, 8];
                break;
            case 8:
                oriMapping = [4, 1, 2, 3, 6, 7, 8, 9];
                break;
        }
        if (oriMapping.indexOf(ori) != -1)
            return ori;
        return oriMapping[0];
    };
    GameUtils.getFlipOriByIndex = function (index, oriMode) {
        if (oriMode === void 0) { oriMode = 8; }
        var oriMapping;
        switch (oriMode) {
            case 1:
                oriMapping = { 0: 4, 1: 6 };
                break;
            case 2:
                oriMapping = { 0: 4, 1: 6 };
                break;
            case 3:
                oriMapping = { 0: 4, 1: 2, 2: 8, 3: 6 };
                break;
            case 4:
                oriMapping = { 0: 2, 1: 4, 2: 6, 3: 8 };
                break;
            case 5:
                oriMapping = { 0: 2, 1: 1, 2: 4, 3: 7, 4: 8, 5: 6 };
                break;
            case 8:
                oriMapping = { 0: 4, 1: 7, 2: 8, 3: 9, 4: 6, 5: 3, 6: 2, 7: 1 };
                break;
        }
        return oriMapping[index];
    };
    GameUtils.getIndexByFlipOri = function (ori, oriMode) {
        if (oriMode === void 0) { oriMode = 8; }
        var oriMapping;
        switch (oriMode) {
            case 1:
                oriMapping = { 1: 0, 2: 0, 3: 0, 4: 0, 6: 1, 7: 0, 8: 0, 9: 0 };
                break;
            case 2:
                oriMapping = { 1: 0, 2: 1, 3: 1, 4: 0, 6: 1, 7: 0, 8: 1, 9: 1 };
                break;
            case 3:
                oriMapping = { 1: 4, 2: 1, 3: 4, 4: 0, 6: 3, 7: 0, 8: 2, 9: 0 };
                break;
            case 4:
                oriMapping = { 1: 1, 2: 0, 3: 2, 4: 1, 6: 2, 7: 1, 8: 3, 9: 2 };
                break;
            case 5:
                oriMapping = { 1: 1, 2: 0, 3: 1, 4: 2, 6: 5, 7: 3, 8: 4, 9: 3 };
                break;
            case 8:
                oriMapping = { 1: 7, 2: 6, 3: 5, 4: 0, 6: 4, 7: 1, 8: 2, 9: 3 };
                break;
        }
        return oriMapping[ori];
    };
    GameUtils.getOriByAngle = function (angle) {
        if (angle >= 337.5 || angle < 22.5) {
            return 8;
        }
        else if (angle >= 22.5 && angle < 67.5) {
            return 9;
        }
        else if (angle >= 67.5 && angle < 112.5) {
            return 6;
        }
        else if (angle >= 112.5 && angle < 157.5) {
            return 3;
        }
        else if (angle >= 157.5 && angle < 202.5) {
            return 2;
        }
        else if (angle >= 202.5 && angle < 247.5) {
            return 1;
        }
        else if (angle >= 247.5 && angle < 292.5) {
            return 4;
        }
        else if (angle >= 292.5 && angle < 337.5) {
            return 7;
        }
        return 2;
    };
    GameUtils.getAngleByOri = function (ori) {
        switch (ori) {
            case 1:
                return 225;
            case 2:
                return 180;
            case 3:
                return 145;
            case 4:
                return 270;
            case 6:
                return 90;
            case 7:
                return 315;
            case 8:
                return 0;
            case 9:
                return 45;
        }
    };
    GameUtils.getFlipOri = function (ori) {
        var mapping = { 1: 9, 2: 8, 3: 7, 4: 6, 6: 4, 7: 3, 8: 2, 9: 1 };
        return mapping[ori];
    };
    GameUtils.getGridPostion = function (p, helpP) {
        if (helpP === void 0) { helpP = null; }
        var rp = helpP;
        var s = Config.SCENE_GRID_SIZE;
        if (rp) {
            rp.x = Math.floor(p.x / s);
            rp.y = Math.floor(p.y / s);
        }
        else {
            rp = new Point(Math.floor(p.x / s), Math.floor(p.y / s));
        }
        return rp;
    };
    GameUtils.getGridCenter = function (p, helpP) {
        if (helpP === void 0) { helpP = null; }
        var rp = helpP;
        var s = Config.SCENE_GRID_SIZE;
        var h = Math.floor(Config.SCENE_GRID_SIZE / 2);
        if (rp) {
            rp.x = Math.floor(p.x / s) * s + h;
            rp.y = Math.floor(p.y / s) * s + h;
        }
        else {
            rp = new Point(Math.floor(p.x / s) * s + h, Math.floor(p.y / s) * s + h);
        }
        return rp;
    };
    GameUtils.getGridBottom = function (p, helpP) {
        if (helpP === void 0) { helpP = null; }
        var rp = helpP;
        var s = Config.SCENE_GRID_SIZE;
        var h = Math.floor(Config.SCENE_GRID_SIZE / 2);
        var h1 = Config.SCENE_GRID_SIZE - 1;
        if (rp) {
            rp.x = Math.floor(p.x / s) * s + h;
            rp.y = Math.floor(p.y / s) * s + h1;
        }
        else {
            rp = new Point(Math.floor(p.x / s) * s + h, Math.floor(p.y / s) * s + h1);
        }
        return rp;
    };
    GameUtils.getGridCenterByGrid = function (gridP, helpP) {
        if (helpP === void 0) { helpP = null; }
        var p = new Point(gridP.x * Config.SCENE_GRID_SIZE, gridP.y * Config.SCENE_GRID_SIZE);
        return GameUtils.getGridCenter(p, helpP);
    };
    GameUtils.getGridBottomByGrid = function (gridP, helpP) {
        if (helpP === void 0) { helpP = null; }
        var p = new Point(gridP.x * Config.SCENE_GRID_SIZE, gridP.y * Config.SCENE_GRID_SIZE);
        return GameUtils.getGridBottom(p, helpP);
    };
    GameUtils.getSameStateGrid = function (mapData, gridX, gridY, width, height, attributes, limit) {
        if (limit === void 0) { limit = 100; }
        var limit = 100;
        var limitRect = new Rectangle(Math.max(gridX - limit, 0), Math.max(gridY - limit, 0), Math.min(width, gridX + limit), Math.min(height, gridY + limit));
        var points = [];
        var firstGrid = mapData[gridX] ? mapData[gridX][gridY] : null;
        var gridHelpArr = [];
        for (var x = 0; x < width; x++) {
            gridHelpArr[x] = [];
        }
        var dir = [null, null, [8, 0, 1], null, [6, -1, 0], null, [4, 1, 0], null, [2, 0, -1]];
        var dirIndexes = [2, 4, 6, 8];
        var needSearchGrid = [];
        needSearchGrid.push({ gridX: gridX, gridY: gridY, from: 0 });
        var from = 0;
        while (1) {
            if (needSearchGrid.length == 0)
                break;
            var currentGridData = needSearchGrid.shift();
            gridX = currentGridData.gridX;
            gridY = currentGridData.gridY;
            if (gridHelpArr[gridX][gridY])
                continue;
            gridHelpArr[gridX][gridY] = true;
            var currentGrid = mapData[gridX] ? mapData[gridX][gridY] : null;
            if (currentGrid == firstGrid) { }
            else if (currentGrid && firstGrid) {
                var isSame;
                if (attributes) {
                    isSame = true;
                    for (var attr in attributes) {
                        var attribute = attributes[attr];
                        if (currentGrid[attribute] != firstGrid[attribute]) {
                            isSame = false;
                            break;
                        }
                    }
                }
                else {
                    isSame = currentGrid === firstGrid;
                }
                if (!isSame)
                    continue;
            }
            else {
                continue;
            }
            points.push(new Point(gridX, gridY));
            for (var d = 0; d < 4; d++) {
                var toDir = dirIndexes[d];
                var toDirData = dir[toDir];
                if (toDirData[0] == currentGridData.from)
                    continue;
                var toX = gridX + toDirData[1];
                var toY = gridY + toDirData[2];
                if (toX < limitRect.x || toX >= limitRect.width || toY < limitRect.y || toY >= limitRect.height)
                    continue;
                needSearchGrid.push({ gridX: toX, gridY: toY, from: toDir });
            }
        }
        return points;
    };
    GameUtils.getMendingGrids = function (grid1, grid2, per) {
        if (per === void 0) { per = 0.1; }
        var gridDetermine = [];
        var grids = [];
        for (var i = 0; i <= 1; i += 0.1) {
            var p = Point.interpolate(grid1, grid2, i);
            p.x = Math.floor(p.x);
            p.y = Math.floor(p.y);
            var xArr = gridDetermine[p.x];
            if (!xArr)
                xArr = gridDetermine[p.x] = [];
            if (xArr[p.y])
                continue;
            xArr[p.y] = true;
            if (grid1.x == p.x && grid1.y == p.y)
                continue;
            grids.push(p);
        }
        return grids;
    };
    GameUtils.getAutoFitSizePre = function (rect, canvasRect) {
        var xPer = canvasRect.width / rect.width;
        var yPer = canvasRect.height / rect.height;
        var per = Math.min(xPer, yPer);
        return per;
    };
    GameUtils.isInheritNode = function (node, parentNode) {
        var p = node.parent;
        while (p) {
            if (p == parentNode)
                return true;
            p = p.parent;
        }
        return false;
    };
    GameUtils.getVarID = function (value) {
        if (value && value.toString().search(/\$[0-9]*/g) == 0) {
            var id = parseInt(value.toString().substr(1));
            return id;
        }
        return 0;
    };
    GameUtils.getTween = function (tweenID) {
        if (!tweenID)
            return [Ease.linearNone, "linearNone"];
        var arr = ["linearNone", "bounceIn", "bounceInOut", "bounceOut", "backIn",
            "backInOut", "backOut", "elasticIn", "elasticInOut", "elasticOut", "strongIn",
            "strongInOut", "strongOut", "sineIn", "sineInOut", "sineOut", "quintIn",
            "quintInOut", "quintOut", "quartIn", "quartInOut", "quartOut", "cubicIn",
            "cubicInOut", "cubicOut", "quadIn", "quadInOut", "quadOut", "expoIn", "expoInOut",
            "expoOut", "circIn", "circInOut", "circOut"];
        return [Ease[arr[tweenID]], arr[tweenID]];
    };
    GameUtils.getTweenLabels = function () {
        var tweenLabel = "[#GAME_THERE_IS_NO]";
        for (var i = 1; i < GameUtils.tweenCount; i++) {
            var tweenData = GameUtils.getTween(i);
            tweenLabel += "," + tweenData[1];
        }
        return tweenLabel;
    };
    GameUtils.isLegalVarName = function (varName, headFont) {
        if (headFont === void 0) { headFont = true; }
        if (!varName)
            return false;
        var reg = /([\$_a-zA-Z]|[\u4e00-\u9fa50-9a-zA-Z_$]){1,255}/g;
        var m = varName.match(reg);
        if (headFont && !isNaN(parseInt(varName[0])))
            return false;
        return m != null && m[0] == varName;
    };
    GameUtils.getCurveData = function (curveStrData) {
        var def = [[0, 0, 0, 99, 100, 0, 0, 0], [0, 100, 100]];
        if (!curveStrData || typeof curveStrData != "string")
            return def;
        if (curveStrData.indexOf("[[0") == -1)
            return def;
        try {
            return JSON.parse(curveStrData);
        }
        catch (e) {
            return def;
        }
    };
    GameUtils.getBezierPoint2ByGroupValue = function (groupValue, x) {
        if (!groupValue || !groupValue.length)
            return 0;
        var maxHeight = groupValue[0][4];
        var t = Math.min(Math.max(MathUtils.float(x), 0), 1);
        var next = ArrayUtils.matchAttributes(groupValue, { 1: t * 100 }, true, ">=", true)[0];
        if (next == null)
            return 0;
        if (next == 0)
            return groupValue[0][2] * maxHeight / 100;
        var lastArr = groupValue[next - 1];
        var nextArr = groupValue[next];
        var lastX = lastArr[1];
        var lastY = lastArr[2];
        var nextX = nextArr[1];
        var nextY = nextArr[2];
        var nextType = nextArr[0];
        if (lastX == nextX) {
            var localT = 0;
        }
        else {
            var localT = (t * 100 - lastX) / (nextX - lastX);
        }
        if (nextType == 0) {
            return ((nextY - lastY) * localT + lastY) * maxHeight / 100;
        }
        else {
            return MathUtils.getBezierPoint2(lastX, lastY, nextArr[3], nextArr[4], nextX, nextY, localT).y * maxHeight / 100;
        }
    };
    GameUtils.getTransData = function (transDataStr) {
        if (!transDataStr || typeof transDataStr != "string")
            return null;
        try {
            var trans = JSON.parse(transDataStr);
            if (trans.transType != undefined && trans.loopType != undefined && trans.timeType != undefined && trans.timeUnit != undefined && trans.totalTime != undefined && trans.tweenType != undefined && trans.tweenTypeName != undefined && trans.curveData != undefined && trans.refreshInterval != undefined)
                return trans;
            else
                return null;
        }
        catch (e) {
            return null;
        }
    };
    GameUtils.getValueByTransData = function (transData, x) {
        var t = Math.min(Math.max(MathUtils.float(x), 0), 1);
        if (!transData) {
            return Ease.linearNone(t, 0, 1, 1);
        }
        if (transData.transType == 0) {
            if (transData.loopType == 0 || transData.loopType == 1) {
                return Ease.linearNone(t, 0, 1, 1);
            }
            else {
                if (t <= 0.5)
                    return Ease.linearNone(t, 0, 1, 0.5);
                else
                    return Ease.linearNone(1 - t, 0, 1, 0.5);
            }
        }
        else if (transData.transType == 1) {
            var normal = [1, 4, 7, 10, 13, 16, 19, 22, 25, 28, 31];
            var tail = [2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32];
            var tween = GameUtils.getTween(transData.tweenType + 1)[0];
            if (!tween)
                return 0;
            if (transData.loopType == 0 || transData.loopType == 1) {
                return tween.call(this, t, 0, 1, 1);
            }
            else if (transData.loopType == 2 || transData.loopType == 4) {
                if (t <= 0.5)
                    return tween.call(this, t, 0, 1, 0.5);
                else {
                    if (normal.indexOf(transData.tweenType) != -1)
                        return tween.call(this, 1 - t, 0, 1, 0.5);
                    else if (tail.indexOf(transData.tweenType) != -1) {
                        var tailTween = GameUtils.getTween(transData.tweenType - 1)[0];
                        if (!tailTween)
                            return 0;
                        return tailTween.call(this, 1 - t, 0, 1, 0.5);
                    }
                    else {
                        var forwwordTween = GameUtils.getTween(transData.tweenType + 3)[0];
                        if (!forwwordTween)
                            return 0;
                        return forwwordTween.call(this, 1 - t, 0, 1, 0.5);
                    }
                }
            }
            else {
                if (t <= 0.5)
                    return tween.call(this, t, 0, 1, 0.5);
                else
                    return tween.call(this, 1 - t, 0, 1, 0.5);
            }
        }
        else {
            var curvedata = transData.curveData;
            if (!curvedata)
                return 0;
            if (transData.loopType == 0 || transData.loopType == 1) {
                return GameUtils.getBezierPoint2ByGroupValue(curvedata, t);
            }
            else if (transData.loopType == 2 || transData.loopType == 4) {
                if (t <= 0.5)
                    return GameUtils.getBezierPoint2ByGroupValue(curvedata, t * 2);
                else
                    return GameUtils.getBezierPoint2ByGroupValue(curvedata, (2 - t * 2));
            }
            else {
                if (t <= 0.5)
                    return GameUtils.getBezierPoint2ByGroupValue(curvedata, t * 2);
                else
                    return GameUtils.getBezierPoint2ByGroupValue(curvedata, (2 - t * 2));
            }
        }
    };
    GameUtils.getSelectUICompData = function (selectDataStr) {
        if (!selectDataStr || typeof selectDataStr != "string")
            return null;
        try {
            return JSON.parse(selectDataStr);
        }
        catch (e) {
            return null;
        }
    };
    GameUtils.tweenCount = 34;
    return GameUtils;
}());
var IndexedDBManager = (function () {
    function IndexedDBManager() {
    }
    IndexedDBManager.setIndexDB = function (key, value, onFin) {
        if (onFin === void 0) { onFin = null; }
        if (!IndexedDBManager.used)
            return;
        var req = IndexedDBManager.indexedDB.open(IndexedDBManager.databaseName, IndexedDBManager.version);
        req.onupgradeneeded = function (event) {
            var db = event.target.result;
            if (!db.objectStoreNames.contains(IndexedDBManager.tableName)) {
                db.createObjectStore(IndexedDBManager.tableName, { keyPath: "name" });
            }
        };
        req.onsuccess = function (event) {
            var db = event.target.result;
            if (db.objectStoreNames.contains(IndexedDBManager.tableName)) {
                var transaction = db.transaction([IndexedDBManager.tableName], 'readwrite');
                var store = transaction.objectStore(IndexedDBManager.tableName);
                var cache = { name: key, value: value };
                var get_req = store.get(key);
                get_req.onsuccess = function (event) {
                    if (event.target.result) {
                        updataIndexDB(store, cache, onFin);
                    }
                    else {
                        addIndexDB(store, cache, onFin);
                    }
                };
                get_req.onerror = function () {
                    addIndexDB(store, cache, onFin);
                };
            }
            else {
                onFin && onFin.apply(this, [false]);
            }
        };
        req.onerror = function () {
            onFin && onFin.apply(this, [false]);
        };
        function addIndexDB(store, cache, onFin) {
            var add_req = store.add(cache);
            add_req.onsuccess = function () {
                onFin && onFin.apply(this, [true]);
            };
            add_req.onerror = function () {
                onFin && onFin.apply(this, [false]);
            };
        }
        function updataIndexDB(store, cache, onFin) {
            var updata_req = store.put(cache);
            updata_req.onsuccess = function () {
                onFin && onFin.apply(this, [true]);
            };
            updata_req.onerror = function () {
                onFin && onFin.apply(this, [false]);
            };
        }
    };
    IndexedDBManager.getIndexDB = function (key, onFin) {
        if (!IndexedDBManager.used)
            return;
        var req = IndexedDBManager.indexedDB.open(IndexedDBManager.databaseName, IndexedDBManager.version);
        req.onupgradeneeded = function (event) {
            var db = event.target.result;
            if (!db.objectStoreNames.contains(IndexedDBManager.tableName)) {
                db.createObjectStore(IndexedDBManager.tableName, { keyPath: "name" });
            }
        };
        req.onsuccess = function (event) {
            var db = event.target.result;
            if (db.objectStoreNames.contains(IndexedDBManager.tableName)) {
                var transaction = db.transaction([IndexedDBManager.tableName], 'readwrite');
                var store = transaction.objectStore(IndexedDBManager.tableName);
                var store_req = store.get(key);
                store_req.onsuccess = function (event) {
                    if (event.target.result) {
                        onFin.apply(this, [event.target.result.value]);
                    }
                    else {
                        onFin.apply(this, [null]);
                    }
                };
                store_req.onerror = function () {
                    onFin.apply(this, [null]);
                };
            }
            else {
                onFin.apply(this, [null]);
            }
        };
        req.onerror = function () {
            onFin.apply(this, [null]);
        };
    };
    IndexedDBManager.setIndexDBJson = function (key, value, onFin) {
        if (onFin === void 0) { onFin = null; }
        if (!IndexedDBManager.used)
            return;
        var req = IndexedDBManager.indexedDB.open(IndexedDBManager.databaseName, IndexedDBManager.version);
        req.onupgradeneeded = function (event) {
            var db = event.target.result;
            if (!db.objectStoreNames.contains(IndexedDBManager.tableName)) {
                db.createObjectStore(IndexedDBManager.tableName, { keyPath: "name" });
            }
        };
        req.onupgradeneeded = function (event) {
            var db = event.target.result;
            if (!db.objectStoreNames.contains(IndexedDBManager.tableName)) {
                db.createObjectStore(IndexedDBManager.tableName, { keyPath: "name" });
            }
        };
        req.onsuccess = function (event) {
            var db = event.target.result;
            if (db.objectStoreNames.contains(IndexedDBManager.tableName)) {
                var transaction = db.transaction([IndexedDBManager.tableName], 'readwrite');
                var store = transaction.objectStore(IndexedDBManager.tableName);
                var content = JSON.stringify(value);
                var cache = { name: key, value: content };
                var get_req = store.get(key);
                get_req.onsuccess = function (event) {
                    if (event.target.result) {
                        updataIndexDBJson(store, cache, onFin);
                    }
                    else {
                        addIndexDBJson(store, cache, onFin);
                    }
                };
                get_req.onerror = function (event) {
                    addIndexDBJson(store, cache, onFin);
                };
            }
            else {
                onFin && onFin.apply(this, [false]);
            }
        };
        req.onerror = function () {
            onFin && onFin.apply(this, [false]);
        };
        function addIndexDBJson(store, cache, onFin) {
            var add_req = store.add(cache);
            add_req.onsuccess = function () {
                onFin && onFin.apply(this, [true]);
            };
            add_req.onerror = function () {
                onFin && onFin.apply(this, [false]);
            };
        }
        function updataIndexDBJson(store, cache, onFin) {
            var updata_req = store.put(cache);
            updata_req.onsuccess = function () {
                onFin && onFin.apply(this, [true]);
            };
            updata_req.onerror = function () {
                onFin && onFin.apply(this, [false]);
            };
        }
    };
    IndexedDBManager.getIndexDBJson = function (key, onFin) {
        if (!IndexedDBManager.used)
            return;
        var req = IndexedDBManager.indexedDB.open(IndexedDBManager.databaseName, IndexedDBManager.version);
        req.onupgradeneeded = function (event) {
            var db = event.target.result;
            if (!db.objectStoreNames.contains(IndexedDBManager.tableName)) {
                db.createObjectStore(IndexedDBManager.tableName, { keyPath: "name" });
            }
        };
        req.onsuccess = function (event) {
            var db = event.target.result;
            if (db.objectStoreNames.contains(IndexedDBManager.tableName)) {
                var transaction = db.transaction([IndexedDBManager.tableName], 'readwrite');
                var store = transaction.objectStore(IndexedDBManager.tableName);
                var store_req = store.get(key);
                store_req.onsuccess = function (event) {
                    if (event.target.result) {
                        try {
                            var content = JSON.parse(event.target.result.value);
                            onFin.apply(this, [content]);
                        }
                        catch (e) {
                            onFin.apply(this, [null]);
                        }
                    }
                    else {
                        onFin.apply(this, [null]);
                    }
                };
                store_req.onerror = function (event) {
                    onFin.apply(this, [false]);
                };
            }
            else {
                onFin.apply(this, [null]);
            }
        };
        req.onerror = function () {
            onFin.apply(this, [null]);
        };
    };
    IndexedDBManager.removeIndexDBItem = function (key, onFin) {
        if (onFin === void 0) { onFin = null; }
        if (!IndexedDBManager.used)
            return;
        var req = IndexedDBManager.indexedDB.open(IndexedDBManager.databaseName, IndexedDBManager.version);
        req.onupgradeneeded = function (event) {
            var db = event.target.result;
            if (!db.objectStoreNames.contains(IndexedDBManager.tableName)) {
                db.createObjectStore(IndexedDBManager.tableName, { keyPath: "name" });
            }
        };
        req.onsuccess = function (event) {
            var db = event.target.result;
            if (db.objectStoreNames.contains(IndexedDBManager.tableName)) {
                var transaction = db.transaction([IndexedDBManager.tableName], 'readwrite');
                var store = transaction.objectStore(IndexedDBManager.tableName);
                var store_req = store.delete(key);
                store_req.onsuccess = function (event) {
                    onFin && onFin.apply(this, [true]);
                };
                store_req.onerror = function (event) {
                    onFin && onFin.apply(this, [false]);
                };
            }
            else {
                onFin && onFin.apply(this, [false]);
            }
        };
        req.onerror = function () {
            onFin && onFin.apply(this, [false]);
        };
    };
    IndexedDBManager.items = function (onFin) {
        if (!IndexedDBManager.used)
            return;
        var req = IndexedDBManager.indexedDB.open(IndexedDBManager.databaseName, IndexedDBManager.version);
        req.onupgradeneeded = function (event) {
            var db = event.target.result;
            if (!db.objectStoreNames.contains(IndexedDBManager.tableName)) {
                db.createObjectStore(IndexedDBManager.tableName, { keyPath: "name" });
            }
        };
        req.onsuccess = function (event) {
            var db = event.target.result;
            if (db.objectStoreNames.contains(IndexedDBManager.tableName)) {
                var transaction = db.transaction([IndexedDBManager.tableName], 'readwrite');
                var store = transaction.objectStore(IndexedDBManager.tableName);
                var store_req = store.openCursor();
                var list = {};
                store_req.onsuccess = function (event) {
                    var cursor = event.target.result;
                    if (cursor) {
                        list[cursor.value.name] = cursor.value.value;
                        cursor.continue();
                    }
                    else {
                        onFin.apply(this, [list]);
                    }
                };
                store_req.onerror = function (event) {
                    onFin.apply(this, [{}]);
                };
            }
        };
        req.onerror = function () {
            onFin.apply(this, [{}]);
        };
    };
    IndexedDBManager.clear = function (onFin) {
        if (onFin === void 0) { onFin = null; }
        if (!IndexedDBManager.used)
            return;
        var req = IndexedDBManager.indexedDB.open(IndexedDBManager.databaseName, IndexedDBManager.version);
        req.onupgradeneeded = function (event) {
            var db = event.target.result;
            if (!db.objectStoreNames.contains(IndexedDBManager.tableName)) {
                db.createObjectStore(IndexedDBManager.tableName, { keyPath: "name" });
            }
        };
        req.onsuccess = function (event) {
            var db = event.target.result;
            if (db.objectStoreNames.contains(IndexedDBManager.tableName)) {
                var transaction = db.transaction([IndexedDBManager.tableName], 'readwrite');
                var store = transaction.objectStore(IndexedDBManager.tableName);
                var store_req = store.clear();
                store_req.onsuccess = function (event) {
                    onFin && onFin.apply(this, [true]);
                };
                store_req.onerror = function (event) {
                    onFin && onFin.apply(this, [false]);
                };
            }
        };
        req.onerror = function () {
            onFin && onFin.apply(this, [false]);
        };
    };
    IndexedDBManager.indexedDB = (typeof window != "undefined" && (window.indexedDB || window['webkitIndexedDB'] || window['mozIndexedDB'] || window['msIndexedDB']));
    IndexedDBManager.support = IndexedDBManager.indexedDB ? true : false;
    IndexedDBManager.used = false;
    IndexedDBManager.databaseName = "GameCreator";
    IndexedDBManager.version = 1;
    IndexedDBManager.tableName = "GC_Cache";
    return IndexedDBManager;
}());
var SceneObjectBehaviors = (function () {
    function SceneObjectBehaviors(so, loop, targetSceneObject, onOver, startIndex, executor) {
        if (startIndex === void 0) { startIndex = 0; }
        if (executor === void 0) { executor = null; }
        this.behaviors = [];
        this.so = so;
        this.loop = loop;
        this.index = startIndex;
        this.onOver = onOver;
        this['targetPlayerSceneObject'] = this.targetSceneObject = targetSceneObject;
        this.executor = executor;
    }
    Object.defineProperty(SceneObjectBehaviors.prototype, "index", {
        get: function () {
            return this._index;
        },
        set: function (v) {
            this._index = v;
            EventUtils.happen(this, SceneObjectBehaviors.EVENT_INDEX_CHANGE, [v]);
        },
        enumerable: false,
        configurable: true
    });
    SceneObjectBehaviors.toBehaviorData = function (behaviorStr) {
        var behaviorData = [-1, 0, [], 0, 0];
        if (typeof behaviorStr == "string") {
            var behaviorSymbolIndex = behaviorStr.indexOf(String.fromCharCode(5));
            if (behaviorSymbolIndex != -1) {
                try {
                    var behaviorJson = JSON.parse(behaviorStr.substr(behaviorSymbolIndex + 1));
                    behaviorData = behaviorJson;
                }
                catch (e) { }
            }
        }
        return {
            targetSceneObjectIndex: MathUtils.int(behaviorData[0]),
            behaviorData: behaviorData[2],
            loop: behaviorData[1] == 1,
            cover: behaviorData[3] == 1,
            forceStopLastBehavior: behaviorData[4] == 1
        };
    };
    SceneObjectBehaviors.prototype.dispose = function () {
        EventUtils.clear(this);
    };
    SceneObjectBehaviors.prototype.setBehaviors = function (behaviorData, delayFrame) {
        if (delayFrame === void 0) { delayFrame = 0; }
        this.delayFrame = delayFrame;
        this.behaviors = [];
        this.behaviorData = behaviorData;
        var len = behaviorData.length;
        for (var i = 0; i < len; i++) {
            var behavior = behaviorData[i].concat();
            var behaviorID = behavior.shift();
            var behaviorParams = behavior;
            var behaviorFunc = this["behavior" + behaviorID];
            var globehaviorFunc = null;
            if (globalThis["CustomSceneObjectBehavior"]) {
                globehaviorFunc = globalThis["CustomSceneObjectBehavior"]["f" + behaviorID];
                if (globehaviorFunc && typeof globehaviorFunc == "function") {
                    behaviorFunc = globehaviorFunc;
                }
            }
            if (!behaviorFunc || typeof behaviorFunc != "function")
                continue;
            this.behaviors.push([behaviorFunc, behaviorParams, globehaviorFunc ? true : false]);
        }
    };
    SceneObjectBehaviors.prototype.reset = function (defSceneObejct) {
    };
    SceneObjectBehaviors.prototype.waitFrame = function (frame) {
        if (this.ignoreProcess)
            return;
        if (frame < 1)
            frame = 1;
        this.delayFrame = frame;
    };
    SceneObjectBehaviors.prototype.doWaitFrame = function () {
        if (!this.delayFrame)
            return;
        this.delayFrame--;
    };
    SceneObjectBehaviors.prototype.update = function () {
        if (this.so.isDisposed)
            return false;
        this.doWaitFrame();
        if (this.delayFrame || !this.so || !this.so.inScene)
            return false;
        if (this.logicPause)
            return false;
        var behavior = this.behaviors[this.index];
        if (behavior) {
            var lastIndex = this.index;
            var params = behavior[2] ? [this].concat(behavior[1]) : behavior[1];
            this.index++;
            try {
                behavior[0].apply(this, params);
            }
            catch (e) {
                trace(e.stack);
            }
            if (this.delayFrame || this.logicPause)
                return false;
            if (!this.ignoreProcess && this.index != lastIndex)
                return this.update();
        }
        if (this.index == this.behaviors.length) {
            if (this.loop) {
                this.index = 0;
            }
            else {
                this.onOver && this.onOver.runWith([this]);
                return true;
            }
        }
        return false;
    };
    SceneObjectBehaviors.prototype.getSaveData = function () {
        return [this.behaviorData, this.index, this.loop, this.delayFrame, this.targetSceneObject ? this.targetSceneObject.index : -1, this.executor ? this.executor.index : -1];
    };
    SceneObjectBehaviors.EVENT_INDEX_CHANGE = "SceneObjectBehaviorsEVENT_PLAY_NEXT_STEP";
    return SceneObjectBehaviors;
}());
var Common = (function () {
    function Common() {
    }
    Object.defineProperty(Common, "runPlatform", {
        get: function () {
            if (typeof window != "undefined" && typeof isCrossServer != "undefined" && isCrossServer) {
                return 0;
            }
            else if (typeof window != "undefined") {
                return 2;
            }
            else {
                return 1;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "inGC", {
        get: function () {
            return (typeof window == "undefined" || Config.IS_SERVER) ? false : (typeof mainDomain_gcide != "undefined");
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "gameData", {
        get: function () {
            if (Config.IS_SERVER) {
                return ServerWorld.gameData;
            }
            else {
                return Game.data;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "variableNameList", {
        get: function () {
            return this.getGameDataAttrValue(GameData.LIST_TYPE_VARIABLE);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "switchNameList", {
        get: function () {
            return this.getGameDataAttrValue(GameData.LIST_TYPE_SWITCH);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "stringNameList", {
        get: function () {
            return this.getGameDataAttrValue(GameData.LIST_TYPE_STRING);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "playerVariableNameList", {
        get: function () {
            return this.getGameDataAttrValue(GameData.LIST_TYPE_PLAYER_VARIABLE);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "playerSwitchNameList", {
        get: function () {
            return this.getGameDataAttrValue(GameData.LIST_TYPE_PLAYER_SWITCH);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "playerStringNameList", {
        get: function () {
            return this.getGameDataAttrValue(GameData.LIST_TYPE_PLAYER_STRING);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "sceneList", {
        get: function () {
            return this.getGameDataAttrValue(GameData.LIST_TYPE_SCENE);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "sceneObjectModelList", {
        get: function () {
            return this.getGameDataAttrValue(GameData.LIST_TYPE_SCENE_OBJECT_MODEL);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "sceneObjectModuleList", {
        get: function () {
            return this.getGameDataAttrValue(GameData.LIST_TYPE_SCENE_OBJECT_MODULE);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "tileList", {
        get: function () {
            return this.getGameDataAttrValue(GameData.LIST_TYPE_TILE);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "avatarActList", {
        get: function () {
            return this.getGameDataAttrValue(GameData.LIST_TYPE_AVATAR_ACT);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "standingExpressionList", {
        get: function () {
            return this.getGameDataAttrValue(GameData.LIST_TYPE_STANDING_EXPRESSION);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "avatarRefObjList", {
        get: function () {
            return this.getGameDataAttrValue(GameData.LIST_TYPE_AVATAR_REF_OBJ);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "animationSignalList", {
        get: function () {
            return this.getGameDataAttrValue(GameData.LIST_TYPE_ANIMATION_SIGNAL);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "dataStructureList", {
        get: function () {
            if (Config.EDIT_MODE) {
                return EUIWindowDataStructureConfig.dataStructureClone ? EUIWindowDataStructureConfig.dataStructureClone : Game.data.dataStructureList;
            }
            else if (Config.IS_SERVER) {
                return ServerWorld.gameData.dataStructureList;
            }
            else {
                return Game.data.dataStructureList;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "customModuleList", {
        get: function () {
            if (Config.EDIT_MODE) {
                return EUIWindowDataStructureConfig.customModuleClone ? EUIWindowDataStructureConfig.customModuleClone : Game.data.customModuleList;
            }
            else if (Config.IS_SERVER) {
                return ServerWorld.gameData.customModuleList;
            }
            else {
                return Game.data.customModuleList;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "customModuleDataList", {
        get: function () {
            return this.getNewestDBData(GameData.LIST_TYPE_CUSTOM_MODULE_DATA);
        },
        enumerable: false,
        configurable: true
    });
    Common.getCustomModuleDataList = function (moduleID) {
        var attr = GameData.LIST_TYPE_CUSTOM_MODULE_DATA;
        if (Config.EDIT_MODE) {
            var res = Editor.data && Editor.data.dbData && Editor.data.dbData[attr] && Editor.data.dbData[attr][moduleID] ? Editor.data.dbData[attr][moduleID] : Game.data[attr][moduleID];
            return res;
        }
        else if (Config.IS_SERVER) {
            return ServerWorld.gameData[attr][moduleID];
        }
        else {
            return Game.data[attr][moduleID];
        }
    };
    Common.ModifyingCustomModuleData = function (fin, moduleID) {
        var attr = GameData.LIST_TYPE_CUSTOM_MODULE_DATA;
        var customModule;
        var isDbData = false;
        if (Config.EDIT_MODE) {
            if (Editor.data && Editor.data.dbData) {
                if (Editor.data.dbData[attr].length == 0)
                    Editor.data.dbData[attr] = ObjectUtils.depthClone(Game.data[attr]);
                customModule = Editor.data.dbData[attr][moduleID];
                isDbData = true;
            }
            else
                customModule = Game.data[attr][moduleID];
        }
        else if (Config.IS_SERVER) {
            customModule = ServerWorld.gameData[attr][moduleID];
        }
        else
            customModule = Game.data[attr][moduleID];
        if (!customModule)
            return;
        var dataIDs = fin(customModule);
        if (!dataIDs)
            return;
        if (!isDbData) {
            EditorData.updateNeedSaveFile(EditorData.NEED_SAVE_CUSTOM_MODEL_DATA_LIST + moduleID);
            dataIDs.forEach(function (v) { EditorData.updateNeedSaveFile(EditorData.NEED_SAVE_CUSTOM_MODEL_DATA + moduleID, false, MathUtils.int(v)); });
        }
        else
            EventUtils.happen(EUIDataBase, EUIDataBase.EVENT_RESER_DATABASE_CUSTOM_MODULE_WINDOW, [moduleID, dataIDs]);
    };
    Object.defineProperty(Common, "customSceneModelList", {
        get: function () {
            return null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "customGameAttribute", {
        get: function () {
            if (Config.EDIT_MODE) {
                return Editor.data.dbData && Editor.data.dbData.customGameAttribute ? Editor.data.dbData.customGameAttribute : Game.data.customGameAttribute;
            }
            else if (Config.IS_SERVER) {
                return ServerWorld.gameData.customGameAttribute;
            }
            else {
                return Game.data.customGameAttribute;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "customSceneEventTypeList", {
        get: function () {
            if (Config.IS_SERVER) {
                return ServerWorld.gameData.customSceneEventTypeList;
            }
            else {
                return Game.data.customSceneEventTypeList;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "customObjectEventTypeList", {
        get: function () {
            if (Config.IS_SERVER) {
                return ServerWorld.gameData.customObjectEventTypeList;
            }
            else {
                return Game.data.customObjectEventTypeList;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "customUIEventTypeList", {
        get: function () {
            if (Config.IS_SERVER) {
                return ServerWorld.gameData.customUIEventTypeList;
            }
            else {
                return Game.data.customUIEventTypeList;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "customCommandTypeList", {
        get: function () {
            if (Config.IS_SERVER) {
                return ServerWorld.gameData.customCommandTypeList;
            }
            else {
                return Game.data.customCommandTypeList;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "customBehaviorTypeList", {
        get: function () {
            if (Config.IS_SERVER) {
                return ServerWorld.gameData.customBehaviorTypeList;
            }
            else {
                return Game.data.customBehaviorTypeList;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "customWorldData", {
        get: function () {
            if (Config.IS_SERVER) {
                return ServerWorld.gameData.customGameAttribute.worldAttributeSetting;
            }
            else {
                return Game.data.customGameAttribute.worldAttributeSetting;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "customPlayerData", {
        get: function () {
            if (Config.IS_SERVER) {
                return ServerWorld.gameData.customGameAttribute.playerAttributeSetting;
            }
            else {
                return Game.data.customGameAttribute.playerAttributeSetting;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "avatarList", {
        get: function () {
            return this.getNewestDBData(GameData.LIST_TYPE_AVATAR);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "standAvatarList", {
        get: function () {
            return this.getNewestDBData(GameData.LIST_TYPE_STANDING);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "commonEventList", {
        get: function () {
            return this.getNewestDBData(GameData.LIST_TYPE_COMMON_EVENT);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "dialogList", {
        get: function () {
            return this.getNewestDBData(GameData.LIST_TYPE_DIALOG);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "animationList", {
        get: function () {
            return this.getNewestDBData(GameData.LIST_TYPE_ANIMATION);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Common, "uiList", {
        get: function () {
            return this.getNewestDBData(GameData.LIST_TYPE_UI);
        },
        enumerable: false,
        configurable: true
    });
    Common.getGameDataAttrValue = function (attr) {
        if (Config.IS_SERVER) {
            return ServerWorld.gameData[attr];
        }
        else {
            return Game.data[attr];
        }
    };
    Common.getNewestDBData = function (attr) {
        if (Config.EDIT_MODE) {
            return Editor.data && Editor.data.dbData && Editor.data.dbData[attr] ? Editor.data.dbData[attr] : Game.data[attr];
        }
        else if (Config.IS_SERVER) {
            return ServerWorld.gameData[attr];
        }
        else {
            return Game.data[attr];
        }
    };
    Common.excludeTranslates = ['labelFont', 'font', 'FONTS', 'DEFAULT_FONT', "languages"];
    Common.otherTranslates = ['editorPreviewJS', 'jsCode', 'customPhraseDescJS', 'cmdPreviewJS', 'IMAGE_LAYER_DP_COORD_JS'];
    Common.systeamTranslates = {
        "信息": "[#GAME_INFORMATION]", "游戏进程": "[#GAME_THE_GAME_PROCESS]", "音频": "[#GAME_AUDIO]",
        "界面层": "[#GAME_INTERFACE]", "目标层": "[#GAME_THE_TARGET_LAYER]", "动画层": "[#GAME_THE_ANIMATION_LAYER]",
        "音效层": "[#GAME_SOUND_LAYER]"
    };
    return Common;
}());
var Config = (function () {
    function Config() {
    }
    Object.defineProperty(Config, "INDIA_APPLICATION_GAME_INFO", {
        get: function () {
            return Config.indiaApplicationGameInfo;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Config, "useNewSceneObjectModel", {
        get: function () {
            return ((Config.RELEASE_TEMPLATE_GC_VERSION && Config.RELEASE_TEMPLATE_GC_VERSION >= 0.984) || (Config.EDIT_MODE && !Config.BEHAVIOR_EDIT_MODE && !Config.RELEASE_MODE));
        },
        enumerable: false,
        configurable: true
    });
    Config.init = function () {
        var max = 4096;
        Config.IS_SERVER = Common.runPlatform != 2;
        Config.SCENE_GRID_SIZE = Math.min(max, Config.SCENE_GRID_SIZE);
        if (!Config.IS_SERVER) {
            if (!Config.EDIT_MODE && Config.DEFAULT_FONT) {
                Font.defaultFamily = Config.DEFAULT_FONT;
            }
            stage.on(EventObject.RESIZE, this, Config.refreshTileSplitSize, [false]);
            Config.refreshTileSplitSize(true);
        }
        if (!Config.EDIT_MODE && !Config.IS_SERVER) {
            Game.layer.refreshLayerSize();
        }
    };
    Config.refreshTileSplitSize = function (force) {
        if (force === void 0) { force = false; }
        if (!force && Config.TILE_SPLIT_SIZE_LOCK && Config.EDIT_MODE)
            return;
        var max = 4096;
        Config.TILE_SPLIT_SIZE = Math.floor(max / Config.SCENE_GRID_SIZE) * Config.SCENE_GRID_SIZE;
        var per = GameUtils.getAutoFitSizePre(new Rectangle(0, 0, Config.WINDOW_WIDTH, Config.WINDOW_HEIGHT), new Rectangle(0, 0, stage.width, stage.height));
        var displayWidth = Math.floor(Math.min(Config.WINDOW_WIDTH, Browser.width) * per);
        var displayHeight = Math.floor(Math.min(Config.WINDOW_HEIGHT, Browser.height) * per);
        if (Config.TILE_SPLIT_SIZE > displayWidth || Config.TILE_SPLIT_SIZE > displayHeight) {
            Config.TILE_SPLIT_SIZE = Math.min(displayWidth, displayHeight);
        }
        var p = 2;
        while (1) {
            p *= 2;
            if (p > Config.TILE_SPLIT_SIZE) {
                break;
            }
        }
        Config.TILE_SPLIT_SIZE = p / 2;
        if ((Config.TILE_SPLIT_SIZE / Config.SCENE_GRID_SIZE) != Math.floor(Config.TILE_SPLIT_SIZE / Config.SCENE_GRID_SIZE)) {
            var p = 1;
            while (1) {
                if (Config.SCENE_GRID_SIZE * p > Config.TILE_SPLIT_SIZE) {
                    Config.TILE_SPLIT_SIZE = Config.SCENE_GRID_SIZE * p;
                    break;
                }
                p++;
            }
        }
        while (Config.TILE_SPLIT_SIZE > os.canvas.width || Config.TILE_SPLIT_SIZE > os.canvas.height) {
            Config.TILE_SPLIT_SIZE /= 2;
        }
        if (Config.TILE_SPLIT_SIZE <= 0) {
            Config.TILE_SPLIT_SIZE = 512;
        }
    };
    Object.defineProperty(Config, "indiaApplicationGameInfo", {
        get: function () {
            if (Config.IS_SERVER)
                return null;
            if (window.location.href.indexOf("gcDebugPort=") == -1)
                return null;
            var params = window.location.href.split("?").pop();
            var paramsArr = params.split("&");
            var res = {};
            for (var i = 0; i < paramsArr.length; i++) {
                var pStr = paramsArr[i];
                var pStrArr = pStr.split("=");
                var pName = pStrArr[0];
                var pValue = pStrArr[1];
                res[pName] = pValue;
            }
            if (res.gcAppID == null || res.gcDebugPort == null)
                return null;
            return res;
        },
        enumerable: false,
        configurable: true
    });
    Config.USE_FN = true;
    Config.saveAttrs = ["verManager", "startupPreloadFonts", "FONTS", "EDITOR_MAG_FILTER", "IMAGE_LAYER_DP_COORD_JS", "IMAGE_LAYER_DP_COORD_TS",
        "CREATED_GC_VERSION", "RELEASE_TEMPLATE_GC_VERSION", "gameSID", "gameProjectName", "gameVersion", "fragmentFileVersion", "GAME_MAG_FILTER", "templateVersionID",
        "languages", "language", "GC_CLOUD_PLATFORM", "TEMPLETE_USER_UID", "AI_PAINTING_ID", "gridAlignMode", "z1"];
    Config.ENGINE_MERGE_STARTUP_FILE = true;
    Config.compatibleOldProgram = true;
    Config.JSON_PATH = "asset/json";
    Config.JSON_CONFIG = Config.JSON_PATH + "/config.json";
    Config.SCENE_BY_DRAWLINES_MAX = 500;
    Config.DATA_GRIDS = [];
    Config.FONTS = [];
    Config.startupPreloadFonts = true;
    Config.verManager = [];
    Config.languages = "简体中文,繁体中文,English";
    Config.language = 0;
    Config.AI_PAINTING_ID = 1;
    Config.gridAlignMode = 0;
    return Config;
}());
var IdentityObject = (function () {
    function IdentityObject() {
        this.id = ++IdentityObject.idCount;
    }
    IdentityObject.idCount = 0;
    return IdentityObject;
}());
var Player = (function () {
    function Player(dataCls) {
        if (dataCls === void 0) { dataCls = null; }
        if (dataCls)
            this.data = new dataCls();
        else {
            this.data = {};
        }
        ;
        if (Config.IS_SERVER) {
            this.variable = new Variable(this);
        }
        else {
            var accountInfo = LocalStorage.getJSON("gc_account");
            if (accountInfo) {
                this.uid = accountInfo.uid;
                this.gcToken = accountInfo.gcToken;
                this.gcNickName = accountInfo.gcNickName;
            }
        }
    }
    Player.prototype.toScene = function (sceneID, x, y, ori) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (ori === void 0) { ori = 0; }
    };
    Player.installCustomData = function (player) {
        var customGameAttribute = Common.customGameAttribute;
        var attrSettings = CustomCompositeSetting.getAllAttributes(customGameAttribute.playerAttributeSetting, false);
        CustomAttributeSetting.installAttributeFromEditorSet(player.data, customGameAttribute.playerAttributeConfig.attrs, attrSettings, false, false, GameData.CUSTOM_ATTR_PLAYER_DATA);
    };
    Player.installFilePlayerData = function (player, fileData) {
        Player.installCustomData(player);
        var fileSceneObjectData = fileData.sceneObject;
        delete fileData.sceneObject;
        var customGameAttribute = Common.customGameAttribute;
        var attrSettings = CustomCompositeSetting.getAllAttributes(customGameAttribute.playerAttributeSetting, false);
        CustomAttributeSetting.installAttributeFromRecordData(player.data, fileData, attrSettings, customGameAttribute.playerAttributeConfig.attrs, GameData.CUSTOM_ATTR_PLAYER_DATA);
        var modelData = Common.sceneObjectModelList.data[player.data.sceneObject.modelID];
        if (modelData) {
            if (Config.useNewSceneObjectModel) {
                var fixModelData = Common.sceneObjectModelList.data[0];
            }
            else {
                fixModelData = modelData;
            }
            CustomAttributeSetting.installAttributeFromRecordData(player.data.sceneObject, fileSceneObjectData, fixModelData.varAttributes, Config.BORN.customAttribute, GameData.CUSTOM_ATTR_SCENE_OBJECT_DATA);
        }
    };
    return Player;
}());















var CommandTrigger = (function (_super) {
    __extends(CommandTrigger, _super);
    function CommandTrigger(mainType, indexType, scene, trigger, multiline, executor) {
        var _this_1 = _super.call(this) || this;
        _this_1.commandScope = [];
        _this_1.behaviors = [];
        _this_1._delayPause = false;
        _this_1.inputMessage = [];
        _this_1.mainType = mainType;
        _this_1.indexType = indexType;
        _this_1.scene = scene;
        _this_1.trigger = trigger;
        _this_1.multiline = multiline;
        _this_1.executor = executor;
        trigger.triggerLines[_this_1.id] = _this_1;
        return _this_1;
    }
    Object.defineProperty(CommandTrigger.prototype, "delayPause", {
        get: function () {
            return this._delayPause;
        },
        set: function (v) {
            if (v == this._delayPause)
                return;
            this._delayPause = v;
            if (this.delayTime) {
                if (v) {
                    this.delayStopStartTime = new Date().getTime();
                }
                else {
                    var dt = new Date().getTime() - this.delayStopStartTime;
                    this.delayStartTime += dt;
                }
            }
        },
        enumerable: false,
        configurable: true
    });
    CommandTrigger.prototype.initFrom = function (cmdPage) {
        if (this.from != null)
            return;
        switch (this.mainType) {
            case CommandTrigger.COMMAND_MAIN_TYPE_SCENE_OBJECT:
                this.from = this.executor.index;
                return;
            case CommandTrigger.COMMAND_MAIN_TYPE_UI:
                var uiCustomCommandPages = Config.IS_SERVER ? ServerWorld.uiCustomCommandPages : ClientWorld.uiCustomCommandPages;
                for (var sid in uiCustomCommandPages) {
                    if (uiCustomCommandPages[sid][this.indexType] == cmdPage) {
                        this.from = sid;
                        return;
                    }
                }
        }
        this.from = this.indexType;
    };
    CommandTrigger.prototype.dispose = function () {
        if (this.lock || !this.trigger || !this.trigger.triggerLines)
            return;
        if (!this.isDisposed) {
            this.isDisposed = true;
            delete this.trigger.triggerLines[this.id];
            EventUtils.clear(this);
            if (!Config.IS_SERVER) {
                os.remove_ENTERFRAME(this.doWaitFrame, this);
                os.remove_ENTERFRAME(this.doWaitTime, this);
            }
        }
    };
    CommandTrigger.prototype.waitFrame = function (frame) {
        if (Config.IS_SERVER) {
            setFrameout(CommandPage.executeEvent, frame, this);
            return;
        }
        if (frame < 1)
            frame = 1;
        this.delayFrame = frame;
        os.add_ENTERFRAME(this.doWaitFrame, this);
    };
    CommandTrigger.prototype.doWaitFrame = function () {
        if (this.delayPause || this.lock)
            return;
        this.delayFrame--;
        if (this.delayFrame == 0) {
            os.remove_ENTERFRAME(this.doWaitFrame, this);
            CommandPage.executeEvent(this);
        }
    };
    CommandTrigger.prototype.waitTime = function (time) {
        if (Config.IS_SERVER) {
            setTimeout(CommandPage.executeEvent, time, this);
            return;
        }
        this.delayTime = time;
        this.delayStartTime = new Date().getTime();
        os.add_ENTERFRAME(this.doWaitTime, this);
    };
    CommandTrigger.prototype.doWaitTime = function () {
        if (this.delayPause || this.lock)
            return;
        var now = new Date().getTime();
        if (now - this.delayStartTime >= this.delayTime) {
            this.delayTime = 0;
            os.remove_ENTERFRAME(this.doWaitTime, this);
            CommandPage.executeEvent(this);
        }
    };
    Object.defineProperty(CommandTrigger.prototype, "triggerPlayer", {
        get: function () {
            return this.trigger ? (Config.IS_SERVER ? this.trigger.player : Game.player) : null;
        },
        enumerable: false,
        configurable: true
    });
    CommandTrigger.prototype.goto = function (index) {
        this.commandScope[this.commandScope.length - 1].index = index - 1;
    };
    CommandTrigger.prototype.offset = function (i) {
        this.commandScope[this.commandScope.length - 1].index += i;
    };
    CommandTrigger.prototype.end = function () {
        this.commandScope.pop();
    };
    CommandTrigger.prototype.addCommonEventCommandPageLayer = function (commonEventID) {
        if (Config.IS_SERVER) {
            var cmdPage = ServerWorld.commonEventPages[commonEventID];
        }
        else {
            cmdPage = ClientWorld.commonEventPages[commonEventID];
        }
        if (!cmdPage)
            return;
        this.commandScope.push({ cmdPage: cmdPage, index: 0, commonEventID: commonEventID, fragmentCommands: null });
    };
    CommandTrigger.prototype.addFragmentEventCommandPageLayer = function (feData) {
        var feFormatData = CommandPage.getFormatFeData(feData);
        if (feFormatData) {
            this.commandScope.push({ cmdPage: feFormatData.feCmdPage, index: 0, commonEventID: 0, fragmentCommands: feFormatData.feCommands });
        }
    };
    CommandTrigger.prototype.addBehavior = function (targetSo, behaviorData, loop, targetPlayerSceneObject, cover, startIndex, Immediate, forceStopLastBehavior, delayFrame, executor) {
        var _this_1 = this;
        if (startIndex === void 0) { startIndex = 0; }
        if (Immediate === void 0) { Immediate = true; }
        if (forceStopLastBehavior === void 0) { forceStopLastBehavior = false; }
        if (delayFrame === void 0) { delayFrame = 0; }
        if (executor === void 0) { executor = null; }
        var isOver = false;
        var soBehavior = targetSo.addBehavior(behaviorData, loop, targetPlayerSceneObject, Callback.New(function (targetSo) {
            isOver = true;
            _this_1.removeBehaviorCount(targetSo);
        }, this, [targetSo]), cover, startIndex, Immediate, forceStopLastBehavior, delayFrame, executor);
        if (cover)
            this.behaviors = ArrayUtils.matchAttributes(this.behaviors, { so: targetSo }, false, "!=");
        if (!isOver)
            this.behaviors.push({ so: targetSo, behavior: soBehavior });
    };
    CommandTrigger.prototype.removeBehaviorCount = function (targetSo) {
        var behaviorsInv = this.behaviors.concat().reverse();
        var lastIndex = ArrayUtils.matchAttributes(behaviorsInv, { so: targetSo }, true, "==", true)[0];
        if (lastIndex != -1) {
            lastIndex = this.behaviors.length - lastIndex - 1;
            this.behaviors.splice(lastIndex, 1);
        }
        if (this.behaviors.length == 0) {
            EventUtils.happen(this, CommandTrigger.EVENT_BEHAVIOR_OVER);
            if (this.continueWhenBehaviorOver && this.pause) {
                this.continueWhenBehaviorOver = false;
                CommandPage.executeEvent(this);
            }
        }
    };
    Object.defineProperty(CommandTrigger.prototype, "hasBehavior", {
        get: function () {
            return this.behaviors.length > 0;
        },
        enumerable: false,
        configurable: true
    });
    CommandTrigger.prototype.getSaveData = function () {
        var o = {};
        o.id = this.id;
        o.mainType = this.mainType;
        o.indexType = this.indexType;
        o.multiline = this.multiline;
        o.continueWhenBehaviorOver = this.continueWhenBehaviorOver;
        o.trigger = this.trigger.index;
        o.executor = this.executor.index;
        o.pause = this.pause;
        o.delayPause = this.delayPause;
        o.inputMessage = this.inputMessage;
        o.delayFrame = this.delayFrame;
        o.delayTime = this.delayTime;
        o.delayStartTime = this.delayStartTime;
        o.delayStopStartTime = this.delayStopStartTime;
        o.from = this.from;
        o.commandScope = [];
        for (var i = 0; i < this.commandScope.length; i++) {
            o.commandScope[i] = { index: this.commandScope[i].index, commonEventID: this.commandScope[i].commonEventID, fragmentCommands: this.commandScope[i].fragmentCommands };
        }
        o.behaviors = [];
        for (var i = 0; i < this.behaviors.length; i++) {
            var behavior = this.behaviors[i];
            var triggerIndex = behavior.behavior.targetSceneObject ? behavior.behavior.targetSceneObject.index : -1;
            var exectorIndex = behavior.behavior.executor ? behavior.behavior.executor.index : -1;
            o.behaviors[i] = { soIndex: behavior.so.index, triggerIndex: triggerIndex, exectorIndex: exectorIndex, behaviorIndex: behavior.so.getBehaviorIndex(behavior.behavior), behaviorData: behavior.behavior.getSaveData() };
        }
        return o;
    };
    CommandTrigger.prototype.recoverySaveData = function (o, scene, commonEventPages, intervalTime) {
        this.mainType = o.mainType;
        this.indexType = o.indexType;
        this.multiline = o.multiline;
        this.pause = o.pause;
        this.delayPause = o.delayPause;
        this.inputMessage = o.inputMessage;
        this.continueWhenBehaviorOver = o.continueWhenBehaviorOver;
        this.commandScope = [];
        this.from = o.from;
        for (var i = 0; i < o.commandScope.length; i++) {
            var scope = o.commandScope[i];
            if (i == 0) {
                var cmdPage;
                if (this.mainType == CommandTrigger.COMMAND_MAIN_TYPE_SCENE) {
                    cmdPage = scene.customCommandPages[this.indexType];
                }
                else if (this.mainType == CommandTrigger.COMMAND_MAIN_TYPE_SCENE_OBJECT) {
                    cmdPage = this.executor.customCommandPages[this.indexType];
                }
                else if (this.mainType == CommandTrigger.COMMAND_MAIN_TYPE_UI) {
                    var uiCustomCommandPagesFrom = ClientWorld.uiCustomCommandPages[this.from];
                    if (uiCustomCommandPagesFrom) {
                        cmdPage = uiCustomCommandPagesFrom[this.indexType];
                    }
                }
                else if (this.mainType == CommandTrigger.COMMAND_MAIN_TYPE_CALL_COMMON_EVENT) {
                    cmdPage = commonEventPages[this.from];
                }
                else if (this.mainType == CommandTrigger.COMMAND_MAIN_TYPE_FRAGMENT_EVENT) {
                    cmdPage = new CommandPage(scope.fragmentCommands);
                }
                if (!cmdPage)
                    return false;
                this.commandScope.push({ cmdPage: cmdPage, index: scope.index, commonEventID: scope.commonEventID, fragmentCommands: scope.fragmentCommands });
            }
            else {
                if (scope.fragmentCommands) {
                    cmdPage = new CommandPage(scope.fragmentCommands);
                }
                else {
                    cmdPage = commonEventPages[scope.commonEventID];
                }
                if (!cmdPage)
                    return false;
                this.commandScope.push({ cmdPage: cmdPage, index: scope.index, commonEventID: scope.commonEventID, fragmentCommands: scope.fragmentCommands });
            }
        }
        this.delayFrame = o.delayFrame;
        this.delayTime = o.delayTime;
        this.delayStartTime = o.delayStartTime + intervalTime;
        this.delayStopStartTime = o.delayStopStartTime + intervalTime;
        if (this.delayFrame) {
            os.add_ENTERFRAME(this.doWaitFrame, this);
        }
        else if (this.delayTime) {
            os.add_ENTERFRAME(this.doWaitTime, this);
        }
        return true;
    };
    CommandTrigger.prototype.recovery = function () {
        this.isExecuteing = true;
        if (!this.pause) {
            CommandPage.executeEvent(this, this.inputMessage);
        }
        else {
        }
    };
    CommandTrigger.EVENT_START = "CommandTrigger_EVENT_START_TRIGGER";
    CommandTrigger.EVENT_OVER = "CommandTrigger_EVENT_OVER";
    CommandTrigger.EVENT_BEHAVIOR_OVER = "CommandTrigger_EVENT_BEHAVIOR_OVER";
    CommandTrigger.COMMAND_MAIN_TYPE_SCENE = 0;
    CommandTrigger.COMMAND_MAIN_TYPE_SCENE_OBJECT = 1;
    CommandTrigger.COMMAND_MAIN_TYPE_UI = 2;
    CommandTrigger.COMMAND_MAIN_TYPE_CALL_COMMON_EVENT = 3;
    CommandTrigger.COMMAND_MAIN_TYPE_FRAGMENT_EVENT = 4;
    return CommandTrigger;
}(IdentityObject));















var AIPaintingCustomData = (function (_super) {
    __extends(AIPaintingCustomData, _super);
    function AIPaintingCustomData() {
        var _this_1 = _super !== null && _super.apply(this, arguments) || this;
        _this_1.name = null;
        _this_1.features = 0;
        _this_1.defaultDes = '';
        _this_1.maxHeight = 512;
        _this_1.minHeight = 64;
        _this_1.maxWidth = 512;
        _this_1.minWidth = 64;
        _this_1.allowDel = false;
        _this_1.saveInfo = mainDomain_gcide.LanguageManager.parseIDE("[#GAME_STORE_IMAGE_TO]") + "${url}";
        return _this_1;
    }
    AIPaintingCustomData.replacePlaceholder = function (str, values) {
        return Object.entries(values).reduce(function (result, _b) {
            var key = _b[0], value = _b[1];
            return result.replace(new RegExp("\\$\\{" + key + "\\}", "g"), value);
        }, str);
    };
    ;
    return AIPaintingCustomData;
}(OriginalData));















var AnimationData = (function (_super) {
    __extends(AnimationData, _super);
    function AnimationData() {
        var _this_1 = _super !== null && _super.apply(this, arguments) || this;
        _this_1.totalFrame = 0;
        _this_1.imageSources = [null];
        _this_1.layers = [];
        _this_1.isParticle = false;
        return _this_1;
    }
    AnimationData.getAllLayers = function (data) {
        var layers = data.layers.concat();
        var index = 0;
        while (index < layers.length) {
            layers = layers.concat(layers[index].children);
            index++;
        }
        return layers;
    };
    AnimationData.isEmpty = function (data) {
        var aniName = GameListData.getName(Game.data.animationList, data.id, true);
        if (aniName)
            return false;
        return (data.totalFrame == 0 && data.imageSources.length == 1 && data.imageSources[0] == null && data.layers.length == 0 && !data.isParticle && data.particleData == null);
    };
    return AnimationData;
}(OriginalData));
var AnimationItemType;
(function (AnimationItemType) {
    AnimationItemType[AnimationItemType["Target"] = 0] = "Target";
    AnimationItemType[AnimationItemType["Image"] = 1] = "Image";
    AnimationItemType[AnimationItemType["GCAnimation"] = 2] = "GCAnimation";
    AnimationItemType[AnimationItemType["Audio"] = 3] = "Audio";
    AnimationItemType[AnimationItemType["RefObj"] = 4] = "RefObj";
})(AnimationItemType || (AnimationItemType = {}));















var AutoTileData = (function (_super) {
    __extends(AutoTileData, _super);
    function AutoTileData() {
        var _this_1 = _super !== null && _super.apply(this, arguments) || this;
        _this_1.url = "";
        _this_1.dataLayers = [];
        _this_1.GCATMode = 0;
        return _this_1;
    }
    AutoTileData.getAutoTileData = function (texID) {
        return Game.data.autoTileList.data[texID];
    };
    AutoTileData.isEmpty = function (data, plugType) {
        var tileName = GameListData.getName(Game.data.autoTileList, data.id, true);
        if (tileName)
            return false;
        return !data.url;
    };
    return AutoTileData;
}(OriginalData));















var AvatarData = (function (_super) {
    __extends(AvatarData, _super);
    function AvatarData() {
        var _this_1 = _super !== null && _super.apply(this, arguments) || this;
        _this_1.picUrls = ["editorAsset/img/empty.png"];
        _this_1.oriMode = 4;
        _this_1.autoFlip = true;
        _this_1.refObjs = {};
        _this_1.helperSetting = {};
        _this_1.helperType = 0;
        _this_1.referenceMode = false;
        _this_1.referenceID = 1;
        _this_1.parts = [{ id: 0, showOnEditor: true, mouseEventEnabledInEditor: true }];
        _this_1.actionListArr = [{
                id: 1,
                frameImageInfo: []
            }];
        return _this_1;
    }
    AvatarData.isEmpty = function (data, plugType) {
        if (plugType == 0) {
            var avatarName = GameListData.getName(Game.data.avatarList, data.id, true);
            if (avatarName)
                return false;
        }
        else {
            var standAvatarName = GameListData.getName(Game.data.standingList, data.id, true);
            if (standAvatarName)
                return false;
        }
        return ((data.actionListArr.length == 0) || (data.actionListArr.length == 1 && data.actionListArr[0].frameImageInfo.length == 0))
            && data.parts.length == 1 && data.picUrls.length == 1 && data.picUrls[0] == "editorAsset/img/empty.png";
    };
    return AvatarData;
}(OriginalData));















var AvatarRefObjData = (function (_super) {
    __extends(AvatarRefObjData, _super);
    function AvatarRefObjData() {
        var _this_1 = _super !== null && _super.apply(this, arguments) || this;
        _this_1.color = "#FFFFFF";
        _this_1.line = true;
        return _this_1;
    }
    return AvatarRefObjData;
}(OriginalData));















var CommonEventData = (function (_super) {
    __extends(CommonEventData, _super);
    function CommonEventData() {
        var _this_1 = _super !== null && _super.apply(this, arguments) || this;
        _this_1.allowClient = false;
        _this_1.conditionSwitch = 1;
        _this_1.updateMode = false;
        _this_1.commands = [];
        return _this_1;
    }
    return CommonEventData;
}(OriginalData));















var CustomCompositeSetting = (function (_super) {
    __extends(CustomCompositeSetting, _super);
    function CustomCompositeSetting() {
        var _this_1 = _super !== null && _super.apply(this, arguments) || this;
        _this_1.compAutoOrderLimitHeight = 0;
        return _this_1;
    }
    CustomCompositeSetting.isEmpty = function (data, plugType) {
        var list = {
            9: Game.data.customModuleList, 10: Game.data.dataStructureList, 11: Game.data.customBehaviorTypeList,
            12: Game.data.customCommandTypeList, 13: Game.data.customConditionList, 16: Game.data.customDataDisplayList,
            20: Game.data.materialList, 21: Game.data.customGameStringList
        };
        var dataName = GameListData.getName(list[plugType], data.id);
        if (dataName)
            return false;
        return data.blockList.length == 1 && CustomCompositeBlock.isEmpty(data.blockList[0]);
    };
    CustomCompositeSetting.init = function (data) {
        var block = new CustomCompositeBlock();
        CustomCompositeBlock.init(block);
        data.blockList = [block];
    };
    CustomCompositeSetting.runCode = function (gameData) {
        CustomCompositeSetting.runCodeByList(gameData.dataStructureList, 0, gameData);
        CustomCompositeSetting.runCodeByList(gameData.customModuleList, 1, gameData);
        CustomCompositeSetting.runWorldData();
        CustomCompositeSetting.runCodeByItem(gameData.customGameAttribute.playerAttributeSetting, 3, gameData);
        CustomCompositeSetting.createPresetCustomModuleDatas();
    };
    CustomCompositeSetting.runCodeByList = function (list, mode, gameData) {
        var dsItems = GameListData.getItems(list);
        for (var i in dsItems) {
            var dsItem = dsItems[i];
            CustomCompositeSetting.runCodeByItem(dsItem, mode, gameData);
        }
    };
    CustomCompositeSetting.createPresetCustomModuleDatas = function () {
        var customModuleList = Common.customModuleList;
        for (var i in customModuleList.data) {
            var moduleIndex = parseInt(i);
            var cmSetting = customModuleList.data[moduleIndex];
            if (cmSetting) {
                var singleModuleDataArr = GameData.customModulePresetDatas[moduleIndex] = [];
                var moduleDataList = Common.getCustomModuleDataList(moduleIndex);
                if (!moduleDataList)
                    continue;
                var cmDatas = moduleDataList.data;
                var attrSettings = CustomCompositeSetting.getAllAttributes(cmSetting, false);
                for (var s in cmDatas) {
                    var dataID = parseInt(s);
                    var cmData = cmDatas[dataID];
                    if (cmData) {
                        var cmObj = {};
                        cmObj.id = dataID;
                        cmObj.name = GameListData.getName(moduleDataList, dataID);
                        singleModuleDataArr[dataID] = cmObj;
                        CustomAttributeSetting.installAttributeFromEditorSet(cmObj, cmData.attrs, attrSettings, true, !Config.IS_SERVER);
                    }
                }
            }
        }
    };
    CustomCompositeSetting.runCodeByItem = function (dsItem, mode, gameData) {
        var attrs = CustomCompositeSetting.getAllAttributes(dsItem, false);
        var classVarName = this.getVarTypeInEditorCode(mode, dsItem.id);
        if (classVarName == "any")
            return;
        var vars = "";
        var dsCls = "var " + classVarName + " = function(){" + vars;
        for (var i in attrs) {
            var attr = attrs[i];
            if (!Config.IS_SERVER && attr.accessMode == 0)
                continue;
            if (attr.arrayMode) {
                dsCls += "this." + attr.varName + " = [];";
            }
            else {
                if (attr.defaultValue) {
                    if (attr.varType == 0) {
                        dsCls += "this." + attr.varName + " = " + MathUtils.float(attr.defaultValue) + ";";
                    }
                    else if (attr.varType == 1) {
                        if (attr.defaultValue.length >= 2 && attr.defaultValue[0] == "\"" && attr.defaultValue[attr.defaultValue.length - 1] == "\"") {
                            dsCls += "this." + attr.varName + " = " + attr.defaultValue + ";";
                        }
                        else {
                            dsCls += "this." + attr.varName + " = \"" + attr.defaultValue + "\";";
                        }
                    }
                    else if (attr.varType == 2) {
                        dsCls += "this." + attr.varName + " = " + (attr.defaultValue ? "true" : "false") + ";";
                    }
                }
                if (attr.varType == 3) {
                    if (gameData.dataStructureList.data[attr.dataStructureID]) {
                        if (attr.onlyPointTo) {
                            dsCls += "this." + attr.varName + " = " + attr.dataStructureID + ";";
                        }
                        else {
                            var dataStructureCls = this.getVarTypeInEditorCode(0, attr.dataStructureID);
                            if (dataStructureCls != "any")
                                dsCls += "this." + attr.varName + " = new " + dataStructureCls + ";";
                        }
                    }
                }
                else if (attr.varType == 4) {
                    if (gameData.customModuleList.data[attr.moduleID]) {
                        if (attr.onlyPointTo) {
                            dsCls += "this." + attr.varName + " = " + attr.moduleID + ";this." + attr.varName + ".name = \"\";";
                        }
                        else {
                            var customCls = this.getVarTypeInEditorCode(1, attr.moduleID);
                            if (customCls != "any") {
                                dsCls += "this." + attr.varName + " = new " + customCls + ";this." + attr.varName + ".name = \"\";";
                            }
                        }
                    }
                }
            }
        }
        dsCls += "}";
        globalThis.eval(dsCls);
    };
    CustomCompositeSetting.runWorldData = function () {
        var customGameAttribute = Common.customGameAttribute;
        globalThis.WorldData = {};
        var attrSettings = CustomCompositeSetting.getAllAttributes(customGameAttribute.worldAttributeSetting, false);
        CustomAttributeSetting.installAttributeFromEditorSet(globalThis.WorldData, customGameAttribute.worldAttributeConfig.attrs, attrSettings, false, !Config.IS_SERVER, GameData.CUSTOM_ATTR_WORLD_DATA);
        if (!Config.EDIT_MODE) {
            if (Config.IS_SERVER) {
                ServerWorld.data = globalThis.WorldData;
                CustomAttributeSetting.installAttributeFromRecordData(ServerWorld.data, ServerSql.recordWorldData, attrSettings, customGameAttribute.worldAttributeConfig.attrs, GameData.CUSTOM_ATTR_WORLD_DATA);
                ServerSql.recordWorldData = null;
            }
            else {
                ClientWorld.data = globalThis.WorldData;
            }
        }
    };
    CustomCompositeSetting.getAllAttributes = function (data, dsAttrMode, varInBlockMapping) {
        if (dsAttrMode === void 0) { dsAttrMode = true; }
        if (varInBlockMapping === void 0) { varInBlockMapping = null; }
        if (data == null || !data.blockList) {
            return [];
        }
        var len = data.blockList.length;
        var arr = [];
        for (var i = 0; i < len; i++) {
            var block = data.blockList[i];
            var aLen = block.blockAttrs.length;
            for (var s = 0; s < aLen; s++) {
                var ca = block.blockAttrs[s];
                if (varInBlockMapping)
                    varInBlockMapping[ca.attr.varName] = block;
                if (dsAttrMode) {
                    arr.push(ca);
                }
                else {
                    arr.push(ca.attr);
                }
            }
        }
        return arr;
    };
    CustomCompositeSetting.getIDValue = function (varNameValue, setting) {
        var idValue = {};
        var attrSettings = CustomCompositeSetting.getAllAttributes(setting, false);
        for (var s = 0; s < attrSettings.length; s++) {
            var mAttr = attrSettings[s];
            if (!mAttr)
                continue;
            var value = varNameValue[mAttr.varName];
            idValue[mAttr.id] = value;
        }
        return idValue;
    };
    CustomCompositeSetting.getAllAPIRunetime = function (mode, limitJurisdiction, needCreateComboboxItemAPI) {
        if (limitJurisdiction === void 0) { limitJurisdiction = false; }
        if (needCreateComboboxItemAPI === void 0) { needCreateComboboxItemAPI = false; }
        if (mode == 0 || mode == 1 || mode == 4) {
            var lists = [Common.dataStructureList, Common.customModuleList, null, null, null];
            var nameHeads = ["DataStructure", "Module", null, null, "SceneModel"];
            var list = lists[mode];
            var datas = GameListData.getItems(list);
            var runtimeStr = "";
            var len = datas.length;
            for (var i = 0; i < len; i++) {
                var data = datas[i];
                if (mode == 0 || mode == 1) {
                    if (!data.varName)
                        continue;
                }
                runtimeStr += this.getAPIRuntime(mode, data, limitJurisdiction, false, needCreateComboboxItemAPI);
                if (i != len - 1)
                    runtimeStr += "\n";
            }
            return runtimeStr;
        }
        else if (mode == 2) {
            return this.getAPIRuntime(mode, Common.customGameAttribute.worldAttributeSetting, limitJurisdiction, true);
        }
        else if (mode == 3) {
            return this.getAPIRuntime(mode, Common.customGameAttribute.playerAttributeSetting, limitJurisdiction);
        }
        return "";
    };
    CustomCompositeSetting.getAPIRuntime = function (mode, cSetting, limitJurisdiction, isStatic, needCreateComboboxItemAPI) {
        if (limitJurisdiction === void 0) { limitJurisdiction = false; }
        if (isStatic === void 0) { isStatic = false; }
        if (needCreateComboboxItemAPI === void 0) { needCreateComboboxItemAPI = false; }
        var attrs = CustomCompositeSetting.getAllAttributes(cSetting, false);
        var len = attrs.length;
        var className = this.getVarTypeInEditorCode(mode, cSetting.id);
        if (className == "any")
            return "";
        var dataName;
        if (mode == 0) {
            dataName = GameListData.getName(Common.dataStructureList, cSetting.id);
        }
        else if (mode == 1) {
            dataName = GameListData.getName(Common.customModuleList, cSetting.id);
        }
        else {
            dataName = "";
        }
        var runtimeStr = (cSetting.id ? "/**\n * #" + cSetting.id + " " + dataName + "\n */\n" : "") + "class " + className + " {\n";
        if (mode == 1) {
            runtimeStr += "    id: number;\n    name: string;\n";
        }
        else if (mode == 3) {
            runtimeStr += "    sceneObject: SceneObject;\n";
        }
        for (var i = 0; i < len; i++) {
            var attr = attrs[i];
            if (CustomAttributeSetting.ONLY_DISPLAY.indexOf(attr.compData.compType) != -1)
                continue;
            if (!limitJurisdiction || attr.accessMode != 0) {
                var varStr = CustomAttributeSetting.getAPIRuntime(attr, isStatic, needCreateComboboxItemAPI);
                runtimeStr += "    " + varStr;
                runtimeStr += "\n";
            }
        }
        runtimeStr += "}";
        return runtimeStr;
    };
    CustomCompositeSetting.getCustomCommandBehaviorParamsAPI = function () {
        var api1 = this.getCustomParamsAPIBy(Common.customCommandTypeList, "[#GAME_CUSTOM_COMMANDS]", "CustomCommandParams");
        return api1;
    };
    CustomCompositeSetting.getCustomConditionParamsAPI = function () {
        var api1 = this.getCustomParamsAPIBy(Game.data.customConditionList, "[#GAME_CUSTOM_CONDITIONS]", "CustomConditionParams");
        return api1;
    };
    CustomCompositeSetting.getCustomDataDisplayParamsAPI = function () {
        var api1 = this.getCustomParamsAPIBy(Game.data.customDataDisplayList, "[#GAME_CUSTOMIZE_GAME_VALUES]", "CustomGameNumberParams");
        return api1;
    };
    CustomCompositeSetting.getCustomGameStringParamsAPI = function () {
        var api1 = this.getCustomParamsAPIBy(Game.data.customGameStringList, "[#GAME_CUSTOM_GAME_STRINGS]", "CustomGameStringParams");
        return api1;
    };
    CustomCompositeSetting.getCustomParamsAPIBy = function (customList, codePrompt, className) {
        if (GameListData.getAllLength(customList) == 0)
            return "";
        var tips = mainDomain_gcide.LanguageManager.parseIDE("[#GAME_SYSTEM_GENERATED_FILES_BY_GAMECREATOR]");
        codePrompt = mainDomain_gcide.LanguageManager.parseIDE(codePrompt);
        var apis = "/**\n * " + tips + "\n */\n";
        for (var i = 1; i <= 16; i++) {
            var dataLen = GameListData.getLength(customList, i);
            for (var s = 1; s <= dataLen; s++) {
                var id = GameListData.getID(i, s);
                var name = GameListData.getName(customList, id);
                var customCommandTypeData = customList.data[id];
                if (customCommandTypeData) {
                    apis += "/**\n* " + codePrompt + " " + id + "-" + name + "\n*/\n";
                    apis += "class " + className + "_" + id + " {\n";
                    var attrs = CustomCompositeSetting.getAllAttributes(customCommandTypeData, false);
                    for (var p = 0; p < attrs.length; p++) {
                        var cusAttr = attrs[p];
                        if (CustomAttributeSetting.ONLY_DISPLAY.indexOf(cusAttr.compData.compType) != -1)
                            continue;
                        apis += "    " + CustomAttributeSetting.getAPIRuntime(cusAttr) + "\n";
                    }
                    apis += "}\n";
                }
            }
        }
        return apis;
    };
    CustomCompositeSetting.getCustomParamsAPIOneInstance = function (instanceName, ccAttr, classMode) {
        if (classMode === void 0) { classMode = false; }
        if (classMode) {
            var varHeadStr = "class " + instanceName;
            var apis = varHeadStr + " {\n";
        }
        else {
            var varHeadStr = "var " + instanceName;
            var apis = varHeadStr + ": {\n";
        }
        var attrs = CustomCompositeSetting.getAllAttributes(ccAttr, false);
        for (var p = 0; p < attrs.length; p++) {
            var cusAttr = attrs[p];
            if (CustomAttributeSetting.ONLY_DISPLAY.indexOf(cusAttr.compData.compType) != -1)
                continue;
            apis += "    " + CustomAttributeSetting.getAPIRuntime(cusAttr, false, true) + "\n";
        }
        apis += "}";
        return apis;
    };
    CustomCompositeSetting.getPerShaderVar = function (ccAttr) {
        var attrs = CustomCompositeSetting.getAllAttributes(ccAttr, false);
        var str = "var sp:GameSprite; // \u4F7F\u7528\u8BE5\u6750\u8D28\u7684\u663E\u793A\u5BF9\u8C61\nvar shader: {\n";
        for (var p = 0; p < attrs.length; p++) {
            var cusAttr = attrs[p];
            if (CustomAttributeSetting.ONLY_DISPLAY.indexOf(cusAttr.compData.compType) != -1)
                continue;
            if (CustomAttributeSetting.isHideComp(cusAttr) || cusAttr.useCommand)
                continue;
            if (cusAttr.varType >= 3)
                continue;
            var tsType = CustomAttributeSetting.getPreShaderTSType(cusAttr);
            if (!tsType)
                continue;
            var varName = " mu" + ccAttr.id + "_" + cusAttr.varName + ": " + tsType;
            if (p != attrs.length - 1) {
                varName += ",";
            }
            var varDesc = "";
            if (cusAttr.alias)
                varDesc += " " + cusAttr.alias;
            if (cusAttr.attrTips)
                varDesc += " " + cusAttr.attrTips;
            if (varDesc) {
                varName += " //" + varDesc;
            }
            str += varName + "\n";
        }
        str += "}";
        return str;
    };
    CustomCompositeSetting.getShaderUniformCodes = function (ccAttr, isNote) {
        if (isNote === void 0) { isNote = false; }
        var attrs = CustomCompositeSetting.getAllAttributes(ccAttr, false);
        var customUniformsNotes = "";
        for (var p = 0; p < attrs.length; p++) {
            var cusAttr = attrs[p];
            if (CustomAttributeSetting.ONLY_DISPLAY.indexOf(cusAttr.compData.compType) != -1)
                continue;
            if (CustomAttributeSetting.isHideComp(cusAttr) || cusAttr.useCommand)
                continue;
            if (cusAttr.varType >= 3)
                continue;
            var uniformType = CustomAttributeSetting.getShaderUniformType(cusAttr);
            if (!uniformType)
                continue;
            var varName = " mu" + ccAttr.id + "_" + cusAttr.varName;
            varName += ";";
            var varDesc = "";
            if (isNote) {
                varDesc += " MU" + ccAttr.id + "_" + cusAttr.varName;
                if (cusAttr.alias)
                    varDesc += " " + cusAttr.alias;
                if (cusAttr.attrTips)
                    varDesc += " " + cusAttr.attrTips;
                varDesc = " //" + varDesc;
            }
            customUniformsNotes += "\n" + (isNote ? "// " : "") + "uniform " + uniformType + varName + varDesc;
            if (uniformType == "sampler2D") {
                customUniformsNotes += "\n" + (isNote ? "// " : "") + "uniform vec4 mu" + ccAttr.id + "_" + cusAttr.varName + "_UVInfo;";
                if (isNote) {
                    customUniformsNotes += " // mu" + ccAttr.id + "_" + cusAttr.varName + "\u8D34\u56FE\u7684\u539F\u59CB\u5750\u6807\u4FE1\u606F\uFF0C\u83B7\u53D6\u6E32\u67D3\u5750\u6807\uFF1Avec2 a = getDrawUV(v_texcoord,mu" + ccAttr.id + "_" + cusAttr.varName + "_UVInfo);";
                }
            }
        }
        if (ccAttr.shaderSize) {
            customUniformsNotes += "\n// uniform vec2 renderTargetSize; // \u6E32\u67D3\u5BF9\u8C61\u5C3A\u5BF8\u4FE1\u606F x=\u5BBD\u5EA6 y=\u9AD8\u5EA6";
        }
        return customUniformsNotes;
    };
    CustomCompositeSetting.getShaderNotes = function (ccAttr) {
        var customUniformsNotes = this.getShaderUniformCodes(ccAttr, true);
        var uniformTime = "";
        var tips = [mainDomain_gcide.LanguageManager.parseIDE("[#GAME_FRAME_BY_FRAME_INCREMENT_1]"), mainDomain_gcide.LanguageManager.parseIDE("[#GAME_THIS_COMMENT_IS_AUTOMATICALLY_GENERRATED_BY_THE_SYSTEM_PLEASE_DO_NOT_DELETE]"),
            mainDomain_gcide.LanguageManager.parseIDE("[#GAME_FIXED_PARAMETERS]"), mainDomain_gcide.LanguageManager.parseIDE("[#GAME_ORIGINAL_MAPPING_UV_COORDINATES]"),
            mainDomain_gcide.LanguageManager.parseIDE("[#GAME_ORIGINAL_MAPPING]"), mainDomain_gcide.LanguageManager.parseIDE("[#GAME_TRANSPARENCY_OF_THE_ACTUAL_RENDERING_OF_THE_CURRENT_OBJECT]"),
            mainDomain_gcide.LanguageManager.parseIDE("[#GAME_CUSTOM_PARAMETERS+FOR_THIS_MATERIAL_MACRO_TO_DETERMINE_THE_EXISTENCE_OF_THIS_VARIABLE]"), mainDomain_gcide.LanguageManager.parseIDE("[#GAME_CODE_RULES]"),
            mainDomain_gcide.LanguageManager.parseIDE("[#GAME_DUE_TO_THE_MULTI_MATERIAL_MERGE_SHADER_CODE_RUN]"), mainDomain_gcide.LanguageManager.parseIDE("[#GAME_ENTRY_FUNCTION_VEC4_MF_MATERIAL_ID_MAIN_AS]"),
            mainDomain_gcide.LanguageManager.parseIDE("[#GAME_ORIGINAL_MAP_SAMPLING_COORDINTES_ARE_OBTAINED]"), mainDomain_gcide.LanguageManager.parseIDE("[#GAME_ORIFINAL_IMAGE_SAMPLING]"),
            mainDomain_gcide.LanguageManager.parseIDE("[#GAME_INFORMTION_ABOUT_THE_COORDINATES_OF_THE_CUSTOM_MAPPING_THE_CUSTOM_MAPPING_MAY_BE_PART_OF_THE_ATLAS]"), mainDomain_gcide.LanguageManager.parseIDE("[#GAME_THE_COORDINATE_SYSTEM_RELATIVE_TO_PROVIDES_MAPPING_INFORMATION_FOR_THE_ATLAS_VEC4]"),
            mainDomain_gcide.LanguageManager.parseIDE("[#GAME_VARIABLE_MACROS_CAN_BE_USED_TO_DETERMINE_IF_THE_VARIABLE_MEETS_THE_OCCURRENCE_VONDITIONS]"), mainDomain_gcide.LanguageManager.parseIDE("[#GAME_SYSTEM_MACRO_IN_GC_EDITOR_WHETHER_TO_RUN_IN_THE_EDITOR]"),
            mainDomain_gcide.LanguageManager.parseIDE("[#GAME_SYNTAX_C_FOR_MORE_INFORMATION_PLEASE_REFER_TO_GLSL_SHADER]")];
        if (ccAttr.shaderTime) {
            uniformTime = "\n// uniform float time; // " + tips[0];
        }
        var notes = "//======================================================================================================\n// SYSTEM START " + tips[1] + "\n//======================================================================================================\n//------------------------------------------------------------------------------------------------------\n// " + tips[2] + "\n//------------------------------------------------------------------------------------------------------\n// varying vec2 v_texcoord; //  " + tips[3] + "\n// uniform sampler2D texture; // " + tips[4] + "\n// uniform float alpha; // " + tips[5] + uniformTime + "\n//------------------------------------------------------------------------------------------------------\n// " + tips[6] + "\n//------------------------------------------------------------------------------------------------------" + customUniformsNotes + "\n//------------------------------------------------------------------------------------------------------\n// shader " + tips[7] + "\n// 1." + tips[8] + " mf" + ccAttr.id + "_myFunc\n// 2." + tips[9] + " vec4 mf" + ccAttr.id + "_main(){return gl_FragColor;}\n// 3." + tips[10] + "vec2 texCoord = getInRangeTextureCoord(v_texcoord);\n// 4." + tips[11] + "vec4 color = getTextureColor(texCoord);\n// 5." + tips[12] + "\n//   " + tips[13] + "\n// 6." + tips[14] + "\n// 7." + tips[15] + "\n// 8." + tips[16] + "\n//======================================================================================================\n// SYSTEM END\n//======================================================================================================\n";
        return notes;
    };
    CustomCompositeSetting.replaceShaderNotes = function (ccAttr, shaderCode, replaceNewCode) {
        if (replaceNewCode === void 0) { replaceNewCode = null; }
        var noteStart = shaderCode.indexOf("//======================================================================================================\n// SYSTEM START");
        var endStr = "SYSTEM END\n//======================================================================================================\n";
        var nodeEnd = shaderCode.indexOf(endStr);
        var needReplace = true;
        if (noteStart == -1 || nodeEnd == -1) {
            needReplace = false;
        }
        if (replaceNewCode == null) {
            replaceNewCode = this.getShaderNotes(ccAttr);
        }
        if (needReplace) {
            var oldStr = shaderCode.substr(noteStart, nodeEnd - noteStart + endStr.length);
            shaderCode = shaderCode.replace(oldStr, replaceNewCode);
        }
        else {
            shaderCode = replaceNewCode + "";
        }
        return shaderCode;
    };
    CustomCompositeSetting.getShaderDataRuntimes = function () {
        var materialList = Game.data.materialList;
        var len = GameListData.getLength(materialList, 1);
        if (len == 0)
            return "";
        var tips = [mainDomain_gcide.LanguageManager.parseIDE("[#GAME_SYSTEM_GENERATED_FILES_BY_GAMECREATOR]"), mainDomain_gcide.LanguageManager.parseIDE("[#GAME_MATERIAL_BASE_DATA]"),
            mainDomain_gcide.LanguageManager.parseIDE("[#GAME_MATERIAL_ID]"), mainDomain_gcide.LanguageManager.parseIDE("[#GAME_IS_ENABLE]"),
            mainDomain_gcide.LanguageManager.parseIDE("[#GAME_STORE_THE_CURRENT_TIME_FRAME_INFORMATION_OF_THE_TRANSITION]"), mainDomain_gcide.LanguageManager.parseIDE("[#GAME_THE_MATERIAL]")];
        var str = "/**\n * " + tips[0] + "\n */\n/**\n * " + tips[1] + "\n */\nclass MaterialData {\n    id: number; // " + tips[2] + "\n    enable: boolean;//" + tips[3] + "\n    ____timeInfo: {[varName:string]: number} = {}; // " + tips[4] + "\n}\n";
        for (var i = 1; i <= len; i++) {
            var materiaSetting = materialList.data[i];
            var attrs = CustomCompositeSetting.getAllAttributes(materiaSetting, false);
            var varStrs = ["    id: number = " + i + ";"];
            for (var s = 0; s < attrs.length; s++) {
                var attr = attrs[s];
                if (CustomAttributeSetting.isHideComp(attr) || (CustomAttributeSetting.ONLY_DISPLAY.indexOf(attr.compData.compType) != -1))
                    continue;
                var attrTSType = CustomAttributeSetting.getShaderTSType(attr);
                if (!attrTSType) {
                    if (attr.varType == 0)
                        attrTSType = "number";
                    else if (attr.varType == 1)
                        attrTSType = "string";
                    else if (attr.varType == 2)
                        attrTSType = "boolean";
                    else
                        continue;
                }
                var defaultValueStr;
                if (attr.varType == 0 && attr.defaultValue) {
                    defaultValueStr = " = " + MathUtils.float(attr.defaultValue);
                }
                else if (attr.varType == 1) {
                    defaultValueStr = " = \"" + attr.defaultValue + "\"";
                }
                else if (attr.varType == 2 && attr.defaultValue) {
                    defaultValueStr = " = " + (attr.defaultValue == "true" || attr.defaultValue != "false" ? "true" : "false");
                }
                else {
                    defaultValueStr = "";
                }
                varStrs.push("    " + (attr.onlyConfig ? "readonly " : "") + attr.varName + ": " + attrTSType + defaultValueStr + "; // " + attr.alias + " " + attr.attrTips);
            }
            str += "/**\n * " + tips[5] + i + "-" + GameListData.getName(materialList, i) + "\n */\nclass MaterialData" + i + " extends MaterialData {\n" + varStrs.join("\n") + "\n}\n";
        }
        return str;
    };
    CustomCompositeSetting.getShaderCompVars = function (materialID) {
        var resArr = [];
        var materialList = Game.data.materialList;
        var materiaSetting = materialList.data[materialID];
        if (!materiaSetting)
            return resArr;
        var attrs = CustomCompositeSetting.getAllAttributes(materiaSetting, true);
        for (var s = 0; s < attrs.length; s++) {
            var attrComp = attrs[s];
            var attr = attrComp.attr;
            if (CustomAttributeSetting.isHideComp(attr) || (CustomAttributeSetting.ONLY_DISPLAY.indexOf(attr.compData.compType) != -1))
                continue;
            var attrTSType = CustomAttributeSetting.getShaderTSType(attr);
            if (!attrTSType && attr.varType > 2)
                continue;
            var defaultValue;
            if (attr.varType == 0 && attr.defaultValue) {
                defaultValue = MathUtils.float(attr.defaultValue);
            }
            else if (attr.varType == 1) {
                defaultValue = attr.defaultValue;
            }
            else if (attr.varType == 2 && attr.defaultValue) {
                defaultValue = attr.defaultValue == "true" || attr.defaultValue != "false" ? true : false;
            }
            resArr.push({ varName: attr.varName, value: defaultValue, varAttributeSetting: attr, varCompAttributeSetting: attrComp });
        }
        return resArr;
    };
    CustomCompositeSetting.fixShaderTsValue = function (materialID, materialData, materiaSetting) {
        if (materiaSetting === void 0) { materiaSetting = null; }
        if (!materialData)
            return;
        if (!materiaSetting) {
            var materialList = Game.data.materialList;
            materiaSetting = materialList.data[materialID];
        }
        if (!materiaSetting)
            return;
        var attrs = CustomCompositeSetting.getAllAttributes(materiaSetting, false);
        for (var s = 0; s < attrs.length; s++) {
            var attr = attrs[s];
            if (CustomAttributeSetting.isHideComp(attr) || (CustomAttributeSetting.ONLY_DISPLAY.indexOf(attr.compData.compType) != -1))
                continue;
            var attrTSType = CustomAttributeSetting.getShaderTSType(attr);
            if (!attrTSType && attr.varType > 2 && attr.compData.compType != 41)
                continue;
            var materialDataValue = materialData[attr.varName];
            if (attr.varType == 0 && typeof materialDataValue != "number") {
                materialData[attr.varName] = MathUtils.float(attr.defaultValue);
            }
            else if (attr.varType == 1) {
                if (typeof materialDataValue != "string") {
                    materialData[attr.varName] = attr.defaultValue;
                }
                else if (attr.compData.compType == 12) {
                    if (materialDataValue.length != 7 || materialDataValue.match(/#[0-9A-Fa-f]{6}/g) == null) {
                        materialData[attr.varName] = "#000000";
                    }
                }
                else if (attr.compData.compType == 41) {
                    var transData = GameUtils.getTransData(materialDataValue);
                    if (transData) {
                        var oldTimeType = transData.timeType;
                        var oldLoopType = transData.loopType;
                        transData.timeType = MathUtils.int(attr.compData.compParam.timeType);
                        if (!attr.compData.compParam.loopType) {
                            transData.loopType = 0;
                        }
                        if (oldTimeType != transData.timeType || oldLoopType != transData.loopType) {
                            materialData[attr.varName] = JSON.stringify(transData);
                        }
                    }
                }
            }
            else if (attr.varType == 2 && typeof materialData[attr.varName] != "boolean") {
                materialData[attr.varName] = attr.defaultValue == "true" || attr.defaultValue != "false" ? true : false;
            }
        }
    };
    CustomCompositeSetting.getPreShaderClacNotes = function (ccAttr) {
        var tips = function (index) {
            var t = ["[#GAME_HERE_YOU_CAN_WRITE_ADDITIONAL_SHADER_UNIFORM_THAT]", "[#GAME_THE_CODE_IS_CALLED_BY_THE_SYSTEM:_IF]", "[#GAME_THE_CUSTOM_VARIABLES_OF_THE_VISUALIZATION_ARE_AUTOMATICALLY]",
                "[#GAME_YOU_CAN_GET_THE_DISPLAY_OBJECT_(GAMESPRITE)_THAT]", "[#GAME_YOU_CAN_GET_OR_MODIFY_THE_VALUE_OF]", "[#GAME_NEW_ATTRIBUTE_ADDED]",
                "[#GAME_WRITE_DIRECTLY_HERE_SHADER_MUMATERIALNUMBER_CUSTOMVARIABLENAME_FOR_EXAMPLE]", "[#GAME_IN_THE_SHADER_CODE_YOU_NEED_TO_ENTER]", "[#GAME_IF_YOU_NEED_TO_CACHE_THE_RESULT_OF]",
                "[#GAME_VARIABLE_MAPPING_IN_TYPESCRIPT_AND_GLSL]", "[#GAME_DEPENDING_ON_THE_LENGTH_OF_THE_ARRAY_OF]", "[#GAME_CORRESPONDS_TO_4X4_MATRIX_DATA_IN_ORDER]"];
            return mainDomain_gcide.LanguageManager.parseIDE(t[index]);
        };
        return "//------------------------------------------------------------------------------------------------------\n// " + tips(0) + "\n// " + tips(1) + "\n// " + tips(2) + "\n// -- sp " + tips(3) + "\n// -- shader " + tips(4) + " shader.mu3_xxx\n// -- " + tips(5) + "\n//    1." + tips(6) + " shader[\"mu3_abc\"] = 5;\n//    2." + tips(7) + " uniform float mu3_abc;\n// -- " + tips(8) + "\n// " + tips(9) + "\n// -- number             => uniform float\n// -- number[]           => uniform vec2/vec3/vec4  " + tips(10) + "\n// -- Float32Array(16)   => uniform mat4  " + tips(11) + "\n//------------------------------------------------------------------------------------------------------\n";
    };
    CustomCompositeSetting.getPreviewCustomModuleCode = function () {
        var tips = function (index) {
            var t = ["[#GAME_EDITOR_CUSTOM_MODULE_SCRIPT]", "[#GAME_CURRENT_CUSTOM_MODULE_DATA]", "[#GAME_CURRENT_CUSTOM_MODULE_INDEX]", "[#GAME_ATTRIBUTE_VALUE_CHANGE]", "[#GAME_ATTRIBUTE_VARNAME_CHANGE]", "[#GAME_ATTRIBUTE_VALUE_INFO]"];
            return mainDomain_gcide.LanguageManager.parseIDE(t[index]);
        };
        return "//------------------------------------------------------------------------------------------------------\n// " + tips(0) + "\n//------------------------------------------------------------------------------------------------------\n/**\n * " + tips(1) + "\n */\ndeclare var myData: any;\n/**\n * " + tips(2) + "\n */\ndeclare var index: number;\n/**\n * " + tips(3) + "\n * @param varName " + tips(4) + "\n * @param value " + tips(5) + "\n */\nfunction onAttributeChange(varName: string, value: any) {\n\n}\n";
    };
    CustomCompositeSetting.getPreviewCommandCode = function () {
        var code = "//------------------------------------------------------------------------------------------------------\n// [#GAME_EDITOR_PRIVEW_1]\n// [#GAME_EDITOR_PRIVEW_2]\n// -- 1.imageLayerPassageClear [#GAME_EDITOR_PRIVEW_3]\n// -- 2.runCommand [#GAME_EDITOR_PRIVEW_4]\n// -- 3.imageLayerPassageStart [#GAME_EDITOR_PRIVEW_3]\n// [#GAME_EDITOR_PRIVEW_5]\n// -- 1.imageLayerPassageClear [#GAME_EDITOR_PRIVEW_3]\n// -- 2.runCommand [#GAME_EDITOR_PRIVEW_6]\n//------------------------------------------------------------------------------------------------------\n/**\n * [#GAME_EDITOR_PRIVEW_7]\n */\ndeclare var commandID: number;\n/**\n * [#GAME_EDITOR_PRIVEW_8]\n */\ndeclare var imageLayerPassageData: any[];\n/**\n * [#GAME_EDITOR_PRIVEW_9]\n */\ndeclare var gameLayer: GameSprite;\n/**\n * [#GAME_EDITOR_PRIVEW_10]\n */\ndeclare var imageLayer: GameImageLayer;\n/**\n * [#GAME_EDITOR_PRIVEW_28]\n */\ndeclare var uiLayer: GameSprite;\n/**\n * [#GAME_EDITOR_PRIVEW_11]\n */\ndeclare var previewWin: {\n    /**\n     * [#GAME_EDITOR_PRIVEW_12]\n     */\n    clearData: Function;\n    /**\n     * [#GAME_EDITOR_PRIVEW_13]\n     */\n    setData: Function;\n    /**\n     * [#GAME_EDITOR_PRIVEW_14]\n     */\n    currentSelectCmd: Command;\n    /**\n     * [#GAME_EDITOR_PRIVEW_15]\n     */\n    currentCommandPage: CommandPage;\n    /**\n     * [#GAME_EDITOR_PRIVEW_16]\n     */\n    viewAreaRightMouseMove: boolean;\n    /**\n     * [#GAME_EDITOR_PRIVEW_17]\n     */\n    allowAllDisplayObject: boolean;\n    /**\n     * [#GAME_EDITOR_PRIVEW_18]\n     */\n    playUpdateWait: boolean;\n    /**\n     * [#GAME_EDITOR_PRIVEW_19]\n     */\n    operateObjectTool: {\n        // [#GAME_EDITOR_PRIVEW_20]\n        refresh: Function;\n        // [#GAME_EDITOR_PRIVEW_21]\n        selectObjects: (sp: GameSprite[]) => void;\n        // [#GAME_EDITOR_PRIVEW_22]\n        addExcludeOperactionObject: (sp: GameSprite) => void\n    }\n    /**\n     * [#GAME_EDITOR_PRIVEW_23]\n     * onChange(changeType:number,cameraX:number,cameraY:number,cameraZ:number,cameraRotation:number)\n     */\n    openCameraTools: (onChange: Function) => void;\n    /**\n     * [#GAME_EDITOR_PRIVEW_24]\n     */\n    refreshCameraTools: Function;\n    /**\n     * [#GAME_EDITOR_PRIVEW_25]\n     * @param cmd [#GAME_EDITOR_PRIVEW_26]\n     * @param sendEvent [#GAME_EDITOR_PRIVEW_27]\n     */\n    selectCmdMessageByCmd(cmd: Command, sendEvent?: boolean);\n    /**\n     * [#GAME_EDITOR_PRIVEW_29]\n     * @param cmd [#GAME_EDITOR_PRIVEW_30]\n     * @param varName [#GAME_ATTRIBUTE_VARNAME_CHANGE]\n     * @param newValue [#GAME_EDITOR_PRIVEW_31]\n     */\n    modifyCommandParam: (cmd: Command, varName: string, newValue: any) => void;\n    /**\n     * [#GAME_EDITOR_PRIVEW_32] varNameValue\n     * @param customID [#GAME_EDITOR_PRIVEW_33]\n     * @param varNameValue [#GAME_EDITOR_PRIVEW_34] {dpX:100,dpY:200}\n     * @param selectedIndex [#GAME_EDITOR_PRIVEW_35] \n     * @param refreshPreViewArea [#GAME_EDITOR_PRIVEW_36]\n     */\n    insertCustomCMD(customID: number, varNameValue: any, selectedIndex?: number, refreshPreViewArea?: boolean): Command;\n    /**\n     * [#GAME_EDITOR_PRIVEW_37]\n     * @param cmdID [#GAME_EDITOR_PRIVEW_38]\n     * @param params [#GAME_PARAMETER]\n     * @param selectedIndex [#GAME_EDITOR_PRIVEW_39]\n     * @param refreshPreViewArea [#GAME_EDITOR_PRIVEW_40]\n     */\n    insertSystemCMD(cmdID: number, params: any[], selectedIndex?: number, refreshPreViewArea?: boolean): Command;\n    /**\n     * [#GAME_EDITOR_PRIVEW_41]\n     * @param selectedIndex [#GAME_EDITOR_PRIVEW_42]\n     */\n    changeLayer(selectedIndex: number):void;\n    /**\n     * [#GAME_EDITOR_PRIVEW_43]\n     * var menuData:any[] = [\n               {\n                   label:\"[#GAME_RENAME]\",\n                   splitLine:false,// [#GAME_EDITOR_PRIVEW_44]\n                   children:[], // [#GAME_EDITOR_PRIVEW_45]\n                   execute:\"functionName\", // [#GAME_EDITOR_PRIVEW_46]\n                   shortcutKey:\"\", //[#GAME_EDITOR_PRIVEW_47]\n                   menuHotKey:\"\", //[#GAME_EDITOR_PRIVEW_48]\n                   enabled:true, // [#GAME_EDITOR_PRIVEW_49]\n                   visible:true, // [#GAME_EDITOR_PRIVEW_50]\n\t\t\t\t   selected:true, // [#GAME_EDITOR_PRIVEW_51]\n\t\t\t\t   group:\"myGroupName\" // [#GAME_EDITOR_PRIVEW_52]\n               }\n           ];\n     * @param menuData [#GAME_EDITOR_PRIVEW_53]\n     * @param x [#GAME_EDITOR_PRIVEW_54]\n     * @param y [#GAME_EDITOR_PRIVEW_55]\n     * @param executeDomain [#GAME_EDITOR_PRIVEW_56]\n     */\n    createMenu(menuData: any[], x: number, y: number, executeDomain: any);\n}\n/**\n * [#GAME_EDITOR_PRIVEW_57]\n */\ndeclare var editor:Editor;\n//------------------------------------------------------------------------------------------------------\n// [#GAME_EDITOR_PRIVEW_58]\n//------------------------------------------------------------------------------------------------------\ndeclare class PassageData {\n    // ====> system [#GAME_EDITOR_PRIVEW_59]\n    /**\n     * [#GAME_EDITOR_PRIVEW_60]\n     */\n    passageID: number;\n    /**\n     * [#GAME_EDITOR_PRIVEW_61]\n     */\n    type: string;\n    /**\n     * [#GAME_EDITOR_PRIVEW_62]\n     */\n    cmd: Command;\n    /**\n     * [#GAME_EDITOR_PRIVEW_63]\n     */\n    onCoverPassage: Function;\n    // ====> custom [#GAME_EDITOR_PRIVEW_64]\n\n}\n//------------------------------------------------------------------------------------------------------\n// [#GAME_EDITOR_PRIVEW_65]\n//------------------------------------------------------------------------------------------------------\nvar passageType = \"gcXXXXX\";\n//------------------------------------------------------------------------------------------------------\n// [everyone used command type] [#GAME_EDITOR_PRIVEW_66]\n//------------------------------------------------------------------------------------------------------\n/**\n * [#GAME_EDITOR_PRIVEW_67]\n */\nfunction customCommandStart(): void{\n\n}\n/**\n * [#GAME_EDITOR_PRIVEW_68]\n */\nfunction customCommandEnd(): void{\n\n}\n//------------------------------------------------------------------------------------------------------\n// [everyone used command] [#GAME_EDITOR_PRIVEW_69]\n//------------------------------------------------------------------------------------------------------\n/**\n * [#GAME_EDITOR_PRIVEW_70]\n * [#GAME_EDITOR_PRIVEW_71]\n * [#GAME_EDITOR_PRIVEW_72]\n * @param cmdParams [#GAME_EDITOR_PRIVEW_73]\n * @param cmd [#GAME_EDITOR_PRIVEW_74]\n * @param isPlayMode [#GAME_EDITOR_PRIVEW_75]\n */\nfunction runCommand(cmdParams: ThisCommandParams, cmd: Command, isPlayMode: boolean) {\n\n}\n/**\n * [#GAME_EDITOR_PRIVEW_77]\n * @param onFin [#GAME_EDITOR_PRIVEW_78]\n * @param cmdParams [#GAME_EDITOR_PRIVEW_73]\n */\nfunction inEditorPlayPreload(onFin: Function, cmdParams: ThisCommandParams) {\n    // [#GAME_EDITOR_PRIVEW_80]\n    onFin.apply(this);\n}\n//------------------------------------------------------------------------------------------------------\n// [#GAME_EDITOR_PRIVEW_81]\n// [#GAME_EDITOR_PRIVEW_82]\n// [current used command] \n//------------------------------------------------------------------------------------------------------\n/**\n * [#GAME_EDITOR_PRIVEW_83]\n * @param cmd [#GAME_EDITOR_PRIVEW_84]\n * @param cmdParams [#GAME_EDITOR_PRIVEW_85] \n * @param varName [#GAME_EDITOR_PRIVEW_86]\n */\nfunction onCommandAttributeBeforeChange(cmd: Command, cmdParams: ThisCommandParams, varName: string) {\n\n}\n/**\n * [#GAME_ATTRIBUTE_VALUE_CHANGE]\n * @param cmd [#GAME_EDITOR_PRIVEW_84]\n * @param cmdParams [#GAME_EDITOR_PRIVEW_85] \n * @param varName [#GAME_EDITOR_PRIVEW_86]\n * @param newValue [#GAME_EDITOR_PRIVEW_87]\n */\nfunction onCommandAttributeChange(cmd: Command, cmdParams: ThisCommandParams, varName: string, value: any) {\n\n}\n//------------------------------------------------------------------------------------------------------\n// [#GAME_EDITOR_PRIVEW_88]\n// [everyone used command type] [#GAME_EDITOR_PRIVEW_89]\n//------------------------------------------------------------------------------------------------------\n/**\n * [#GAME_EDITOR_PRIVEW_90]\n * @param realSelObjs [#GAME_EDITOR_PRIVEW_91]\n */\nfunction imageLayerOnToolsChangePostion(realSelObjs: GameSprite[]): void {\n\n}\n/**\n * [#GAME_EDITOR_PRIVEW_92]\n * @param realSelObjs [#GAME_EDITOR_PRIVEW_91]\n */\nfunction imageLayerOnToolsChangeSize(realSelObjs: GameSprite[]) {\n\n}\n/**\n * [#GAME_EDITOR_PRIVEW_93]\n * @param realSelObjs [#GAME_EDITOR_PRIVEW_91]\n */\nfunction imageLayerOnToolsChangeRotation(realSelObjs: GameSprite[]) {\n\n}\n/**\n * [#GAME_EDITOR_PRIVEW_94]\n */\nfunction imageLayerOnToolsChangeStart(realSelObjs: GameSprite[]) {\n\n}\n/**\n * [#GAME_EDITOR_PRIVEW_95]\n */\nfunction imageLayerOnToolsChangeEnd(realSelObjs: GameSprite[]) {\n\n}\n/**\n * [#GAME_EDITOR_PRIVEW_96]\n */\nfunction imageLayerOnToolsSelectObject(realSelObjs: GameSprite[]) {\n\n}\n//------------------------------------------------------------------------------------------------------\n// [#GAME_EDITOR_PRIVEW_97]\n// [everyone passage] x [everyone used command type]\n//------------------------------------------------------------------------------------------------------\n/**\n * [#GAME_EDITOR_PRIVEW_98]\n * @param passageID [#GAME_EDITOR_PRIVEW_99]\n * @param passageData [#GAME_EDITOR_PRIVEW_100]\n * @param isPlayMode [#GAME_EDITOR_PRIVEW_101]\n */\nfunction imageLayerPassageClear(passageID: number, passageData: PassageData,isPlayMode: boolean) {\n    // -- [#GAME_EDITOR_PRIVEW_102]\n    if (passageData.type == passageType) {\n\n    }\n}\n/**\n * [#GAME_EDITOR_PRIVEW_103]\n * @param passageID [#GAME_EDITOR_PRIVEW_99]\n * @param passageData [#GAME_EDITOR_PRIVEW_100]\n * @param isPlayMode [#GAME_EDITOR_PRIVEW_101]\n */\nfunction imageLayerPassageStart(passageID: number, passageData: PassageData,isPlayMode: boolean) {\n    // -- [#GAME_EDITOR_PRIVEW_102]\n    if (passageData.type == passageType) {\n\n    }\n}";
        return mainDomain_gcide.LanguageManager.parseIDE(code);
    };
    CustomCompositeSetting.getVarTypeInEditorCode = function (mode, id) {
        if (mode == 0 || mode == 1 || mode == 4) {
            var lists = [Common.dataStructureList, Common.customModuleList, null, null, null];
            var nameHeads = ["DataStructure", "Module", null, null, "SceneModel"];
            if (id == -1)
                return nameHeads[mode];
            var list = lists[mode];
            var cSetting = list.data[id];
            if (cSetting) {
                if (mode == 0 || mode == 1) {
                    var settingName = cSetting.varName;
                }
                else {
                    var settingName = GameListData.getName(list, id);
                }
                return nameHeads[mode] + "_" + settingName;
            }
            else {
                return "any";
            }
        }
        else if (mode == 2) {
            return "WorldData";
        }
        else if (mode == 3) {
            return "PlayerData";
        }
    };
    CustomCompositeSetting.getConditionAPI = function (customSetting) {
        if (Array.isArray(customSetting)) {
            var customAttributeSetting = customSetting;
        }
        else {
            var customAttributeSetting = CustomCompositeSetting.getAllAttributes(customSetting, false);
        }
        var attrs = "var attrs:{";
        for (var i = 0; i < customAttributeSetting.length; i++) {
            var cusAttr = customAttributeSetting[i];
            if (cusAttr.varType >= 3)
                continue;
            if (cusAttr.compData.compType == 2 || cusAttr.compData.compType == 15) {
                attrs += "\n    " + cusAttr.varName + ":";
                switch (cusAttr.varType) {
                    case 0:
                        attrs += "number";
                        break;
                    case 1:
                        attrs += "string";
                        break;
                    case 2:
                        attrs += "boolean";
                        break;
                }
                if (i != customAttributeSetting.length - 1) {
                    attrs += ",";
                }
            }
        }
        attrs += "\n    };";
        return attrs;
    };
    return CustomCompositeSetting;
}(OriginalData));
var CustomCompositeBlock = (function () {
    function CustomCompositeBlock() {
    }
    CustomCompositeBlock.init = function (data) {
        data.name = mainDomain_gcide.LanguageManager.parseIDE("[#GAME_UNNAMED_BLOCK]");
        ;
        data.blockAttrs = [];
        data.blockCondition = [];
        data.blockHeight = 300;
        data.autoOrder = true;
    };
    CustomCompositeBlock.isEmpty = function (data) {
        return data.blockAttrs.length == 0 && data.blockCondition.length == 0;
    };
    CustomCompositeBlock.meetConditionData = function (block, idValue, varNameValue) {
        var conditions = block.blockCondition;
        for (var s in conditions) {
            var condition = conditions[s];
            if (condition.isExpression) {
                try {
                    var res = eval(condition.jsCode);
                    if (!res)
                        return false;
                }
                catch (e) {
                    trace("条件表达式出错-" + condition.codeName + ":" + e);
                }
            }
            else {
                var paramValue = idValue[condition.attrID];
                if (condition.value == null)
                    condition.value = typeof paramValue == "number" ? 0 : false;
                if (condition.value != paramValue) {
                    return false;
                }
            }
        }
        return true;
    };
    return CustomCompositeBlock;
}());
var CustomCompositeAttributeSetting = (function () {
    function CustomCompositeAttributeSetting() {
    }
    CustomCompositeAttributeSetting.init = function (data) {
        data.attr = new CustomAttributeSetting();
        CustomAttributeSetting.init(data.attr);
        data.attrConditions = [];
        data.x = data.y = 0;
        data.width = 200;
        data.height = 32;
    };
    CustomCompositeAttributeSetting.meetConditionData = function (conditions, idValue, varNameValue, customCompSettings) {
        if (customCompSettings === void 0) { customCompSettings = null; }
        for (var s in conditions) {
            var condition = conditions[s];
            if (condition.isExpression) {
                try {
                    var attrs = varNameValue;
                    var res = eval(condition.jsCode);
                    if (!res)
                        return false;
                }
                catch (e) {
                    trace("条件表达式出错-" + condition.codeName + ":" + e);
                }
            }
            else {
                if (!idValue) {
                    var customCompSetting = ArrayUtils.matchAttributes(customCompSettings, { id: condition.attrID }, true)[0];
                    if (!customCompSetting)
                        continue;
                    var paramValue = varNameValue[customCompSetting.varName];
                }
                else {
                    var paramValue = idValue[condition.attrID];
                }
                if (condition.value == null)
                    condition.value = typeof paramValue == "number" ? 0 : false;
                if (condition.value != paramValue) {
                    return false;
                }
            }
        }
        return true;
    };
    CustomCompositeAttributeSetting.meetCondition = function (attributeComps, preSetting, conditions) {
        for (var s in conditions) {
            var condition = conditions[s];
            if (condition.isExpression) {
                var persetDataStructor = preSetting;
                var customAttributeSetting = CustomCompositeSetting.getAllAttributes(persetDataStructor, false);
                var attrs = {};
                for (var i in customAttributeSetting) {
                    var cusAttr = customAttributeSetting[i];
                    if (cusAttr.varType >= 3)
                        continue;
                    var comp = attributeComps[cusAttr.id];
                    if (!comp)
                        continue;
                    if (comp instanceof TitleCombobox) {
                        attrs[cusAttr.varName] = comp.comp.selectedIndex;
                    }
                    else if (comp instanceof TitleCheckBox) {
                        attrs[cusAttr.varName] = comp.checkbox.selected;
                    }
                }
                try {
                    var res = eval(condition.jsCode);
                    if (!res)
                        return false;
                }
                catch (e) {
                    trace("条件表达式出错-" + condition.codeName + ":" + e);
                }
            }
            else {
                var comp = attributeComps[condition.attrID];
                if (comp) {
                    if (comp instanceof TitleCombobox) {
                        if (condition.value != comp.comp.selectedIndex) {
                            return false;
                        }
                    }
                    else if (comp instanceof TitleCheckBox) {
                        if (condition.value == null)
                            condition.value = false;
                        if (condition.value != comp.checkbox.selected) {
                            return false;
                        }
                    }
                }
            }
        }
        return true;
    };
    CustomCompositeAttributeSetting.matchDataTypeByComponent = function (attrs) {
        var len = attrs.length;
        for (var i = 0; i < attrs.length; i++) {
            var attr = attrs[i];
            if (attr.varType <= 2 && !CustomAttributeSetting.isHideComp(attr)) {
                var newVarType = EditorDataUICompAttribute.itemVarTypeMapping[attr.compData.compType];
                if (newVarType != null) {
                    attr.varType = newVarType;
                }
            }
        }
    };
    return CustomCompositeAttributeSetting;
}());















var CustomData = (function (_super) {
    __extends(CustomData, _super);
    function CustomData() {
        var _this_1 = _super !== null && _super.apply(this, arguments) || this;
        _this_1.attrs = {};
        return _this_1;
    }
    return CustomData;
}(OriginalData));















var CustomEventType = (function (_super) {
    __extends(CustomEventType, _super);
    function CustomEventType() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return CustomEventType;
}(OriginalData));















var DialogData = (function (_super) {
    __extends(DialogData, _super);
    function DialogData() {
        var _this_1 = _super !== null && _super.apply(this, arguments) || this;
        _this_1.initData = false;
        _this_1.previewMode = false;
        _this_1.dialogBox = {
            x: 52,
            y: 439,
            width: 891,
            height: 259,
            alpha: 1,
            blend: 0,
            image: "asset/image/picture/control/dialogBg.png",
            flip: false,
            grid9: "0,0,0,0,0",
            showOnEditor: true,
            mouseEventEnabledInEditor: true,
            materialData: [{ materials: [] }],
            index: 0
        };
        _this_1.headBox = {
            x: 60,
            y: 511,
            width: 150,
            height: 140,
            alpha: 1,
            blend: 0,
            locksize: true,
            adaptation: true,
            previewHeadImg: Config.EDIT_MODE ? Editor.URL_UNKNOW_IMAGE : "",
            flip: false,
            perviewMode: 0,
            previewStandAvatarID: 0,
            previewStandAvatarExp: 0,
            previewAnimationID: 0,
            previewUIID: 0,
            viewscaleX: 1,
            viewscaleY: 1,
            viewFps: 12,
            viewPlayOnce: false,
            showOnEditor: true,
            mouseEventEnabledInEditor: true,
            materialData: [{ materials: [] }],
            index: 1,
        };
        _this_1.optionBox = {
            x: 272,
            y: 191,
            width: 231,
            height: 111,
            alpha: 1,
            blend: 0,
            column: 4,
            columnSpaceing: 5,
            row: 1,
            rowSpaceing: 5,
            image1: "asset/image/picture/control/dialogNormal.png",
            grid9img1: "0,0,0,0,0",
            image2: "asset/image/picture/control/dialogOpOver.png",
            grid9img2: "0,0,0,0,0",
            image3: "asset/image/picture/control/dialogOpDown.png",
            grid9img3: "0,0,0,0,0",
            overSe: "",
            overVolume: 1,
            overPitch: 1,
            clickSe: "",
            clickVolume: 1,
            clikcPitch: 1,
            selectImageURL: "asset/image/picture/control/dialogSelect.png",
            grid9img4: "0,0,0,0,0",
            showOnEditor: true,
            mouseEventEnabledInEditor: true,
            materialData: [{ materials: [] }],
            index: 2
        };
        _this_1.dialog = {
            x: 221,
            y: 512,
            width: 699,
            height: 134,
            alpha: 1,
            blend: 0,
            fontSize: 22,
            color: "#FFFFFF",
            bold: false,
            italic: false,
            smooth: false,
            align: 0,
            leading: 5,
            letterSpacing: 0,
            font: "Arial",
            shadowEnabled: false,
            shadowColor: "#000000",
            shadowDx: 1,
            shadowDy: 1,
            stroke: 0,
            strokeColor: "#000000",
            showOnEditor: true,
            mouseEventEnabledInEditor: true,
            wordWrap: false,
            materialData: [{ materials: [] }],
            index: 3
        };
        _this_1.option = {
            x: 290,
            y: 226,
            width: 196,
            height: 40,
            alpha: 1,
            blend: 0,
            fontSize: 24,
            color: "#FFFFFF",
            overColor: "#FFFFFF",
            clickColor: "#FFFFFF",
            bold: false,
            italic: false,
            smooth: false,
            align: 1,
            leading: 0,
            letterSpacing: 0,
            font: "Arial",
            valign: 1,
            shadowEnabled: false,
            shadowColor: "#000000",
            shadowDx: 1,
            shadowDy: 1,
            stroke: 0,
            strokeColor: "#000000",
            showOnEditor: true,
            mouseEventEnabledInEditor: true,
            materialData: [{ materials: [] }],
            index: 4
        };
        _this_1.nameBox = {
            x: 121,
            y: 456,
            width: 123,
            height: 28,
            alpha: 1,
            blend: 0,
            fontSize: 24,
            color: "#FFFFFF",
            bold: false,
            italic: false,
            smooth: false,
            align: 1,
            leading: 0,
            letterSpacing: 0,
            font: "Arial",
            valign: 1,
            shadowEnabled: false,
            shadowColor: "#000000",
            shadowDx: 1,
            shadowDy: 1,
            stroke: 0,
            strokeColor: "#000000",
            showOnEditor: true,
            mouseEventEnabledInEditor: true,
            materialData: [{ materials: [] }],
            index: 5
        };
        _this_1.skipBox = {
            x: 895,
            y: 608,
            width: 0,
            height: 0,
            alpha: 1,
            blend: 0,
            posIndex: 0,
            posX: 0,
            posY: 0,
            animationID: 0,
            scaleNumber: 1,
            playType: 2,
            delayTime: 0,
            showOnEditor: true,
            mouseEventEnabledInEditor: true,
            index: 6
        };
        return _this_1;
    }
    DialogData.isEmpty = function (data) {
        if (!DialogData.emptyData)
            DialogData.emptyData = new DialogData();
        var dialogName = GameListData.getName(Game.data.dialogList, data.id, true);
        if (dialogName)
            return false;
        var dataClone = {};
        for (var i in data) {
            if (i == "id" || i == "name")
                continue;
            dataClone[i] = data[i];
        }
        return ObjectUtils.depthSame(dataClone, DialogData.emptyData);
    };
    return DialogData;
}(OriginalData));















var SceneObjectModelData = (function (_super) {
    __extends(SceneObjectModelData, _super);
    function SceneObjectModelData() {
        var _this_1 = _super !== null && _super.apply(this, arguments) || this;
        _this_1.preLayer = [];
        _this_1.varAttributes = [];
        _this_1.attrConditions = [];
        _this_1.presetModules = [];
        _this_1.serverInstanceClassName = SceneObjectModelData.SERVER_SCENE_OBJECT_CORE_CLASS;
        _this_1.clientInstanceClassName = SceneObjectModelData.CLIENT_SCENE_OBJECT_CORE_CLASS;
        _this_1.supportTriggerTypes = [];
        _this_1.supportStatusPage = true;
        _this_1.hidePublicAttributes = [];
        _this_1.editorListPresetData = [];
        return _this_1;
    }
    SceneObjectModelData.addPresetData = function (index, sceneSoData, soIndex, screenshotName, soName) {
        var data = Game.data.sceneObjectModelList.data[index];
        if (!data)
            return null;
        var onePresetData = SceneObjectOneData.sceneObjectData2PresetData(sceneSoData, soIndex, screenshotName, soName);
        if (onePresetData) {
            data.editorListPresetData.push(onePresetData);
        }
        return onePresetData;
    };
    SceneObjectModelData.removePresetData = function (index, presetDataIndex) {
        var data = Game.data.sceneObjectModelList.data[index];
        if (!data)
            return null;
        if (data.editorListPresetData[presetDataIndex]) {
            data.editorListPresetData.splice(presetDataIndex, 1);
            return true;
        }
        return false;
    };
    SceneObjectModelData.clear = function (modelData) {
        modelData.preLayer = [];
        modelData.varAttributes = [];
        modelData.serverInstanceClassName = null;
        modelData.clientInstanceClassName = null;
        delete modelData.presetModules;
    };
    SceneObjectModelData.initCommonModelData = function (modelData) {
        if (modelData.sysInitCommonModelData)
            return;
        modelData.serverInstanceClassName = SceneObjectModelData.SERVER_SCENE_OBJECT_COMMON_CLASS;
        modelData.clientInstanceClassName = SceneObjectModelData.CLIENT_SCENE_OBJECT_COMMON_CLASS;
        delete modelData.supportTriggerTypes;
        delete modelData.supportStatusPage;
        delete modelData.hidePublicAttributes;
        modelData.sysInitCommonModelData = true;
    };
    Object.defineProperty(SceneObjectModelData, "commonModelData", {
        get: function () {
            return Common.sceneObjectModelList.data[0];
        },
        enumerable: false,
        configurable: true
    });
    SceneObjectModelData.getModelAttributeData = function (modelData) {
        var arr = [];
        if (Config.useNewSceneObjectModel) {
            var commonModelData = Game.data.sceneObjectModelList.data[0];
            arr.push({ moduleID: 0, preLayer: commonModelData.preLayer, varAttributes: commonModelData.varAttributes });
            for (var i = 0; i < modelData.presetModules.length; i++) {
                var moduleID = modelData.presetModules[i];
                var moduleData = Game.data.sceneObjectModuleList.data[moduleID];
                if (!moduleData)
                    continue;
                arr.push({ moduleID: moduleID, preLayer: moduleData.preLayer, varAttributes: moduleData.varAttributes });
            }
        }
        else {
            arr.push({ preLayer: modelData.preLayer, varAttributes: modelData.varAttributes });
        }
        return arr;
    };
    SceneObjectModelData.isEmpty = function (data, plugType) {
        if (plugType == 22) {
            var dataName = GameListData.getName(Game.data.sceneObjectModuleList, data.id, true);
        }
        else {
            dataName = GameListData.getName(Game.data.sceneObjectModelList, data.id, true);
        }
        if (dataName)
            return false;
        return data.preLayer.length == 0 && data.varAttributes.length == 0;
    };
    SceneObjectModelData.getServerJsBaseCode = function (modelData) {
        return "var ServerSceneObject_" + modelData.id + " = (function (_super) {__extends(ServerSceneObject_" + modelData.id + ", _super);function ServerSceneObject_" + modelData.id + "(soData,presetCustomAttrs,player) {_super.apply(this, [soData,presetCustomAttrs,player]);}return ServerSceneObject_" + modelData.id + ";}(" + this.SERVER_SCENE_OBJECT_CORE_CLASS + "));";
    };
    SceneObjectModelData.getAllAPICodeInEditorNew = function (mode) {
        var list = Game.data.sceneObjectModuleList;
        var tips = [mainDomain_gcide.LanguageManager.parseIDE("[#GAME_SYSTEM_GENERATED_FILES_BY_GAMECREATOR]"), mainDomain_gcide.LanguageManager.parseIDE("[#GAME_SCENE_OBJECT_MODLE_BASE_DATA]"),
            mainDomain_gcide.LanguageManager.parseIDE("[#GAME_MODULE_ID]"), mainDomain_gcide.LanguageManager.parseIDE("[#GAME_MODULE_NAME]"),
            mainDomain_gcide.LanguageManager.parseIDE("[#GAME_SCENE_OBJECT_ENTITY]"), mainDomain_gcide.LanguageManager.parseIDE("[#GAME_WGRTHER_IS_HAS_BEEN_DESTROYED]"),
            mainDomain_gcide.LanguageManager.parseIDE("[#GAME_CONSTRUSTOR]"), mainDomain_gcide.LanguageManager.parseIDE("[#GAME_ATTRIBUTE_VALUES_USED_TO_INSTALL_THE_MODULE]"),
            mainDomain_gcide.LanguageManager.parseIDE("[#GAME_FUNCTIONS_TO_BE_EXECUTED_WHEN_THE_MODULE_IS_REMOVED]"), mainDomain_gcide.LanguageManager.parseIDE("[#GAME_REFRESH_IT_IS_USUALLY_NECESSARY_TO_CALL_THIS_FUNCTION_TO_UNIFORMLY_REFRESH_THE_EFFECT]"),
            mainDomain_gcide.LanguageManager.parseIDE("[#GAME_FUNCTIONS_EXECUTED_WHEN_THE_MODULE_IS_UNLOADED]")];
        var codes = "/**\n * " + tips[0] + "\n */\n";
        var commonModelData = EUIWindowSceneObjectModel.commonModelDataClone ? EUIWindowSceneObjectModel.commonModelDataClone : Game.data.sceneObjectModelList.data[0];
        var instanceClassName = mode == 1 ? commonModelData.serverInstanceClassName : commonModelData.clientInstanceClassName;
        codes += "/**\n * " + tips[1] + "\n */\nclass SceneObjectModule {\n    static moduleClassArr:(typeof SceneObjectModule)[] = [];\n    id: number; // " + tips[2] + "\n    name: string; // " + tips[3] + "\n    so: " + instanceClassName + "; // " + tips[4] + "\n    isDisposed:boolean; // " + tips[5] + "\n    /**\n     * " + tips[6] + "\n     * @param installCB " + tips[7] + "\n     */\n    constructor(installCB: Callback) {\n        installCB && installCB.runWith([this]);\n    }\n    /**\n     * " + tips[8] + "\n     */\n    onRemoved():void {\n        \n    }\n    /**\n     * " + tips[9] + "\n     */\n    refresh():void {\n        \n    }\n    /**\n     * " + tips[10] + "\n     */\n    dispose():void {\n        this.so = null;\n        this.name = null;\n        this.isDisposed = true;\n    }\n}\n";
        var allModuleData = [commonModelData].concat(list.data);
        for (var i in allModuleData) {
            var model = allModuleData[i];
            if (!model)
                continue;
            var modelID = model.id;
            if (EUIWindowSceneObjectModule.cloneData) {
                var newestModel = EUIWindowSceneObjectModule.cloneData.data[modelID];
                if (newestModel)
                    model = newestModel;
            }
            if (mode == 1) {
                var serverCode = this.getServerCodeNew(model, modelID == 0);
                codes += serverCode.serverSoBaseCode + "\n";
            }
            else if (mode == 2) {
                var clientCode = this.getClientCodeNew(model, modelID == 0);
                codes += clientCode.clientSoBaseCode + "\n";
            }
        }
        return codes;
    };
    SceneObjectModelData.getServerCodeNew = function (modelData, isCommon) {
        var serverVars = CustomAttributeSetting.getAPIRuntimes(modelData.varAttributes);
        if (isCommon) {
            var modelName = mainDomain_gcide.LanguageManager.parseIDE("[#GAME_THE_SCENE_OBJECT_PUBLIC_CLASS_WHICH_ANY_SCENE_OBJECT]");
            var serverSoBaseCode = "/**\n * " + modelName + "\n */\nclass SceneObjectCommon extends ServerSceneObject {\n" + serverVars + "    constructor(soData: SceneObject,presetCustomAttrs: { [varName: string]: { varType: number, value: any, copy: boolean } } = null,player: GameServerPlayer) {\n        super(soData,presetCustomAttrs,player);\n    }\n}";
        }
        else {
            var sceneObjectModuleList = EUIWindowSceneObjectModule.cloneData ? EUIWindowSceneObjectModule.cloneData : Game.data.sceneObjectModuleList;
            var modelName_1 = GameListData.getName(sceneObjectModuleList, modelData.id);
            var commonModelData = EUIWindowSceneObjectModel.commonModelDataClone ? EUIWindowSceneObjectModel.commonModelDataClone : Game.data.sceneObjectModelList.data[0];
            var instanceClassName = commonModelData.serverInstanceClassName;
            var nName = mainDomain_gcide.LanguageManager.parseIDE("[#GAME_SCENE_OBJECT_MODULE]");
            var serverSoBaseCode = "/**\n * " + nName + "\uFF1A" + modelName_1 + "\n */\nclass SceneObjectModule_" + modelData.id + " extends SceneObjectModule {\n" + serverVars + "    constructor(installCB: Callback) {\n        super(installCB);\n    }\n    dispose() {\n    }\n}\nSceneObjectModule.moduleClassArr[" + modelData.id + "]=SceneObjectModule_" + modelData.id + ";";
        }
        return { serverSoBaseCode: serverSoBaseCode };
    };
    SceneObjectModelData.getClientCodeNew = function (modelData, isCommon) {
        var clientVars = CustomAttributeSetting.getAPIRuntimes(modelData.varAttributes, true);
        var clientDisplayVars = "";
        for (var i in modelData.preLayer) {
            var preLayer = modelData.preLayer[i];
            if (preLayer.inEditorShowMode == 2)
                continue;
            var varTypeStr = "";
            if (preLayer.type <= 1) {
                continue;
            }
            else if (preLayer.type == 2) {
                var uiData = Common.uiList.data[preLayer.id];
                if (!uiData)
                    continue;
                if (uiData.uiDisplayData.instanceClassName) {
                    varTypeStr += uiData.uiDisplayData.instanceClassName + ";\n";
                }
                else {
                    varTypeStr += "GUI_" + preLayer.id + ";\n";
                }
            }
            else if (preLayer.type == 3) {
                varTypeStr = "UIRoot;\n";
            }
            else if (preLayer.type <= 5) {
                varTypeStr = "GCAnimation;\n";
            }
            clientDisplayVars += "    " + preLayer.varName + ": " + varTypeStr;
        }
        if (isCommon) {
            var modelName = mainDomain_gcide.LanguageManager.parseIDE("[#GAME_THE_SCENE_OBJECT_PUBLIC_CLASS_WHICH_ANY_SCENE_OBJECT]");
            var clientSoBaseCode = "/**\n * " + modelName + "\n */\nclass SceneObjectCommon extends ClientSceneObject {\n" + clientVars + clientDisplayVars + "    constructor(soData: SceneObject, scene: ClientScene) {\n        super(soData,scene);\n    }\n}";
        }
        else {
            var sceneObjectModuleList = EUIWindowSceneObjectModule.cloneData ? EUIWindowSceneObjectModule.cloneData : Game.data.sceneObjectModuleList;
            var modelName_2 = GameListData.getName(sceneObjectModuleList, modelData.id);
            var commonModelData = EUIWindowSceneObjectModel.commonModelDataClone ? EUIWindowSceneObjectModel.commonModelDataClone : Game.data.sceneObjectModelList.data[0];
            var instanceClassName = commonModelData.clientInstanceClassName;
            var nName = mainDomain_gcide.LanguageManager.parseIDE("[#GAME_SCENE_OBJECT_MODEL]");
            var clientSoBaseCode = "/**\n * " + nName + "\uFF1A" + modelName_2 + "\n */\nclass SceneObjectModule_" + modelData.id + " extends SceneObjectModule {\n" + clientVars + clientDisplayVars + "    constructor(installCB: Callback) {\n        super(installCB);\n    }\n}\nSceneObjectModule.moduleClassArr[" + modelData.id + "]=SceneObjectModule_" + modelData.id + ";";
        }
        return { clientSoBaseCode: clientSoBaseCode };
    };
    SceneObjectModelData.getAllAPICodeInEditor = function (mode) {
        if (Config.useNewSceneObjectModel)
            return SceneObjectModelData.getAllAPICodeInEditorNew(mode);
        var list = Game.data.sceneObjectModelList;
        var tips = mainDomain_gcide.LanguageManager.parseIDE("[#GAME_SYSTEM_GENERATED_FILES_BY_GAMECREATOR]");
        var codes = "/**\n * " + tips + "\n */\n";
        for (var i in list.data) {
            var model = list.data[i];
            if (!model)
                continue;
            if (EUIWindowSceneObjectModel.modelData && model.id == EUIWindowSceneObjectModel.modelData.id) {
                model = EUIWindowSceneObjectModel.modelData;
            }
            if (mode == 1) {
                var serverCode = this.getServerCode(model);
                codes += serverCode.serverSoBaseCode + "\n";
            }
            else if (mode == 2) {
                var clientCode = this.getClientCode(model);
                codes += clientCode.clientSoBaseCode + "\n";
            }
        }
        return codes;
    };
    SceneObjectModelData.getServerCode = function (modelData) {
        var serverVars = CustomAttributeSetting.getAPIRuntimes(modelData.varAttributes);
        var modelName = GameListData.getName(Common.sceneObjectModelList, modelData.id);
        var nName = mainDomain_gcide.LanguageManager.parseIDE("[#GAME_SCENE_OBJECT_MODEL]");
        var serverSoBaseCode = "/**\n * " + nName + "\uFF1A" + modelName + "\n */\nclass ServerSceneObject_" + modelData.id + " extends " + this.SERVER_SCENE_OBJECT_CORE_CLASS + " {\n" + serverVars + "    constructor(soData: SceneObject,presetCustomAttrs: { [varName: string]: { varType: number, value: any, copy: boolean } } = null,player: GameServerPlayer) {\n        super(soData,presetCustomAttrs,player);\n    }\n}";
        return { serverSoBaseCode: serverSoBaseCode };
    };
    SceneObjectModelData.getClientCode = function (modelData) {
        var clientVars = CustomAttributeSetting.getAPIRuntimes(modelData.varAttributes, true);
        var clientDisplayVars = "";
        for (var i in modelData.preLayer) {
            var preLayer = modelData.preLayer[i];
            if (preLayer.inEditorShowMode == 2)
                continue;
            var varTypeStr = "";
            if (preLayer.type <= 1) {
                continue;
            }
            else if (preLayer.type == 2) {
                var uiData = Common.uiList.data[preLayer.id];
                if (!uiData)
                    continue;
                if (uiData.uiDisplayData.instanceClassName) {
                    varTypeStr += uiData.uiDisplayData.instanceClassName + ";\n";
                }
                else {
                    varTypeStr += "GUI_" + preLayer.id + ";\n";
                }
            }
            else if (preLayer.type == 3) {
                varTypeStr = "UIRoot;\n";
            }
            else if (preLayer.type <= 5) {
                varTypeStr = "GCAnimation;\n";
            }
            clientDisplayVars += "    " + preLayer.varName + ": " + varTypeStr;
        }
        var modelName = GameListData.getName(Common.sceneObjectModelList, modelData.id);
        var nName = mainDomain_gcide.LanguageManager.parseIDE("[#GAME_SCENE_OBJECT_MODEL]");
        var clientSoBaseCode = "/**\n * " + nName + "\uFF1A" + modelName + "\n */\nclass ClientSceneObject_" + modelData.id + " extends " + this.CLIENT_SCENE_OBJECT_CORE_CLASS + " {\n" + clientVars + clientDisplayVars + "    constructor(soData: SceneObject, scene: ClientScene) {\n        super(soData,scene);\n    }\n}";
        return { clientSoBaseCode: clientSoBaseCode };
    };
    SceneObjectModelData.getClientJsBaseCode = function (modelData) {
        return "var ClientSceneObject_" + modelData.id + " = (function (_super) {__extends(ClientSceneObject_" + modelData.id + ", _super);function ClientSceneObject_" + modelData.id + "(soData,scene) {_super.apply(this, [soData,scene]);}return ClientSceneObject_" + modelData.id + ";}(" + this.CLIENT_SCENE_OBJECT_CORE_CLASS + "));";
    };
    SceneObjectModelData.SERVER_SCENE_OBJECT_CORE_CLASS = "GameServerSceneObject_Core";
    SceneObjectModelData.CLIENT_SCENE_OBJECT_CORE_CLASS = "GameClientSceneObject_Core";
    SceneObjectModelData.SERVER_SCENE_OBJECT_COMMON_CLASS = "GameServerSceneObject";
    SceneObjectModelData.CLIENT_SCENE_OBJECT_COMMON_CLASS = "GameClientSceneObject";
    SceneObjectModelData.TYPE_AVATAR_TYPE = 1;
    SceneObjectModelData.TYPE_UI_DESIGNATION = 2;
    SceneObjectModelData.TYPE_UI_TYPE = 3;
    SceneObjectModelData.TYPE_ANIMATION_DESIGNATION = 4;
    SceneObjectModelData.TYPE_ANIMATION_TYPE = 5;
    SceneObjectModelData.sceneObjectClass = {};
    return SceneObjectModelData;
}(OriginalData));
var SceneObjectModuleBase = (function () {
    function SceneObjectModuleBase(installCB) {
        installCB && installCB.runWith([this]);
    }
    SceneObjectModuleBase.prototype.onRemoved = function () { };
    SceneObjectModuleBase.prototype.refresh = function () { };
    SceneObjectModuleBase.prototype.dispose = function () { };
    SceneObjectModuleBase.moduleClassArr = [];
    return SceneObjectModuleBase;
}());
var AvatarAction = (function () {
    function AvatarAction() {
        this.frameImageInfo = [];
    }
    AvatarAction.prototype.getFrameLength = function (ori, useMapping) {
        if (useMapping === void 0) { useMapping = true; }
        var assetOri = useMapping ? GameUtils.getAssetOri(ori, this.oriMode) : ori;
        var frameImageInfo = this.frameImageInfo[assetOri];
        return frameImageInfo && frameImageInfo.length ? frameImageInfo.length : 0;
    };
    AvatarAction.prototype.getFrameImage = function (ori, frame, useMapping) {
        if (useMapping === void 0) { useMapping = true; }
        var assetOri = useMapping ? GameUtils.getAssetOri(ori, this.oriMode) : ori;
        var arr = this.frameImageInfo[assetOri];
        if (!arr)
            return null;
        return arr[frame];
    };
    AvatarAction.prototype.hasOri = function (ori) {
        var frameImageInfo = this.frameImageInfo[ori];
        return frameImageInfo ? true : false;
    };
    return AvatarAction;
}());
var AvatarFrameImage = (function () {
    function AvatarFrameImage() {
    }
    Object.defineProperty(AvatarFrameImage.prototype, "positiveRect", {
        get: function () {
            if (!this._positiveRect)
                this._positiveRect = new Rectangle(-this.rect.x, -this.rect.y, this.rect.width, this.rect.height);
            return this._positiveRect;
        },
        enumerable: false,
        configurable: true
    });
    return AvatarFrameImage;
}());















var AvatarRefObj = (function () {
    function AvatarRefObj() {
    }
    return AvatarRefObj;
}());
var Helper = (function (_super) {
    __extends(Helper, _super);
    function Helper() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Helper;
}(AvatarRefObj));
var CommandExecuteGame;
(function (CommandExecuteGame) {
    function command_11(triggerLineID, dialogID, head, name, speed, comicSceneObjectIndex, msg, audio, exp, nameColor, cmdID, changeData) {
        if (!GameCommand.isNeedPlayerInput) {
            GameDialog.fromCommandID = cmdID;
            GameDialog.showDialog(dialogID, head, name, speed, comicSceneObjectIndex, msg, null, audio, exp, nameColor, changeData);
        }
        return GameCommand.COMMAND_STATE_NEED_INPUT;
    }
    CommandExecuteGame.command_11 = command_11;
})(CommandExecuteGame || (CommandExecuteGame = {}));
(function (CommandExecuteGame) {
    function command_12(triggerLineID, dialogID, head, name, speed, comicMode, msg) {
        return GameCommand.COMMAND_STATE_NEED_INPUT;
    }
    CommandExecuteGame.command_12 = command_12;
})(CommandExecuteGame || (CommandExecuteGame = {}));
(function (CommandExecuteGame) {
    function command_17(triggerLineID, delay, unit) {
        if (unit == 1) {
            setTimeout(GameCommand.start, delay, [triggerLineID]);
        }
        else {
            setFrameout(GameCommand.start, delay, [triggerLineID]);
        }
        return GameCommand.COMMAND_STATE_STOP;
    }
    CommandExecuteGame.command_17 = command_17;
})(CommandExecuteGame || (CommandExecuteGame = {}));
(function (CommandExecuteGame) {
    function command_37(triggerLineID, imageInfos) {
        imageInfos = ObjectUtils.depthClone(imageInfos);
        GameImage.addGroup(triggerLineID, imageInfos);
        return GameCommand.COMMAND_STATE_CONTINUE;
    }
    CommandExecuteGame.command_37 = command_37;
    function command_71(triggerLineID, imageInfos) {
        return command_37(triggerLineID, imageInfos);
    }
    CommandExecuteGame.command_71 = command_71;
    function command_38(triggerLineID, imageInfos) {
        if (GameImage.isPlaying(triggerLineID)) {
            GameImage.listenerImageOver(triggerLineID);
        }
        else {
            GameCommand.inputMessageAndContinueExecute(null, true, 0, triggerLineID);
        }
        return GameCommand.COMMAND_STATE_CONTINUE;
    }
    CommandExecuteGame.command_38 = command_38;
})(CommandExecuteGame || (CommandExecuteGame = {}));
(function (CommandExecuteGame) {
    function command_3(triggerLineID, dialogID, selContents, defaultIndex, cancelIndex, hideIndexs) {
        if (!GameCommand.isNeedPlayerInput || triggerLineID == GameCommand.inputTriggerLine) {
            GameDialog.showOption(dialogID, selContents, false, defaultIndex, cancelIndex, hideIndexs);
        }
        return GameCommand.COMMAND_STATE_NEED_INPUT;
    }
    CommandExecuteGame.command_3 = command_3;
})(CommandExecuteGame || (CommandExecuteGame = {}));
var Camera = (function () {
    function Camera() {
        this.viewPort = new Rectangle(0, 0, 100, 100);
        this.rotation = 0;
        this.offsetX = 0;
        this.offsetY = 0;
        this.z = 0;
        this.scaleX = 1;
        this.scaleY = 1;
    }
    Camera.prototype.getSaveData = function () {
        var o = {};
        ObjectUtils.cloneExcludeFunction(this, o);
        o.sceneObject = this.sceneObject ? this.sceneObject.index : null;
        o.viewPort = [this.viewPort.x, this.viewPort.y, this.viewPort.width, this.viewPort.height];
        return o;
    };
    Camera.prototype.recoverySaveData = function (o) {
        this.viewPort.x = o.viewPort[0];
        this.viewPort.y = o.viewPort[1];
        this.viewPort.width = o.viewPort[2];
        this.viewPort.height = o.viewPort[3];
        for (var i in o) {
            if (i == "viewPort" || i == "sceneObject")
                continue;
            this[i] = o[i];
        }
        if (o.sceneObject != null) {
            this.sceneObject = Game.currentScene.sceneObjects[o.sceneObject];
        }
    };
    return Camera;
}());
var AssetManager = (function () {
    function AssetManager() {
    }
    AssetManager.preLoadSceneAsset = function (id, complete, syncCallbackWhenAssetExist, autoDispose, prerender) {
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (autoDispose === void 0) { autoDispose = false; }
        if (prerender === void 0) { prerender = false; }
        if (id == 0) {
            complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
            return;
        }
        AssetManager.loadJson("asset/json/scene/data/scene" + id + ".json", Callback.New(function (jsonObj) {
            if (!jsonObj) {
                complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
                return;
            }
            var loadCount = 1;
            function onLoadOne() {
                loadCount--;
                if (loadCount == 0) {
                    if (autoDispose)
                        AssetManager.disposeScene(id);
                    complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
                }
            }
            var onLoadOneCB = Callback.New(onLoadOne, this);
            if (jsonObj.preloadMapAsset) {
                var imgUrls = [];
                for (var i = 0; i < jsonObj.LayerDatas.length; i++) {
                    var layerData = jsonObj.LayerDatas[i];
                    if (!layerData.drawMode && layerData.img) {
                        imgUrls.push(layerData.img);
                    }
                    if (layerData.drawMode && layerData.tileTexIDs) {
                        for (var tileID in layerData.tileTexIDs) {
                            var tileIDInt = MathUtils.int(tileID);
                            if (tileIDInt < 0) {
                                var autoTileData = Game.data.autoTileList.data[-tileIDInt];
                                if (autoTileData && autoTileData.url)
                                    imgUrls.push(autoTileData.url);
                            }
                            else {
                                var tileData = Game.data.tileList.data[tileIDInt];
                                if (tileData && tileData.url)
                                    imgUrls.push(tileData.url);
                            }
                        }
                    }
                }
                loadCount += 1;
                AssetManager.loadImages(imgUrls, onLoadOneCB, syncCallbackWhenAssetExist, true, prerender);
                if (jsonObj.bgm) {
                    loadCount++;
                    AssetManager.loadAudio(jsonObj.bgm, onLoadOneCB, syncCallbackWhenAssetExist);
                }
                if (jsonObj.bgs) {
                    loadCount++;
                    AssetManager.loadAudio(jsonObj.bgs, onLoadOneCB, syncCallbackWhenAssetExist);
                }
            }
            if (AssetManager.preLoadSceneAssetExt) {
                loadCount++;
                AssetManager.preLoadSceneAssetExt.runWith([id, onLoadOne]);
            }
            for (var s in jsonObj.preLoadAssets) {
                var preLoadAssetInfo = jsonObj.preLoadAssets[s];
                var valueStr = preLoadAssetInfo.value;
                var valueInt = preLoadAssetInfo.value;
                loadCount++;
                switch (preLoadAssetInfo.type) {
                    case 0:
                        AssetManager.loadImage(valueStr, onLoadOneCB, syncCallbackWhenAssetExist, true, prerender);
                        break;
                    case 1:
                        AssetManager.loadAudio(valueStr, onLoadOneCB, syncCallbackWhenAssetExist);
                        break;
                    case 2:
                        AssetManager.loadText(valueStr, onLoadOneCB, syncCallbackWhenAssetExist);
                        break;
                    case 3:
                        AssetManager.loadJson(valueStr, onLoadOneCB, syncCallbackWhenAssetExist);
                        break;
                    case 4:
                        AssetManager.preLoadAvatarAsset(valueInt, onLoadOneCB, syncCallbackWhenAssetExist, false, prerender);
                        break;
                    case 5:
                        AssetManager.preLoadUIAsset(valueInt, onLoadOneCB, syncCallbackWhenAssetExist, false, prerender);
                        break;
                    case 6:
                        AssetManager.preLoadAnimationAsset(valueInt, onLoadOneCB, syncCallbackWhenAssetExist, false, prerender);
                        break;
                    case 7:
                        AssetManager.preLoadStandAvatarAsset(valueInt, onLoadOneCB, syncCallbackWhenAssetExist, false, prerender);
                        break;
                    case 8:
                        AssetManager.preLoadDialog(valueInt, onLoadOneCB, syncCallbackWhenAssetExist);
                        break;
                }
            }
            onLoadOneCB.run();
        }, this));
    };
    AssetManager.preLoadSceneObjectAsset = function (so, complete, syncCallbackWhenAssetExist, autoDispose, prerender) {
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (autoDispose === void 0) { autoDispose = false; }
        if (prerender === void 0) { prerender = false; }
        var modelData = Common.sceneObjectModelList.data[so.modelID];
        var fixModuleData = Config.useNewSceneObjectModel ? Common.sceneObjectModelList.data[0] : modelData;
        if (!modelData) {
            complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
            return;
        }
        var loadCount = 0;
        function onLoadOne() {
            loadCount--;
            if (loadCount == 0) {
                loadCount = -1;
                complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
            }
        }
        var onLoadOneCB = Callback.New(onLoadOne, this);
        var loads = [];
        if (so.avatarID != 0) {
            loadCount++;
            loads.push(Callback.New(this.preLoadAvatarAsset, this, [so.avatarID, onLoadOneCB, syncCallbackWhenAssetExist, autoDispose, prerender]));
        }
        for (var i in fixModuleData.preLayer) {
            var preLayer = fixModuleData.preLayer[i];
            var displayInfo = so.displayList[preLayer.varName];
            if (!displayInfo)
                continue;
            addPreloadByLoad.call(this, displayInfo);
        }
        if (so.moduleDisplayList) {
            for (var s = 0; s < so.moduleDisplayList.length; s++) {
                var moduleDisplayList = so.moduleDisplayList[s];
                for (var i in moduleDisplayList) {
                    var displayInfo = moduleDisplayList[i];
                    if (!displayInfo)
                        continue;
                    addPreloadByLoad.call(this, displayInfo);
                }
            }
        }
        for (var i in loads) {
            loads[i].run();
        }
        if (loadCount == 0) {
            complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
        }
        function addPreloadByLoad(displayInfo) {
            if (displayInfo.type == SceneObjectModelData.TYPE_UI_DESIGNATION || displayInfo.type == SceneObjectModelData.TYPE_UI_DESIGNATION) {
                loadCount++;
                loads.push(Callback.New(this.preLoadUIAsset, this, [displayInfo.id, onLoadOneCB, syncCallbackWhenAssetExist, autoDispose, prerender]));
            }
            else if (displayInfo.type == SceneObjectModelData.TYPE_ANIMATION_DESIGNATION || displayInfo.type == SceneObjectModelData.TYPE_ANIMATION_TYPE) {
                loadCount++;
                loads.push(Callback.New(this.preLoadAnimationAsset, this, [displayInfo.id, onLoadOneCB, syncCallbackWhenAssetExist, autoDispose, prerender]));
            }
        }
    };
    AssetManager.preLoadAvatarAsset = function (id, complete, syncCallbackWhenAssetExist, autoDispose, prerender) {
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (autoDispose === void 0) { autoDispose = false; }
        if (prerender === void 0) { prerender = false; }
        AssetManager.preLoadAvatarBaseAsset(id, complete, syncCallbackWhenAssetExist, autoDispose, false, prerender);
    };
    AssetManager.preLoadStandAvatarAsset = function (id, complete, syncCallbackWhenAssetExist, autoDispose, prerender) {
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (autoDispose === void 0) { autoDispose = false; }
        if (prerender === void 0) { prerender = false; }
        if (id <= 0) {
            complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
        }
        else {
            AssetManager.preLoadAvatarBaseAsset(id, complete, syncCallbackWhenAssetExist, autoDispose, true, prerender);
        }
    };
    AssetManager.preLoadAvatarBaseAsset = function (id, complete, syncCallbackWhenAssetExist, autoDispose, isStandAvatar, prerender) {
        var _this_1 = this;
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (autoDispose === void 0) { autoDispose = false; }
        if (isStandAvatar === void 0) { isStandAvatar = false; }
        if (prerender === void 0) { prerender = false; }
        var assetURLHead = isStandAvatar ? "asset/json/standAvatar/data/standAvatar" : "asset/json/avatar/data/avatar";
        if (id < 0 || (id == 0 && !Config.EDIT_MODE)) {
            complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
            return;
        }
        AssetManager.loadJson(assetURLHead + id + ".json", Callback.New(function (id, complete, syncCallbackWhenAssetExist, autoDispose, isStandAvatar, prerender, avatarData) {
            if (complete === void 0) { complete = null; }
            if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
            if (autoDispose === void 0) { autoDispose = false; }
            if (isStandAvatar === void 0) { isStandAvatar = false; }
            if (prerender === void 0) { prerender = false; }
            if (avatarData === void 0) { avatarData = null; }
            if (!avatarData) {
                complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
                return;
            }
            var loadCount = avatarData.parts.length;
            var onLoaded = Callback.New(function (id, complete, syncCallbackWhenAssetExist, autoDispose, isStandAvatar, avatarData) {
                if (complete === void 0) { complete = null; }
                if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
                if (autoDispose === void 0) { autoDispose = false; }
                if (isStandAvatar === void 0) { isStandAvatar = false; }
                if (avatarData === void 0) { avatarData = null; }
                loadCount--;
                if (loadCount == 0) {
                    if (autoDispose)
                        isStandAvatar ? AssetManager.disposeStandAvatarAsset(id) : AssetManager.disposeAvatarAsset(id);
                    complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
                }
            }, _this_1, [id, complete, syncCallbackWhenAssetExist, autoDispose, isStandAvatar, prerender, avatarData]);
            AssetManager.loadImages(avatarData.picUrls, onLoaded, syncCallbackWhenAssetExist, true, prerender);
            for (var i = 0; i < avatarData.parts.length; i++) {
                var avatarPartID = avatarData.parts[i].id;
                if (avatarPartID == 0)
                    continue;
                AssetManager.preLoadAvatarBaseAsset(avatarPartID, onLoaded, syncCallbackWhenAssetExist, false, isStandAvatar, prerender);
            }
        }, this, [id, complete, syncCallbackWhenAssetExist, autoDispose, isStandAvatar, prerender]), syncCallbackWhenAssetExist);
    };
    AssetManager.preLoadUIAsset = function (id, complete, syncCallbackWhenAssetExist, autoDispose, prerender) {
        var _this_1 = this;
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (autoDispose === void 0) { autoDispose = false; }
        if (prerender === void 0) { prerender = false; }
        if (id == 0) {
            complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
            return;
        }
        AssetManager.loadJson("asset/json/ui/data/ui" + id + ".json", Callback.New(function (uiDisData) {
            if (!uiDisData || !uiDisData.root) {
                complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
                return;
            }
            var root = new UIComponent.UIRoot(true, id);
            root.onlyForPreload = true;
            var uiArr = AssetManager.preUIs[id];
            if (!uiArr)
                uiArr = AssetManager.preUIs[id] = [];
            uiArr.push(root);
            root.once(EventObject.LOADED, complete.caller, function (prerender, root) {
                if (prerender)
                    AssetManager.prerender(root);
                complete.run();
                if (autoDispose)
                    AssetManager.disposeUIAsset(id);
            }, [prerender, root]);
            Callback.CallLaterBeforeRender(function () {
                var ui = GameUI.parse(uiDisData, false, null, id, root, syncCallbackWhenAssetExist);
            }, _this_1);
        }, this), syncCallbackWhenAssetExist, false);
    };
    AssetManager.preLoadAnimationAsset = function (id, complete, syncCallbackWhenAssetExist, autoDispose, prerender) {
        var _this_1 = this;
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (autoDispose === void 0) { autoDispose = false; }
        if (prerender === void 0) { prerender = false; }
        if (id <= 0) {
            complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
            return;
        }
        AssetManager.loadJson("asset/json/animation/data/ani" + id + ".json", Callback.New(function (id, complete, syncCallbackWhenAssetExist, autoDispose, prerender, aniData) {
            if (complete === void 0) { complete = null; }
            if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
            if (autoDispose === void 0) { autoDispose = false; }
            if (prerender === void 0) { prerender = false; }
            if (aniData === void 0) { aniData = null; }
            if (!aniData) {
                complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
                return;
            }
            var loadCount = 1;
            var onLoaded = Callback.New(function () {
                loadCount--;
                if (loadCount == 0) {
                    if (autoDispose)
                        AssetManager.disposeAnimationAsset(id);
                    complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
                }
            }, _this_1);
            if (aniData.isParticle && aniData.particleData) {
                AssetManager.loadTexture(aniData.particleData.textureName, onLoaded, syncCallbackWhenAssetExist);
            }
            else {
                for (var index = 0; index < aniData.layers.length; index++) {
                    var layerInfo = aniData.layers[index];
                    if (layerInfo.type == AnimationItemType.GCAnimation) {
                        var nodes = ArrayUtils.getTreeNodeArray(layerInfo);
                        for (var s in nodes) {
                            var childLayerInfo = nodes[s];
                            if (childLayerInfo.type == AnimationItemType.GCAnimation) {
                                loadCount++;
                                AssetManager.preLoadAnimationAsset(childLayerInfo.animationId, onLoaded, syncCallbackWhenAssetExist, false, prerender);
                            }
                        }
                    }
                }
                var picUrls = aniData.imageSources ? aniData.imageSources.reduce(function (pv, v) { if (v && pv.indexOf(v.url) == -1)
                    pv.push(v.url); return pv; }, []) : [];
                AssetManager.loadImages(picUrls, onLoaded, syncCallbackWhenAssetExist, true, prerender);
            }
        }, this, [id, complete, syncCallbackWhenAssetExist, autoDispose, prerender]), syncCallbackWhenAssetExist);
    };
    AssetManager.preLoadCommandPage = function (commandPage, complete, syncCallbackWhenAssetExist, autoDispose) {
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (autoDispose === void 0) { autoDispose = false; }
        if (AssetManager.commandPerloadCache[commandPage.id]) {
            complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
            return;
        }
        var loadCount = 0;
        function onLoadOne() {
            loadCount--;
            if (loadCount == 0) {
                loadCount = -1;
                complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
            }
        }
        var onLoadOneCB = Callback.New(onLoadOne, this);
        var loads = [];
        var commandsLength = commandPage.commands.length;
        var dialogCache = [], avatarCache = [], imageCache = [], audioCache = [], uiCache = [], animationCache = [], standAvatarCache = [], cmdPageCache = [];
        var perlaodCommandPageAssetCache = [dialogCache, avatarCache, imageCache, audioCache, uiCache, animationCache, standAvatarCache, cmdPageCache];
        if (!AssetManager.commandPerloadCache[commandPage.id])
            AssetManager.commandPerloadCache[commandPage.id] = perlaodCommandPageAssetCache;
        for (var i = 0; i < commandsLength; i++) {
            var cmd = commandPage.commands[i];
            if (cmd.type == 11 || cmd.type == 3) {
                loadCount++;
                var dialogID = cmd.params[0];
                loads.push(Callback.New(this.preLoadDialog, this, [dialogID, onLoadOneCB, syncCallbackWhenAssetExist, autoDispose]));
                dialogCache.push(dialogID);
                if (cmd.type == 11) {
                    var dialogData = Common.dialogList.data[dialogID];
                    if (!dialogData)
                        continue;
                    var mode = dialogData.headBox.perviewMode;
                    if (!mode) {
                        loads.push(Callback.New(this.loadImage, this, [cmd.params[1], onLoadOneCB, syncCallbackWhenAssetExist, true]));
                        imageCache.push(cmd.params[1]);
                    }
                    else if (mode == 1) {
                        var standID = MathUtils.int(cmd.params[1]);
                        if (standID > 0) {
                            loads.push(Callback.New(this.preLoadStandAvatarAsset, this, [standID, onLoadOneCB, syncCallbackWhenAssetExist, autoDispose]));
                            standAvatarCache.push(standID);
                        }
                    }
                    else if (mode == 2) {
                        var aniID = MathUtils.int(cmd.params[1]);
                        if (aniID > 0) {
                            loads.push(Callback.New(this.preLoadAnimationAsset, this, [aniID, onLoadOneCB, syncCallbackWhenAssetExist, autoDispose]));
                            animationCache.push(aniID);
                        }
                    }
                    else if (mode == 3) {
                        var viewID = MathUtils.int(cmd.params[1]);
                        if (viewID > 0) {
                            loads.push(Callback.New(this.preLoadUIAsset, this, [viewID, onLoadOneCB, syncCallbackWhenAssetExist, autoDispose]));
                            uiCache.push(viewID);
                        }
                    }
                    if (cmd.params[6]) {
                        var audioURLInfo = GameAudio.getAudioURL(cmd.params[6]);
                        var audioURL = audioURLInfo ? audioURLInfo.url : null;
                        if (audioURL) {
                            loads.push(Callback.New(this.loadAudio, this, [audioURL, onLoadOneCB, syncCallbackWhenAssetExist, true]));
                            audioCache.push(audioURL);
                        }
                    }
                }
            }
            else if (cmd.type == 22) {
                var m = ArrayUtils.matchAttributes(cmd.params[2], { 0: 0 }, false);
                loadCount += m.length;
                for (var s = 0; s < m.length; s++) {
                    var avatarID = m[s][1];
                    loads.push(Callback.New(this.preLoadAvatarAsset, this, [avatarID, onLoadOneCB, syncCallbackWhenAssetExist, autoDispose]));
                    avatarCache.push(avatarID);
                }
            }
            else if (cmd.type == 36) {
                loadCount++;
                var img = cmd.params[0];
                imageCache.push(img);
                loads.push(Callback.New(this.loadImage, this, [img, onLoadOneCB, syncCallbackWhenAssetExist, true]));
            }
            else if (cmd.type == 63 || cmd.type == 65 || cmd.type == 67 || cmd.type == 69) {
                loadCount++;
                var audioUrl = cmd.params[0];
                audioCache.push(audioUrl);
                loads.push(Callback.New(this.loadAudio, this, [audioUrl, onLoadOneCB, syncCallbackWhenAssetExist, true]));
            }
            else if (cmd.type == 72) {
                loadCount++;
                var uiID = cmd.params[0];
                uiCache.push(uiID);
                loads.push(Callback.New(this.preLoadUIAsset, this, [uiID, onLoadOneCB, syncCallbackWhenAssetExist, autoDispose]));
            }
            else if (cmd.type == 37) {
                var imageInfos = cmd.params[0];
                var mPics = ArrayUtils.matchAttributes(imageInfos, { 0: 0 }, false);
                var mAnis = ArrayUtils.matchAttributes(imageInfos, { 0: 5 }, false);
                var mDialogs = ArrayUtils.matchAttributes(imageInfos, { 0: 9 }, false);
                var mSes = ArrayUtils.matchAttributes(imageInfos, { 0: 10 }, false);
                var mStandAvatars = ArrayUtils.matchAttributes(imageInfos, { 0: 11 }, false);
                var mUis = ArrayUtils.matchAttributes(imageInfos, { 0: 13 }, false);
                loadCount += mPics.length + mAnis.length + mDialogs.length + mSes.length + mStandAvatars.length + mUis.length;
                for (var s = 0; s < mPics.length; s++) {
                    imageCache.push(mPics[s][2]);
                    loads.push(Callback.New(this.loadImage, this, [mPics[s][2], onLoadOneCB, syncCallbackWhenAssetExist, true]));
                }
                for (var s = 0; s < mAnis.length; s++) {
                    animationCache.push(mAnis[s][2]);
                    loads.push(Callback.New(this.preLoadAnimationAsset, this, [mAnis[s][2], onLoadOneCB, syncCallbackWhenAssetExist, autoDispose]));
                }
                for (var s = 0; s < mDialogs.length; s++) {
                    dialogCache.push(mDialogs[s][1]);
                    loads.push(Callback.New(this.preLoadDialog, this, [mDialogs[s][1], onLoadOneCB, syncCallbackWhenAssetExist, autoDispose]));
                }
                for (var s = 0; s < mSes.length; s++) {
                    audioCache.push(mSes[s][1]);
                    loads.push(Callback.New(this.loadAudio, this, [mSes[s][1], onLoadOneCB, syncCallbackWhenAssetExist, true]));
                }
                for (var s = 0; s < mStandAvatars.length; s++) {
                    standAvatarCache.push(mStandAvatars[s][8]);
                    loads.push(Callback.New(this.preLoadStandAvatarAsset, this, [mStandAvatars[s][8], onLoadOneCB, syncCallbackWhenAssetExist, autoDispose]));
                }
                for (var s = 0; s < mUis.length; s++) {
                    uiCache.push(mUis[s][8]);
                    loads.push(Callback.New(this.preLoadUIAsset, this, [mUis[s][8], onLoadOneCB, syncCallbackWhenAssetExist, autoDispose]));
                }
            }
            else if (cmd.type == 16) {
                var cmdPage = Command.gameWorld.commonEventPages[cmd.params[0]];
                if (cmdPage) {
                    loadCount++;
                    cmdPageCache.push(cmdPage);
                    AssetManager.preLoadCommandPage(cmdPage, onLoadOneCB, syncCallbackWhenAssetExist, autoDispose);
                }
            }
            else if (cmd.type == 15) {
                var realSID = commandPage.id + "_" + commandPage.commands.indexOf(cmd);
                var fragmentPage = CommandExecute.fragmentEvents[realSID];
                if (!fragmentPage)
                    fragmentPage = CommandExecute.fragmentEvents[realSID] = new CommandPage(cmd.params[2]);
                if (fragmentPage) {
                    loadCount++;
                    cmdPageCache.push(fragmentPage);
                    AssetManager.preLoadCommandPage(fragmentPage, onLoadOneCB, syncCallbackWhenAssetExist, autoDispose);
                }
            }
        }
        for (var f in loads) {
            loads[f].run();
        }
        if (loadCount == 0) {
            complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
        }
    };
    AssetManager.preLoadDialog = function (id, complete, syncCallbackWhenAssetExist, autoDispose) {
        var _this_1 = this;
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (autoDispose === void 0) { autoDispose = false; }
        if (id == 0) {
            complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
            return;
        }
        AssetManager.loadJson("asset/json/dialog/data/dialog" + id + ".json", Callback.New(function (id, complete, syncCallbackWhenAssetExist, autoDispose, dialogData) {
            if (complete === void 0) { complete = null; }
            if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
            if (autoDispose === void 0) { autoDispose = false; }
            if (!dialogData) {
                complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
                return;
            }
            var d = dialogData;
            var imageUrls = [d.dialogBox.image, d.optionBox.image1, d.optionBox.image2, d.optionBox.image3, d.optionBox.selectImageURL];
            var seUrls = [d.optionBox.clickSe, d.optionBox.overSe];
            var aniID = d.skipBox.animationID;
            var loadCount = 0;
            function onLoadOne(id, complete, syncCallbackWhenAssetExist, autoDispose) {
                if (complete === void 0) { complete = null; }
                if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
                if (autoDispose === void 0) { autoDispose = false; }
                loadCount--;
                if (loadCount == 0) {
                    loadCount = -1;
                    if (autoDispose)
                        AssetManager.disposeDialog(id);
                    complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
                }
            }
            var onLoadOneCB = Callback.New(onLoadOne, _this_1, [id, complete, syncCallbackWhenAssetExist, autoDispose]);
            var loads = [];
            loadCount += imageUrls.length + seUrls.length + 1;
            for (var s = 0; s < imageUrls.length; s++)
                loads.push(Callback.New(AssetManager.loadImage, _this_1, [imageUrls[s], onLoadOneCB, syncCallbackWhenAssetExist, true]));
            for (var s = 0; s < seUrls.length; s++)
                loads.push(Callback.New(AssetManager.loadAudio, _this_1, [seUrls[s], onLoadOneCB, syncCallbackWhenAssetExist, true]));
            _this_1.preLoadAnimationAsset(aniID, onLoadOneCB, syncCallbackWhenAssetExist, autoDispose);
            for (var f in loads) {
                loads[f].run();
            }
        }, this, [id, complete, syncCallbackWhenAssetExist, autoDispose]), syncCallbackWhenAssetExist);
    };
    AssetManager.batchPreLoadAsset = function (onFin, onProgress, images, scenes, avatars, standAvatars, animations, uis, jsons, audios, dialogs, syncCallbackWhenAssetExist, autoDispose, prerender) {
        if (onProgress === void 0) { onProgress = null; }
        if (images === void 0) { images = []; }
        if (scenes === void 0) { scenes = []; }
        if (avatars === void 0) { avatars = []; }
        if (animations === void 0) { animations = []; }
        if (uis === void 0) { uis = []; }
        if (jsons === void 0) { jsons = []; }
        if (audios === void 0) { audios = []; }
        if (dialogs === void 0) { dialogs = []; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (autoDispose === void 0) { autoDispose = false; }
        if (prerender === void 0) { prerender = false; }
        var loadCount = images.length + scenes.length + avatars.length + standAvatars.length + animations.length + uis.length + jsons.length + (Array.isArray(audios) ? audios.length : 0) + (Array.isArray(dialogs) ? dialogs.length : 0);
        if (loadCount == 0) {
            onFin && (syncCallbackWhenAssetExist ? onFin.run() : onFin.delayRun(0));
            return;
        }
        var loadCountR = loadCount;
        function onLoaded() {
            loadCount--;
            onProgress && onProgress.runWith([loadCountR - loadCount, loadCountR]);
            if (loadCount == 0) {
                onFin && (syncCallbackWhenAssetExist ? onFin.run() : onFin.delayRun(0));
            }
        }
        var onLoadedCB = Callback.New(onLoaded, this);
        for (var i = 0; i < images.length; i++) {
            var url = images[i];
            this.loadImage(url, onLoadedCB, syncCallbackWhenAssetExist, true, prerender);
            if (autoDispose)
                AssetManager.disposeImage(url);
        }
        for (var i = 0; i < scenes.length; i++) {
            this.preLoadSceneAsset(scenes[i], onLoadedCB, syncCallbackWhenAssetExist, autoDispose, prerender);
        }
        for (var i = 0; i < avatars.length; i++) {
            this.preLoadAvatarAsset(avatars[i], onLoadedCB, syncCallbackWhenAssetExist, autoDispose, prerender);
        }
        for (var i = 0; i < standAvatars.length; i++) {
            this.preLoadStandAvatarAsset(standAvatars[i], onLoadedCB, syncCallbackWhenAssetExist, autoDispose, prerender);
        }
        for (var i = 0; i < animations.length; i++) {
            this.preLoadAnimationAsset(animations[i], onLoadedCB, syncCallbackWhenAssetExist, autoDispose, prerender);
        }
        for (var i = 0; i < uis.length; i++) {
            this.preLoadUIAsset(uis[i], onLoadedCB, syncCallbackWhenAssetExist, autoDispose, prerender);
        }
        for (var i = 0; i < jsons.length; i++) {
            var url = jsons[i];
            this.loadJson(url, onLoadedCB, syncCallbackWhenAssetExist, true);
            if (autoDispose)
                AssetManager.disposeJson(url);
        }
        if (Array.isArray(audios)) {
            for (var i = 0; i < audios.length; i++) {
                this.loadAudio(audios[i], onLoadedCB, syncCallbackWhenAssetExist, true);
                if (autoDispose)
                    AssetManager.disposeAudio(url);
            }
        }
        if (Array.isArray(dialogs)) {
            for (var i = 0; i < dialogs.length; i++) {
                this.preLoadDialog(dialogs[i], onLoadedCB, syncCallbackWhenAssetExist, autoDispose);
            }
        }
    };
    AssetManager.disposeScene = function (id) {
        if (!id || id <= 0 || Config.EDIT_MODE)
            return;
        var dataURL = "asset/json/scene/data/scene" + id + ".json";
        AssetManager.loadJson(dataURL, Callback.New(function (jsonObj) {
            if (!jsonObj)
                return;
            if (AssetManager.disposeSceneAssetExt) {
                AssetManager.disposeSceneAssetExt.runWith([id]);
            }
            AssetManager.disposeJson(dataURL);
            if (jsonObj.preloadMapAsset) {
                var imgUrls = [];
                for (var i = 0; i < jsonObj.LayerDatas.length; i++) {
                    var layerData = jsonObj.LayerDatas[i];
                    if (!layerData.drawMode && layerData.img) {
                        imgUrls.push(layerData.img);
                    }
                    if (layerData.drawMode && layerData.tileTexIDs) {
                        for (var tileID in layerData.tileTexIDs) {
                            var tileIDInt = MathUtils.int(tileID);
                            if (tileIDInt < 0) {
                                var autoTileData = Game.data.autoTileList.data[-tileIDInt];
                                if (autoTileData && autoTileData.url)
                                    imgUrls.push(autoTileData.url);
                            }
                            else {
                                var tileData = Game.data.tileList.data[tileIDInt];
                                if (tileData && tileData.url)
                                    imgUrls.push(tileData.url);
                            }
                        }
                    }
                }
                AssetManager.disposeImages(imgUrls);
            }
            if (jsonObj.bgm) {
                AssetManager.disposeAudio(jsonObj.bgm);
            }
            if (jsonObj.bgs) {
                AssetManager.disposeAudio(jsonObj.bgs);
            }
            for (var s in jsonObj.preLoadAssets) {
                var preLoadAssetInfo = jsonObj.preLoadAssets[s];
                var valueStr = preLoadAssetInfo.value;
                var valueInt = preLoadAssetInfo.value;
                switch (preLoadAssetInfo.type) {
                    case 0:
                        AssetManager.disposeImage(valueStr);
                        break;
                    case 1:
                        AssetManager.disposeAudio(valueStr);
                        break;
                    case 2:
                        AssetManager.disposeText(valueStr);
                        break;
                    case 3:
                        AssetManager.disposeJson(valueStr);
                        break;
                    case 4:
                        AssetManager.disposeAvatarAsset(valueInt);
                        break;
                    case 5:
                        AssetManager.disposeUIAsset(valueInt);
                        break;
                    case 6:
                        AssetManager.disposeAnimationAsset(valueInt);
                        break;
                    case 7:
                        AssetManager.disposeStandAvatarAsset(valueInt);
                        break;
                    case 8:
                        AssetManager.disposeDialog(valueInt);
                        break;
                }
            }
        }, this), true, false);
    };
    AssetManager.disposeSceneObject = function (so) {
        if (Config.EDIT_MODE)
            return;
        var modelData = Common.sceneObjectModelList.data[so.modelID];
        if (!modelData) {
            return;
        }
        var loads = [];
        for (var i in modelData.preLayer) {
            var preLayer = modelData.preLayer[i];
            var displayInfo = so.displayList[preLayer.varName];
            if (!displayInfo) {
                continue;
            }
            ;
            switch (preLayer.type) {
                case 1:
                    this.disposeAvatarAsset(displayInfo.id);
                    break;
                case 2:
                    this.disposeUIAsset(preLayer.id);
                    break;
                case 3:
                    if (displayInfo) {
                        this.disposeUIAsset(displayInfo.id);
                    }
                    break;
                case 4:
                    this.disposeAnimationAsset(preLayer.id);
                    break;
                case 5:
                    if (displayInfo) {
                        this.disposeAnimationAsset(displayInfo.id);
                    }
                    break;
            }
        }
    };
    AssetManager.disposeAvatarAsset = function (id, isStandAvatar) {
        if (isStandAvatar === void 0) { isStandAvatar = false; }
        if (!id || id < 0 || Config.EDIT_MODE)
            return;
        var assetURLHead = isStandAvatar ? "asset/json/standAvatar/data/standAvatar" : "asset/json/avatar/data/avatar";
        var dataURL = assetURLHead + id + ".json";
        AssetManager.loadJson(dataURL, Callback.New(function (isStandAvatar, dataURL, avatarData) {
            if (!avatarData) {
                return;
            }
            AssetManager.disposeJson(dataURL);
            AssetManager.disposeImages(avatarData.picUrls);
            for (var i = 0; i < avatarData.parts.length; i++) {
                var avatarPartID = avatarData.parts[i].id;
                if (avatarPartID == 0)
                    continue;
                AssetManager.disposeAvatarAsset(avatarPartID, isStandAvatar);
            }
        }, this, [isStandAvatar, dataURL]), true, false);
    };
    AssetManager.disposeStandAvatarAsset = function (id) {
        return AssetManager.disposeAvatarAsset(id, true);
    };
    AssetManager.disposeUIAsset = function (id) {
        if (!id || id <= 0 || Config.EDIT_MODE)
            return;
        var uiArr = AssetManager.preUIs[id];
        if (!uiArr || uiArr.length == 0)
            return;
        var ui = uiArr.shift();
        ui.dispose();
    };
    AssetManager.disposeAnimationAsset = function (id) {
        if (!id || id <= 0 || Config.EDIT_MODE)
            return;
        var dataURL = "asset/json/animation/data/ani" + id + ".json";
        AssetManager.loadJson(dataURL, Callback.New(function (aniData) {
            if (!aniData || !aniData.imageSources) {
                return;
            }
            AssetManager.disposeJson(dataURL);
            if (aniData.isParticle && aniData.particleData) {
                AssetManager.disposeImage(aniData.particleData.textureName);
            }
            else {
                for (var index = 0; index < aniData.layers.length; index++) {
                    var layerInfo = aniData.layers[index];
                    if (layerInfo.type == AnimationItemType.GCAnimation) {
                        var nodes = ArrayUtils.getTreeNodeArray(layerInfo);
                        for (var s in nodes) {
                            var childLayerInfo = nodes[s];
                            if (childLayerInfo.type == AnimationItemType.GCAnimation) {
                                AssetManager.disposeAnimationAsset(childLayerInfo.animationId);
                            }
                        }
                    }
                }
                var picUrls = aniData.imageSources.reduce(function (pv, v) { if (v && pv.indexOf(v.url) == -1)
                    pv.push(v.url); return pv; }, []);
                AssetManager.disposeImages(picUrls);
            }
        }, this), true, false);
    };
    AssetManager.disposeCommandPage = function (commandPage) {
        var cache = AssetManager.commandPerloadCache[commandPage.id];
        if (cache) {
            var dialogCache = cache[0], avatarCache = cache[1], imageCache = cache[2], audioCache = cache[3], uiCache = cache[4], animationCache = cache[5], standAvatarCache = cache[6], cmdPageCache = cache[7];
            for (var s = 0; s < dialogCache.length; s++)
                AssetManager.disposeDialog(dialogCache[s]);
            for (var s = 0; s < avatarCache.length; s++)
                AssetManager.disposeAvatarAsset(avatarCache[s]);
            for (var s = 0; s < imageCache.length; s++)
                AssetManager.disposeImage(imageCache[s]);
            for (var s = 0; s < audioCache.length; s++) {
                AssetManager.disposeAudio(audioCache[s]);
            }
            for (var s = 0; s < uiCache.length; s++)
                AssetManager.disposeUIAsset(uiCache[s]);
            for (var s = 0; s < animationCache.length; s++)
                AssetManager.disposeAnimationAsset(animationCache[s]);
            for (var s = 0; s < standAvatarCache.length; s++)
                AssetManager.disposeStandAvatarAsset(standAvatarCache[s]);
            for (var s = 0; s < cmdPageCache.length; s++)
                AssetManager.disposeCommandPage(cmdPageCache[s]);
            delete AssetManager.commandPerloadCache[commandPage.id];
        }
    };
    AssetManager.disposeDialog = function (id) {
        if (id == 0)
            return;
        var jsonURL = "asset/json/dialog/data/dialog" + id + ".json";
        AssetManager.loadJson(jsonURL, Callback.New(function (jsonURL, dialogData) {
            if (!dialogData) {
                return;
            }
            AssetManager.disposeJson(jsonURL);
            var d = dialogData;
            var imageUrls = [d.dialogBox.image, d.optionBox.image1, d.optionBox.image2, d.optionBox.image3];
            var seUrls = [d.optionBox.clickSe, d.optionBox.overSe];
            var aniID = d.skipBox.animationID;
            for (var s = 0; s < imageUrls.length; s++)
                AssetManager.disposeImage(imageUrls[s]);
            for (var s = 0; s < seUrls.length; s++)
                AssetManager.disposeAudio(seUrls[s]);
            AssetManager.disposeAnimationAsset(aniID);
        }, this, [jsonURL]), true, false);
    };
    AssetManager.loadImage = function (url, complete, syncCallbackWhenAssetExist, useRef, prerender) {
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (useRef === void 0) { useRef = true; }
        if (prerender === void 0) { prerender = false; }
        var loadType = (!Config.EDIT_MODE && os.resourceEncryption) ? "image_decrypt" : Loader.IMAGE;
        this.loadAsset(url, loadType, complete, syncCallbackWhenAssetExist, useRef, false, prerender);
    };
    AssetManager.loadTexture = function (url, complete, syncCallbackWhenAssetExist, useRef) {
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (useRef === void 0) { useRef = true; }
        var loadType = (!Config.EDIT_MODE && os.resourceEncryption) ? "image_decrypt" : Loader.IMAGE;
        this.loadAsset(url, loadType, complete, syncCallbackWhenAssetExist, useRef, true);
    };
    AssetManager.loadImages = function (urls, complete, syncCallbackWhenAssetExist, useRef, prerender) {
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (useRef === void 0) { useRef = true; }
        if (prerender === void 0) { prerender = false; }
        var loadType = (!Config.EDIT_MODE && os.resourceEncryption) ? "image_decrypt" : Loader.IMAGE;
        this.batchLoadAsset(urls, loadType, complete, syncCallbackWhenAssetExist, useRef, false, prerender);
    };
    AssetManager.loadTextures = function (urls, complete, syncCallbackWhenAssetExist, useRef) {
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (useRef === void 0) { useRef = true; }
        var loadType = (!Config.EDIT_MODE && os.resourceEncryption) ? "image_decrypt" : Loader.IMAGE;
        this.batchLoadAsset(urls, loadType, complete, syncCallbackWhenAssetExist, useRef, true);
    };
    AssetManager.loadAudio = function (url, complete, syncCallbackWhenAssetExist, useRef) {
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (useRef === void 0) { useRef = true; }
        var newURL = url.split(",")[0];
        this.loadAsset(newURL, Loader.SOUND, complete, syncCallbackWhenAssetExist, useRef);
    };
    AssetManager.loadAudios = function (urls, complete, syncCallbackWhenAssetExist, useRef) {
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (useRef === void 0) { useRef = true; }
        var newURLs = [];
        for (var i in urls) {
            var url = urls[i].split(",")[0];
            if (url)
                newURLs.push(url);
        }
        this.batchLoadAsset(newURLs, Loader.SOUND, complete, syncCallbackWhenAssetExist, useRef);
    };
    AssetManager.loadJson = function (url, complete, syncCallbackWhenAssetExist, useRef, onErrorTips) {
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (useRef === void 0) { useRef = true; }
        if (onErrorTips === void 0) { onErrorTips = true; }
        if (!url) {
            complete && (syncCallbackWhenAssetExist ? complete.runWith([]) : complete.delayRun(1, null, []));
            return;
        }
        if (useRef)
            AssetManager.addRef(url);
        var asset = loader.getRes(url);
        if (asset) {
            complete && (syncCallbackWhenAssetExist ? complete.runWith([asset]) : complete.delayRun(1, null, [asset]));
            return;
        }
        FileUtils.loadJsonFile(url, complete, onErrorTips);
    };
    AssetManager.loadJsons = function (urls, complete, syncCallbackWhenAssetExist, useRef) {
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (useRef === void 0) { useRef = true; }
        this.batchLoadAsset(urls, Loader.JSON, complete, syncCallbackWhenAssetExist, useRef);
    };
    AssetManager.loadText = function (url, complete, syncCallbackWhenAssetExist, useRef) {
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (useRef === void 0) { useRef = true; }
        this.loadAsset(url, Loader.TEXT, complete, syncCallbackWhenAssetExist, useRef);
    };
    AssetManager.loadTexts = function (urls, complete, syncCallbackWhenAssetExist, useRef) {
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (useRef === void 0) { useRef = true; }
        this.batchLoadAsset(urls, Loader.TEXT, complete, syncCallbackWhenAssetExist, useRef);
    };
    AssetManager.loadFileArrayBuffer = function (url, complete, useRef, syncCallbackWhenAssetExist) {
        if (useRef === void 0) { useRef = true; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = true; }
        this.loadAsset(url, Loader.BUFFER, complete, syncCallbackWhenAssetExist, useRef);
    };
    AssetManager.loadAsset = function (url, type, complete, syncCallbackWhenAssetExist, useRef, isTexture, prerender) {
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (useRef === void 0) { useRef = true; }
        if (isTexture === void 0) { isTexture = false; }
        if (prerender === void 0) { prerender = false; }
        if (!url || typeof url !== "string") {
            complete && (syncCallbackWhenAssetExist ? complete.runWith([]) : complete.delayRun(1));
            return;
        }
        if (useRef)
            AssetManager.addRef(url);
        var asset = loader.getRes(url);
        if (asset) {
            if (isTexture && asset.bitmap && (type == Loader.IMAGE || type == "image_decrypt")) {
                (asset.bitmap).enableMerageInAtlas = false;
            }
            if (prerender && (type == Loader.IMAGE || type == "image_decrypt")) {
                var sp = new Sprite;
                sp.texture = asset;
                sp.texture["__rendered"] = true;
                AssetManager.prerender(sp);
                sp.texture = null;
                sp.destroy(true);
            }
            complete && (syncCallbackWhenAssetExist ? complete.runWith([asset]) : complete.delayRun(1, null, [asset]));
            return;
        }
        loader.load(url, Handler.create(this, function (asset) {
            if (!asset) {
                complete && complete.runWith([null]);
                return;
            }
            if (isTexture && asset.bitmap && (type == Loader.IMAGE || type == "image_decrypt")) {
                (asset.bitmap).enableMerageInAtlas = false;
            }
            if (prerender && (type == Loader.IMAGE || type == "image_decrypt")) {
                var sp = new Sprite;
                sp.texture = asset;
                sp.texture["__rendered"] = true;
                AssetManager.prerender(sp);
                sp.texture = null;
                sp.destroy(true);
            }
            complete && complete.runWith([asset]);
        }), null, type);
    };
    AssetManager.batchLoadAsset = function (urls, type, complete, syncCallbackWhenAssetExist, useRef, isTexture, prerender) {
        var _this_1 = this;
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (useRef === void 0) { useRef = true; }
        if (isTexture === void 0) { isTexture = false; }
        if (prerender === void 0) { prerender = false; }
        var loadUrls = [];
        for (var i in urls) {
            if (urls[i] && typeof urls[i] === "string")
                loadUrls.push(urls[i]);
        }
        if (loadUrls.length == 0) {
            complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(1));
            return;
        }
        var allExist = true;
        for (var i in loadUrls) {
            var url = loadUrls[i];
            if (useRef)
                AssetManager.addRef(url);
            var asset = loader.getRes(url);
            if (!asset) {
                allExist = false;
            }
        }
        if (allExist) {
            for (var i in loadUrls) {
                var url = loadUrls[i];
                var asset = loader.getRes(url);
                if (!asset)
                    continue;
                if (isTexture && asset.bitmap && (type == Loader.IMAGE || type == "image_decrypt")) {
                    if (isTexture)
                        (asset.bitmap).enableMerageInAtlas = false;
                }
                if (prerender && (type == Loader.IMAGE || type == "image_decrypt")) {
                    var sp = new Sprite;
                    sp.texture = asset;
                    sp.texture["__rendered"] = true;
                    AssetManager.prerender(sp);
                    sp.texture = null;
                    sp.destroy(true);
                }
            }
            complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(1));
        }
        else {
            loader.load(loadUrls, Handler.create(this, function () {
                var displayCount = loadUrls.length;
                var onDisplay = Callback.New(function () {
                    displayCount--;
                    if (displayCount == 0)
                        complete && complete.run();
                }, _this_1);
                for (var i in loadUrls) {
                    var url = loadUrls[i];
                    var asset = loader.getRes(url);
                    onDisplay.run();
                    if (!asset)
                        continue;
                    if (isTexture && asset.bitmap && (type == Loader.IMAGE || type == "image_decrypt")) {
                        if (isTexture)
                            (asset.bitmap).enableMerageInAtlas = false;
                    }
                    if (prerender && (type == Loader.IMAGE || type == "image_decrypt")) {
                        var sp = new Sprite;
                        sp.texture = asset;
                        sp.texture["__rendered"] = true;
                        AssetManager.prerender(sp);
                        sp.texture = null;
                        sp.destroy(true);
                    }
                }
            }), null, type);
        }
    };
    AssetManager.batchDisposeAsset = function (images, scenes, avatars, standAvatars, animations, uis, jsons, audios, dialogs) {
        if (images === void 0) { images = []; }
        if (scenes === void 0) { scenes = []; }
        if (avatars === void 0) { avatars = []; }
        if (animations === void 0) { animations = []; }
        if (uis === void 0) { uis = []; }
        if (jsons === void 0) { jsons = []; }
        if (audios === void 0) { audios = []; }
        if (dialogs === void 0) { dialogs = []; }
        for (var i = 0; i < images.length; i++) {
            var url = images[i];
            AssetManager.disposeImage(url);
        }
        for (var i = 0; i < scenes.length; i++) {
            this.disposeScene(scenes[i]);
        }
        for (var i = 0; i < avatars.length; i++) {
            this.disposeAvatarAsset(avatars[i]);
        }
        for (var i = 0; i < standAvatars.length; i++) {
            this.disposeStandAvatarAsset(standAvatars[i]);
        }
        for (var i = 0; i < animations.length; i++) {
            this.disposeAnimationAsset(animations[i]);
        }
        for (var i = 0; i < uis.length; i++) {
            this.disposeUIAsset(uis[i]);
        }
        for (var i = 0; i < jsons.length; i++) {
            var url = jsons[i];
            AssetManager.disposeJson(url);
        }
        for (var i = 0; i < audios.length; i++) {
            this.disposeAudio(audios[i]);
        }
        for (var i = 0; i < dialogs.length; i++) {
            AssetManager.disposeDialog(dialogs[i]);
        }
    };
    AssetManager.getImage = function (url) {
        var tex = loader.getRes(url);
        return tex;
    };
    AssetManager.getJson = function (url) {
        return loader.getRes(url);
    };
    AssetManager.getText = function (url) {
        return loader.getRes(url);
    };
    AssetManager.getFileArrayBuffer = function (url) {
        return loader.getRes(url);
    };
    AssetManager.disposeImage = function (url, force) {
        if (force === void 0) { force = false; }
        if (Config.EDIT_MODE)
            return;
        if (!url)
            return;
        function doDisposeImage(url) {
            AssetManager.imageAssets[url] = null;
            AssetManager.textureAssets[url] = null;
            delete AssetManager.assetCountMap[url];
            var t = loader.getRes(url);
            loader.clearRes(url, true);
            if (t && t.destroy) {
                t.destroy(true);
            }
        }
        if (force) {
            doDisposeImage(url);
            return;
        }
        Callback.New(function (url) {
            var ref = AssetManager.subRef(url);
            if (ref == 0)
                doDisposeImage(url);
        }, this, [url]).delayRun(AssetManager.disposeInterval);
    };
    AssetManager.disposeImages = function (urls, force) {
        if (force === void 0) { force = false; }
        if (Config.EDIT_MODE)
            return;
        if (!urls || urls.length == 0)
            return;
        for (var i in urls) {
            AssetManager.disposeImage(urls[i], force);
        }
    };
    AssetManager.disposeAudio = function (url, force) {
        if (force === void 0) { force = false; }
        if (Config.EDIT_MODE)
            return;
        if (!url)
            return;
        function doDisposeAudio(url) {
            delete AssetManager.assetCountMap[url];
            var s = loader.getRes(url);
            loader.clearRes(url, true);
            if (s && s.dispose)
                s.dispose();
        }
        if (force) {
            doDisposeAudio(url);
            return;
        }
        Callback.New(function (url) {
            var ref = AssetManager.subRef(url);
            if (ref == 0)
                doDisposeAudio(url);
        }, this, [url]).delayRun(AssetManager.disposeInterval);
    };
    AssetManager.disposeJson = function (url, force) {
        if (force === void 0) { force = false; }
        if (Config.EDIT_MODE || !url)
            return;
        function doDisposeJson(url) {
            delete AssetManager.assetCountMap[url];
            loader.clearRes(url, true);
        }
        if (force) {
            doDisposeJson(url);
            return;
        }
        Callback.New(function (url) {
            var ref = AssetManager.subRef(url);
            if (ref == 0)
                doDisposeJson(url);
        }, this, [url]).delayRun(force ? 0 : AssetManager.disposeInterval);
    };
    AssetManager.disposeText = function (url, force) {
        if (force === void 0) { force = false; }
        if (Config.EDIT_MODE || !url)
            return;
        function doDisposeText(url) {
            delete AssetManager.assetCountMap[url];
            loader.clearRes(url, true);
        }
        if (force) {
            doDisposeText(url);
            return;
        }
        Callback.New(function (url) {
            var ref = AssetManager.subRef(url);
            if (ref == 0)
                doDisposeText(url);
        }, this, [url]).delayRun(force ? 0 : AssetManager.disposeInterval);
    };
    AssetManager.disposeFileArrayBuffer = function (url, force) {
        if (force === void 0) { force = false; }
        if (Config.EDIT_MODE || !url)
            return;
        function doDisposeFileArrayBuffer(url) {
            delete AssetManager.assetCountMap[url];
            loader.clearRes(url, true);
        }
        if (force) {
            doDisposeFileArrayBuffer(url);
            return;
        }
        Callback.New(function (url) {
            var ref = AssetManager.subRef(url);
            if (ref == 0)
                doDisposeFileArrayBuffer(url);
        }, this, [url]).delayRun(force ? 0 : AssetManager.disposeInterval);
    };
    AssetManager.getClipImage = function (url, x, y, rect) {
        var tex = AssetManager.getImage(url);
        if (!tex)
            return null;
        var imageAssetClips = AssetManager.imageAssets[url];
        if (!imageAssetClips)
            imageAssetClips = AssetManager.imageAssets[url] = {};
        var key = x + "_" + y + "_" + rect.width + "_" + rect.height + "_" + rect.x + "_" + rect.y;
        var g = imageAssetClips[key];
        if (!g || (g && g["___useTexture"] != tex)) {
            g = imageAssetClips[key] = new Graphics();
            g.fillTexture(tex, x, y, rect.width, rect.height, null, new Point(rect.x, rect.y));
            g["___useTexture"] = tex;
        }
        return g;
    };
    AssetManager.getClipTexture = function (url, x, y, width, height) {
        var tex = AssetManager.getImage(url);
        if (!tex)
            return null;
        var textureAssetClips = AssetManager.textureAssets[url];
        if (!textureAssetClips)
            textureAssetClips = AssetManager.textureAssets[url] = {};
        var key = x + "_" + y + "_" + width + "_" + height;
        var texAsset = textureAssetClips[key];
        if (!texAsset || (texAsset && texAsset["___useTexture"] != tex)) {
            texAsset = textureAssetClips[key] = Texture.createFromTexture(tex, x, y, width, height);
            if (!texAsset)
                return null;
            texAsset["___useTexture"] = tex;
        }
        return texAsset;
    };
    AssetManager.drawToTexture = function (source, textureWidth, textureHeight, offsetX, offsetY, mipmap, minFifter, magFifter) {
        if (offsetX === void 0) { offsetX = 0; }
        if (offsetY === void 0) { offsetY = 0; }
        if (mipmap === void 0) { mipmap = false; }
        if (minFifter === void 0) { minFifter = 0x2600; }
        if (magFifter === void 0) { magFifter = 0x2600; }
        var helpSprite;
        if (source instanceof Graphics) {
            helpSprite = new Sprite();
            helpSprite.graphics = source;
            helpSprite.blendMode = null;
        }
        else {
            helpSprite = source;
        }
        var oldRect = helpSprite.scrollRect;
        helpSprite.scrollRect = new Rectangle(-offsetX, -offsetY, textureWidth, textureHeight);
        var t = _drawToTexture(helpSprite, textureWidth, textureHeight, 0, 0, mipmap, minFifter, magFifter);
        helpSprite.scrollRect = oldRect;
        var texture = new Texture(t.bitmap);
        return texture;
        function _drawToTexture(sprite, textureWidth, textureHeight, offsetX, offsetY, mipmap, minFifter, magFifter) {
            var _renderType = 640;
            offsetX -= sprite.x;
            offsetY -= sprite.y;
            sprite.scaleY *= -1;
            var oldSpriteScaleX = sprite.scaleX;
            var oldSpriteScaleY = sprite.scaleY;
            var sx = stage.width / os.canvas.width;
            var sy = stage.height / os.canvas.height;
            var specialHandle = (sx > 1 || sy > 1) && textureWidth >= os.canvas.width && textureHeight >= os.canvas.height;
            if (specialHandle) {
                sprite.scaleY /= sy;
                sprite.scaleX /= sx;
                var texSx = textureWidth / stage.width;
                var texSy = textureHeight / stage.height;
                sprite.scaleX *= texSx;
                sprite.scaleY *= texSy;
            }
            var renderTarget = RenderTarget2D.create(textureWidth, textureHeight, 0x1908, 0x1401, 0, mipmap, false, minFifter, magFifter);
            if (specialHandle) {
                renderTarget.bitmap["_w"] = Math.ceil(sx * stage.width);
                renderTarget.bitmap["_h"] = Math.ceil(sy * stage.height);
                renderTarget["_w"] = os.canvas.width * texSx;
                renderTarget["_h"] = os.canvas.height * texSy;
            }
            renderTarget.start();
            renderTarget.clear(0.0, 0.0, 0.0, 0.0);
            Render.context.clear();
            RenderSprite.renders[_renderType]._fun(sprite, Render.context, offsetX, RenderState2D.height + offsetY);
            if (specialHandle) {
                os.context.viewport(0, 0, os.canvas.width * texSx, os.canvas.height * texSy);
            }
            Render.context.flush();
            renderTarget.end();
            if (specialHandle) {
                sprite.scaleX = oldSpriteScaleX;
                sprite.scaleY = oldSpriteScaleY;
            }
            sprite.scaleY *= -1;
            return renderTarget;
        }
    };
    AssetManager.prerender = function (source) {
        var oldChilds = stage._childs;
        var oldScaleX = source.scaleX;
        source.scaleX = 0;
        stage._childs = [source];
        stage._loop();
        stage._childs = oldChilds;
        source.scaleX = oldScaleX;
    };
    AssetManager.drawToAtlasSprite = function (source, width, height, mipmap, minFifter, magFifter, offsetX, offsetY) {
        if (mipmap === void 0) { mipmap = false; }
        if (minFifter === void 0) { minFifter = -1; }
        if (magFifter === void 0) { magFifter = -1; }
        if (offsetX === void 0) { offsetX = 0; }
        if (offsetY === void 0) { offsetY = 0; }
        var root = new Sprite();
        var splitW = Math.ceil(width / Config.TILE_SPLIT_SIZE);
        var splitH = Math.ceil(height / Config.TILE_SPLIT_SIZE);
        for (var xGrid = 0; xGrid < splitW; xGrid++) {
            for (var yGrid = 0; yGrid < splitH; yGrid++) {
                var dx = -Config.TILE_SPLIT_SIZE * xGrid;
                var dy = -Config.TILE_SPLIT_SIZE * yGrid;
                var tex = AssetManager.drawToTexture(source, Config.TILE_SPLIT_SIZE, Config.TILE_SPLIT_SIZE, dx + offsetX, dy + offsetY, mipmap, minFifter, magFifter);
                var splitSp = new Sprite();
                splitSp.texture = tex;
                splitSp.x = -dx;
                splitSp.y = -dy;
                root.addChild(splitSp);
            }
        }
        return root;
    };
    AssetManager.bigTextureToAtlasSprite = function (texture, xLoop, yLoop, mapWidth, mapHeight) {
        if (xLoop === void 0) { xLoop = false; }
        if (yLoop === void 0) { yLoop = false; }
        if (mapWidth === void 0) { mapWidth = 0; }
        if (mapHeight === void 0) { mapHeight = 0; }
        var drawArea = [];
        if (xLoop) {
            drawArea.push([1, 0], [-1, 0]);
        }
        if (yLoop) {
            drawArea.push([0, 1], [0, -1]);
        }
        if (xLoop && yLoop) {
            drawArea.push([-1, -1], [1, -1], [1, 1], [-1, 1]);
        }
        var img = texture.bitmap["_image"];
        if (!img) {
            return new Sprite();
        }
        var maxW = Config.TILE_SPLIT_SIZE;
        var maxH = Config.TILE_SPLIT_SIZE;
        var root = new Sprite();
        var splitW = Math.ceil(img.width / maxW);
        var splitH = Math.ceil(img.height / maxW);
        for (var xGrid = 0; xGrid < splitW; xGrid++) {
            for (var yGrid = 0; yGrid < splitH; yGrid++) {
                var dx = maxW * xGrid;
                var dy = maxW * yGrid;
                var canvas = document.createElement("canvas");
                canvas.width = maxW;
                canvas.height = maxW;
                var canvas2d = document.createElement("canvas");
                canvas2d.width = maxW;
                canvas2d.height = maxW;
                var ctx = canvas2d.getContext("2d");
                ctx.drawImage(img, dx, dy, maxW, maxW, 0, 0, maxW, maxH);
                var wgImage = new WebGLImage(canvas2d, new Date().getTime() + Math.random().toString());
                var newTexture = new Texture(wgImage);
                var splitSp = new Sprite();
                splitSp.texture = newTexture;
                splitSp.x = dx;
                splitSp.y = dy;
                for (var s in drawArea) {
                    var loopSp = new Sprite();
                    loopSp.name = "loop";
                    loopSp.texture = newTexture;
                    root.addChild(loopSp);
                    loopSp.x = drawArea[s][0] * mapWidth + splitSp.x;
                    loopSp.y = drawArea[s][1] * mapHeight + splitSp.y;
                }
                root.addChild(splitSp);
            }
        }
        return root;
    };
    AssetManager.disposeAtlasSprite = function (root) {
        if (!root)
            return;
        for (var i = 0; i < root.numChildren; i++) {
            var sp = root.getChildAt(i);
            sp.texture.destroy(true);
            sp.texture = null;
        }
        root.removeChildren();
    };
    AssetManager.subRef = function (url) {
        var ref = AssetManager.assetCountMap[url];
        if (ref == null) {
            return 0;
        }
        ref--;
        if (ref == 0) {
            delete AssetManager.assetCountMap[url];
        }
        else {
            AssetManager.assetCountMap[url] = ref;
        }
        return ref;
    };
    AssetManager.addRef = function (url) {
        var ref = AssetManager.assetCountMap[url];
        if (ref == null) {
            AssetManager.assetCountMap[url] = ref = 0;
        }
        AssetManager.assetCountMap[url] = ++ref;
    };
    AssetManager.textureToBase64 = function (texture) {
        var sp = new Sprite();
        sp.texture = texture;
        var htmlCanvas = sp.drawToCanvas(texture.width, texture.height, 0, 0);
        var canvas = htmlCanvas.getCanvas();
        var base64 = canvas.toDataURL("image/png");
        htmlCanvas.dispose();
        return base64;
    };
    AssetManager.textureToArrayBuffer = function (texture) {
        var base64 = AssetManager.textureToBase64(texture);
        var arr = base64.split(',');
        var mime = arr[0].match(/:(.*?);/)[1];
        var bstr = atob(arr[1]);
        var n = bstr.length;
        var u8arr = new Uint8Array(n);
        while (n--) {
            u8arr[n] = bstr.charCodeAt(n);
        }
        return u8arr.buffer;
    };
    AssetManager.arrayBufferToBase64 = function (arrayBuffer) {
        var binary = "";
        var bytes = new Uint8Array(arrayBuffer);
        var len = bytes.byteLength;
        for (var i = 0; i < len; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        var base64 = "data:image/jpeg;base64," + window.btoa(binary);
        return base64;
    };
    AssetManager.base64ToArrayBuffer = function (base64) {
        var arr = base64.split(',');
        var bstr = window.atob(arr[1]);
        var n = bstr.length;
        var u8arr = new Uint8Array(n);
        while (n--) {
            u8arr[n] = bstr.charCodeAt(n);
        }
        return u8arr.buffer;
    };
    AssetManager.base64ToTexture = function (base64, callback) {
        var buffer = AssetManager.base64ToArrayBuffer(base64);
        AssetManager.arrayBufferToTexture(buffer, callback);
    };
    AssetManager.arrayBufferToTexture = function (arrayBuffer, callback) {
        var blob = new Blob([arrayBuffer], { type: "image/png" });
        var url = URL.createObjectURL(blob);
        var image;
        var onload = function () {
            var tex = new Texture(image);
            callback && callback.runWith([tex]);
        };
        var onerror = function () {
            callback && callback.runWith([]);
        };
        new HTMLImage.create(url, {
            onload: onload, onerror: onerror, onCreate: function (img) {
                image = img;
            }
        });
    };
    AssetManager.preloadFonts = function (complete, syncCallbackWhenAssetExist) {
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        var list = Config.FONTS ? Config.FONTS : [];
        var allExist = true;
        for (var i = 0; i < list.length; i++) {
            var name = list[i].name;
            var fontFace = FontLoadManager.getFontByName(name);
            if (!fontFace)
                allExist = false;
        }
        if (allExist) {
            complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(1));
        }
        else {
            FontLoadManager.loadFontFile(list, complete);
        }
    };
    AssetManager.preloadFont = function (fontUrl, complete, syncCallbackWhenAssetExist) {
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (!fontUrl) {
            complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(1));
            return;
        }
        var arr = fontUrl.split("/");
        var fullname = arr.pop();
        var arr2 = fullname.split(".");
        var ext = arr2.pop();
        var name = arr2.join(".");
        var fontFace = FontLoadManager.getFontByName(name);
        if (fontFace) {
            complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(1));
        }
        else {
            var font = { name: name, path: fontUrl, fonttype: ext, size: 0 };
            FontLoadManager.loadFontFile([font], complete);
        }
    };
    AssetManager.saveScreenshot = function (screenTexBase64, screenshotName, onFin) {
        if (onFin === void 0) { onFin = null; }
        var imgFolder = "asset/image/screenshot/";
        var localURL = imgFolder + screenshotName + ".png";
        var indiaAppGameInfo = Config.INDIA_APPLICATION_GAME_INFO;
        if (indiaAppGameInfo) {
            var rq = new HttpRequest();
            var data = JSON.stringify({ mode: 7, localURL: localURL, content: screenTexBase64 });
            var IDEHttpServerURL = "http://127.0.0.1:" + indiaAppGameInfo.gcDebugPort + "/kdsrpg_http_indieapp.js?cmd=3";
            rq.send(IDEHttpServerURL, data, "post");
            rq.add_ERROR(function () {
                onFin && onFin.delayRun(0, null, [false]);
            }, this);
            rq.add_COMPLETE(function (str) {
                onFin && onFin.delayRun(0, null, [str == "ok"]);
            }, this);
            return;
        }
        if (!Config.EDIT_MODE && (os.platform != 2)) {
            var screenshotJson = { base64: screenTexBase64, isScreenshot: true };
            if (IndexedDBManager.support && IndexedDBManager.used) {
                IndexedDBManager.setIndexDBJson(localURL, screenshotJson, function (success) {
                    onFin && onFin.delayRun(0, null, [success]);
                });
            }
            else {
                LocalStorage.setJSON(localURL, screenshotJson);
                onFin && onFin.delayRun(0, null, [true]);
            }
            return;
        }
        if (typeof mainDomain_fs == "undefined" || typeof mainDomain_Buffer == "undefined") {
            onFin && onFin.delayRun(0, null, [false]);
            return;
        }
        try {
            var isExists = mainDomain_fs.existsSync(FileUtils.nativePath + "/" + imgFolder);
            if (!isExists)
                FileUtils.createDirectoryForce(imgFolder, Callback.New(function (success) {
                    if (!success)
                        onFin && onFin.delayRun(0, null, [false]);
                    else
                        toSaveScreenShotImg();
                }, this));
            else {
                toSaveScreenShotImg();
            }
            function toSaveScreenShotImg() {
                var imgtype = 'png';
                var _fixType = function (img) {
                    img = img.toLowerCase().replace(/jpg/i, 'jpeg');
                    var r = img.match(/png|jpeg|bmp|gif/)[0];
                    return 'image/' + r;
                };
                screenTexBase64 = screenTexBase64.replace(_fixType(imgtype), 'image/png');
                var base64Data = screenTexBase64.replace(/^data:image\/\w+;base64,/, "");
                var dataBuffer = mainDomain_Buffer.from(base64Data, 'base64');
                mainDomain_fs.writeFile(FileUtils.nativePath + "/" + localURL, dataBuffer, function (err) {
                    onFin.delayRun(0, null, [err ? false : true]);
                });
            }
        }
        catch (e) {
            onFin && onFin.delayRun(0, null, [false]);
        }
    };
    AssetManager.loadScreenshot = function (screenshotName, onFin) {
        if (onFin === void 0) { onFin = null; }
        var imgFolder = "asset/image/screenshot/";
        var localURL = imgFolder + screenshotName + ".png";
        var indiaAppGameInfo = Config.INDIA_APPLICATION_GAME_INFO;
        if (indiaAppGameInfo) {
            onFin && onFin.runWith([localURL]);
            return;
        }
        if (!Config.EDIT_MODE && (os.platform != 2)) {
            if (IndexedDBManager.support && IndexedDBManager.used) {
                IndexedDBManager.getIndexDBJson(localURL, function (value) {
                    onFin && onFin.runWith([value ? value.base64 : ""]);
                });
            }
            else {
                var storage = LocalStorage.getJSON(localURL);
                onFin && onFin.runWith([storage ? storage.base64 : ""]);
            }
            return;
        }
        onFin && onFin.runWith([localURL]);
    };
    AssetManager.deleteScreenshot = function (screenshotName, onFin) {
        if (onFin === void 0) { onFin = null; }
        var imgFolder = "asset/image/screenshot/";
        var localURL = imgFolder + screenshotName + ".png";
        var indiaAppGameInfo = Config.INDIA_APPLICATION_GAME_INFO;
        if (indiaAppGameInfo) {
            FileUtils.deleteFile(localURL, onFin);
            return;
        }
        if (!Config.EDIT_MODE && (os.platform != 2)) {
            if (IndexedDBManager.support && IndexedDBManager.used) {
                IndexedDBManager.removeIndexDBItem(localURL, function (success) {
                    onFin && onFin.runWith([success]);
                });
            }
            else {
                LocalStorage.removeItem(localURL);
                onFin && onFin.runWith([true]);
            }
            return;
        }
        FileUtils.deleteFile(localURL, onFin);
    };
    AssetManager.deleteAllScreenshot = function (onFin) {
        if (onFin === void 0) { onFin = null; }
        var imgFolder = "asset/image/screenshot/";
        var indiaAppGameInfo = Config.INDIA_APPLICATION_GAME_INFO;
        if (indiaAppGameInfo) {
            FileUtils.deleteFile(imgFolder, onFin);
            return;
        }
        if (!Config.EDIT_MODE && (os.platform != 2)) {
            if (IndexedDBManager.support && IndexedDBManager.used) {
                var items = [];
                IndexedDBManager.items(function (list) {
                    for (var key in list) {
                        var indexStr = list[key];
                        if (!indexStr || typeof indexStr != "string")
                            continue;
                        var indexItem = JSON.parse(indexStr);
                        if (!indexItem || !indexItem.isScreenshot)
                            continue;
                        items.push(key);
                        IndexedDBManager.removeIndexDBItem(key);
                    }
                    items.forEach(function (v) {
                        IndexedDBManager.removeIndexDBItem(key);
                    });
                    onFin && onFin.runWith([true]);
                });
            }
            else {
                var list = [];
                for (var key in LocalStorage.items) {
                    var storageStr = LocalStorage.items[key];
                    if (!storageStr || typeof storageStr != "string")
                        continue;
                    var storageItem = JSON.parse(storageStr);
                    if (!storageItem || !storageItem.isScreenshot)
                        continue;
                    list.push(key);
                }
                list.forEach(function (v) {
                    LocalStorage.removeItem(v);
                });
                onFin && onFin.runWith([true]);
            }
            return;
        }
        FileUtils.deleteFile(imgFolder, onFin);
    };
    AssetManager.assetCountMap = {};
    AssetManager.imageAssets = {};
    AssetManager.textureAssets = {};
    AssetManager.disposeInterval = 60000;
    AssetManager.preUIs = [];
    AssetManager.commandPerloadCache = [];
    return AssetManager;
}());















var ClientScene = (function (_super) {
    __extends(ClientScene, _super);
    function ClientScene() {
        var _this_1 = _super.call(this) || this;
        _this_1.mapSupportPause = true;
        _this_1.players = [];
        _this_1.sceneObjects = [];
        _this_1.settingLayers = [];
        _this_1.layers = [];
        _this_1.camera = new Camera();
        if (typeof GameSprite == "undefined")
            return _this_1;
        _this_1.displayObject = new GameSprite();
        _this_1.displayObjectView = new GameSprite();
        _this_1.displayObject.addChild(_this_1.displayObjectView);
        _this_1.camera.viewPort.setTo(0, 0, Config.WINDOW_WIDTH, Config.WINDOW_HEIGHT);
        if (typeof Game == "undefined")
            return _this_1;
        EventUtils.addEventListener(Game, Game.EVENT_PAUSE_CHANGE, Callback.New(_this_1.onPauseChange, _this_1));
        return _this_1;
    }
    ClientScene.createScene = function (sceneID, onBaseDataLoaded, onLoaded, syncCallbackWhenAssetExist) {
        var _this_1 = this;
        if (onBaseDataLoaded === void 0) { onBaseDataLoaded = null; }
        if (onLoaded === void 0) { onLoaded = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        AssetManager.loadJson("asset/json/scene/data/scene" + sceneID + ".json", Callback.New(function (mapData) {
            if (!mapData) {
                console.log("Error: Scene Do Not Exist");
                return;
            }
            var cls = mapData.clientInstanceClassName;
            var classImpl = globalThis[cls];
            var scene = (classImpl && classImpl.prototype instanceof ClientScene) ? new classImpl : new ClientScene();
            scene.isSetScene = true;
            scene.id = sceneID;
            scene.parse(mapData, Common.gameData);
            if (scene.createSceneLoadExt) {
                scene.createSceneLoadExt(onBaseDataLoadedFunction);
            }
            else {
                onBaseDataLoadedFunction.apply(_this_1);
            }
            function onBaseDataLoadedFunction() {
                scene.event(ClientScene.BASE_DATA_LOADED, [scene]);
                onBaseDataLoaded && onBaseDataLoaded.runWith([scene]);
                scene.install(Callback.New(function () {
                    scene.event(EventObject.LOADED, [scene]);
                    onLoaded && onLoaded.runWith([scene]);
                }, scene));
            }
        }, this), syncCallbackWhenAssetExist);
    };
    ClientScene.prototype.dispose = function () {
        if (!this.isDisposed) {
            this.event(GameSprite.ON_DISPOSE);
            this.isDisposed = true;
            AssetManager.disposeJson("asset/json/scene/data/scene" + this.id + ".json");
            this.stopRender();
            this.displayObject.removeSelf();
            for (var i in this.layers) {
                this.layers[i].dispose();
            }
            for (var i in this.sceneObjects) {
                var so = this.sceneObjects[i];
                if (so)
                    so.dispose();
            }
            this.displayObject.dispose();
            this.sceneObjects.length = 0;
        }
    };
    ClientScene.prototype.install = function (onFin) {
        this.settingLayers.length = 0;
        var oldLayers = this.layers.concat();
        for (var i = 0; i < oldLayers.length; i++) {
            oldLayers[i].dispose();
        }
        this.layers.length = this.settingLayers.length = 0;
        if (!Config.EDIT_MODE)
            this.displayObject.hitArea = new Rectangle(-this.width, -this.height, this.width * 2, this.height * 2);
        for (var i = 0; i < this.LayerDatas.length; i++) {
            var layerData = this.LayerDatas[i];
            var layer = new ClientSceneLayer(this);
            if (!layerData.p) {
                new SyncTask(ClientScene.TASK_INSTALL, function () { });
                layer.install(layerData, Callback.New(SyncTask.taskOver, SyncTask, [ClientScene.TASK_INSTALL]));
            }
            this.addLayer(layer);
            this.settingLayers.push(layer);
            if (layerData.p)
                this.sceneObjectLayer = layer;
        }
        var sceneObjectLayerIndex = this.layers.indexOf(this.sceneObjectLayer);
        this.sceneObjectLowLayer = new ClientSceneLayer(this);
        this.addLayerAt(this.sceneObjectLowLayer, sceneObjectLayerIndex);
        this.animationLowLayer = new ClientSceneLayer(this);
        this.addLayerAt(this.animationLowLayer, sceneObjectLayerIndex);
        this.shadowLayer = new ClientSceneLayer(this);
        this.addLayerAt(this.shadowLayer, sceneObjectLayerIndex);
        var layerArr = ["sceneObjectHighLayer", "animationHighLayer", "fogLayer", "weaterLayer"];
        for (var s in layerArr) {
            layer = this[layerArr[s]] = new ClientSceneLayer(this);
            this.addLayer(layer);
        }
        this.sceneObjectLowLayer.isChangeChildZOrder = true;
        this.sceneObjectLayer.isChangeChildZOrder = true;
        this.sceneObjectHighLayer.isChangeChildZOrder = true;
        if (this.camera.viewPort.width > this.width) {
            this.camera.viewPort.width = this.width;
        }
        if (this.camera.viewPort.height > this.height) {
            this.camera.viewPort.height = this.height;
        }
        new SyncTask(ClientScene.TASK_INSTALL, function () {
            onFin.run();
            SyncTask.taskOver(ClientScene.TASK_INSTALL);
        });
    };
    ClientScene.prototype.refreshSceneSystemLayers = function () {
        this.layers.length = 0;
        this.displayObjectView.removeChildren();
        for (var i = 0; i < this.settingLayers.length; i++) {
            var layer = this.settingLayers[i];
            this.addLayer(layer);
        }
        var sceneObjectLayerIndex = this.layers.indexOf(this.sceneObjectLayer);
        this.addLayerAt(this.sceneObjectLowLayer, sceneObjectLayerIndex);
        this.addLayerAt(this.animationLowLayer, sceneObjectLayerIndex);
        this.addLayerAt(this.shadowLayer, sceneObjectLayerIndex);
        var layerArr = ["sceneObjectHighLayer", "animationHighLayer", "fogLayer", "weaterLayer"];
        for (var s in layerArr) {
            layer = this[layerArr[s]];
            this.addLayer(layer);
        }
    };
    ClientScene.prototype.addLayer = function (layer) {
        this.displayObjectView.addChild(layer);
        this.layers.push(layer);
    };
    ClientScene.prototype.addLayerAt = function (layer, index) {
        this.displayObjectView.addChildAt(layer, index);
        this.layers.splice(index, 0, layer);
    };
    ClientScene.prototype.removeLayer = function (layer) {
        this.displayObjectView.removeChild(layer);
        this.layers.splice(this.layers.indexOf(layer), 1);
    };
    ClientScene.prototype.removeLayerAt = function (index) {
        this.displayObjectView.removeChildAt(index);
        this.layers.splice(index, 1);
    };
    ClientScene.prototype.setLayerIndex = function (layer, index) {
        this.displayObjectView.setChildIndex(layer, index);
        ArrayUtils.setIndex(this.layers, layer, index);
    };
    ClientScene.prototype.getLayerLength = function () {
        return this.layers.length;
    };
    ClientScene.prototype.getLayer = function (index) {
        return this.layers[index];
    };
    ClientScene.prototype.getLayerByPreset = function (id) {
        return ArrayUtils.get(this.settingLayers, id - 1);
    };
    ClientScene.prototype.getLayerByName = function (name) {
        return ArrayUtils.matchAttributes(this.settingLayers, { name: name }, true)[0];
    };
    ClientScene.prototype.addSceneObject = function (soData, isEntity, useModelClass, className) {
        if (isEntity === void 0) { isEntity = false; }
        if (useModelClass === void 0) { useModelClass = false; }
        if (className === void 0) { className = null; }
        var lastSo = this.sceneObjects[soData.index];
        if (lastSo && lastSo != soData) {
            return null;
        }
        var soc;
        if (isEntity) {
            soc = soData;
        }
        else {
            if (useModelClass) {
                if (Config.useNewSceneObjectModel) {
                    var fixModelData = Common.sceneObjectModelList.data[0];
                }
                else {
                    var fixModelData = Common.sceneObjectModelList.data[soData.modelID];
                }
                if (fixModelData) {
                    var cls;
                    if (className && window[className]) {
                        cls = window[className];
                    }
                    else if (fixModelData.clientInstanceClassName && window[fixModelData.clientInstanceClassName]) {
                        cls = window[fixModelData.clientInstanceClassName];
                    }
                    else {
                        cls = SceneObjectModelData.sceneObjectClass[soData.modelID];
                    }
                    if (!cls)
                        cls = ClientSceneObject;
                    soc = new cls(soData, this);
                }
                else {
                    soc = new ClientSceneObject(soData, this);
                }
            }
            else {
                soc = new ClientSceneObject(soData, this);
            }
        }
        var needInScene = soData.persetData ? soc.inScene : true;
        this.sceneObjects[soData.index] = soc;
        soc.inScene = needInScene;
        soc.scene = this;
        if (needInScene) {
            if (soc.layerLevel == 0) {
                this.sceneObjectLowLayer.addChild(soc.root);
                this.sceneObjectLowLayer.updateChildZOrder();
            }
            else if (soc.layerLevel == 1) {
                this.sceneObjectLayer.addChild(soc.root);
                this.sceneObjectLayer.updateChildZOrder();
            }
            else {
                this.sceneObjectHighLayer.addChild(soc.root);
                this.sceneObjectHighLayer.updateChildZOrder();
            }
            this.shadowLayer.addChild(soc.shadow);
            Callback.CallLaterBeforeRender(soc.refreshCoordinate, soc);
        }
        if (Game.pause)
            soc.stopRender(true);
        return soc;
    };
    ClientScene.prototype.removeSceneObject = function (so, removeFromList) {
        if (removeFromList === void 0) { removeFromList = true; }
        var soc = this.sceneObjects[so.index];
        if (removeFromList)
            this.sceneObjects[so.index] = null;
        if (soc) {
            if (removeFromList && !Config.EDIT_MODE && !Config.BEHAVIOR_EDIT_MODE && Config.SINGLE_PLAYER_CORE) {
                for (var i = 0; i < this.sceneObjects.length; i++) {
                    var tSo = this.sceneObjects[i];
                    if (!tSo || tSo == soc)
                        continue;
                    for (var s1 in tSo.triggerLines) {
                        var tSoTrigger = tSo.triggerLines[s1];
                        if (tSoTrigger && (tSoTrigger.executor == soc || tSoTrigger.trigger == soc)) {
                            tSoTrigger.dispose();
                        }
                    }
                    for (var s2 in tSo.triggerSingleLines) {
                        var tSoTrigger = tSo.triggerSingleLines[s2];
                        if (tSoTrigger && (tSoTrigger.executor == soc || tSoTrigger.trigger == soc)) {
                            tSoTrigger.dispose();
                            delete tSo.triggerSingleLines[s2];
                        }
                    }
                }
            }
            soc.root.removeSelf();
            soc.shadow.removeSelf();
            soc.inScene = false;
        }
        return soc;
    };
    ClientScene.prototype.getPresetSceneObjectDatas = function () {
        var sceneData = Game.data.sceneList.data[this.id];
        var sceneObjDatas = sceneData.sceneObjectData;
        var sceneObjects = sceneObjDatas.sceneObjects;
        return sceneObjects;
    };
    ClientScene.prototype.addNewSceneObject = function (modelID, presetSceneObjectData, soSwitchs, recordData) {
        if (presetSceneObjectData === void 0) { presetSceneObjectData = null; }
        if (soSwitchs === void 0) { soSwitchs = null; }
        if (recordData === void 0) { recordData = null; }
        if (!Game.currentScene)
            return;
        var modelData = Game.data.sceneObjectModelList.data[modelID];
        if (modelData) {
            var fixModelData = Config.useNewSceneObjectModel ? Game.data.sceneObjectModelList.data[0] : modelData;
            var presetCustomAttrs = CustomAttributeSetting.formatCustomData(null, fixModelData.varAttributes);
            var so = new SceneObject();
            if (presetSceneObjectData)
                ObjectUtils.clone(presetSceneObjectData, so);
            SceneObject.installCustomData(so, presetCustomAttrs);
            so.index = ArrayUtils.getNullPosition(this.sceneObjects);
            if (recordData && recordData.index != null && this.sceneObjects[recordData.index] == null) {
                so.index = recordData.index;
            }
            var eventData = {
                condition: [],
                customCommands: []
            };
            var sceneData = Game.data.sceneList.data[this.id];
            var modulesCustomAttribute = [];
            if (Config.useNewSceneObjectModel) {
                so.moduleIDs = modelData.presetModules.concat();
                for (var i_8 = 0; i_8 < so.moduleIDs.length; i_8++) {
                    var moduleID = so.moduleIDs[i_8];
                    var moduleData = Game.data.sceneObjectModuleList.data[moduleID];
                    if (moduleData) {
                        modulesCustomAttribute.push(CustomAttributeSetting.formatCustomData(null, moduleData.varAttributes));
                    }
                    else {
                        so.moduleIDs.splice(i_8, 1);
                        i_8--;
                    }
                }
            }
            so.persetData = {
                sceneObjectData: sceneData ? sceneData.sceneObjectData : new SceneObjectData(),
                fromSceneObjectindex: Game.player.sceneObject.index,
                soData: so,
                customAttr: presetCustomAttrs,
                eventData: eventData,
                soSwitchs: soSwitchs,
                soIndex: so.index,
                recordData: recordData,
                moduleCustomAttrs: modulesCustomAttribute
            };
            var soc = this.addSceneObject(so, false, true, presetSceneObjectData === null || presetSceneObjectData === void 0 ? void 0 : presetSceneObjectData.className);
            soc.allowAutoSave = true;
            soc.persetData = null;
            return soc;
        }
    };
    ClientScene.prototype.addSceneObjectFromClone = function (fromSceneID, fromSceneObjectindex, isCopy, presetSceneObjectData, soSwitchs, recordData) {
        if (isCopy === void 0) { isCopy = true; }
        if (presetSceneObjectData === void 0) { presetSceneObjectData = null; }
        if (soSwitchs === void 0) { soSwitchs = null; }
        if (recordData === void 0) { recordData = null; }
        if (fromSceneID < 0 || fromSceneObjectindex < 0)
            return;
        var sceneData = Game.data.sceneList.data[fromSceneID];
        if (!sceneData)
            return null;
        var globalSoData = sceneData.sceneObjectData.sceneObjects[fromSceneObjectindex];
        if (!globalSoData)
            return null;
        var globalSoDataClone = SceneObject.__gcClone(globalSoData);
        if (typeof presetSceneObjectData == "boolean")
            presetSceneObjectData = null;
        if (presetSceneObjectData) {
            ObjectUtils.clone(presetSceneObjectData, globalSoDataClone);
        }
        var soData = new SceneObject();
        for (var s in SceneObject.statusCommonAttributes) {
            soData[s] = globalSoDataClone[s];
        }
        var customAttr = sceneData.sceneObjectData.customAttributes[fromSceneObjectindex];
        var eventData = sceneData.sceneObjectData.events[fromSceneObjectindex];
        if (Config.useNewSceneObjectModel) {
            var modulesCustomAttribute = sceneData.sceneObjectData.modulesCustomAttributes[fromSceneObjectindex];
        }
        var toIndex = recordData ? recordData.index : fromSceneObjectindex;
        if (Game.currentScene.sceneObjects[toIndex]) {
            soData.index = ArrayUtils.getNullPosition(Game.currentScene.sceneObjects);
        }
        else {
            soData.index = toIndex;
        }
        soData["_isCopy"] = isCopy;
        if (!isCopy && !soSwitchs) {
            soSwitchs = SinglePlayerGame.getSceneObjectSwitch(fromSceneID, fromSceneObjectindex);
        }
        soData.persetData = {
            sceneObjectData: sceneData.sceneObjectData,
            fromSceneObjectindex: fromSceneObjectindex,
            soData: globalSoDataClone,
            customAttr: customAttr,
            eventData: eventData,
            soSwitchs: soSwitchs,
            soIndex: soData.index,
            recordData: recordData,
            moduleCustomAttrs: modulesCustomAttribute
        };
        var soc = this.addSceneObject(soData, false, true);
        soc.allowAutoSave = true;
        soc.persetData = null;
        soc["_isCopy"] = isCopy;
        soc["_copyFrom"] = { sceneID: fromSceneID, sceneObjectIndex: fromSceneObjectindex };
        return soc;
    };
    ClientScene.prototype.addPlayer = function (player) {
        if (this.players.indexOf(player) == -1)
            this.players.push(player);
    };
    ClientScene.prototype.removePlayer = function (player) {
        ArrayUtils.remove(this.players, player);
    };
    Object.defineProperty(ClientScene.prototype, "localX", {
        get: function () {
            if (!this.displayObjectView.scrollRect)
                return 0;
            return this.displayObjectView.mouseX - (this.displayObjectView.scrollRect.x / this.displayObjectView.scaleX) + this.displayObjectView.scrollRect.x;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ClientScene.prototype, "localY", {
        get: function () {
            if (!this.displayObjectView.scrollRect)
                return 0;
            return this.displayObjectView.mouseY - (this.displayObjectView.scrollRect.y / this.displayObjectView.scaleY) + this.displayObjectView.scrollRect.y;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ClientScene.prototype, "globalPos", {
        get: function () {
            return this.getGlobalPos(this.displayObjectView.mouseX, this.displayObjectView.mouseY);
        },
        enumerable: false,
        configurable: true
    });
    ClientScene.prototype.getGlobalPos = function (localX, localY) {
        var sceneP = new Point(localX, localY);
        var globalP = this.displayObjectView.localToGlobal(sceneP);
        return globalP;
    };
    ClientScene.prototype.onPauseChange = function () {
        for (var i = 0; i < this.sceneObjects.length; i++) {
            var so = this.sceneObjects[i];
            if (so) {
                Game.pause ? so.stopRender(true) : so.recoveryRender(true);
            }
        }
    };
    ClientScene.prototype.setViewPort = function (isLimit) {
        if (isLimit === void 0) { isLimit = true; }
        if (this.isDisposed)
            return;
        this.displayObject.scaleX = this.camera.scaleX;
        this.displayObject.scaleY = this.camera.scaleY;
        var rect = this.camera.viewPort;
        var camera = this.camera;
        var viewW = this.width * camera.scaleX;
        var viewH = this.height * camera.scaleY;
        if (!Config.EDIT_MODE) {
            if (viewW < Config.WINDOW_WIDTH) {
                rect.width = Config.WINDOW_WIDTH;
                isLimit = false;
            }
            if (viewH < Config.WINDOW_HEIGHT) {
                rect.height = Config.WINDOW_HEIGHT;
                isLimit = false;
            }
        }
        if (this.displayObject.scaleX != 1 || this.displayObject.scaleY != 1) {
            rect = rect.clone();
            var sw = (1 / this.displayObject.scaleX) * rect.width - rect.width;
            var sh = (1 / this.displayObject.scaleY) * rect.height - rect.height;
            this["__sw"] = sw;
            this["__sh"] = sh;
            rect.x -= sw * 0.5;
            rect.y -= sh * 0.5;
            rect.width += sw;
            rect.height += sh;
        }
        if ((isLimit && !this.editorMode) || this.forceLimitView) {
            if (rect.x > this.width - rect.width)
                rect.x = this.width - rect.width;
            if (rect.y > this.height - rect.height)
                rect.y = this.height - rect.height;
            if (rect.x < 0)
                rect.x = 0;
            if (rect.y < 0)
                rect.y = 0;
        }
        var cloneRect;
        if (this.camera.offsetX != 0 || this.camera.offsetY != 0) {
            rect = rect.clone();
            rect.x += this.camera.offsetX;
            rect.y += this.camera.offsetY;
            cloneRect = true;
        }
        if (this.camera.rotation == 0) {
            this.displayObjectView.x = this.displayObjectView.y = this.displayObject.x = this.displayObject.y = 0;
        }
        else {
            var sx = this.displayObject.scaleX;
            var sy = this.displayObject.scaleY;
            var dx = (rect.width * (1 - sx) * 0.5);
            var dy = (rect.height * (1 - sy) * 0.5);
            var hw = rect.width * 0.5;
            var hh = rect.height * 0.5;
            this.displayObjectView.x = -rect.width;
            this.displayObjectView.y = -rect.height;
            this.displayObject.x = hw - dx;
            this.displayObject.y = hh - dy;
            if (!cloneRect)
                rect = rect.clone();
            rect.x -= hw;
            rect.y -= hh;
            rect.width *= 2;
            rect.height *= 2;
        }
        this.displayObjectView.scrollRect = rect;
        this.displayObject.rotation = this.camera.rotation;
        var len = this.displayObjectView.numChildren;
        for (var i = 0; i < len; i++) {
            var layer = this.displayObjectView.getChildAt(i);
            layer.setViewPort(rect);
        }
    };
    ClientScene.prototype.startRender = function () {
        this.stopRender();
        os.add_ENTERFRAME(this.onRender, this);
    };
    ClientScene.prototype.stopRender = function (LayerMoveToZero) {
        if (LayerMoveToZero === void 0) { LayerMoveToZero = false; }
        os.remove_ENTERFRAME(this.onRender, this);
        if (LayerMoveToZero) {
            for (var i = 0; i < this.layers.length; i++) {
                var layer = this.layers[i];
                layer.onRender(LayerMoveToZero);
            }
        }
    };
    ClientScene.prototype.updateCamera = function () {
        if (this.camera.sceneObject) {
            this.camera.viewPort.x = Math.floor(this.camera.sceneObject.x - this.camera.viewPort.width * 0.5);
            this.camera.viewPort.y = Math.floor(this.camera.sceneObject.y - this.camera.viewPort.height * 0.5);
        }
        this.setViewPort(true);
    };
    ClientScene.prototype.onRender = function () {
        var now = Game.now;
        if (this.mapSupportPause && Game.pause)
            return;
        this.updateCamera();
        for (var i = 0; i < this.layers.length; i++) {
            var layer = this.layers[i];
            layer.onRender();
        }
        for (var s in this.sceneObjects) {
            var soc = this.sceneObjects[s];
            if (!soc)
                continue;
            soc.update(now);
        }
    };
    ClientScene.prototype.hasListener = function (type) { return this.displayObject.hasListener.apply(this.displayObject, arguments); };
    ;
    ClientScene.prototype.event = function (type, data) { return this.displayObject.event.apply(this.displayObject, arguments); };
    ;
    ClientScene.prototype.on = function (type, caller, listener, args) { return this.displayObject.on.apply(this.displayObject, arguments); };
    ;
    ClientScene.prototype.once = function (type, caller, listener, args) { return this.displayObject.once.apply(this.displayObject, arguments); };
    ;
    ClientScene.prototype.off = function (type, caller, listener, onceOnly) { return this.displayObject.off.apply(this.displayObject, arguments); };
    ;
    ClientScene.prototype.offAll = function (type) { return this.displayObject.offAll.apply(this, arguments); };
    ;
    ClientScene.BASE_DATA_LOADED = "ClientScene_BASE_DATA_LOADED";
    ClientScene.EVENT_IN_NEW_SCENE = "ClientSceneEVENT_IN_NEW_SCENE";
    ClientScene.TASK_INSTALL = "ClientScene_TASK_INSTALL";
    return ClientScene;
}(Scene));
ObjectUtils.reDefineGetSet("ClientScene.prototype", {
    id: function (v) {
        var _this_1 = this;
        if (!this.isSetScene) {
            this.isSetScene = true;
            if (!Config.EDIT_MODE) {
                AssetManager.loadJson("asset/json/scene/data/scene" + this.id + ".json", Callback.New(function (mapData) {
                    if (!mapData)
                        return;
                    _this_1.parse(mapData, Common.gameData);
                    if (_this_1.createSceneLoadExt) {
                        _this_1.createSceneLoadExt(onBaseDataLoadedFunction);
                    }
                    else {
                        onBaseDataLoadedFunction.apply(_this_1);
                    }
                    function onBaseDataLoadedFunction() {
                        var _this_1 = this;
                        this.event(ClientScene.BASE_DATA_LOADED, [this]);
                        this.install(Callback.New(function () {
                            _this_1.event(EventObject.LOADED, [_this_1]);
                        }, this));
                    }
                }, this));
            }
        }
    }
});















var ClientSceneObject = (function (_super) {
    __extends(ClientSceneObject, _super);
    function ClientSceneObject(soData, scene) {
        if (scene === void 0) { scene = null; }
        var _this_1 = _super.call(this, soData ? soData.persetData : null) || this;
        _this_1.___animations = [];
        _this_1.scene = scene;
        if (!soData)
            return _this_1;
        if (!soData.persetData) {
            _this_1.____beforeInstallAttributeInit();
            if (soData) {
                if (Config.EDIT_MODE) {
                    ObjectUtils.clone(soData, _this_1);
                    for (var i in SceneObject.compoundAttributes) {
                        var attrName = SceneObject.compoundAttributes[i];
                        _this_1[attrName] = ObjectUtils.depthClone(soData[attrName]);
                    }
                }
                else {
                    ObjectUtils.clone(soData, _this_1);
                }
            }
            _this_1.____afterInstallAttributeInit();
            if (Config.useNewSceneObjectModel) {
                if (!Config.EDIT_MODE && soData == Game.player.data.sceneObject) {
                    if (!_this_1.moduleIDs)
                        _this_1.moduleIDs = [];
                    if (!_this_1.moduleDisplayList)
                        _this_1.moduleDisplayList = [];
                    var moduleIDs = _this_1.moduleIDs.concat();
                    var moduleDisplayList = _this_1.moduleDisplayList.concat();
                    var presetData = null;
                    if (Game.player.data.sceneObject.___gcRestoreModules) {
                        presetData = Game.player.data.sceneObject.___gcRestoreModules;
                        delete Game.player.data.sceneObject.___gcRestoreModules;
                    }
                    _this_1.installModulesByTypeValue(moduleIDs, moduleDisplayList, Config.BORN.bornModulesCustomAttribute, presetData);
                }
            }
            _this_1.refreshDisplayListOrder();
        }
        return _this_1;
    }
    ClientSceneObject.createDisplayObjectByPreLayer = function (type, id) {
        if (type == 2 || type == 3) {
            return GameUI.load(id, true);
        }
        else if (type == 4 || type == 5) {
            var animation = new GCAnimation();
            if (Config.EDIT_MODE)
                animation.silentMode = true;
            animation.id = id;
            animation.loop = true;
            animation.showHitEffect = true;
            animation.gotoAndPlay();
            return animation;
        }
    };
    ClientSceneObject.prototype.____beforeInstallAttributeInit = function () {
        this.root = new GameSprite();
        this.root.name = "__SOC";
        this.root["__SOC"] = this;
        var layerNames = {
            animationLowLayer: GameSprite,
            customLayer: GameSprite,
            animationHighLayer: GameSprite,
            customHighLayer: GameSprite,
            systemUILayer: Sprite
        };
        for (var i in layerNames) {
            var layer = this[i] = new layerNames[i]();
            this.root.addChild(layer);
        }
        this.avatarContainer = new GameSprite();
        this.avatar = new Avatar();
        this.avatarContainer.addChild(this.avatar);
        this.shadow = new Sprite();
        this.avatar.installMaterialData(this.materialData);
    };
    ClientSceneObject.prototype.____afterInstallAttributeInit = function () {
        this.drawShadow();
        this.refreshCommonDisplayList();
        for (var i_9 = 0; i_9 < this.materialData.length; i_9++) {
            var materials = this.materialData[i_9].materials;
            for (var s = 0; s < materials.length; s++) {
                this.avatar.addMaterial(materials[s]);
            }
        }
    };
    ClientSceneObject.prototype.refreshCommonDisplayList = function () {
        this.clearCommonDisplayList();
        var modelData = Game.data.sceneObjectModelList.data[this.modelID];
        var fixModelData = Config.useNewSceneObjectModel ? Game.data.sceneObjectModelList.data[0] : modelData;
        if (!fixModelData || !modelData)
            return;
        var layer = this.customLayer;
        for (var i = 0; i < fixModelData.preLayer.length; i++) {
            var preLayer = fixModelData.preLayer[i];
            if (preLayer.type != 1 && (preLayer.inEditorShowMode == 1 && Config.EDIT_MODE) || (preLayer.inEditorShowMode == 2 && !Config.EDIT_MODE))
                continue;
            var newLayer = null;
            var needRecordVarName = true;
            switch (preLayer.type) {
                case 1:
                    if (Config.EDIT_MODE) {
                        if (modelData.editorPreview && modelData.editorPreview.type != 1) {
                            needRecordVarName = false;
                            break;
                        }
                    }
                    newLayer = this.avatar;
                    layer.addChild(this.avatarContainer);
                    layer = this.customHighLayer;
                    needRecordVarName = false;
                    break;
                case 2:
                    newLayer = ClientSceneObject.createDisplayObjectByPreLayer(preLayer.type, preLayer.id);
                    if (newLayer)
                        layer.addChild(newLayer);
                    break;
                case 3:
                    var displayListInfo = this.displayList[preLayer.varName];
                    if (displayListInfo) {
                        newLayer = ClientSceneObject.createDisplayObjectByPreLayer(preLayer.type, displayListInfo.id);
                        if (newLayer)
                            layer.addChild(newLayer);
                    }
                    break;
                case 4:
                    var animation = newLayer = ClientSceneObject.createDisplayObjectByPreLayer(preLayer.type, preLayer.id);
                    animation.sceneObject = this;
                    layer.addChild(animation);
                    break;
                case 5:
                    var displayListInfo = this.displayList[preLayer.varName];
                    if (displayListInfo) {
                        var animation = newLayer = ClientSceneObject.createDisplayObjectByPreLayer(preLayer.type, displayListInfo.id);
                        animation.sceneObject = this;
                        layer.addChild(animation);
                    }
                    break;
            }
            if (needRecordVarName) {
                this[preLayer.varName] = newLayer;
                this.commonDisplayObjectVarNames.push(preLayer.varName);
            }
        }
        this.refreshDisplayListOrder();
    };
    ClientSceneObject.prototype.refreshDisplayListOrder = function () {
        var _this_1 = this;
        if (Config.useNewSceneObjectModel) {
            var addModuleChildToCustomLayer = function (insertToLayer, startInsertIndex, isLowLayer) {
                if (_this_1.moduleIDs) {
                    for (var s = 0; s < _this_1.moduleIDs.length; s++) {
                        var startInsert = isLowLayer;
                        var moduleID = _this_1.moduleIDs[s];
                        var soModule = _this_1.getModuleAt(s);
                        if (!soModule)
                            return;
                        var moduleData = Game.data.sceneObjectModuleList.data[moduleID];
                        if (moduleData) {
                            var preLayers = moduleData.preLayer.concat();
                            if (ArrayUtils.matchAttributes(preLayers, { type: SceneObjectModelData.TYPE_AVATAR_TYPE }, true).length == 0) {
                                preLayers.unshift({ type: SceneObjectModelData.TYPE_AVATAR_TYPE });
                            }
                            for (var i = 0; i < preLayers.length; i++) {
                                var preLayerSetting = preLayers[i];
                                if (preLayerSetting.type == SceneObjectModelData.TYPE_AVATAR_TYPE) {
                                    if (!startInsert)
                                        startInsert = true;
                                    else
                                        break;
                                }
                                else if (startInsert) {
                                    var commonDisplayObj = soModule[preLayerSetting.varName];
                                    if (commonDisplayObj) {
                                        insertToLayer.addChildAt(commonDisplayObj, startInsertIndex++);
                                    }
                                }
                            }
                        }
                    }
                }
            };
            var insertToLayer = this.customLayer;
            var insertIndex = 0;
            var commonModuleData = Game.data.sceneObjectModelList.data[0];
            for (var i = 0; i < commonModuleData.preLayer.length; i++) {
                var preLayer = commonModuleData.preLayer[i];
                if (preLayer.type == SceneObjectModelData.TYPE_AVATAR_TYPE) {
                    addModuleChildToCustomLayer.call(this, insertToLayer, insertIndex, true);
                    insertToLayer = this.customHighLayer;
                    insertIndex = 0;
                    continue;
                }
                else {
                    var commonDisplayObj = this[preLayer.varName];
                    if (commonDisplayObj)
                        insertToLayer.addChildAt(commonDisplayObj, insertIndex++);
                }
            }
            addModuleChildToCustomLayer.call(this, insertToLayer, insertIndex, false);
        }
    };
    ClientSceneObject.prototype.clearCommonDisplayList = function () {
        if (!this.commonDisplayObjectVarNames)
            this.commonDisplayObjectVarNames = [];
        for (var i = 0; i < this.commonDisplayObjectVarNames.length; i++) {
            var commonDisplayObjectVarName = this.commonDisplayObjectVarNames[i];
            var commonDisplayObject = this[commonDisplayObjectVarName];
            if (commonDisplayObject) {
                commonDisplayObject.dispose && commonDisplayObject.dispose();
                delete this[commonDisplayObjectVarName];
            }
        }
        this.commonDisplayObjectVarNames.length = 0;
        this.avatarContainer.removeSelf();
    };
    ClientSceneObject.prototype.getCustomDisplayLayers = function () {
        var displays = [];
        for (var i = 0; i < this.customLayer.numChildren; i++) {
            displays.push(this.customLayer.getChildAt(i));
        }
        for (var i = 0; i < this.customHighLayer.numChildren; i++) {
            displays.push(this.customHighLayer.getChildAt(i));
        }
        return displays;
    };
    ClientSceneObject.prototype.dispose = function () {
        if (!this.isDisposed) {
            if (this.scene && this.scene.sceneObjects[this.index] == this)
                this.scene.removeSceneObject(this);
            this.event(GameSprite.ON_DISPOSE);
            this.isDisposed = true;
            this.clearCondition();
            EventUtils.clear(this);
            this.clearCommonDisplayList();
            this.removeAllModules(true);
            this.stopAllAnimation();
            this.avatar && this.avatar.dispose();
            this.avatar = null;
        }
    };
    ClientSceneObject.prototype.addModule = function (soModule) {
        var res = _super.prototype.addModule.call(this, soModule, false);
        if (res) {
            this.refreshDisplayListOrder();
            EventUtils.happen(SceneObjectEntity, SceneObjectEntity.EVENT_ON_ADD_MODULE, [this, soModule]);
        }
        return res;
    };
    ClientSceneObject.prototype.addModuleAt = function (soModule, index) {
        var res = _super.prototype.addModuleAt.apply(this, arguments);
        return res;
    };
    ClientSceneObject.prototype.addModuleByID = function (moduleID) {
        var res = _super.prototype.addModuleByID.apply(this, arguments);
        return res;
    };
    ClientSceneObject.prototype.addModuleByIDAt = function (moduleID, index) {
        var res = _super.prototype.addModuleByIDAt.apply(this, arguments);
        return res;
    };
    ClientSceneObject.prototype.removeAllModules = function (isDispose) {
        if (isDispose === void 0) { isDispose = true; }
        for (var i = 0; i < this._modules.length; i++) {
            var m = this._modules[i];
            if (m)
                this.removeModuleDisplayObjects(m, i, isDispose);
        }
        _super.prototype.removeAllModules.call(this, isDispose);
    };
    ClientSceneObject.prototype.removeModuleByID = function (moduleID, isDispose) {
        if (isDispose === void 0) { isDispose = true; }
        var index = ArrayUtils.matchAttributes(this._modules, { id: moduleID }, true, "==", true)[0];
        if (index != null) {
            this.removeModuleDisplayObjects(this._modules[index], index, isDispose);
            return _super.prototype.removeModuleByID.call(this, moduleID, isDispose);
        }
        return null;
    };
    ClientSceneObject.prototype.removeModule = function (soModule, isDispose) {
        if (isDispose === void 0) { isDispose = true; }
        var index = this._modules.indexOf(soModule);
        if (index != -1) {
            this.removeModuleDisplayObjects(soModule, index, isDispose);
            return _super.prototype.removeModule.call(this, soModule, isDispose);
        }
        return false;
    };
    ClientSceneObject.prototype.removeModuleAt = function (index, isDispose) {
        if (isDispose === void 0) { isDispose = true; }
        var soModule = this._modules[index];
        if (soModule) {
            this.removeModuleDisplayObjects(soModule, index, isDispose);
            return _super.prototype.removeModuleAt.call(this, index, isDispose);
        }
        return false;
    };
    ClientSceneObject.prototype.setModuleIndex = function (soModule, toIndex) {
        var res = _super.prototype.setModuleIndex.apply(this, arguments);
        return res;
    };
    ClientSceneObject.prototype.setModuleIndexByID = function (moduleID, toIndex) {
        var res = _super.prototype.setModuleIndexByID.apply(this, arguments);
        return res;
    };
    ClientSceneObject.prototype.setModuleIndexByIndex = function (fromIndex, toIndex) {
        var res = _super.prototype.setModuleIndexByIndex.apply(this, arguments);
        this.refreshDisplayListOrder();
        return res;
    };
    ClientSceneObject.prototype.removeModuleDisplayObjects = function (soModule, moduleIndex, disposeDisplayObjects) {
        if (disposeDisplayObjects === void 0) { disposeDisplayObjects = true; }
        var displayList = this.moduleDisplayList[moduleIndex];
        for (var varName in displayList) {
            var displayObj = soModule[varName];
            if (displayObj && displayObj instanceof GameSprite) {
                displayObj.removeSelf();
                if (disposeDisplayObjects && displayObj.dispose)
                    displayObj.dispose();
            }
        }
    };
    ClientSceneObject.prototype.drawShadow = function (scalePer) {
        if (scalePer === void 0) { scalePer = 1.0; }
        if (this.isDisposed)
            return;
        if (Config.useNewSceneObjectModel) {
            return;
        }
        this.shadow.graphics.clear();
        if (this.shadowEnable) {
            this.shadow.graphics.drawCircle(0, 0, this.shadowWidth * scalePer, this.shadowWidth * scalePer, "#000000", 0);
            this.shadow.scaleY = this.shadowHeight / this.shadowWidth * this.avatar.scaleY;
            this.shadow.scaleX = this.avatar.scaleX;
            this.shadow.alpha = this.shadowAlpha;
        }
    };
    ClientSceneObject.prototype.updateShadow = function () {
        this.shadow.x = this.root.x;
        this.shadow.y = this.root.y;
    };
    ClientSceneObject.prototype.stopRender = function (stopCurrentFrame) {
        if (stopCurrentFrame === void 0) { stopCurrentFrame = false; }
        this.avatar.stop(stopCurrentFrame ? this.avatar.getCurrentFrame() : this.avatarFrame);
        var aniLen = this.___animations.length;
        for (var s = 0; s < aniLen; s++) {
            var ani = this.___animations[s];
            ani.stop(ani.currentFrame);
        }
        var customDisplayLayers = this.getCustomDisplayLayers();
        for (var i in customDisplayLayers) {
            var sp = customDisplayLayers[i];
            if (sp instanceof GCAnimation) {
                sp.stop(sp.currentFrame);
            }
        }
    };
    ClientSceneObject.prototype.recoveryRender = function (continueCurrentFrame) {
        if (continueCurrentFrame === void 0) { continueCurrentFrame = false; }
        if (this.autoPlayEnable)
            this.avatar.gotoAndPlay(continueCurrentFrame ? this.avatar.getCurrentFrame() : this.avatarFrame);
        var aniLen = this.___animations.length;
        for (var s = 0; s < aniLen; s++) {
            var ani = this.___animations[s];
            ani.gotoAndPlay(ani.currentFrame);
        }
        var customDisplayLayers = this.getCustomDisplayLayers();
        for (var i in customDisplayLayers) {
            var sp = customDisplayLayers[i];
            if (sp instanceof GCAnimation) {
                sp.gotoAndPlay(sp.currentFrame);
            }
        }
    };
    ClientSceneObject.prototype.update = function (nowTime) {
    };
    ClientSceneObject.prototype.refreshCoordinate = function () {
        this.updateShadow();
    };
    Object.defineProperty(ClientSceneObject.prototype, "actionIndex", {
        get: function () {
            return this.avatar ? this.avatar.actionIndex : 0;
        },
        set: function (v) {
            this.avatar.actionIndex = v;
            this["_avatarAct"] = this.avatar.actionID;
        },
        enumerable: false,
        configurable: true
    });
    ClientSceneObject.prototype.syncAvatarStateToSceneObject = function () {
        if (this.avatarID != this.avatar.id) {
            this["_avatarID"] = this.avatar.id;
        }
        if (this.avatarOri != this.avatar.orientation) {
            this["_avatarOri"] = this.avatar.orientation;
        }
        if (!this.avatar.isLoading && this.avatarAct != this.avatar.actionID) {
            this["_avatarAct"] = this.avatar.actionID;
        }
        if (this.avatarFPS != this.avatar.fps) {
            this["_avatarFPS"] = this.avatar.fps;
        }
        if (this.avatarAlpha != this.avatar.alpha) {
            this["_avatarAlpha"] = this.avatar.alpha;
        }
        if (this.avatarHue != this.avatar.hue) {
            this["_avatarHue"] = this.avatar.hue;
        }
        if (this.scale != this.avatar.scaleX) {
            this["_scale"] = this.avatar.scaleX;
        }
    };
    Object.defineProperty(ClientSceneObject.prototype, "animations", {
        get: function () {
            return this.___animations;
        },
        enumerable: false,
        configurable: true
    });
    ClientSceneObject.prototype.playAnimation = function (aniID, loop, isHit, fps, superposition, ignoreReplay) {
        var _this_1 = this;
        if (fps === void 0) { fps = null; }
        if (superposition === void 0) { superposition = false; }
        if (ignoreReplay === void 0) { ignoreReplay = false; }
        var animation;
        if (superposition) {
            animation = new GCAnimation();
            this.___animations.push(animation);
        }
        else {
            animation = ArrayUtils.matchAttributes(this.___animations, { id: aniID }, true, "==")[0];
            if (!animation) {
                animation = new GCAnimation();
                this.___animations.push(animation);
            }
            else if (ignoreReplay)
                return animation;
        }
        animation.sceneObject = this;
        if (fps)
            animation.fps = fps;
        animation.loop = loop;
        animation.showHitEffect = isHit;
        animation.once(GCAnimation.PLAY_COMPLETED, this, this.stopAnimation, [animation]);
        animation.once(EventObject.LOADED, this, function (animation) {
            if (animation.isDisposed)
                return;
            if (animation.isParticle) {
                _this_1.animationHighLayer.addChild(animation);
            }
            else {
                animation.addToGameSprite(_this_1.avatarContainer, _this_1.animationLowLayer, _this_1.animationHighLayer);
            }
        }, [animation]);
        animation.id = aniID;
        animation.gotoAndPlay();
        return animation;
    };
    ClientSceneObject.prototype.stopAnimation = function (aniID) {
        var animation;
        if (aniID instanceof GCAnimation) {
            animation = aniID;
            var animationIdx = this.___animations.indexOf(animation);
            if (animationIdx == -1)
                return;
            this.___animations.splice(animationIdx, 1);
        }
        else {
            var animationIdx = ArrayUtils.matchAttributes(this.___animations, { id: aniID }, true, "==", true)[0];
            if (animationIdx != null) {
                animation = this.___animations.splice(animationIdx, 1)[0];
            }
            else {
                return;
            }
        }
        if (animation) {
            Callback.CallLaterBeforeRender(animation.dispose, animation);
        }
    };
    ClientSceneObject.prototype.stopAllAnimation = function () {
        var aniLen = this.___animations.length;
        for (var s = 0; s < aniLen; s++) {
            var ani = this.___animations[s];
            ani.dispose();
        }
        this.___animations.length = 0;
    };
    ClientSceneObject.prototype.hasListener = function (type) { return this.root.hasListener.apply(this.root, arguments); };
    ;
    ClientSceneObject.prototype.event = function (type, data) { return this.root.event.apply(this.root, arguments); };
    ;
    ClientSceneObject.prototype.on = function (type, caller, listener, args) { return this.root.on.apply(this.root, arguments); };
    ;
    ClientSceneObject.prototype.once = function (type, caller, listener, args) { return this.root.once.apply(this.root, arguments); };
    ;
    ClientSceneObject.prototype.off = function (type, caller, listener, onceOnly) { return this.root.off.apply(this.root, arguments); };
    ;
    ClientSceneObject.prototype.offAll = function (type) { return this.root.offAll.apply(this, arguments); };
    ;
    return ClientSceneObject;
}(SceneObjectEntity));
ObjectUtils.reDefineGetSet("ClientSceneObject.prototype", {
    isBorn: function (v) {
        if (this.root && Config.EDIT_MODE) {
            if (v) {
                var bornSign = new MyGameCreatorEditorUI.Editor.model.SceneObjectBornSignUI();
                this.root.addChild(bornSign);
            }
        }
    },
    x: function (v) { if (this.root) {
        this.root.x = v;
        Callback.CallLaterBeforeRender(this.refreshCoordinate, this);
    } },
    y: function (v) { if (this.root) {
        this.root.y = v;
        Callback.CallLaterBeforeRender(this.refreshCoordinate, this);
    } },
    avatarID: function (v) {
        if (this.avatar) {
            if (v == this.avatar.id)
                return;
            this.avatar.id = v;
        }
    },
    shadowWidth: function (v) {
        if (this.avatar) {
            Callback.CallLaterBeforeRender(this.drawShadow, this);
        }
    },
    shadowHeight: function (v) {
        if (this.avatar) {
            Callback.CallLaterBeforeRender(this.drawShadow, this);
        }
    },
    shadowAlpha: function (v) {
        if (this.avatar) {
            Callback.CallLaterBeforeRender(this.drawShadow, this);
        }
    },
    shadowEnable: function (v) {
        if (this.avatar) {
            Callback.CallLaterBeforeRender(this.drawShadow, this);
        }
    },
    avatarOri: function (v) { if (this.avatar && this.avatar.orientation != v)
        this.avatar.orientation = v; },
    avatarAct: function (v) { if (this.avatar && this.avatar.actionID != v) {
        this.avatar.actionID = v;
    } },
    avatarFPS: function (v) { if (this.avatar)
        this.avatar.fps = v; },
    avatarFrame: function (v) { if (this.avatar) {
        this.avatar.setCurrentFrame(v, true);
    } },
    avatarAlpha: function (v) { if (this.avatar) {
        this.avatar.alpha = v;
    } },
    avatarHue: function (v) { if (this.avatar) {
        this.avatar.hue = v;
    } },
    layerLevel: function (v) {
        if (!this.root || !this.root.stage)
            return;
        if (this.root.parent != this.scene.sceneObjectHighLayer && v == 2) {
            this.scene.sceneObjectHighLayer.addChild(this.root);
        }
        else if (this.root.parent != this.scene.sceneObjectLayer && v == 1) {
            this.scene.sceneObjectLayer.addChild(this.root);
        }
        else if (this.root.parent != this.scene.sceneObjectLowLayer && v == 0) {
            this.scene.sceneObjectLowLayer.addChild(this.root);
        }
    },
    autoPlayEnable: function (v) {
        if (!this.root || !this.avatar)
            return;
        if (v) {
            this.avatar.play();
        }
        else {
            this.avatar.stop(this.avatar.getCurrentFrame());
        }
    },
    scale: function (v) {
        if (!this.root)
            return;
        if (Config.EDIT_MODE && Editor.customSystemEnableds.mapGrid && this.avatarID == 0) {
            try {
                var frameImageData = Common.avatarList.data[0].actionListArr[0].frameImageInfo[0][0];
                if (frameImageData.width != Config.SCENE_GRID_SIZE) {
                    frameImageData.x = frameImageData.y += (frameImageData.width - Config.SCENE_GRID_SIZE) * 0.5;
                    frameImageData.width = frameImageData.height = Config.SCENE_GRID_SIZE;
                    this.avatar.stop(0);
                }
            }
            catch (e) {
            }
        }
        else {
            this.avatar.scaleX = this.avatar.scaleY = v;
        }
        this.drawShadow();
    }
});
(function () {
    var ___soInstallModuleAttributesBeforeConstructor = SceneObject.installModuleAttributesBeforeConstructor;
    SceneObject.installModuleAttributesBeforeConstructor = function (soc, moduleID, moduleName, moduleData, presetData, soModule) {
        ___soInstallModuleAttributesBeforeConstructor.apply(this, arguments);
        if (moduleData.id == 0)
            return;
        for (var i = 0; i < moduleData.preLayer.length; i++) {
            var preLayer = moduleData.preLayer[i];
            if (preLayer.type != 1 && (preLayer.inEditorShowMode == 1 && Config.EDIT_MODE) || (preLayer.inEditorShowMode == 2 && !Config.EDIT_MODE)) {
                soModule[preLayer.varName] = null;
                continue;
            }
            var id;
            var attributeValue = soModule[preLayer.varName];
            if (attributeValue != null) {
                id = typeof attributeValue == "number" ? attributeValue : attributeValue.id;
            }
            else {
                id = preLayer.id;
            }
            var newLayer = null;
            var layer = soc.customHighLayer;
            switch (preLayer.type) {
                case 2:
                    newLayer = ClientSceneObject.createDisplayObjectByPreLayer(preLayer.type, MathUtils.int(preLayer.id));
                    if (newLayer)
                        layer.addChild(newLayer);
                    break;
                case 3:
                    newLayer = ClientSceneObject.createDisplayObjectByPreLayer(preLayer.type, MathUtils.int(id));
                    if (newLayer)
                        layer.addChild(newLayer);
                    break;
                case 4:
                    var animation = newLayer = ClientSceneObject.createDisplayObjectByPreLayer(preLayer.type, MathUtils.int(preLayer.id));
                    animation.sceneObject = this;
                    layer.addChild(animation);
                    break;
                case 5:
                    var animation = newLayer = ClientSceneObject.createDisplayObjectByPreLayer(preLayer.type, MathUtils.int(id));
                    animation.sceneObject = this;
                    layer.addChild(animation);
                    break;
            }
            if (newLayer) {
                soModule[preLayer.varName] = newLayer;
            }
        }
    };
})();
var FontLoadManager = (function () {
    function FontLoadManager() {
    }
    FontLoadManager.needSave = function (FONTS) {
        Config.FONTS = FONTS;
        EditorData.updateNeedSaveFile(EditorData.NEED_SAVE_CONFIG);
    };
    FontLoadManager.getFontByName = function (name) {
        return FontLoadManager.fontFaceList[name];
    };
    FontLoadManager.loadFontFile = function (fontList, callBack) {
        if (callBack === void 0) { callBack = null; }
        if (fontList.length == 0) {
            callBack && callBack.run();
            return;
        }
        for (var i = 0; i < fontList.length; i++) {
            var font = fontList[i];
            new SyncTask(FontLoadManager.FONT_FILE_LOADING, function (data) {
                FontLoadManager.toLoadFontFile(data);
            }, [font]);
        }
        new SyncTask(FontLoadManager.FONT_FILE_LOADING, function () {
            callBack && callBack.run();
            SyncTask.taskOver(FontLoadManager.FONT_FILE_LOADING);
        });
    };
    FontLoadManager.toLoadFontFile = function (font) {
        var fontface = FontLoadManager.fontFaceList[font.name];
        if (fontface) {
            SyncTask.taskOver(FontLoadManager.FONT_FILE_LOADING);
            return;
        }
        var isGoToNext = false;
        var fontType = FontLoadManager.getFontType(font.fonttype);
        fontface = new FontFace(font.name, "url('" + font.path + "') format('" + fontType + "')");
        function doNext() {
            if (isGoToNext)
                return;
            isGoToNext = true;
            SyncTask.taskOver(FontLoadManager.FONT_FILE_LOADING);
        }
        try {
            fontface.load().then(function (loadFace) {
                document.fonts.add(loadFace);
                FontLoadManager.fontFaceList[font.name] = loadFace;
                doNext();
            }).catch(function (err) {
                doNext();
            });
            setTimeout(doNext, 2000);
        }
        catch (e) {
            doNext();
        }
    };
    FontLoadManager.LoadEditorFont = function (callBack) {
        var loadManager = mainDomain_gcide.CodeIDE_FontLoadManager;
        var font = loadManager.fontFaceList[loadManager.defaultFont];
        if (font) {
            var fontType = loadManager.getFontType(font.fonttype);
            var fontface = new FontFace(font.name, "url('" + font.path + "') format('" + fontType + "')");
            try {
                fontface.load().then(function (loadFace) {
                    document.fonts.add(loadFace);
                    callBack();
                }).catch(function (err) {
                    callBack();
                });
            }
            catch (e) {
                callBack();
            }
        }
        else
            callBack();
    };
    FontLoadManager.getFontType = function (name) {
        if (!name)
            return "truetype";
        name = name.toLocaleLowerCase();
        if (name == "otf")
            return "opentype";
        else if (name == "eot")
            return "embedded-opentype";
        else if (name == "svg")
            return "svg";
        else if (name == "woff")
            return "woff";
        else
            return "truetype";
    };
    FontLoadManager.deleteFontFile = function (name) {
        var fontface = FontLoadManager.fontFaceList[name];
        if (!fontface)
            return;
        document.fonts.delete(fontface);
        delete FontLoadManager.fontFaceList[name];
    };
    FontLoadManager.FONT_FILE_LOADING = "font_file_loading";
    FontLoadManager.fontFaceList = {};
    return FontLoadManager;
}());
var GameAudio = (function () {
    function GameAudio() {
    }
    GameAudio.playBGM = function (url, volume, loop, isGradient, gradientTime, pitch) {
        if (volume === void 0) { volume = 1; }
        if (loop === void 0) { loop = 9999; }
        if (isGradient === void 0) { isGradient = false; }
        if (gradientTime === void 0) { gradientTime = 1000; }
        if (pitch === void 0) { pitch = 1; }
        var urlInfo = GameAudio.getAudioURL(url);
        url = urlInfo.url;
        if (urlInfo.volume != null)
            volume = urlInfo.volume;
        if (urlInfo.pitch != null)
            pitch = urlInfo.pitch;
        GameAudio.clearBgmTween();
        if (GameAudio.lastBgmURL != url || pitch != GameAudio.lastBGMPitch) {
            if (GameAudio.lastBgmSoundChannel)
                GameAudio.lastBgmSoundChannel.stop();
            GameAudio.lastBgmSoundChannel = SoundManager.playSound(url, loop, pitch, Handler.create(this, function (url) {
                if (url == GameAudio.lastBgmURL) {
                    GameAudio.lastBgmURL = GameAudio.lastBgmSoundChannel = null;
                }
            }, [url]));
            if (isGradient && GameAudio.lastBgmSoundChannel)
                GameAudio.lastBgmSoundChannel.volume = 0;
        }
        GameAudio.lastBgmURL = url;
        GameAudio.lastBGMPitch = pitch;
        GameAudio.lastBGMVolume = volume;
        if (!GameAudio.lastBgmSoundChannel)
            return null;
        GameAudio.lastBgmSoundChannel["_selfVolume"] = volume;
        if (isGradient) {
            GameAudio.lastBgmTween = Tween.to(GameAudio.lastBgmSoundChannel, { volume: volume * GameAudio._bgmVolume }, gradientTime, null, Handler.create(this, function () {
                GameAudio.lastBgmTween = null;
            }));
            GameAudio.lastBgmTween["gradientTime"] = gradientTime;
        }
        else {
            GameAudio.lastBgmSoundChannel.volume = volume * GameAudio._bgmVolume;
        }
        return GameAudio.lastBgmSoundChannel;
    };
    GameAudio.stopBGM = function (isGradient, gradientTime) {
        if (isGradient === void 0) { isGradient = false; }
        if (gradientTime === void 0) { gradientTime = 1000; }
        GameAudio.clearBgmTween();
        if (GameAudio.lastBgmSoundChannel) {
            if (isGradient) {
                GameAudio.lastBgmTween = Tween.to(GameAudio.lastBgmSoundChannel, { volume: 0 }, gradientTime, null, Handler.create(this, function () {
                    GameAudio.lastBgmURL = null;
                    GameAudio.lastBgmSoundChannel = null;
                }));
            }
            else {
                SoundManager.stopSound(GameAudio.lastBgmSoundChannel.url);
                GameAudio.lastBgmURL = null;
                GameAudio.lastBgmSoundChannel = null;
            }
        }
    };
    GameAudio.playBGS = function (url, volume, loop, isGradient, gradientTime, pitch) {
        if (volume === void 0) { volume = 1; }
        if (loop === void 0) { loop = 9999; }
        if (isGradient === void 0) { isGradient = false; }
        if (gradientTime === void 0) { gradientTime = 1000; }
        if (pitch === void 0) { pitch = 1; }
        var urlInfo = GameAudio.getAudioURL(url);
        url = urlInfo.url;
        if (urlInfo.volume != null)
            volume = urlInfo.volume;
        if (urlInfo.pitch != null)
            pitch = urlInfo.pitch;
        GameAudio.clearBgsTween();
        if (GameAudio.lastBgsURL != url || pitch != GameAudio.lastBGSPitch) {
            if (GameAudio.lastBgsSoundChannel)
                GameAudio.lastBgsSoundChannel.stop();
            GameAudio.lastBgsSoundChannel = SoundManager.playSound(url, loop, pitch, Handler.create(this, function (url) {
                if (url == GameAudio.lastBgsURL) {
                    GameAudio.lastBgsURL = GameAudio.lastBgsSoundChannel = null;
                }
            }, [url]));
            if (isGradient && GameAudio.lastBgsSoundChannel)
                GameAudio.lastBgsSoundChannel.volume = 0;
        }
        GameAudio.lastBgsURL = url;
        GameAudio.lastBGSPitch = pitch;
        GameAudio.lastBGSVolume = volume;
        if (!GameAudio.lastBgsSoundChannel)
            return null;
        GameAudio.lastBgsSoundChannel["_selfVolume"] = volume;
        if (isGradient) {
            GameAudio.lastBgsTween = Tween.to(GameAudio.lastBgsSoundChannel, { volume: volume * GameAudio._bgsVolume }, gradientTime, null, Handler.create(this, function () {
                GameAudio.lastBgsTween = null;
            }));
            GameAudio.lastBgsTween["gradientTime"] = gradientTime;
        }
        else {
            GameAudio.lastBgsSoundChannel.volume = volume * GameAudio._bgsVolume;
        }
        return GameAudio.lastBgsSoundChannel;
    };
    GameAudio.stopBGS = function (isGradient, gradientTime) {
        if (isGradient === void 0) { isGradient = false; }
        if (gradientTime === void 0) { gradientTime = 1000; }
        GameAudio.clearBgsTween();
        if (GameAudio.lastBgsSoundChannel) {
            if (isGradient) {
                GameAudio.lastBgsTween = Tween.to(GameAudio.lastBgsSoundChannel, { volume: 0 }, gradientTime, null, Handler.create(this, function () {
                    GameAudio.lastBgsURL = null;
                    GameAudio.lastBgsSoundChannel = null;
                }));
            }
            else {
                SoundManager.stopSound(GameAudio.lastBgsSoundChannel.url);
                GameAudio.lastBgsURL = null;
                GameAudio.lastBgsSoundChannel = null;
            }
        }
    };
    GameAudio.playSE = function (url, volume, pitch, soc) {
        if (volume === void 0) { volume = 1; }
        if (pitch === void 0) { pitch = 1; }
        if (soc === void 0) { soc = null; }
        return GameAudio.playSuperpositionVoice(url, 0, volume, pitch, soc);
    };
    GameAudio.stopSE = function (channels) {
        if (channels === void 0) { channels = null; }
        var seArr = channels ? channels instanceof Array ? channels : [channels] : GameAudio.seArr;
        GameAudio.stopSuperpositionVoice(seArr);
    };
    GameAudio.playTS = function (url, volume, pitch, soc) {
        if (volume === void 0) { volume = 1; }
        if (pitch === void 0) { pitch = 1; }
        if (soc === void 0) { soc = null; }
        return GameAudio.playSuperpositionVoice(url, 1, volume, pitch, soc);
    };
    GameAudio.stopTS = function (channels) {
        if (channels === void 0) { channels = null; }
        var tsArr = channels ? channels instanceof Array ? channels : [channels] : GameAudio.tsArr;
        GameAudio.stopSuperpositionVoice(tsArr);
    };
    GameAudio.playSuperpositionVoice = function (url, mode, volume, pitch, soc) {
        if (volume === void 0) { volume = 1; }
        if (pitch === void 0) { pitch = 1; }
        if (soc === void 0) { soc = null; }
        if (mode == 0) {
            var scArr = GameAudio.seArr;
            var globalVolume = GameAudio._seVolume;
        }
        else {
            scArr = GameAudio.tsArr;
            globalVolume = GameAudio._tsVolume;
        }
        var urlInfo = GameAudio.getAudioURL(url);
        url = urlInfo.url;
        if (urlInfo.volume != null)
            volume = urlInfo.volume;
        if (urlInfo.pitch != null)
            pitch = urlInfo.pitch;
        if (!url)
            return;
        var channel = SoundManager.playSound(url, 1, pitch);
        if (!channel) {
            return null;
        }
        channel["_selfVolume"] = volume;
        scArr.push(channel);
        channel.completeHandler = Handler.create(this, function (s) {
            var idx = scArr.indexOf(s);
            if (idx != -1)
                scArr.splice(idx, 1);
        }, [channel]);
        if (!soc || !soc.scene) {
            channel.volume = volume * globalVolume;
        }
        else {
            if (soc.scene.camera.sceneObject) {
                var cameraCenter = new Point(soc.scene.camera.sceneObject.x, soc.scene.camera.sceneObject.y);
            }
            else {
                var viewPort = soc.scene.camera.viewPort;
                var cameraCenter = new Point(viewPort.x + viewPort.width / 2, viewPort.y + viewPort.height / 2);
            }
            var dis = cameraCenter.distance(soc.x, soc.y);
            var disPer = Math.max(1 - dis / (Config.WINDOW_WIDTH * 0.5), 0);
            channel.volume = volume * disPer * globalVolume;
        }
        return channel;
    };
    GameAudio.stopSuperpositionVoice = function (channels) {
        for (var i = 0; i < channels.length; i++) {
            var c = channels[i];
            c.stop();
            if (channels) {
                if (channels != GameAudio.seArr) {
                    var idx = GameAudio.seArr.indexOf(c);
                    if (idx != -1) {
                        GameAudio.seArr.splice(idx, 1);
                    }
                }
                if (channels != GameAudio.tsArr) {
                    var idx = GameAudio.tsArr.indexOf(c);
                    if (idx != -1) {
                        GameAudio.tsArr.splice(idx, 1);
                    }
                }
            }
        }
        channels.length = 0;
    };
    GameAudio.clearBgmTween = function () {
        if (GameAudio.lastBgmTween) {
            Tween.clearAll(GameAudio.lastBgmSoundChannel);
            GameAudio.lastBgmTween = null;
        }
    };
    GameAudio.clearBgsTween = function () {
        if (GameAudio.lastBgsTween) {
            Tween.clearAll(GameAudio.lastBgsSoundChannel);
            GameAudio.lastBgsTween = null;
        }
    };
    Object.defineProperty(GameAudio, "bgmVolume", {
        get: function () {
            return this._bgmVolume;
        },
        set: function (v) {
            v = MathUtils.float(v);
            this._bgmVolume = v;
            if (this.lastBgmSoundChannel) {
                if (GameAudio.lastBgmTween) {
                    var lastProgress = GameAudio.lastBgmTween.progress || GameAudio.lastBgmTween["progress2"];
                    var gradientTime = GameAudio.lastBgmTween["gradientTime"] * (1 - lastProgress);
                    this.clearBgmTween();
                    GameAudio.lastBgmTween = Tween.to(GameAudio.lastBgmSoundChannel, { volume: this.lastBgmSoundChannel["_selfVolume"] * v }, gradientTime, null, Handler.create(this, function () {
                        GameAudio.lastBgmTween = null;
                    }));
                    GameAudio.lastBgmTween.progress = GameAudio.lastBgmTween["progress2"] = lastProgress;
                    this.lastBgmSoundChannel.volume = (this.lastBgmSoundChannel["_selfVolume"] * v) * lastProgress;
                }
                else {
                    this.lastBgmSoundChannel.volume = this.lastBgmSoundChannel["_selfVolume"] * v;
                }
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameAudio, "bgsVolume", {
        get: function () {
            return this._bgsVolume;
        },
        set: function (v) {
            v = MathUtils.float(v);
            this._bgsVolume = v;
            if (this.lastBgsSoundChannel) {
                if (GameAudio.lastBgsTween) {
                    var lastProgress = GameAudio.lastBgsTween.progress || GameAudio.lastBgsTween["progress2"];
                    var gradientTime = GameAudio.lastBgsTween["gradientTime"] * (1 - lastProgress);
                    this.clearBgsTween();
                    GameAudio.lastBgsTween = Tween.to(GameAudio.lastBgsSoundChannel, { volume: this.lastBgsSoundChannel["_selfVolume"] * v }, gradientTime, null, Handler.create(this, function () {
                        GameAudio.lastBgsTween = null;
                    }));
                    GameAudio.lastBgsTween.progress = GameAudio.lastBgsTween["progress2"] = lastProgress;
                    this.lastBgsSoundChannel.volume = (this.lastBgsSoundChannel["_selfVolume"] * v) * lastProgress;
                }
                else {
                    this.lastBgsSoundChannel.volume = this.lastBgsSoundChannel["_selfVolume"] * v;
                }
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameAudio, "seVolume", {
        get: function () {
            return this._seVolume;
        },
        set: function (v) {
            v = MathUtils.float(v);
            this._seVolume = v;
            for (var i = 0; i < GameAudio.seArr.length; i++) {
                var c = GameAudio.seArr[i];
                c.volume = c["_selfVolume"] * v;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameAudio, "tsVolume", {
        get: function () {
            return this._tsVolume;
        },
        set: function (v) {
            v = MathUtils.float(v);
            this._tsVolume = v;
            for (var i = 0; i < GameAudio.tsArr.length; i++) {
                var c = GameAudio.tsArr[i];
                c.volume = c["_selfVolume"] * v;
            }
        },
        enumerable: false,
        configurable: true
    });
    GameAudio.setBlurStopMusic = function (isStop) {
        SoundManager.autoStopMusic = isStop;
    };
    GameAudio.getAudioURL = function (url) {
        if (!url)
            url = "";
        var arr = url.split(",");
        url = arr[0];
        var volume = arr[1] != null ? MathUtils.float(arr[1]) : null;
        var pitch = arr[2] != null ? MathUtils.float(arr[2]) : null;
        return { url: url, volume: volume, pitch: pitch };
    };
    GameAudio.pause = function () {
        if (GameAudio.lastBgmSoundChannel && !GameAudio.lastBgmSoundChannel.isStopped)
            GameAudio.lastBgmSoundChannel.pause();
        if (GameAudio.lastBgsSoundChannel && !GameAudio.lastBgsSoundChannel.isStopped)
            GameAudio.lastBgsSoundChannel.pause();
        GameAudio.seArr.forEach(function (v) {
            if (v && !v.isStopped)
                v.pause();
        });
        GameAudio.tsArr.forEach(function (v) {
            if (v && !v.isStopped)
                v.pause();
        });
    };
    GameAudio.resume = function () {
        if (GameAudio.lastBgmSoundChannel)
            GameAudio.lastBgmSoundChannel.resume();
        if (GameAudio.lastBgsSoundChannel)
            GameAudio.lastBgsSoundChannel.resume();
        GameAudio.seArr.forEach(function (v) {
            if (v)
                v.resume();
        });
        GameAudio.tsArr.forEach(function (v) {
            if (v)
                v.resume();
        });
    };
    GameAudio._bgmVolume = 1;
    GameAudio._bgsVolume = 1;
    GameAudio._seVolume = 1;
    GameAudio._tsVolume = 1;
    GameAudio.seArr = [];
    GameAudio.tsArr = [];
    return GameAudio;
}());















var GameCommand = (function (_super) {
    __extends(GameCommand, _super);
    function GameCommand(mainType, indexType) {
        var _this_1 = _super.call(this) || this;
        _this_1.mainType = mainType;
        _this_1.indexType = indexType;
        return _this_1;
    }
    GameCommand.init = function () {
        this.start();
    };
    GameCommand.start = function (triggerLineID) {
        if (triggerLineID === void 0) { triggerLineID = null; }
        if (triggerLineID == null) {
            os.remove_ENTERFRAME(GameCommand.execCommand, GameCommand.execCommand);
            os.add_ENTERFRAME(GameCommand.execCommand, GameCommand.execCommand);
            GameCommand.execCommand();
        }
        else {
            var cmds = GameCommand.cmdTriggerLines[triggerLineID];
            if (cmds)
                cmds.stop = false;
        }
    };
    GameCommand.getCustomCmdDataID = function (cmdID) {
        var type = Math.floor(cmdID / GameCommand.CUSTOM_COMMAND_START_ID);
        var localID = cmdID - GameCommand.CUSTOM_COMMAND_START_ID * type;
        var id = GameListData.getID(type, localID);
        return id;
    };
    GameCommand.getSaveData = function () {
        var o = {};
        for (var i in this.cmdTriggerLines) {
            var c = this.cmdTriggerLines[i];
            var newFuncs = [];
            for (var s = 0; s < c.funcs.length; s++) {
                var newFunc = c.funcs[s].concat();
                newFunc.shift();
                newFuncs.push(newFunc);
            }
            o[i] = { stop: c.stop, funcs: newFuncs };
        }
        return [o, GameCommand.isNeedPlayerInput, GameCommand.inputTriggerLine];
    };
    GameCommand.startSceneCommand = function (indexType, inputMessage, onCommandExecuteOver) {
        if (inputMessage === void 0) { inputMessage = null; }
        if (onCommandExecuteOver === void 0) { onCommandExecuteOver = null; }
        if (GameCommand.mustInScene && !Game.currentScene)
            return false;
        if (!Game.currentScene || Game.currentScene.isDisposed)
            return false;
        var cmd = new GameCommand(CommandTrigger.COMMAND_MAIN_TYPE_SCENE, indexType);
        cmd.startExecute(0, inputMessage, onCommandExecuteOver);
        return true;
    };
    GameCommand.startSceneObjectCommand = function (executorSceneObjectIndex, indexType, inputMessage, onCommandExecuteOver, triggerSceneObject) {
        if (inputMessage === void 0) { inputMessage = null; }
        if (onCommandExecuteOver === void 0) { onCommandExecuteOver = null; }
        if (triggerSceneObject === void 0) { triggerSceneObject = null; }
        if (GameCommand.banSceneObjectEvent)
            return false;
        if (GameCommand.mustInScene && !Game.currentScene)
            return false;
        if (!Game.currentScene || Game.currentScene.isDisposed)
            return false;
        var soc = Game.currentScene.sceneObjects[executorSceneObjectIndex];
        if (soc) {
            var hasCommand = soc.hasCommand[indexType];
            if (hasCommand) {
                var cmd = new GameCommand(CommandTrigger.COMMAND_MAIN_TYPE_SCENE_OBJECT, indexType);
                var triggerSceneObjectIndex = triggerSceneObject ? triggerSceneObject.index : null;
                cmd.startExecute(executorSceneObjectIndex, inputMessage, onCommandExecuteOver, triggerSceneObjectIndex, executorSceneObjectIndex);
                return true;
            }
        }
        return false;
    };
    GameCommand.startUICommand = function (comp, indexType, inputMessage, onCommandExecuteOver) {
        if (inputMessage === void 0) { inputMessage = null; }
        if (onCommandExecuteOver === void 0) { onCommandExecuteOver = null; }
        if (GameCommand.mustInScene && !Game.currentScene)
            return false;
        if (!Game.currentScene || Game.currentScene.isDisposed)
            return false;
        if (comp instanceof UIComponent.GUI_BASE) {
            var hasRootCommand = comp.hasRootCommand[indexType];
            if (hasRootCommand) {
                var cmd = new GameCommand(CommandTrigger.COMMAND_MAIN_TYPE_UI, indexType);
                var guiRootCommandID = comp.guiID + "_root";
                cmd.startExecute(guiRootCommandID, inputMessage, onCommandExecuteOver);
                return false;
            }
            return false;
        }
        var commandID = comp._commondID;
        var hasCommand = comp.hasCommand[indexType];
        if (hasCommand) {
            var cmd = new GameCommand(CommandTrigger.COMMAND_MAIN_TYPE_UI, indexType);
            cmd.startExecute(commandID, inputMessage, onCommandExecuteOver);
            return true;
        }
        return false;
    };
    GameCommand.startCommonCommand = function (id, inputMessage, onCommandExecuteOver, triggerSceneObject, executorSceneObject) {
        if (inputMessage === void 0) { inputMessage = null; }
        if (onCommandExecuteOver === void 0) { onCommandExecuteOver = null; }
        if (triggerSceneObject === void 0) { triggerSceneObject = null; }
        if (executorSceneObject === void 0) { executorSceneObject = null; }
        var triggerSceneObjectIndex = triggerSceneObject ? triggerSceneObject.index : null;
        var executorSceneObjectIndex = executorSceneObject ? executorSceneObject.index : null;
        ClientMsgSender.requestTriggerEvent(2, 0, 0, id, inputMessage, onCommandExecuteOver, triggerSceneObjectIndex, executorSceneObjectIndex);
    };
    GameCommand.rpcCall = function (triggerLineID, params) {
        var cmds = GameCommand.cmdTriggerLines[triggerLineID];
        if (!cmds) {
            cmds = GameCommand.cmdTriggerLines[triggerLineID] = { stop: false, funcs: [] };
        }
        var cmdID = params.shift();
        var customHead = "command_";
        var custom = false;
        if (cmdID >= GameCommand.CUSTOM_COMMAND_START_ID) {
            cmdID = GameCommand.getCustomCmdDataID(cmdID);
            customHead = "customCommand_";
            custom = true;
        }
        var func = CommandExecuteGame[customHead + cmdID];
        if (!func) {
            if (custom)
                return;
            var gameFuncName = params.shift();
            cmds.funcs.push([GameFunction[gameFuncName], params, GameFunction, 0, gameFuncName]);
            GameCommand.execCommand();
            return;
        }
        cmds.funcs.push([func, [triggerLineID].concat(params), CommandExecuteGame, 1, customHead + cmdID]);
        GameCommand.execCommand();
    };
    GameCommand.execCommand = function () {
        for (var i in GameCommand.cmdTriggerLines) {
            var cmds = GameCommand.cmdTriggerLines[i];
            if (cmds.stop)
                continue;
            while (cmds.funcs.length > 0) {
                var cmd = cmds.funcs.shift();
                var state = cmd[0].apply(cmd[2], cmd[1]);
                var inputTriggerLine = cmd[1][0];
                if (state == GameCommand.COMMAND_STATE_STOP) {
                    cmds.stop = true;
                    break;
                }
                else if (state == GameCommand.COMMAND_STATE_NEED_INPUT) {
                    if (GameCommand.isNeedPlayerInput) {
                        if (inputTriggerLine != GameCommand.inputTriggerLine) {
                            cmds.funcs.unshift(cmd);
                            break;
                        }
                    }
                    GameCommand.inputTriggerLine = inputTriggerLine;
                    GameCommand.isNeedPlayerInput = true;
                }
            }
        }
    };
    GameCommand.prototype.startExecute = function (commandID, inputMessage, onCommandExecuteOver, triggerSceneObjectIndex, executorSceneObjectIndex) {
        if (inputMessage === void 0) { inputMessage = null; }
        if (onCommandExecuteOver === void 0) { onCommandExecuteOver = null; }
        if (triggerSceneObjectIndex === void 0) { triggerSceneObjectIndex = null; }
        if (executorSceneObjectIndex === void 0) { executorSceneObjectIndex = null; }
        ClientMsgSender.requestTriggerEvent(0, this.mainType, this.indexType, commandID, inputMessage, onCommandExecuteOver, triggerSceneObjectIndex, executorSceneObjectIndex);
    };
    GameCommand.inputMessageAndContinueExecute = function (inputMessage, force, delay, triggerLineID) {
        if (inputMessage === void 0) { inputMessage = null; }
        if (force === void 0) { force = false; }
        if (delay === void 0) { delay = 1; }
        if (triggerLineID === void 0) { triggerLineID = -1; }
        function doInputMessageAndContinueExecute(inputMessage, force, delay, triggerLineID) {
            if (inputMessage === void 0) { inputMessage = null; }
            if (force === void 0) { force = false; }
            if (force || GameCommand.isNeedPlayerInput) {
                if (triggerLineID == GameCommand.inputTriggerLine || triggerLineID == -1)
                    GameCommand.isNeedPlayerInput = false;
                if (triggerLineID == -1)
                    triggerLineID = GameCommand.inputTriggerLine;
                ClientMsgSender.requestTriggerEvent(1, 0, 0, triggerLineID, inputMessage);
            }
        }
        if (delay == 0) {
            doInputMessageAndContinueExecute.apply(this, arguments);
        }
        else {
            setTimeout(doInputMessageAndContinueExecute, delay, inputMessage, force, delay, triggerLineID);
        }
    };
    GameCommand.CUSTOM_COMMAND_START_ID = 10000;
    GameCommand.COMMAND_STATE_CONTINUE = 0;
    GameCommand.COMMAND_STATE_STOP = 1;
    GameCommand.COMMAND_STATE_NEED_INPUT = 2;
    GameCommand.mustInScene = true;
    GameCommand.cmdTriggerLines = {};
    GameCommand.banSceneObjectEvent = false;
    return GameCommand;
}(IdentityObject));















var GameSprite = (function (_super) {
    __extends(GameSprite, _super);
    function GameSprite() {
        var _this_1 = _super.call(this) || this;
        _this_1._tonalParams = [0, 0, 0, 0, 1, 1, 1];
        _this_1._mouseEventEnabledInEditor = true;
        _this_1._show = true;
        _this_1._showOnEditor = true;
        _this_1._opacity = 1;
        _this_1._blend = 0;
        _this_1._opacityPer = 1;
        _this_1._rotation1 = 0;
        _this_1._rotation2 = 0;
        _this_1._animationTargetEffect = [];
        _this_1.objectID = ObjectUtils.getInstanceID();
        _this_1._filterEnabled = true;
        _this_1._dpZ = 100;
        _this_1._hue = 0;
        _this_1._blur = 0;
        _this_1.materialPassArr = [];
        return _this_1;
    }
    GameSprite.prototype.dispose = function () {
        if (!this.__isDisposed) {
            this.clearMaterials();
            this.event(GameSprite.ON_DISPOSE);
            this.offAll();
            EventUtils.clear(this);
            this.removeSelf();
            this._tonalParams = this._tonalFilter = this.tips = null;
            this.destroy(false);
            this.__isDisposed = true;
        }
    };
    Object.defineProperty(GameSprite.prototype, "isDisposed", {
        get: function () {
            return this.__isDisposed || this.destroyed;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "rotation1", {
        get: function () {
            return this._rotation1;
        },
        set: function (v) {
            this._rotation1 = v;
            this.rotation = this._rotation1 + this._rotation2;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "rotation2", {
        get: function () {
            return this._rotation2;
        },
        set: function (v) {
            this._rotation2 = v;
            this.rotation = this._rotation1 + this._rotation2;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "useDPCoord", {
        get: function () {
            return this._useDPCoord;
        },
        set: function (v) {
            this._useDPCoord = v;
            if (this._dpX == null) {
                this._dpX = 0;
                this._dpY = 0;
                this._dpCameraX = 0;
                this._dpCameraY = 0;
                this._dpZ = 100;
                this._dpOpacity = 1;
                this._dpCameraZ = 0;
                this._dpScaleX = 1;
                this._dpScaleY = 1;
                this._dpWidth = this.width;
                this._dpHeight = this.height;
                this._dpDirty = true;
                Callback.CallLaterBeforeRender(this.dpCoordToRealCoord, this);
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "dpOpacity", {
        get: function () {
            return this._dpOpacity;
        },
        set: function (v) {
            this._dpOpacity = v;
            this.refreshRealAlpha();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "dpZ", {
        get: function () {
            return this._dpZ;
        },
        set: function (v) {
            this._dpZ = v;
            this._dpDirty = true;
            Callback.CallLaterBeforeRender(this.dpCoordToRealCoord, this);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "dpX", {
        get: function () {
            return this._dpX;
        },
        set: function (v) {
            this._dpX = v;
            this._dpDirty = true;
            Callback.CallLaterBeforeRender(this.dpCoordToRealCoord, this);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "dpY", {
        get: function () {
            return this._dpY;
        },
        set: function (v) {
            this._dpY = v;
            this._dpDirty = true;
            Callback.CallLaterBeforeRender(this.dpCoordToRealCoord, this);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "dpScaleX", {
        get: function () {
            return this._dpScaleX;
        },
        set: function (v) {
            this._dpScaleX = v;
            this._dpDirty = true;
            Callback.CallLaterBeforeRender(this.dpCoordToRealCoord, this);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "dpScaleY", {
        get: function () {
            return this._dpScaleY;
        },
        set: function (v) {
            this._dpScaleY = v;
            this._dpDirty = true;
            Callback.CallLaterBeforeRender(this.dpCoordToRealCoord, this);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "dpCameraX", {
        get: function () {
            return this._dpCameraX;
        },
        set: function (v) {
            this._dpCameraX = v;
            this._dpDirty = true;
            Callback.CallLaterBeforeRender(this.dpCoordToRealCoord, this);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "dpCameraY", {
        get: function () {
            return this._dpCameraY;
        },
        set: function (v) {
            this._dpCameraY = v;
            this._dpDirty = true;
            Callback.CallLaterBeforeRender(this.dpCoordToRealCoord, this);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "dpCameraZ", {
        get: function () {
            return this._dpCameraZ;
        },
        set: function (v) {
            this._dpCameraZ = v;
            this._dpDirty = true;
            Callback.CallLaterBeforeRender(this.dpCoordToRealCoord, this);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "dpWidth", {
        get: function () {
            return this._dpWidth;
        },
        set: function (v) {
            this._dpWidth = v;
            this._dpDirty = true;
            Callback.CallLaterBeforeRender(this.dpCoordToRealCoord, this);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "dpHeight", {
        get: function () {
            return this._dpHeight;
        },
        set: function (v) {
            this._dpHeight = v;
            this._dpDirty = true;
            Callback.CallLaterBeforeRender(this.dpCoordToRealCoord, this);
        },
        enumerable: false,
        configurable: true
    });
    GameSprite.prototype.dpCoordToRealCoord = function () {
        if (Config.EDIT_MODE) {
            try {
                GameImageLayer.dpCoordFuncObject.dpCoordToRealCoord.apply(this, [this]);
            }
            catch (e) {
                console.log("[#GAME_IMAGE_DEPTH_COORDINATE_DPCOORDTOREALCOORD_CODE_ERROR]", e.stack);
            }
        }
        else {
            GameImageLayer.dpCoordFuncObject.dpCoordToRealCoord.apply(this, [this]);
        }
    };
    GameSprite.prototype.realCoordToDPCoord = function (calcCoord, calcSize) {
        if (Config.EDIT_MODE) {
            try {
                return GameImageLayer.dpCoordFuncObject.realCoordToDPCoord.apply(this, [this, calcCoord, calcSize]);
            }
            catch (e) {
                console.log("[#GAME_IMAGE_DEPTH_COORDINATE_REALCOORDTODPCOORD_CODE_ERROR]", e.stack);
            }
        }
        else {
            return GameImageLayer.dpCoordFuncObject.realCoordToDPCoord.apply(this, [this, calcCoord, calcSize]);
        }
    };
    GameSprite.prototype.addAnimationTargetEffect = function (ani) {
        this._animationTargetEffect.push(ani);
        this.refreshTargetEffect();
    };
    GameSprite.prototype.removeAnimationTargetEffect = function (ani) {
        ArrayUtils.remove(this._animationTargetEffect, ani);
        this.refreshTargetEffect();
    };
    GameSprite.prototype.resetTargetEffect = function () {
        if (this.isDisposed)
            return;
        var target = {
            x: 0,
            y: 0,
            rotation: 0,
            alpha: 1,
            scaleX: 1,
            scaleY: 1,
            hue: 0,
            blur: 0
        };
        var targetTonal = {
            tonal_r: 0,
            tonal_g: 0,
            tonal_b: 0,
            tonal_gray: 0,
            tonal_mr: 1,
            tonal_mg: 1,
            tonal_mb: 1
        };
        for (var s in target) {
            this[s] = target[s];
        }
        this.setTonal(targetTonal.tonal_r, targetTonal.tonal_g, targetTonal.tonal_b, targetTonal.tonal_gray, targetTonal.tonal_mr, targetTonal.tonal_mb);
    };
    GameSprite.prototype.refreshTargetEffect = function (install) {
        if (install === void 0) { install = true; }
        this.resetTargetEffect();
        var materialAnis = [], rgbAnis = [];
        for (var i = 0; i < this._animationTargetEffect.length; i++) {
            var t = this._animationTargetEffect[i];
            if (!t || t.isDisposed)
                continue;
            if (t.materialsDataExit) {
                materialAnis.push(t);
            }
            else if (!Config.EDIT_MODE || !t.inAniEditor || Config.BEHAVIOR_EDIT_MODE) {
                rgbAnis.push(t);
            }
        }
        if (install) {
            this.installTargetMaterialsEffect(materialAnis);
        }
        else {
            this.refreshTargetMaterialsEffect(materialAnis);
        }
        this.refreshAnimationTargetEffect(rgbAnis);
    };
    GameSprite.prototype.installTargetMaterialsEffect = function (anis) {
        if (this.isDisposed)
            return;
        this.clearMaterials();
        if (anis.length <= 0)
            return;
        var target = {
            x: 0,
            y: 0,
            rotation: 0,
            alpha: 1,
            scaleX: 1,
            scaleY: 1,
        };
        var materialGroups = [{ materials: [] }];
        for (var i = 0; i < anis.length; i++) {
            var t = anis[i];
            target.x += t.x;
            target.y += t.y;
            target.rotation += t.rotation;
            target.alpha *= t.alpha;
            target.scaleX *= t.scaleX;
            target.scaleY *= t.scaleY;
            if (t.materialData) {
                materialGroups = materialGroups.concat(t.materialData);
            }
        }
        for (var s in target) {
            this[s] = target[s];
        }
        this.installMaterialData(materialGroups);
    };
    GameSprite.prototype.refreshTargetMaterialsEffect = function (anis) {
        if (this.isDisposed)
            return;
        if (anis.length <= 0)
            return;
        var target = {
            x: 0,
            y: 0,
            rotation: 0,
            alpha: 1,
            scaleX: 1,
            scaleY: 1,
        };
        var materialGroups = [{ materials: [] }];
        for (var i = 0; i < anis.length; i++) {
            var t = anis[i];
            target.x += t.x;
            target.y += t.y;
            target.rotation += t.rotation;
            target.alpha *= t.alpha;
            target.scaleX *= t.scaleX;
            target.scaleY *= t.scaleY;
            if (t.materialData) {
                materialGroups = materialGroups.concat(t.materialData);
            }
        }
        for (var s in target) {
            this[s] = target[s];
        }
        for (var j = 0; j < materialGroups.length; j++) {
            var materials = materialGroups[j].materials;
            for (var m = 0; m < materials.length; m++) {
                var materialValues = {};
                var materialData = materials[m];
                for (var key in materialData) {
                    var value = materialData[key];
                    if (typeof value == "number") {
                        materialValues["mu" + materialData.id + "_" + key] = value;
                    }
                }
                this.setMaterialValueFast(materialValues, j);
            }
        }
    };
    GameSprite.prototype.refreshAnimationTargetEffect = function (anis) {
        if (this.isDisposed)
            return;
        if (anis.length <= 0)
            return;
        var target = {
            x: this.x,
            y: this.y,
            rotation: this.rotation,
            alpha: this.alpha,
            scaleX: this.scaleX,
            scaleY: this.scaleY,
            hue: 0,
            blur: 0
        };
        var targetTonal = {
            tonal_r: 0,
            tonal_g: 0,
            tonal_b: 0,
            tonal_gray: 0,
            tonal_mr: 1,
            tonal_mg: 1,
            tonal_mb: 1
        };
        for (var i = 0; i < anis.length; i++) {
            var t = anis[i];
            target.x += t.x;
            target.y += t.y;
            target.rotation += t.rotation;
            target.alpha *= t.alpha;
            target.scaleX *= t.scaleX;
            target.scaleY *= t.scaleY;
            target.hue = t.hue;
            target.blur += t.blur;
            targetTonal.tonal_r += t.tonal_r;
            targetTonal.tonal_g += t.tonal_g;
            targetTonal.tonal_b += t.tonal_b;
            targetTonal.tonal_gray += t.tonal_gray;
            targetTonal.tonal_mr *= t.tonal_mr;
            targetTonal.tonal_mg *= t.tonal_mg;
            targetTonal.tonal_mb *= t.tonal_mb;
        }
        for (var s in target) {
            this[s] = target[s];
        }
        this.setTonal(targetTonal.tonal_r, targetTonal.tonal_g, targetTonal.tonal_b, targetTonal.tonal_gray, targetTonal.tonal_mr, targetTonal.tonal_mb);
    };
    Object.defineProperty(GameSprite.prototype, "filterEnabled", {
        get: function () {
            return this._filterEnabled;
        },
        set: function (v) {
            this._filterEnabled = v;
            this.refreshFilters();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "gameFilters", {
        get: function () {
            return [];
        },
        set: function (v) {
        },
        enumerable: false,
        configurable: true
    });
    GameSprite.prototype.appendGameFilter = function (gameFilter) {
    };
    GameSprite.prototype.subtractGameFilter = function (gameFilter) {
    };
    GameSprite.prototype.setTonal = function (r, g, b, gray, mr, mg, mb) {
        if (mr === void 0) { mr = 1; }
        if (mg === void 0) { mg = 1; }
        if (mb === void 0) { mb = 1; }
        r || (r = 0);
        g || (g = 0);
        b || (b = 0);
        gray || (gray = 0);
        if (mr == null)
            mr = 1;
        if (mg == null)
            mr = 1;
        if (mb == null)
            mr = 1;
        if (this._tonalFilter) {
            this._tonalFilter = null;
        }
        this._tonalParams[0] = r;
        this._tonalParams[1] = g;
        this._tonalParams[2] = b;
        this._tonalParams[3] = gray;
        this._tonalParams[4] = mr;
        this._tonalParams[5] = mg;
        this._tonalParams[6] = mb;
        if (r == 0 && g == 0 && b == 0 && gray == 0 && mr == 1 && mg == 1 && mb == 1) {
            this.refreshFilters();
            return;
        }
        var rt1 = 1 - (1 - 0.3086) * gray / 100;
        var gt1 = 1 - (1 - 0.6094) * gray / 100;
        var bt1 = 1 - (1 - 0.0820) * gray / 100;
        var rt0 = 0 - (0 - 0.3086) * gray / 100;
        var gt0 = 0 - (0 - 0.6094) * gray / 100;
        var bt0 = 0 - (0 - 0.0820) * gray / 100;
        this._tonalFilter = new ColorFilter([
            rt1 * mr, gt0, bt0, 0, r / 255,
            rt0, gt1 * mg, bt0, 0, g / 255,
            rt0, gt0, bt1 * mb, 0, b / 255,
            0, 0, 0, 1, 0
        ]);
        this.refreshFilters();
    };
    GameSprite.prototype.getTonal = function () {
        return this._tonalParams.concat();
    };
    GameSprite.prototype.isInherit = function (sp) {
        var p = this.parent;
        while (p) {
            if (p == sp)
                return true;
            p = p.parent;
        }
        return false;
    };
    Object.defineProperty(GameSprite.prototype, "disabled", {
        get: function () {
            return !this.mouseEnabled;
        },
        set: function (v) {
            this.mouseEnabled = !v;
            if (v)
                this.setTonal(0, 0, 0, 100);
            else
                this.setTonal(0, 0, 0, 0);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "tips", {
        get: function () {
            return this._tips ? this._tips : "";
        },
        set: function (v) {
            if (!Config.EDIT_MODE)
                return;
            this._tips = v;
            if (v)
                Tips.reg(this, v, true);
            else
                Tips.cancelReg(this);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "show", {
        get: function () {
            return this._show;
        },
        set: function (v) {
            this._show = v;
            this.visible = this._show && this._showOnEditor;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "showOnEditor", {
        get: function () {
            return this._showOnEditor;
        },
        set: function (v) {
            if (!Config.EDIT_MODE)
                return;
            this._showOnEditor = v;
            this.visible = this._show && this._showOnEditor;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "opacity", {
        get: function () {
            return this._opacity;
        },
        set: function (v) {
            this._opacity = v;
            this.refreshRealAlpha();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "blend", {
        get: function () {
            return this._blend;
        },
        set: function (v) {
            v = Math.min(5, Math.max(v, 0));
            this._blend = v;
            if (!Config.EDIT_MODE)
                this.blendMode = [null, "lighter", "blend5-1", "blend4-1", "blend4-7", "blend4-4"][v];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "opacityPer", {
        get: function () {
            return this._opacityPer;
        },
        set: function (v) {
            this._opacityPer = v;
            this.refreshRealAlpha();
        },
        enumerable: false,
        configurable: true
    });
    GameSprite.prototype.refreshRealAlpha = function () {
        if (this.useDPCoord) {
            this.alpha = this._opacity * this._opacityPer * this._dpOpacity;
        }
        else {
            this.alpha = this._opacity * this._opacityPer;
        }
    };
    Object.defineProperty(GameSprite.prototype, "mouseEventEnabled", {
        get: function () {
            return this._mouseEventEnabled;
        },
        set: function (v) {
            this._mouseEventEnabled = v;
            this.mouseEnabled = this._mouseEventEnabled && this._mouseEventEnabledInEditor;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "mouseEventEnabledInEditor", {
        get: function () {
            return this._mouseEventEnabledInEditor;
        },
        set: function (v) {
            this._mouseEventEnabledInEditor = v;
            this.mouseEnabled = this._mouseEventEnabled && this._mouseEventEnabledInEditor;
        },
        enumerable: false,
        configurable: true
    });
    GameSprite.prototype.refreshFilter = function () {
    };
    GameSprite.prototype.subtractFilter = function (subtract) {
    };
    GameSprite.prototype.appended = function (appended, childLayer) {
        if (childLayer === void 0) { childLayer = false; }
    };
    Object.defineProperty(GameSprite.prototype, "hue", {
        get: function () {
            return this._hue;
        },
        set: function (v) {
            v || (v = 0);
            v = Math.floor(v);
            this._hue = v;
            this._hueFilter = null;
            if (this._hue) {
                this._hueFilter = new HueFilter(this._hue);
            }
            this.refreshFilters();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "blur", {
        get: function () {
            return this._blur;
        },
        set: function (v) {
            v || (v = 0);
            this._blur = v;
            this._blurFilter = null;
            if (this._blur) {
                this._blurFilter = new BlurFilter(this._blur);
            }
            this.refreshFilters();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "tonal_r", {
        get: function () {
            return this._tonalParams[0];
        },
        set: function (v) {
            v || (v = 0);
            this._tonalParams[0] = v;
            this.setTonal(this.tonal_r, this._tonalParams[1], this._tonalParams[2], this._tonalParams[3], this._tonalParams[4], this._tonalParams[5], this._tonalParams[6]);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "tonal_g", {
        get: function () {
            return this._tonalParams[1];
        },
        set: function (v) {
            v || (v = 0);
            this._tonalParams[1] = v;
            this.setTonal(this.tonal_r, this._tonalParams[1], this._tonalParams[2], this._tonalParams[3], this._tonalParams[4], this._tonalParams[5], this._tonalParams[6]);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "tonal_b", {
        get: function () {
            return this._tonalParams[2];
        },
        set: function (v) {
            v || (v = 0);
            this._tonalParams[2] = v;
            this.setTonal(this.tonal_r, this._tonalParams[1], this._tonalParams[2], this._tonalParams[3], this._tonalParams[4], this._tonalParams[5], this._tonalParams[6]);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "tonal_gray", {
        get: function () {
            return this._tonalParams[3];
        },
        set: function (v) {
            v || (v = 0);
            this._tonalParams[3] = v;
            this.setTonal(this.tonal_r, this._tonalParams[1], this._tonalParams[2], this._tonalParams[3], this._tonalParams[4], this._tonalParams[5], this._tonalParams[6]);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "tonal_mr", {
        get: function () {
            return this._tonalParams[4];
        },
        set: function (v) {
            if (v == null)
                v = 1;
            this._tonalParams[4] = v;
            this.setTonal(this.tonal_r, this._tonalParams[1], this._tonalParams[2], this._tonalParams[3], this._tonalParams[4], this._tonalParams[5], this._tonalParams[6]);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "tonal_mb", {
        get: function () {
            return this._tonalParams[6];
        },
        set: function (v) {
            if (v == null)
                v = 1;
            this._tonalParams[6] = v;
            this.setTonal(this.tonal_r, this._tonalParams[1], this._tonalParams[2], this._tonalParams[3], this._tonalParams[4], this._tonalParams[5], this._tonalParams[6]);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "tonal_mg", {
        get: function () {
            return this._tonalParams[5];
        },
        set: function (v) {
            if (v == null)
                v = 1;
            this._tonalParams[5] = v;
            this.setTonal(this.tonal_r, this._tonalParams[1], this._tonalParams[2], this._tonalParams[3], this._tonalParams[4], this._tonalParams[5], this._tonalParams[6]);
        },
        enumerable: false,
        configurable: true
    });
    GameSprite.prototype.getAllMaterialDatas = function () {
        var materialPassDataArr = [];
        for (var i = 0; i < this.materialPassArr.length; i++) {
            var d = this.materialPassArr[i];
            if (!d)
                continue;
            materialPassDataArr.push({ materials: d.materials });
        }
        return materialPassDataArr;
    };
    GameSprite.prototype.installMaterialData = function (materialData, resetTime) {
        if (resetTime === void 0) { resetTime = true; }
        if (!materialData)
            return;
        this.clearMaterials();
        for (var i = 0; i < materialData.length; i++) {
            var passData = materialData[i];
            for (var s = 0; s < passData.materials.length; s++) {
                var mData = passData.materials[s];
                this.addMaterial(mData, i, resetTime);
            }
        }
    };
    GameSprite.prototype.addMaterial = function (materialData, passage, resetTime) {
        if (passage === void 0) { passage = 0; }
        if (resetTime === void 0) { resetTime = true; }
        var pass = this.getMaterialPassage(passage, true);
        if (!pass)
            return false;
        if (resetTime)
            materialData.____timeInfo = {};
        pass.materials.push(materialData);
        this.setMaterialDirty();
        return true;
    };
    GameSprite.prototype.addMaterialAt = function (materialData, index, passage) {
        if (passage === void 0) { passage = 0; }
        var pass = this.getMaterialPassage(passage, true);
        if (!pass || index < 0)
            return false;
        pass.materials.splice(index, 0, materialData);
        this.setMaterialDirty();
        return true;
    };
    GameSprite.prototype.addMaterialByID = function (materialID, passage) {
        if (passage === void 0) { passage = 0; }
        var pass = this.getMaterialPassage(passage, true);
        if (!pass)
            return false;
        var cls = window["MaterialData" + materialID];
        if (!cls)
            return false;
        var materialData = new cls;
        pass.materials.push(materialData);
        this.setMaterialDirty();
        return true;
    };
    GameSprite.prototype.addMaterialAtByID = function (materialID, index, passage) {
        if (passage === void 0) { passage = 0; }
        var pass = this.getMaterialPassage(passage, true);
        if (!pass || index < 0)
            return false;
        var cls = window["MaterialData" + materialID];
        if (!cls)
            return false;
        var materialData = new cls;
        pass.materials.splice(index, 0, materialData);
        this.setMaterialDirty();
        return true;
    };
    GameSprite.prototype.removeMaterial = function (materialData, passage) {
        if (passage === void 0) { passage = 0; }
        var pass = this.getMaterialPassage(passage, true);
        if (!pass)
            return false;
        var idx = pass.materials.indexOf(materialData);
        if (idx == -1)
            return false;
        pass.materials.splice(idx, 1);
        this.setMaterialDirty();
        return true;
    };
    GameSprite.prototype.removeMaterialAt = function (index, passage) {
        if (passage === void 0) { passage = 0; }
        var pass = this.getMaterialPassage(passage, true);
        if (!pass || index < 0 || index >= pass.materials.length)
            return false;
        pass.materials.splice(index, 1);
        this.setMaterialDirty();
        return true;
    };
    GameSprite.prototype.removeMaterialByID = function (materialID, passage) {
        if (passage === void 0) { passage = 0; }
        var pass = this.getMaterialPassage(passage, true);
        if (!pass)
            return false;
        var idx = ArrayUtils.matchAttributes(pass.materials, { id: materialID }, true, "==", true)[0];
        if (idx != null) {
            pass.materials.splice(idx, 1);
            this.setMaterialDirty();
            return true;
        }
        return false;
    };
    GameSprite.prototype.getMaterialByID = function (materialID, passage) {
        if (passage === void 0) { passage = 0; }
        var pass = this.getMaterialPassage(passage, true);
        if (!pass)
            return null;
        return ArrayUtils.matchAttributes(pass.materials, { id: materialID }, true)[0];
    };
    GameSprite.prototype.getMaterialAt = function (index, passage) {
        if (passage === void 0) { passage = 0; }
        var pass = this.getMaterialPassage(passage, true);
        if (!pass || index < 0)
            return null;
        return pass.materials[index];
    };
    GameSprite.prototype.getMaterialLength = function (passage) {
        if (passage === void 0) { passage = 0; }
        var pass = this.getMaterialPassage(passage, true);
        if (!pass)
            return 0;
        return pass.materials.length;
    };
    GameSprite.prototype.getMaterialPassLength = function () {
        return this.materialPassArr.length;
    };
    GameSprite.prototype.clearMaterials = function () {
        for (var i = 0; i < this.materialPassArr.length; i++) {
            this.materialPassArr[i].dispose();
        }
        this.materialPassArr.length = 0;
        this.setMaterialDirty();
    };
    GameSprite.prototype.clearMaterialsInPass = function (passage, deletePass) {
        if (deletePass === void 0) { deletePass = false; }
        if (passage < 0)
            return;
        var pass = this.materialPassArr[passage];
        if (pass) {
            pass.materials.length = 0;
            this.setMaterialDirty();
            if (deletePass) {
                this.materialPassArr.splice(passage, 1);
                pass.dispose();
            }
        }
    };
    GameSprite.prototype.setMaterialIndex = function (material, toIndex, passage) {
        if (passage === void 0) { passage = 0; }
        var pass = this.getMaterialPassage(passage, true);
        if (!pass)
            return false;
        var fromIndex = pass.materials.indexOf(material);
        if (fromIndex == -1)
            return false;
        if (toIndex < 0 || toIndex > pass.materials.length)
            return false;
        ArrayUtils.setIndex(pass.materials, pass, toIndex);
        this.setMaterialDirty();
        return true;
    };
    GameSprite.prototype.swapMaterialIndex = function (fromIndex, toIndex, passage) {
        if (passage === void 0) { passage = 0; }
        var pass = this.getMaterialPassage(passage, true);
        if (!pass)
            return false;
        if (fromIndex < 0 || fromIndex >= pass.materials.length)
            return false;
        if (toIndex < 0 || toIndex >= pass.materials.length)
            return false;
        ArrayUtils.swap(pass.materials, fromIndex, toIndex);
        this.setMaterialDirty();
        return true;
    };
    GameSprite.prototype.swapMaterialPass = function (passFromIndex, passToIndex) {
        if (passFromIndex < 0 || passFromIndex >= this.materialPassArr.length)
            return false;
        if (passToIndex < 0 || passToIndex >= this.materialPassArr.length)
            return false;
        ArrayUtils.swap(this.materialPassArr, passFromIndex, passToIndex);
        this.setMaterialDirty();
        return true;
    };
    GameSprite.prototype.setMaterialsByGameSprite = function (gameSprite, cloneMode) {
        if (gameSprite.isDisposed || this.isDisposed)
            return;
        this.clearMaterials();
        for (var i = 0; i < gameSprite.materialPassArr.length; i++) {
            var mPass = gameSprite.materialPassArr[i];
            var newPass = new GameSpriteMaterialPass(this);
            newPass.materials = cloneMode ? ObjectUtils.depthClone(mPass.materials) : mPass.materials.concat();
            this.materialPassArr.push(newPass);
        }
        this.setMaterialDirty();
    };
    GameSprite.prototype.setMaterialDirty = function () {
        Callback.CallLaterBeforeRender(this.doSetMaterialDirty, this);
    };
    GameSprite.prototype.doSetMaterialDirty = function () {
        if (this.isDisposed)
            return;
        for (var i = 0; i < this.materialPassArr.length; i++) {
            this.materialPassArr[i].refreshRenderData();
        }
        this.refreshFilters();
    };
    GameSprite.prototype.setMaterialValueFast = function (materialValues, passage) {
        var _this_1 = this;
        if (passage === void 0) { passage = 0; }
        Callback.CallLaterBeforeRender(function () {
            var pass = _this_1.materialPassArr[passage];
            if (!pass || !pass.shaderData)
                return;
            for (var i in materialValues) {
                pass.shaderData[i] = materialValues[i];
            }
            _this_1.doRepaint();
        }, this);
    };
    GameSprite.prototype.doRepaint = function () {
        if (this.isDisposed)
            return;
        this.repaint();
    };
    GameSprite.prototype.getMaterialPassage = function (passage, ifNotExistCreate) {
        if (passage < 0)
            return null;
        for (var i = 0; i < passage; i++) {
            if (this.materialPassArr[i])
                continue;
            var pass = this.materialPassArr[i] = new GameSpriteMaterialPass(this);
        }
        var passageArr = this.materialPassArr[passage];
        if (ifNotExistCreate && !passageArr && this.materialPassArr.length == passage) {
            this.materialPassArr[passage] = passageArr = new GameSpriteMaterialPass(this);
        }
        return passageArr;
    };
    GameSprite.prototype.refreshFilters = function () {
        var filters = [];
        if (this._tonalFilter) {
            filters.push(this._tonalFilter);
        }
        if (this._hueFilter) {
            filters.push(this._hueFilter);
        }
        if (this._blurFilter) {
            filters.push(this._blurFilter);
        }
        if (this._filterEnabled) {
            filters = this.materialPassArr.concat(filters);
        }
        this.filters = filters;
    };
    GameSprite.ON_DISPOSE = "GameSpriteON_DISPOSE";
    return GameSprite;
}(Sprite));
Object.defineProperty(GameSprite.prototype, 'width', {
    get: function () {
        if (!this.autoSize)
            return this._width;
        return this.getSelfBounds().width;
    },
    set: function (value) {
        if (this._width !== value) {
            this._width = value;
            this.conchModel && this.conchModel.size(value, this._height);
            this.repaint();
            this.event(EventObject.RESIZE);
        }
    }
});
Object.defineProperty(GameSprite.prototype, 'height', {
    get: function () {
        if (!this.autoSize)
            return this._height;
        return this.getSelfBounds().height;
    },
    set: function (value) {
        if (this._height !== value) {
            this._height = value;
            this.conchModel && this.conchModel.size(this._width, value);
            this.repaint();
            this.event(EventObject.RESIZE);
        }
    }
});















var GameSpriteMaterialPass = (function (_super) {
    __extends(GameSpriteMaterialPass, _super);
    function GameSpriteMaterialPass(gameSprite) {
        var _this_1 = _super.call(this) || this;
        _this_1.varMacros = [];
        _this_1.kdsSetMaterialMacros = [];
        _this_1.materials = [];
        _this_1.materialsPerShaderFuncs = [];
        _this_1.materialsTransInfos = [];
        _this_1.listenVarCallbacks = [];
        _this_1.listenStrVarCallbacks = [];
        _this_1.timeFuncs = [];
        _this_1.imageLoads = [];
        if (Render.isWebGL)
            WebGLFilter.enable();
        _this_1._action = new GameSpriteMaterialPassActionGL();
        _this_1._action.data = _this_1;
        _this_1.gameSprite = gameSprite;
        if (Config.EDIT_MODE) {
            EventUtils.addEventListener(EUIWindowDataStructureConfig, EUIWindowDataStructureConfig.EVENT_CUSTOM_DATA_CHANGED, Callback.New(_this_1.onCustomDataChange, _this_1));
        }
        return _this_1;
    }
    GameSpriteMaterialPass.prototype.dispose = function () {
        this.clearRegFuncs();
    };
    GameSpriteMaterialPass.prototype.clearRegFuncs = function () {
        for (var i = 0; i < this.listenVarCallbacks.length; i++) {
            var cbs = this.listenVarCallbacks[i];
            var varID = cbs[0];
            var cb = cbs[1];
            Game.player.removeListenerPlayerVariable(0, varID, cb);
        }
        this.listenVarCallbacks.length = 0;
        for (var i = 0; i < this.listenStrVarCallbacks.length; i++) {
            var cbs = this.listenStrVarCallbacks[i];
            var varID = cbs[0];
            var cb = cbs[1];
            Game.player.removeListenerPlayerVariable(2, varID, cb);
        }
        this.listenVarCallbacks.length = 0;
        for (var i = 0; i < this.timeFuncs.length; i++) {
            os.remove_ENTERFRAME(this.timeFuncs[i], this);
        }
        this.timeFuncs.length = 0;
        for (var i = 0; i < this.imageLoads.length; i++) {
            var url = this.imageLoads[i];
            AssetManager.disposeImage(url);
        }
        this.imageLoads.length = 0;
        for (var i = 0; i < this.materialsTransInfos.length; i++) {
            var transV = this.materialsTransInfos[i];
            if (TransData.isUseFrame(transV.transData)) {
                os.remove_ENTERFRAME(transV.funcSign, this);
            }
            else {
                clearInterval(transV.funcSign);
            }
        }
        this.materialsTransInfos.length = 0;
        if (this.shaderTime) {
            os.remove_ENTERFRAME(this.shaderTimeLoopFunction, this);
        }
    };
    GameSpriteMaterialPass.prototype.onCustomDataChange = function (mode) {
        if (mode == EUIWindowDataStructureConfig.MODE_CUSTOM_MATERIAL) {
            GameSpriteMaterialPass.materialSettingAttrsCache = [];
            GameSpriteMaterialPass.materialSettingBlockMappingCache = [];
        }
    };
    GameSpriteMaterialPass.color2RGB = function (color) {
        if (typeof color != "string")
            return [0, 0, 0];
        var r = MathUtils.int("0x" + color.substr(1, 2)) / 255;
        var g = MathUtils.int("0x" + color.substr(3, 2)) / 255;
        var b = MathUtils.int("0x" + color.substr(5, 2)) / 255;
        return [r, g, b];
    };
    Object.defineProperty(GameSpriteMaterialPass.prototype, "action", {
        get: function () {
            return this._action;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameSpriteMaterialPass.prototype, "type", {
        get: function () {
            return GameSpriteMaterialPass.shaderType;
        },
        enumerable: false,
        configurable: true
    });
    GameSpriteMaterialPass.prototype.refreshRenderData = function () {
        var _this_1 = this;
        this.shaderSize = false;
        this.shaderTime = false;
        this.clearRegFuncs();
        this.shaderData = {};
        this.varMacros = [];
        this.materialsPerShaderFuncs = [];
        this.materialsTransInfos = [];
        var varMacrosForID = [];
        var varInBlockMapping = {};
        this.kdsSetMaterialMacros.length = 0;
        var len = this.materials.length;
        var shaderTimeOnce = false;
        for (var i = 0; i < len; i++) {
            var material = this.materials[i];
            if (material.enable != null && !material.enable)
                continue;
            var materialID = material.id;
            var materialSetting = Game.data.materialList.data[materialID];
            if (!materialSetting)
                continue;
            if (materialSetting.shaderSize) {
                this.shaderSize = true;
            }
            if (materialSetting.shaderTime && !shaderTimeOnce) {
                this.shaderTime = true;
                shaderTimeOnce = true;
                os.add_ENTERFRAME(this.shaderTimeLoopFunction = function () {
                    Callback.CallLaterBeforeRender(_this_1.gameSprite.doRepaint, _this_1.gameSprite);
                }, this);
            }
            if (!Config.EDIT_MODE) {
                var perShaderClacFunc = GameSpriteMaterialPass.materialSettingPerShaderClacTSCode[materialID];
                if (!perShaderClacFunc) {
                    eval("perShaderClacFunc = GameSpriteMaterialPass.materialSettingPerShaderClacTSCode[materialID] = function(shader,sp){" + materialSetting.customPreShaderClacJS + "}");
                }
                this.materialsPerShaderFuncs[i] = perShaderClacFunc;
            }
            CustomCompositeSetting.fixShaderTsValue(materialID, material, materialSetting);
            var mAttrs = GameSpriteMaterialPass.materialSettingAttrsCache[materialID];
            if (!mAttrs) {
                var mAttrArr = CustomCompositeSetting.getAllAttributes(materialSetting, true, varInBlockMapping);
                mAttrs = {};
                for (var m = 0; m < mAttrArr.length; m++) {
                    var mAttr = mAttrArr[m];
                    mAttrs[mAttr.attr.varName] = mAttr;
                }
                GameSpriteMaterialPass.materialSettingAttrsCache[materialID] = mAttrs;
                GameSpriteMaterialPass.materialSettingBlockMappingCache[materialID] = varInBlockMapping;
            }
            else {
                varInBlockMapping = GameSpriteMaterialPass.materialSettingBlockMappingCache[materialID];
            }
            var idValue = {};
            var varNameValue = {};
            for (var s in material) {
                var mAttr = mAttrs[s];
                if (!mAttr)
                    continue;
                var oriValue = material[s];
                if (typeof oriValue == "function")
                    continue;
                varNameValue[s] = oriValue;
                idValue[mAttr.attr.id] = oriValue;
            }
            for (var s in material) {
                var oriValue = material[s];
                if (typeof oriValue == "function")
                    continue;
                var mAttr = mAttrs[s];
                var runtimeValue = this.getMaterialRuntimeValue(material, s, oriValue, mAttr, idValue, varNameValue, varInBlockMapping[s]);
                this.shaderData["mu" + materialID + "_" + s] = runtimeValue;
                if (runtimeValue != null) {
                    this.varMacros.push("MU" + materialID + "_" + s);
                    varMacrosForID.push(s);
                }
            }
            this.kdsSetMaterialMacros.push(materialID);
        }
        this.kdsSetMaterialMacrosID = "_" + this.kdsSetMaterialMacros.join("_") + "-" + varMacrosForID.join("-") + "-" + this.varMacros.join("-");
    };
    GameSpriteMaterialPass.prototype.getMaterialRuntimeValue = function (material, varName, oriValue, attrSetting, idValue, varNameValue, block) {
        var _this_1 = this;
        function returnNullHandle() {
            if (compType == 13 || compType == 22 || compType == 14) {
                var uvInfoName = "mu" + material.id + "_" + varName + "_UVInfo";
                this.shaderData[uvInfoName] = [0, 0, 0, 0];
            }
        }
        if (!attrSetting || !block) {
            returnNullHandle.apply(this);
            return null;
        }
        ;
        var compType = attrSetting.attr.compData.compType;
        if (CustomAttributeSetting.getShaderUniformType(attrSetting.attr) == null) {
            returnNullHandle.apply(this);
            return null;
        }
        var canShowInBlock = CustomCompositeBlock.meetConditionData(block, idValue, varNameValue);
        if (!canShowInBlock) {
            returnNullHandle.apply(this);
            return null;
        }
        var canShow = CustomCompositeAttributeSetting.meetConditionData(attrSetting.attrConditions, idValue, varNameValue);
        if (!canShow) {
            returnNullHandle.apply(this);
            return null;
        }
        if (compType == 12) {
            return GameSpriteMaterialPass.color2RGB(oriValue);
        }
        else if (compType == 41) {
            var transData = GameUtils.getTransData(oriValue);
            if (!transData || transData.timeType == 0) {
                transData = new TransData();
                transData.timeType = 2;
            }
            var isLoop = TransData.isLoop(transData);
            if (TransData.isUseFrame(transData)) {
                var totalFrame = transData.totalTime - 1;
                if (totalFrame <= 0)
                    return null;
                if (!material.____timeInfo)
                    material.____timeInfo = {};
                var currentFrame = MathUtils.int(material.____timeInfo[varName]);
                if (currentFrame > totalFrame)
                    currentFrame = totalFrame;
                var transV = { muVarName: "mu" + material.id + "_" + varName, currentFrame: currentFrame, totalFrame: totalFrame, transData: transData, isLoop: isLoop, value: null, funcSign: null, lastRefresh: null };
                var f;
                os.add_ENTERFRAME(f = function (transV, material, varName) {
                    if (transV.currentFrame > transV.totalFrame) {
                        if (!transV.isLoop) {
                            os.remove_ENTERFRAME(arguments.callee, _this_1);
                            return;
                        }
                        else {
                            transV.lastRefresh = 0;
                            transV.currentFrame = 0;
                        }
                    }
                    if (transV.lastRefresh == null || transV.currentFrame - transV.lastRefresh >= transV.transData.refreshInterval / Game.oneFrame) {
                        transV.lastRefresh = transV.currentFrame;
                        var per = transV.currentFrame / transV.totalFrame;
                        var value = GameUtils.getValueByTransData(transV.transData, per);
                        transV.value = value;
                        Callback.CallLaterBeforeRender(_this_1.gameSprite.doRepaint, _this_1.gameSprite);
                    }
                    transV.currentFrame++;
                    if (!material.____timeInfo)
                        material.____timeInfo = {};
                    material.____timeInfo[varName] = transV.currentFrame;
                }, this, [transV, material, varName]);
                transV.funcSign = f;
                f.apply(this, [transV, material, varName]);
            }
            else if (TransData.isUseTime(transData)) {
                totalFrame = Math.floor(transData.totalTime * 1000 / transData.refreshInterval);
                if (!material.____timeInfo)
                    material.____timeInfo = {};
                var currentFrame = MathUtils.int(material.____timeInfo[varName]);
                if (currentFrame > totalFrame)
                    currentFrame = totalFrame;
                var transV = { muVarName: "mu" + material.id + "_" + varName, currentFrame: currentFrame, totalFrame: totalFrame, transData: transData, isLoop: isLoop, value: null, funcSign: null, lastRefresh: null };
                var f;
                var interSign = setInterval(f = function (transV, material, varName) {
                    if (transV.currentFrame > transV.totalFrame) {
                        if (!transV.isLoop) {
                            clearInterval(transV.funcSign);
                            return;
                        }
                        else {
                            transV.currentFrame = 0;
                        }
                    }
                    var per = transV.currentFrame == transV.totalFrame ? 1 : transV.currentFrame / transV.totalFrame;
                    var value = GameUtils.getValueByTransData(transV.transData, per);
                    transV.value = value;
                    transV.currentFrame++;
                    Callback.CallLaterBeforeRender(_this_1.gameSprite.doRepaint, _this_1.gameSprite);
                    if (!material.____timeInfo)
                        material.____timeInfo = {};
                    material.____timeInfo[varName] = transV.currentFrame;
                }, transData.refreshInterval, transV, material, varName);
                transV.funcSign = interSign;
                f.apply(this, [transV, material, varName]);
            }
            if (totalFrame == null)
                return null;
            this.materialsTransInfos.push(transV);
            return 0;
        }
        else if (compType == 6) {
            if (Config.EDIT_MODE || Config.BEHAVIOR_EDIT_MODE) {
                return 0;
            }
            var varID = MathUtils.int(oriValue);
            if (varID == 0)
                return 0;
            var cb = Callback.New(function (shaderValueName, typeID, varID, value) {
                _this_1.shaderData[shaderValueName] = value;
                _this_1.gameSprite.repaint();
            }, this, ["mu" + material.id + "_" + varName]);
            this.listenVarCallbacks.push([varID, cb]);
            Game.player.addListenerPlayerVariable(0, varID, cb, false, false);
            return Game.player.variable.getVariable(oriValue);
        }
        else if (compType == 13 || compType == 22 || compType == 14) {
            var uvInfoName = "mu" + material.id + "_" + varName + "_UVInfo";
            if (compType == 14) {
                var strVarID = GameUtils.getVarID(oriValue);
                if (strVarID != 0) {
                    if (Config.EDIT_MODE || Config.BEHAVIOR_EDIT_MODE) {
                        returnNullHandle.apply(this);
                        return null;
                    }
                    oriValue = Game.player.variable.getString(strVarID);
                    var cb = Callback.New(function (shaderValueName, uvInfoName, oldUrl, material, varName, typeID, varID, value) {
                        var oldTexIdx = _this_1.imageLoads.indexOf(oldUrl);
                        if (oldTexIdx != -1) {
                            _this_1.imageLoads.splice(oldTexIdx, 1);
                            AssetManager.disposeImage(oldUrl);
                        }
                        _this_1.shaderData[shaderValueName] = getTextureValue.apply(_this_1, [value, material, varName, uvInfoName]);
                        _this_1.gameSprite.repaint();
                    }, this, ["mu" + material.id + "_" + varName, uvInfoName, oriValue, material, varName]);
                    this.listenStrVarCallbacks.push([strVarID, cb]);
                    Game.player.addListenerPlayerVariable(2, strVarID, cb, false, false);
                }
            }
            function getTextureValue(oriValue, material, varName, uvInfoName) {
                var _this_1 = this;
                if (typeof oriValue != "string") {
                    returnNullHandle.apply(this);
                    return null;
                }
                var tex = AssetManager.getImage(oriValue);
                if (!tex) {
                    this.imageLoads.push(oriValue);
                    AssetManager.loadImage(oriValue, Callback.New(function (shaderValueName, uvInfoName, tex) {
                        _this_1.shaderData[shaderValueName] = tex ? tex.source : null;
                        if (tex)
                            _this_1.shaderData[uvInfoName] = [tex.uv[2] - tex.uv[0], tex.uv[5] - tex.uv[1], tex.uv[0], tex.uv[1]];
                        else
                            _this_1.shaderData[uvInfoName] = [0, 0, 0, 0];
                        _this_1.gameSprite.repaint();
                    }, this, ["mu" + material.id + "_" + varName, uvInfoName]), true, true, true);
                    this.shaderData[uvInfoName] = [0, 0, 0, 0];
                    return null;
                }
                else {
                    if (tex.url) {
                        this.imageLoads.push(tex.url);
                        AssetManager.loadImage(tex.url, null, true, true, false);
                    }
                    if (!tex["__rendered"]) {
                        var sp = new Sprite;
                        sp.texture = tex;
                        sp.texture["__rendered"] = true;
                        AssetManager.prerender(sp);
                        sp.texture = null;
                        sp.destroy(true);
                    }
                    this.shaderData[uvInfoName] = [tex.uv[2] - tex.uv[0], tex.uv[5] - tex.uv[1], tex.uv[0], tex.uv[1]];
                    return tex.source;
                }
            }
            return getTextureValue.apply(this, [oriValue, material, varName, uvInfoName]);
        }
        return oriValue;
    };
    GameSpriteMaterialPass.shaderType = 0x800;
    GameSpriteMaterialPass.frameCount = 0;
    GameSpriteMaterialPass.materialSettingAttrsCache = [];
    GameSpriteMaterialPass.materialSettingBlockMappingCache = [];
    GameSpriteMaterialPass.materialSettingPerShaderClacTSCode = [];
    return GameSpriteMaterialPass;
}(Filter));
var GameSpriteMaterialPassActionGL = (function (_super) {
    __extends(GameSpriteMaterialPassActionGL, _super);
    function GameSpriteMaterialPassActionGL() {
        return _super.call(this) || this;
    }
    GameSpriteMaterialPassActionGL.prototype.apply3d = function (scope, sprite, context, x, y) {
        var b = scope.getValue("bounds");
        var shaderValue = Value2D.create(0x01, 0);
        shaderValue.setFilters([this.data]);
        var tMatrix = Matrix.TEMP;
        tMatrix.identity();
        context.ctx.drawTarget(scope, 0, 0, b.width, b.height, tMatrix, "src", shaderValue);
        shaderValue.setFilters(null);
    };
    ;
    Object.defineProperty(GameSpriteMaterialPassActionGL.prototype, "typeMix", {
        get: function () {
            return GameSpriteMaterialPass.shaderType;
        },
        enumerable: false,
        configurable: true
    });
    GameSpriteMaterialPassActionGL.prototype.setValueMix = function (shader) {
        shader.defines.add(this.data.type);
        var o = shader;
    };
    ;
    GameSpriteMaterialPassActionGL.prototype.setValue = function (shader) {
        var shaderData = this.data.shaderData;
        for (var i in shaderData) {
            shader[i] = shaderData[i];
        }
        shader.kdsSetMaterialMacros = this.data.kdsSetMaterialMacros;
        shader.kdsSetMaterialMacrosID = this.data.kdsSetMaterialMacrosID;
        shader.kdsVarMacros = this.data.varMacros;
        var sp = this.data.gameSprite;
        if (this.data.shaderSize) {
            if (sp.hasTilingAttribute) {
                if (sp instanceof ClientSceneLayer) {
                    if (!sp.drawMode) {
                        var tex = AssetManager.getImage(sp.mapUrl);
                        if (tex) {
                            shader["renderTargetSize"] = [tex.width + 8, tex.height + 8];
                        }
                    }
                    else {
                        shader["u_yFilp"] = 1.0;
                        var selfBounds = sp.getSelfBounds();
                        shader["renderTargetSize"] = [selfBounds.width + 8, selfBounds.height + 8];
                    }
                }
            }
            else {
                var selfBounds = sp.getSelfBounds();
                shader["renderTargetSize"] = [selfBounds.width + 8, selfBounds.height + 8];
            }
        }
        else {
            if (sp instanceof ClientSceneLayer && sp.drawMode) {
                shader["u_yFilp"] = 1.0;
            }
        }
        if (this.data.shaderTime) {
            shader["time"] = GameSpriteMaterialPass.frameCount;
            if (GameSpriteMaterialPass.frameCount != __fCount) {
                GameSpriteMaterialPass.frameCount++;
                GameSpriteMaterialPass.frameCount = __fCount;
            }
        }
        if (Config.EDIT_MODE) {
            var materials = this.data.materials;
            var materialsLen = materials.length;
            var materialListData = Game.data.materialList.data;
            for (var s = 0; s < materialsLen; s++) {
                var material = materials[s];
                var materialSetting = materialListData[material.id];
                if (materialSetting && materialSetting.customPreShaderClacJS) {
                    try {
                        eval(materialSetting.customPreShaderClacJS);
                    }
                    catch (e) {
                        trace("[#GAME_THE_MATERIAL]" + material.id + "[#GAME_ERROR_IN_EXTRA_CALCULATION_BEFORE_PARAMETER_TRANSFER]", e.stack);
                    }
                }
            }
        }
        else {
            var materials = this.data.materials;
            var materialsLen = materials.length;
            var materialListData = Game.data.materialList.data;
            for (var s = 0; s < materialsLen; s++) {
                var material = materials[s];
                var perShaderClacFunc = this.data.materialsPerShaderFuncs[s];
                if (perShaderClacFunc) {
                    perShaderClacFunc.apply(this, [shader, sp]);
                }
            }
        }
        var materialsTransInfos = this.data.materialsTransInfos;
        if (materialsTransInfos) {
            for (var s = 0; s < materialsTransInfos.length; s++) {
                var m = materialsTransInfos[s];
                shader[m.muVarName] = m.value;
            }
        }
    };
    ;
    return GameSpriteMaterialPassActionGL;
}(FilterActionGL));
var GameUI = (function () {
    function GameUI() {
    }
    GameUI.isOpened = function (uiID) {
        var ui = GameUI.get(uiID);
        if (ui && ui.stage)
            return true;
        return false;
    };
    GameUI.load = function (id, copy) {
        if (copy === void 0) { copy = false; }
        var data = Common.uiList.data[id];
        if (!data)
            return null;
        if (Config.EDIT_MODE) {
            if (data) {
                return GameUI.parse(data.uiDisplayData, false, null, id);
            }
            return GameUI.getEmptyRoot(id);
        }
        if (!copy && this.uiDatas[id]) {
            return this.uiDatas[id];
        }
        var instanceClassName = data.uiDisplayData.instanceClassName;
        var classObj = window[instanceClassName];
        if (!classObj)
            classObj = window["GUI_" + id];
        if (!classObj) {
            var emptyRoot = this.uiDatas[id] = new UIComponent.UIRoot;
            GameUI.parse(data.uiDisplayData, false, null, id, emptyRoot);
            return emptyRoot;
        }
        if (id == 0) {
            root = this.uiDatas[id] = GameUI.getEmptyRoot(id);
            return root;
        }
        var root = new classObj();
        if (!copy) {
            this.uiDatas[id] = root;
        }
        return root;
    };
    GameUI.getAllSystemGroupUIs = function () {
        return GameUI.uiDatas;
    };
    GameUI.get = function (id) {
        return GameUI.uiDatas[id];
    };
    GameUI.dispose = function (id) {
        var ui = GameUI.uiDatas[id];
        if (ui) {
            delete GameUI.uiDatas[id];
            ui.dispose();
            EventUtils.happen(GameUI, GameUI.EVENT_CLOSE_SYSTEM_UI, [id]);
        }
    };
    GameUI.show = function (id) {
        var ui = this.load(id);
        Game.layer.uiLayer.addChild(ui);
        EventUtils.happen(GameUI, GameUI.EVENT_OPEN_SYSTEM_UI, [id]);
        return ui;
    };
    GameUI.hide = function (id) {
        var ui = GameUI.uiDatas[id];
        if (ui && ui.stage) {
            Game.layer.uiLayer.removeChild(ui);
            EventUtils.happen(GameUI, GameUI.EVENT_CLOSE_SYSTEM_UI, [id]);
        }
    };
    GameUI.hideAll = function () {
        for (var id in GameUI.uiDatas) {
            var ui = GameUI.uiDatas[id];
            if (ui.stage) {
                ui.removeSelf();
                EventUtils.happen(GameUI, GameUI.EVENT_CLOSE_SYSTEM_UI, [id]);
            }
        }
    };
    GameUI.init = function () {
        for (var i in UIComponent) {
            window[i] = UIComponent[i];
        }
    };
    GameUI.getEmptyRoot = function (id) {
        var root = new UIComponent.UIRoot(true, id);
        Callback.New(function () { root.event(EventObject.LOADED); }, this).delayRun(0);
        return root;
    };
    GameUI.parse = function (data, newID, childList, uiID, root, syncLoadedEventWhenAssetExist) {
        if (newID === void 0) { newID = false; }
        if (childList === void 0) { childList = null; }
        if (uiID === void 0) { uiID = null; }
        if (root === void 0) { root = null; }
        if (syncLoadedEventWhenAssetExist === void 0) { syncLoadedEventWhenAssetExist = false; }
        if (!root)
            root = new UIComponent.UIRoot(true, data.id);
        if (!root || !data || !data.root) {
            return null;
        }
        root["hasRootCommand"] = data.hasRootCommand ? data.hasRootCommand.concat() : [];
        if (!root["compsIDInfo"])
            root["compsIDInfo"] = {};
        addChild(root, data.root.children);
        function addChild(parent, childDatas) {
            if (!childDatas)
                return;
            for (var i = 0; i < childDatas.length; i++) {
                var childData = childDatas[i];
                var compClass = childData.type;
                if (!compClass)
                    continue;
                var childInstance;
                if (!Config.EDIT_MODE && compClass == "UIGUI") {
                    var data = Game.data.uiList.data[childData.guiID];
                    if (data) {
                        if (childData.instanceClassName && window[childData.instanceClassName]) {
                            childInstance = new window[childData.instanceClassName](false, childData.guiID);
                        }
                        else if (data.uiDisplayData.instanceClassName && window[data.uiDisplayData.instanceClassName]) {
                            childInstance = new window[data.uiDisplayData.instanceClassName](false, childData.guiID);
                        }
                        else {
                            var guiCls = window["GUI_" + childData.guiID];
                            if (guiCls) {
                                childInstance = new guiCls(false, childData.guiID);
                                childInstance.onlyForPreload = root.onlyForPreload;
                            }
                            else {
                                console.log("can not find class GUI_" + childData.guiID + ".");
                                return;
                            }
                        }
                    }
                    else {
                        childInstance = new UIComponent.UIRoot(false, childData.guiID);
                    }
                }
                else {
                    var clsObj = UIComponent[childData.type];
                    if (!clsObj)
                        continue;
                    childInstance = new clsObj();
                }
                if (childInstance instanceof UIComponent.UIBitmap)
                    childInstance.defaultStateImage = false;
                childInstance.guiRoot = root;
                if (childList)
                    childList.push(childInstance);
                var childrenData = childData.children;
                for (var s in childData) {
                    if (s == "children" || (!Config.EDIT_MODE && GameUI.excludeAttrDataMapping[s]))
                        continue;
                    var attr = childData[s];
                    if (newID && s == "id") {
                        childInstance["__id"] = attr;
                        continue;
                    }
                    if (typeof attr == "boolean" || typeof attr == "number" || typeof attr == "string") {
                        var realAttrName = GameUI.attrDataMapping[s];
                        if (!Config.EDIT_MODE && realAttrName) {
                            childInstance[realAttrName] = attr;
                        }
                        else {
                            childInstance[s] = attr;
                        }
                    }
                    else {
                        try {
                            childInstance[s] = ObjectUtils.depthClone(attr);
                        }
                        catch (e) { }
                    }
                }
                if (!root[childInstance.name]) {
                    root[childInstance.name] = childInstance;
                }
                root["compsIDInfo"][childInstance.id] = childInstance;
                parent.addChild(childInstance);
                childInstance.constructorInit(uiID, syncLoadedEventWhenAssetExist);
                addChild(childInstance, childrenData);
            }
        }
        root.constructorInit(uiID, syncLoadedEventWhenAssetExist);
        if (!root.onlyForPreload)
            EventUtils.happen(GameUI, GameUI.EVENT_CREATE_UI, [root]);
        return root;
    };
    GameUI.getAllCompChildren = function (ui, keyValueMode, conditionFunc) {
        if (conditionFunc === void 0) { conditionFunc = null; }
        var allComps = [];
        ArrayUtils.getTreeNodeArray(ui, "_childs", allComps);
        if (keyValueMode) {
            var nodeObjs2 = {};
            var len = allComps.length;
            for (var s = 0; s < len; s++) {
                var nodeComp = allComps[s];
                if (nodeComp instanceof UIComponent.UIBase) {
                    if (!conditionFunc || conditionFunc.apply(this, [nodeComp])) {
                        nodeObjs2[nodeComp.id] = nodeComp;
                    }
                }
            }
            return { arr: allComps, keyValue: nodeObjs2 };
        }
        return { arr: allComps, keyValue: null };
    };
    GameUI.EVENT_TEST_LOAD_CHILD_UI = "EVENT_TEST_LOAD_CHILD_UI";
    GameUI.EVENT_OPEN_SYSTEM_UI = "GameUIEVENT_OPEN_SYSTEM_UI";
    GameUI.EVENT_CLOSE_SYSTEM_UI = "GameUIEVENT_CLOSE_SYSTEM_UI";
    GameUI.EVENT_CREATE_UI = "GameUIEVENT_CREATE_UI";
    GameUI.uiTaskHead = "kds.ui.active";
    GameUI.uiDatas = {};
    GameUI.attrDataMapping = { "mouseEventEnabledData": "mouseEventEnabled" };
    GameUI.excludeAttrDataMapping = { "showOnEditor": true, "mouseEventEnabledInEditor": true };
    return GameUI;
}());
var GameFunction = (function () {
    function GameFunction() {
    }
    Object.defineProperty(GameFunction, "scene", {
        get: function () {
            return Config.EDIT_MODE && this._scene ? this._scene : typeof Game == "undefined" ? null : Game.currentScene;
        },
        set: function (scene) {
            this._scene = scene;
        },
        enumerable: false,
        configurable: true
    });
    GameFunction.shake = function (strength, duration) {
        if (Game && Game.pause && Game.currentScene && Game.currentScene.mapSupportPause) {
            Callback.CallLater(GameFunction.shake, GameFunction, [strength, duration]);
            return;
        }
        var me = arguments.callee;
        if (GameFunction.lock) {
            var args = arguments;
            this["shakeCB"] = Callback.New(function () {
                me.apply(this, args);
            }, this).delayRun(1, setFrameout);
            return;
        }
        if (this["shakeCB"]) {
            this["shakeCB"].stopDelay(clearFrameout);
        }
        var scene = this.scene;
        ;
        if (!scene || scene.isDisposed)
            return;
        if (duration == 0) {
            scene.camera.offsetX = 0;
            scene.camera.offsetY = 0;
            return;
        }
        ;
        scene.camera.offsetX = strength * (Math.random() < 0.5 ? 1 : -1);
        scene.camera.offsetY = strength * (Math.random() < 0.5 ? 1 : -1);
        this["shakeCB"] = Callback.New(function () {
            me.apply(this, [strength, duration - 1]);
        }, this).delayRun(1, setFrameout);
    };
    GameFunction.tonal = function (r, g, b, gray, t, mr, mg, mb, layer, tCur) {
        if (layer === void 0) { layer = -1; }
        if (tCur === void 0) { tCur = null; }
        if (Game && Game.pause && Game.currentScene && Game.currentScene.mapSupportPause) {
            Callback.CallLater(GameFunction.tonal, GameFunction, [r, g, b, gray, t, mr, mg, mb, layer, tCur]);
            return;
        }
        var me = arguments.callee;
        if (GameFunction.lock) {
            var args = arguments;
            this["tonalCB"] = Callback.New(function () {
                me.apply(this, args);
            }, this).delayRun(1, setFrameout);
            return;
        }
        if (this["tonalCB"]) {
            this["tonalCB"].stopDelay(clearFrameout);
        }
        if (t < 1)
            t = 1;
        var s, scene = this.scene;
        if (!scene || scene.isDisposed)
            return;
        if (!tCur) {
            tCur = 1;
            s = scene.displayObject.getTonal();
            this["tonalCB_startValue"] = s;
        }
        else {
            s = this["tonalCB_startValue"];
        }
        var per = tCur / t;
        function toValue(from, to, per) {
            return from - (from - to) * per;
        }
        scene.displayObject.setTonal(toValue(s[0], r, per), toValue(s[1], g, per), toValue(s[2], b, per), toValue(s[3], gray, per), toValue(s[4], mr, per), toValue(s[5], mg, per), toValue(s[6], mb, per));
        tCur++;
        if (tCur > t) {
            return;
        }
        ;
        this["tonalCB"] = Callback.New(function () {
            me.apply(this, [r, g, b, gray, t, mr, mg, mb, layer, tCur]);
        }, this).delayRun(1, setFrameout);
    };
    GameFunction.cameraMove = function (type, x, y, soIndex, tween, t, tCur, window_width, window_height) {
        if (tCur === void 0) { tCur = null; }
        if (window_width === void 0) { window_width = null; }
        if (window_height === void 0) { window_height = null; }
        if (Game && Game.pause && Game.currentScene && Game.currentScene.mapSupportPause) {
            Callback.CallLater(GameFunction.cameraMove, GameFunction, [type, x, y, soIndex, tween, t, tCur, window_width, window_height]);
            return;
        }
        if (!window_width)
            window_width = Config.WINDOW_WIDTH;
        if (!window_height)
            window_height = Config.WINDOW_HEIGHT;
        var me = arguments.callee;
        if (this["cameraMoveCB"]) {
            this["cameraMoveCB"].stopDelay(clearFrameout);
        }
        var scene = this.scene;
        if (!scene || scene.isDisposed)
            return;
        var startRect = scene.camera.viewPort;
        if (tCur == null) {
            this["cameraMove_from"] = new Point(startRect.x, startRect.y);
            tCur = 1;
            scene.camera.sceneObject = null;
            scene.updateCamera();
        }
        var fromP = this["cameraMove_from"];
        var toP, soc;
        if (type == 1) {
            if (soIndex >= 0) {
                soc = scene.sceneObjects[soIndex];
                if (soc) {
                    toP = new Point(soc.x - window_width * 0.5, soc.y - window_height * 0.5);
                }
            }
        }
        else {
            toP = new Point(x - window_width * 0.5, y - window_height * 0.5);
        }
        if (!toP) {
            return;
        }
        var curP, per;
        if (tween) {
            per = Ease.strongOut(tCur, 0, 1, t);
        }
        else {
            per = tCur / t;
        }
        curP = Point.interpolate(toP, fromP, per);
        scene.camera.viewPort.x = curP.x;
        scene.camera.viewPort.y = curP.y;
        scene.updateCamera();
        tCur++;
        if (tCur > t) {
            if (type == 1) {
                scene.camera.sceneObject = soc;
                scene.updateCamera();
            }
            return;
        }
        ;
        this["cameraMoveCB"] = Callback.New(function () {
            me.apply(this, [type, x, y, soIndex, tween, t, tCur, window_width, window_height]);
        }, this).delayRun(1, setFrameout);
    };
    GameFunction.fogSet = function (url, sx, sy, dx, dy, alpha, blendMode) {
        if (Game && Game.pause && Game.currentScene && Game.currentScene.mapSupportPause) {
            Callback.CallLater(GameFunction.fogSet, GameFunction, [url, sx, sy, dx, dy, alpha, blendMode]);
            return;
        }
        var scene = this.scene;
        ;
        if (sx == 0)
            sx = 1;
        if (sy == 0)
            sy = 1;
        scene.fogLayer.scaleX = sx;
        scene.fogLayer.scaleY = sy;
        scene.fogLayer.xLoop = true;
        scene.fogLayer.yLoop = true;
        scene.fogLayer.xMove = dx;
        scene.fogLayer.yMove = dy;
        scene.fogLayer.alpha = alpha;
        scene.fogLayer.blendMode = blendMode == 0 ? null : "lighter";
        if (scene.fogLayer.mapUrl != url)
            scene.fogLayer.setBigImage(url);
    };
    GameFunction.playTS = function (soIndex, url, volume, pitch) {
        if (soIndex == -1) {
            GameAudio.playTS(url, volume, pitch);
            return;
        }
        var soc = this.scene.sceneObjects[soIndex];
        if (!soc)
            return;
        GameAudio.playTS(url, volume, pitch, soc);
    };
    GameFunction.stopTS = function () {
        GameAudio.stopTS();
    };
    GameFunction.playSE = function (soIndex, url, volume, pitch) {
        if (soIndex == -1) {
            GameAudio.playSE(url, volume, pitch);
            return;
        }
        var soc = this.scene.sceneObjects[soIndex];
        if (!soc)
            return;
        GameAudio.playSE(url, volume, pitch, soc);
    };
    GameFunction.stopSE = function () {
        GameAudio.stopSE();
    };
    GameFunction.playBGM = function (bgmURL, volume, pitch, fadeIn) {
        GameAudio.playBGM(bgmURL, volume, 99999, fadeIn != 0, fadeIn * 1000, pitch);
    };
    GameFunction.playBGS = function (bgsURL, volume, pitch, fadeIn) {
        GameAudio.playBGS(bgsURL, volume, 99999, fadeIn != 0, fadeIn * 1000, pitch);
    };
    GameFunction.stopBGM = function (fadeOut) {
        GameAudio.stopBGM(fadeOut != 0, fadeOut * 1000);
    };
    GameFunction.stopBGS = function (fadeOut) {
        GameAudio.stopBGS(fadeOut != 0, fadeOut * 1000);
    };
    GameFunction.openUI = function (id) {
        GameUI.show(id);
    };
    GameFunction.closeUI = function (id) {
        GameUI.hide(id);
    };
    GameFunction.executeScript = function (code) {
        eval(code);
    };
    return GameFunction;
}());
for (var i in GameFunction) {
    if (i == "scene")
        continue;
    var attr = GameFunction[i];
    if (typeof attr == "function") {
        GameFunction.prototype[i] = attr;
    }
}
ObjectUtils.redefinedEventFunc = function redefinedEventFunc(clsName, types, toObjName, checkMouseEvent) {
    if (checkMouseEvent === void 0) { checkMouseEvent = false; }
    var EvArr = ["hasListener", "on", "once", "off", "offAll", "isMouseEvent"];
    if (checkMouseEvent) {
        types = types.concat(___mouseEvent);
    }
    var typesStr = JSON.stringify(types);
    for (var i in EvArr) {
        var mouseCheckCode = "";
        if (checkMouseEvent && (i == "2" || i == "3" || i == "4" || i == "5")) {
            mouseCheckCode = "if(" + ___mouseEventStr + ".indexOf(type)!=-1){\n                if(this." + toObjName + ")this.mouseEnabled = this." + toObjName + ".mouseEnabled;\n            }";
        }
        eval("\n                    " + clsName + ".prototype._" + EvArr[i] + " = " + clsName + ".prototype." + EvArr[i] + ";\n                    " + clsName + ".prototype." + EvArr[i] + " = function(type){\n                        if(" + typesStr + ".indexOf(type)!=-1){\n                            var t = null;\n                            if(this." + toObjName + ")t = this." + toObjName + "." + EvArr[i] + ".apply(this." + toObjName + ",arguments);\n                            " + mouseCheckCode + "\n                            return t;\n                        }\n                        else{\n                            return this._" + EvArr[i] + ".apply(this,arguments);\n                        }\n                    }\n                ");
    }
};
Shader2D.initMaterial = function () {
    ShaderValue.kdsMaterialShaders = [];
    Shader.sharders = [];
    Shader.KDSPSShaderLogicArr = {};
    var materialUniformCode = "";
    var materialUniformFuncs = "";
    var materialLogicCode = "// KDS_PS_SHADER_LOGICS\n";
    var materialList = Game.data.materialList;
    var len = materialList ? GameListData.getLength(materialList) : 0;
    var exit = false;
    for (var i = 1; i <= len; i++) {
        var material = materialList.data[i];
        if (!material)
            continue;
        var mf_mainReg = new RegExp("vec4 +?mf" + i + "_main {0,999}\\(");
        var shaderCode = material.customShader;
        if (!shaderCode)
            continue;
        shaderCode = CustomCompositeSetting.replaceShaderNotes(material, shaderCode, "");
        if (shaderCode.search(mf_mainReg) == -1)
            continue;
        exit = true;
        var MACRO_START = "\n#ifdef KDS_M" + i + "\n";
        var MACRO_END = "\n#endif\n";
        var uniformsCode = CustomCompositeSetting.getShaderUniformCodes(material, false) + "\n";
        materialUniformCode += MACRO_START;
        materialUniformCode += uniformsCode;
        materialUniformCode += MACRO_END;
        materialUniformFuncs += MACRO_START;
        materialUniformFuncs += shaderCode + "\n";
        materialUniformFuncs += MACRO_END;
        var KDSShaderLogic = "";
        KDSShaderLogic += MACRO_START;
        KDSShaderLogic += "gl_FragColor=mf" + i + "_main();\n";
        KDSShaderLogic += MACRO_END;
        Shader.KDSPSShaderLogicArr["KDS_M" + i] = KDSShaderLogic;
    }
    if (len == 0 || !exit) {
        Shader.addInclude("parts/KDS_ps_logic.glsl", " ", true);
        Shader.addInclude("parts/KDS_ps_uniform.glsl", " ", true);
    }
    else {
        Shader.addInclude("parts/KDS_ps_logic.glsl", materialLogicCode, true);
        if (materialUniformCode + materialUniformFuncs != "") {
            Shader.addInclude("parts/KDS_ps_uniform.glsl", materialUniformCode + materialUniformFuncs, true);
        }
    }
    var vs, ps;
    vs = "\n\t attribute vec4 position;\n\t attribute vec2 texcoord;\n\t uniform vec2 size;\n\t #ifdef WORLDMAT\n\t  uniform mat4 mmat;\n\t #endif\n\t varying vec2 v_texcoord;\n\t void main() {\n\t\t   vec2 sizex = size;\n\t\t   #ifdef WORLDMAT\n\t\t\tvec4 pos=mmat*position;\n\t\t\tgl_Position =vec4((pos.x/sizex.x-0.5)*2.0,(0.5-pos.y/sizex.y)*2.0,pos.z,1.0);\n\t\t   #else\n\t\t\tgl_Position =vec4((position.x/sizex.x-0.5)*2.0,(0.5-position.y/sizex.y)*2.0,position.z,1.0);\n\t\t   #endif\n\t\t  v_texcoord = texcoord;\n\t }";
    ps = "\n\t " + (Config.EDIT_MODE ? "#define IN_GC_EDITOR" : "") + "\n\t precision mediump float;\n\t //precision highp float;\n\t varying vec2 v_texcoord;\n\t uniform sampler2D texture;\n\t uniform float alpha;\n\t uniform vec2 renderTargetSize;\n\t uniform float u_yFilp;\n\t uniform float time;\n \n\t vec2 getDrawUV(vec2 texcoord,vec4 p){\n\t\t vec2 drawUV = texcoord;\n\t\t drawUV.x = fract(drawUV.x);\n\t\t if(u_yFilp==1.0){\n\t\t\t drawUV.y = fract(drawUV.y);\n\t\t }\n\t\t else{\n\t\t\t drawUV.y = fract(drawUV.y)*-1.0+1.0;\n\t\t }\n\t\t \n \n\t\t drawUV.x *= p.x;\n\t\t drawUV.y *= p.y;\n \n\t\t drawUV.x += p.z;\n\t\t drawUV.y += p.w;\n \n\t\t return drawUV;\n\t }\n\t vec4 getTextureColor(vec2 texcoord) {\n\t\t  vec4 color= texture2D(texture, fract(texcoord));\n\t\t  return color;\n\t }\n \n\t vec2 getInRangeTextureCoord(vec2 texcoord){\n\t\t return fract(texcoord);\n\t }\n\t \n\t #include?KDS  \"parts/KDS_ps_uniform.glsl\";\n\t #include?BLUR_FILTER  \"parts/BlurFilter_ps_uniform.glsl\";\n\t #include?COLOR_FILTER \"parts/ColorFilter_ps_uniform.glsl\";\n\t #include?GLOW_FILTER \"parts/GlowFilter_ps_uniform.glsl\";\n\t #include?COLOR_ADD \"parts/ColorAdd_ps_uniform.glsl\";\n\t void main() {\n \n\t\t vec4 color= getTextureColor(v_texcoord);\n\t\t color.a*=alpha;\n\t\t color.rgb*=alpha;\n\t\t gl_FragColor=color;\n \n\t\t\t#include?KDS  \"parts/KDS_ps_logic.glsl\";\n\t\t\t#include?COLOR_ADD \"parts/ColorAdd_ps_logic.glsl\"; \n\t\t\t#include?BLUR_FILTER  \"parts/BlurFilter_ps_logic.glsl\";\n\t\t\t#include?COLOR_FILTER \"parts/ColorFilter_ps_logic.glsl\";\n\t\t\t#include?GLOW_FILTER \"parts/GlowFilter_ps_logic.glsl\";\n \n\t\t //    gl_FragColor.g = 1.0;\n \n\t }";
    Shader.preCompile2D(0, 0x01, vs, ps, null);
    vs = "\n\t attribute vec4 position;\n\t attribute vec2 texcoord;\n\t uniform vec2 size;\n\t #ifdef WORLDMAT\n\t uniform mat4 mmat;\n\t #endif\n\t varying vec2 v_texcoord;\n\t void main() {\n\t\t   #ifdef WORLDMAT\n\t\t\t vec4 pos=mmat*position;\n\t\t\t gl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\n\t\t   #else\n\t\t\t gl_Position =vec4((position.x/size.x-0.5)*2.0,(0.5-position.y/size.y)*2.0,position.z,1.0);\n\t\t   #endif\n\t\t   v_texcoord = texcoord;\n\t }";
    ps = "\n\t " + (Config.EDIT_MODE ? "#define IN_GC_EDITOR" : "") + "\n\t #ifdef FSHIGHPRECISION\n\t precision highp float;\n\t #else\n\t precision mediump float;\n\t #endif\n\t //precision highp float;\n\t varying vec2 v_texcoord;\n\t uniform sampler2D texture;\n\t uniform float alpha;\n\t uniform vec4 u_TexRange;\n\t uniform vec2 u_offset;\n\t uniform vec2 renderTargetSize;\n\t uniform float time;\n \n\t vec2 getDrawUV(vec2 texcoord,vec4 p){\n\t\t vec2 drawUV = texcoord;\n\t\t drawUV.x = fract(drawUV.x);\n\t\t drawUV.y = fract(drawUV.y); // *-1.0+1.0\n \n\t\t drawUV.x *= p.x;\n\t\t drawUV.y *= p.y;\n \n\t\t drawUV.x += p.z;\n\t\t drawUV.y += p.w;\n \n\t\t return drawUV;\n\t }\n\t \n\t vec4 getTextureColor(vec2 texcoord) {\n\t\t  vec2 newTexCoord;\n\t\t  newTexCoord.x = mod(u_offset.x + texcoord.x,u_TexRange.y) + u_TexRange.x;\n\t\t  newTexCoord.y = mod(u_offset.y + texcoord.y,u_TexRange.w) + u_TexRange.z;\n\t\t  vec4 color = texture2D(texture, newTexCoord);\n\t\t  return color;\n\t }\n \n\t vec2 getInRangeTextureCoord(vec2 texcoord){\n\t\t vec2 newTexCoord;\n\t\t newTexCoord.x = fract(mod(u_offset.x + texcoord.x,u_TexRange.y) + u_TexRange.x);\n\t\t newTexCoord.y = fract(mod(u_offset.y + texcoord.y,u_TexRange.w) + u_TexRange.z);\n\t\t return newTexCoord;\n\t }\n \n\t #include?KDS  \"parts/KDS_ps_uniform.glsl\";\n\t #include?BLUR_FILTER  \"parts/BlurFilter_ps_uniform.glsl\";\n\t #include?COLOR_FILTER \"parts/ColorFilter_ps_uniform.glsl\";\n\t #include?GLOW_FILTER \"parts/GlowFilter_ps_uniform.glsl\";\n\t #include?COLOR_ADD \"parts/ColorAdd_ps_uniform.glsl\";\n\t void main() {\n\t\t vec4 color= getTextureColor(v_texcoord);\n\t\t color.a*=alpha;\n\t\t color.rgb*=alpha;\n\t\t gl_FragColor=color;\n\t\t  #include?KDS  \"parts/KDS_ps_logic.glsl\";\n\t\t  #include?COLOR_ADD \"parts/ColorAdd_ps_logic.glsl\";   \n\t\t  #include?BLUR_FILTER  \"parts/BlurFilter_ps_logic.glsl\";\n\t\t  #include?COLOR_FILTER \"parts/ColorFilter_ps_logic.glsl\";\n\t\t  #include?GLOW_FILTER \"parts/GlowFilter_ps_logic.glsl\";\n\t }";
    Shader.preCompile2D(0, 0x100, vs, ps, null);
    ShaderDefines2D.reg("KDS", GameSpriteMaterialPass.shaderType);
};
Shader2D.__init__ = function () {
    Shader.addInclude("parts/ColorFilter_ps_uniform.glsl", "uniform vec4 colorAlpha;\nuniform mat4 colorMat;");
    Shader.addInclude("parts/ColorFilter_ps_logic.glsl", "mat4 alphaMat =colorMat;\n\nalphaMat[0][3] *= gl_FragColor.a;\nalphaMat[1][3] *= gl_FragColor.a;\nalphaMat[2][3] *= gl_FragColor.a;\n\ngl_FragColor = gl_FragColor * alphaMat;\ngl_FragColor += colorAlpha*gl_FragColor.a;\n");
    Shader.addInclude("parts/GlowFilter_ps_uniform.glsl", "\n\t uniform vec4 u_color;\n\t uniform float u_strength;\n\t uniform float u_blurX;\n\t uniform float u_blurY;\n\t uniform float u_offsetX;\n\t uniform float u_offsetY;\n\t uniform float u_textW;\n\t uniform float u_textH;");
    Shader.addInclude("parts/GlowFilter_ps_logic.glsl", "\n\t const float c_IterationTime = 10.0;\n\t float floatIterationTotalTime = c_IterationTime * c_IterationTime;\n\t vec4 vec4Color = vec4(0.0,0.0,0.0,0.0);\n\t vec2 vec2FilterDir = vec2(-(u_offsetX)/u_textW,-(u_offsetY)/u_textH);\n\t vec2 vec2FilterOff = vec2(u_blurX/u_textW/c_IterationTime * 2.0,u_blurY/u_textH/c_IterationTime * 2.0);\n\t float maxNum = u_blurX * u_blurY;\n\t vec2 vec2Off = vec2(0.0,0.0);\n\t float floatOff = c_IterationTime/2.0;\n\t for(float i = 0.0;i<=c_IterationTime; ++i){\n\t\t\t for(float j = 0.0;j<=c_IterationTime; ++j){\n\t\t\t\t vec2Off = vec2(vec2FilterOff.x * (i - floatOff),vec2FilterOff.y * (j - floatOff));\n\t\t\t\t vec4Color += texture2D(texture, v_texcoord + vec2FilterDir + vec2Off)/floatIterationTotalTime;\n\t\t\t }\n\t }\n\t gl_FragColor = vec4(u_color.rgb,vec4Color.a * u_strength);\n\t gl_FragColor.rgb *= gl_FragColor.a;");
    Shader.addInclude("parts/BlurFilter_ps_logic.glsl", "gl_FragColor =   blur();\ngl_FragColor.w*=alpha;");
    Shader.addInclude("parts/BlurFilter_ps_uniform.glsl", "\n\t uniform vec4 strength_sig2_2sig2_gauss1;\n\t uniform vec2 blurInfo;\n \n\t vec4 blur(){\n\t   float mu3_strength = strength_sig2_2sig2_gauss1[0];\n\t   \n \n\t   // \u5982\u679C\u5F3A\u5EA6\u4E3A0\u5219\u76F4\u63A5\u8FD4\u56DE\n\t\tif(mu3_strength==0.0)return gl_FragColor;\n\t   // \u5468\u56F4NxN\u50CF\u7D20\uFF0C\u4EE5\u81EA\u5DF1\u4E3A\u4E2D\u5FC3 blurw\u8D8A\u5927\u5219\u6548\u679C\u8D8A\u597D\uFF0C\u4F46\u8D8A\u6D88\u8017\u6027\u80FD\n\t   const float blurw = 9.0;\n\t   float blurw10 = (blurw+1.0);\n\t   float blurw5 = blurw10/2.0;\n\t   float blurw100 = blurw10*blurw10;\n\t   float blurw50 =  blurw100/2.0;\n\t   float blurwP1 = 1.0/blurw100;\n\t   // \u83B7\u53D6\u5355\u4F4D\u50CF\u7D20\uFF0C\u5E76\u6839\u636E\u5F3A\u5EA6\u8FDB\u884C\u6269\u6563\n\t   float dx = 1.0/blurInfo.x * mu3_strength/3.0; // 100=(blurw+1)^2\n\t   float dy = 1.0/blurInfo.y * mu3_strength/3.0; // 100=(blurw+1)^2\n\t   // \n\t   vec4 vec4Color = vec4(0.0,0.0,0.0,0.0);\n\t   float halfDx = dx * blurw50;\n\t   float halfDy = dy * blurw50;\n\t   // \u8D77\u59CB\u5750\u6807\uFF1A\u5F53\u524D\u5750\u6807\u70B9 - N/2\n\t   vec2 startpos=vec2(v_texcoord.x-halfDx,v_texcoord.y-halfDy);\n\t   vec2 ctexcoord = startpos;\n\t   // \u5206\u644A\u7684\u989C\u8272\n\t   float pColorPer = blurwP1;\n\t   // \u91C7\u6837\u56FA\u5B9A\u504F\u79FB\n\t   float fixDx = halfDx - dx*blurw5;\n\t   float fixDy = halfDy - dy*blurw5;\n\t   // \u91C7\u6837\u4EE5\u81EA\u5DF1\u4E3A\u4E2D\u5FC3\u91C7\u6837 N x N \u50CF\u7D20\u8FDB\u884C\u6DF7\u5408\n\t   for(float y = 0.0;y<=blurw; ++y){\n\t\t  for(float x = 0.0;x<=blurw; ++x){\n\t\t\t\t  ctexcoord.x = startpos.x + dx*x + fixDx;\n\t\t\t   ctexcoord.y = startpos.y + dy*y + fixDy;\n\t\t\t   float xPer = (1.0-abs((x-blurw5)/blurw5));\n\t\t\t   float yPer = (1.0-abs((y-blurw5)/blurw5));\n\t\t\t   vec4Color += getTextureColor(ctexcoord)*pColorPer*xPer*yPer*4.0;\n\t\t   }\n\t  }\n\t  return vec4Color;\n\t }\n\t \n\t \n\t \n\t ");
    var KDSLogin = "\n\t\t gl_FragColor =   cccc();\ngl_FragColor.w*=alpha;\n\t ";
    var KDSLogin2 = "\n\t\t gl_FragColor.r = 1.0;\n\t\t // gl_FragColor.w*=alpha;\n\t ";
    var KDSUniform = "\n\t uniform vec4 strength_sig2_2sig2_gauss1;\n\t uniform vec2 blurInfo;\n \n\t uniform mat4 colorMatx;\n\t uniform vec4 colorMaty;\n\t \n\t \n\t uniform float xxxxx;\n\t uniform sampler2D tex2;\n\t uniform sampler2D tex3;\n\t uniform vec2 kds_vec2;\n\t uniform vec3 kds_vec3;\n\t uniform vec4 kds_vec4;\n\t uniform float rd;\n\t uniform float rd2;\n\t uniform float fd;\n\t uniform float autoI;\n \n\t uniform float zzzzw;\n \n\t \n\t \n\t \n\t // uniform sampler2D tex4;\n\t // uniform sampler2D tex5;\n\t // uniform sampler2D tex6;\n\t // uniform sampler2D tex7;\n\t // uniform sampler2D tex8;\n\t // uniform sampler2D tex9;\n\t // uniform sampler2D tex10;\n \n\t // uniform sampler2D tex11;\n\t // uniform sampler2D tex12;\n\t // uniform sampler2D tex13;\n \n\t // uniform sampler2D tex14;\n\t // uniform sampler2D tex15;\n\t // uniform sampler2D tex16;\n \n\t // uniform sampler2D tex17;\n\t // uniform sampler2D tex18;\n\t // uniform sampler2D tex19;\n\t \n\t \n\t uniform float mu1_a1;\n\t uniform float mu1_a2;\n \n\t \n\t \n \n\t vec4 bbbb(){\n\t\t return vec4(1.0,0.5,0.0,1.0);\n\t }\n\t vec4 cccc(){\n\t\t gl_FragColor.g += mu1_a2;\n\t\t return gl_FragColor;;\n \n\t\t // \u6D4B\u8BD5\u8272\u8C03\n\t\t // mat4 alphaMat =colorMatx;\n\t\t // float lastDr = alphaMat[0][3];\n\t\t // float lastDg = alphaMat[1][3];\n\t\t // float lastDb = alphaMat[2][3];\n\t\t // alphaMat[0][3] =0.0;\n\t\t // alphaMat[1][3] =0.0;\n\t\t // alphaMat[2][3] =0.0;\n\t\t // gl_FragColor = gl_FragColor * alphaMat;\n\t\t // gl_FragColor.r += lastDr*(lastDr<0.0?gl_FragColor.r:1.0);\n\t\t // gl_FragColor.g += lastDg*(lastDr<0.0?gl_FragColor.g:1.0);\n\t\t // gl_FragColor.b += lastDb*(lastDr<0.0?gl_FragColor.b:1.0);\n\t\t // return gl_FragColor;\n \n\t\t \n\t\t // \u53D6\u5F97UV\uFF0C\u5F53\u524D\u9876\u70B9\u662F\u8BE5\u5BF9\u8C61\u7684\u5305\u56F4\u76D2\uFF08\u5982\u679C\u5408\u5E76\u7684\u8BDD\u5219\u4F1A\u5408\u5E76\u8BA1\u7B97\u5305\u56F4\u76D2\uFF09\n\t\t vec2 uvCustom = v_texcoord;\n\t\t // \u622A\u53D6 [0,1] \u8303\u56F4\u5185\n \n // \t\tif(fd!=1.1){\n // \t    vec4 zhujue = texture2D(texture, uvCustom);\n // \t\tzhujue.r = 1.0;\n // \t\treturn zhujue;\n // }\n\t\t \n\t\t \n\t\t uvCustom.x = fract(uvCustom.x);\n\t\t uvCustom.y = fract(uvCustom.y);\n\t\t \n\t\t \n\t\t \n \n \n\t\t // uvCustom.x *= 10000.0;\n\t\t // uvCustom.y *= 10000.0;\n\t\t // uvCustom.x = mod(uvCustom.x,10000.0);\n\t\t // uvCustom.y = mod(uvCustom.y,10000.0);\n\t\t \n\t\t //  uvCustom.x /= 10000.0;\n\t\t //  uvCustom.y /= 10000.0;\n \n\t\t \n\t if(fd!=1.1){\n\t\t if(fd==15.0){\n\t\t\t float yyy = floor(uvCustom.y * 400.0);\n\t\t\t if(mod(yyy,2.0)==0.0){\n\t\t\t\t uvCustom.x -= 0.01*autoI*uvCustom.y * yyy/400.0;\n\t\t\t }\n\t\t\t else{\n\t\t\t\t uvCustom.x += 0.01*autoI*uvCustom.y * yyy/400.0;\n\t\t\t }\n \n\t\t\t \n\t\t }\n\t\t else{\n\t\t\t uvCustom.x += 0.01*rd*uvCustom.y;\n\t\t\t uvCustom.y += 0.01*rd2*uvCustom.x;\n\t\t }\n\t \n }\n\t\t // uvCustom.x*=uvCustom.x;\n\t\t // uvCustom.y*=uvCustom.y;\n\t\t \n \n \n\t\t vec4 color = texture2D(texture, uvCustom);\n\t\t \n\t \n\t\t \n\t\t // \u7ED8\u5236\u81EA\u5B9A\u4E49\u56FE\u5F621\uFF0C\u6B63\u5E38\u9700\u8981\u98A0\u5012\n\t\t uvCustom.y = fract(uvCustom.y)*-1.0+1.0;\n\t\t \n\t\t \n\t\t \n\t\t vec4 transColor = texture2D(tex3, v_texcoord);\n\t\t // if(fd==1.1){\n\t\t //    color += texture2D(tex2, uvCustom)*0.5;\n\t\t // }\n\t\t //\n \n\t\t // \u6E10\u53D8\n\t\t if(fd==1.1){\n\t\t\t \n\t\t\t float transShow = (1.0*autoI-transColor.g);\n\t\t\t if(transShow>1.0)transShow=1.0;\n\t\t\t if(transShow<0.0)transShow=0.0;\n\t\t\t vec4 toColor = transShow*texture2D(tex2, uvCustom);\n\t\t\t if(toColor.r>0.1){\n\t\t\t\t color *= 0.2;\n\t\t\t\t color += toColor;\n\t\t\t }\n\t\t\t \n\t\t }\n\t \n\t\t \n\t \n\t\t if(color.r==1.0){\n\t\t\t \n\t\t }\n\t\t \n\t\t #ifdef KDS_M1\n\t\t\t color.r = 1.0;\n\t\t\t \n\t\t\t \n\t\t #endif\n \n\t\t #ifdef KDS_M2\n\t\t\t color.g = 1.0;\n\t\t #endif\n \n\t\t \n\t\t \n \n\t\t return color;\n\t\t \n\t }\n \n \n\t vec4 dddd(){\n\t\t \n\t\t return vec4(1.0,0.5,0.0,1.0);\n \n\t\t const int sampleRadius = 5;\n\t\t const int samples = sampleRadius * 2 + 1;\n\t\t // \n\t\t float GAUSSIAN_VALUES[11];\n\t\t GAUSSIAN_VALUES[0] = 0.0093;\n\t\t GAUSSIAN_VALUES[1] = 0.028002;\n\t\t GAUSSIAN_VALUES[2] = 0.065984;\n\t\t GAUSSIAN_VALUES[3] = 0.121703;\n\t\t GAUSSIAN_VALUES[4] = 0.175713;\n\t\t GAUSSIAN_VALUES[5] = 0.198596;\n\t\t GAUSSIAN_VALUES[6] = 0.175713;\n\t\t GAUSSIAN_VALUES[7] = 0.121703;\n\t\t GAUSSIAN_VALUES[8] = 0.065984;\n\t\t GAUSSIAN_VALUES[9] = 0.028002;\n\t\t GAUSSIAN_VALUES[10] = 0.0093;\n\t\t //\n\t\t vec2 blurUv = vec2(strength_sig2_2sig2_gauss1.x / blurInfo.x,strength_sig2_2sig2_gauss1.x / blurInfo.y);\n\t\t vec4 color = vec4(0, 0, 0, 0);\n\t\t vec2 uv = vec2(0.0, 0.0);\n\t\t blurUv.x /= 5.0;\n\t \n\t\t // for (int i = -sampleRadius; i <= sampleRadius; i++) {\n\t\t // \tuv.x = v_texcoord.x + float(i) * blurUv.x;\n\t\t // \tuv.y = v_texcoord.y + float(i) * blurUv.y;\n\t\t // \tcolor += texture2D(texture, uv) * GAUSSIAN_VALUES[i + sampleRadius];\n\t\t // }\n\t\t // // color.g = 0.0;\n\t\t // color.b = xxxxx;\n \n\t\t // vec2 uvCustom = v_texcoord;\n\t\t // // uvCustom.y *=-1.0;\n \n\t\t // if(uvCustom.y>=1.0)uvCustom.y=1.0;\n\t\t // // else if(uvCustom.y==1.0)uvCustom.y=0.0;\n \n\t\t // color.r += kds_vec3.x;\n \n\t\t // color = texture2D(tex2, uvCustom);\n\t\t \n\t\t // return color;\n\t }\n \n\t ";
    var kds_customUniform = "\n\t\t uniform vec4 colorAlpha;\n\t\t uniform mat4 colorMat;\n\t\t float test;\n\t\t float xxxxx;\n\t ";
    Shader.addInclude("parts/CUSTOM_ps_logic.glsl", "mat4 alphaMat =colorMat;\n\t float lastDr = alphaMat[0][3];\n\t float lastDg = alphaMat[1][3];\n\t float lastDb = alphaMat[2][3];\n\t alphaMat[0][3] =0.0;\n\t alphaMat[1][3] =0.0;\n\t alphaMat[2][3] =0.0;\n\t gl_FragColor = gl_FragColor * alphaMat;\n\t gl_FragColor.r += lastDr*(lastDr<0.0?gl_FragColor.r:1.0);\n\t gl_FragColor.g += lastDg*(lastDr<0.0?gl_FragColor.g:1.0);\n\t gl_FragColor.b += lastDb*(lastDr<0.0?gl_FragColor.b:1.0);\n \n\t \n\t ");
    Shader.addInclude("parts/CUSTOM_ps_uniform.glsl", kds_customUniform);
    Shader.addInclude("parts/ColorAdd_ps_uniform.glsl", "uniform vec4 colorAdd;\n");
    Shader.addInclude("parts/ColorAdd_ps_logic.glsl", "gl_FragColor = vec4(colorAdd.rgb,colorAdd.a*gl_FragColor.a);\ngl_FragColor.xyz *= colorAdd.a;");
    var vs, ps;
    vs = "attribute vec4 position;\nuniform vec2 size;\nuniform mat4 mmat;\nvoid main() {\n  vec4 pos=mmat*position;\n  gl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\n}";
    ps = "\n\t precision mediump float;\n\t uniform vec4 color;\n\t uniform float alpha;\n\t #include?COLOR_FILTER \"parts/ColorFilter_ps_uniform.glsl\";\n\t void main() {\n\t\t\t vec4 a = vec4(color.r, color.g, color.b, color.a);\n\t\t\t a.w = alpha;\n\t\t\t a.xyz *= alpha;\n\t\t\t gl_FragColor = a;\n\t\t\t #include?COLOR_FILTER \"parts/ColorFilter_ps_logic.glsl\";\n\t }";
    Shader.preCompile2D(0, 0x02, vs, ps, null);
    vs = "attribute vec4 position;\nattribute vec3 a_color;\nuniform mat4 mmat;\nuniform mat4 u_mmat2;\nuniform vec2 u_pos;\nuniform vec2 size;\nvarying vec3 color;\nvoid main(){\n  vec4 tPos = vec4(position.x + u_pos.x,position.y + u_pos.y,position.z,position.w);\n  vec4 pos=mmat*u_mmat2*tPos;\n  gl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\n  color=a_color;\n}";
    ps = "precision mediump float;\n//precision mediump float;\nvarying vec3 color;\nuniform float alpha;\nvoid main(){\n	//vec4 a=vec4(color.r, color.g, color.b, 1);\n	//a.a*=alpha;\n    gl_FragColor=vec4(color.r, color.g, color.b, alpha);\n	gl_FragColor.rgb*=alpha;\n}";
    Shader.preCompile2D(0, 0x04, vs, ps, null);
    vs = "attribute vec2 position;\nattribute vec2 texcoord;\nattribute vec4 color;\nuniform vec2 size;\nuniform float offsetX;\nuniform float offsetY;\nuniform mat4 mmat;\nuniform mat4 u_mmat2;\nvarying vec2 v_texcoord;\nvarying vec4 v_color;\nvoid main() {\n  vec4 pos=mmat*u_mmat2*vec4(offsetX+position.x,offsetY+position.y,0,1 );\n  gl_Position = vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\n  v_color = color;\n  v_color.rgb *= v_color.a;\n  v_texcoord = texcoord;  \n}";
    ps = "precision mediump float;\nvarying vec2 v_texcoord;\nvarying vec4 v_color;\nuniform sampler2D texture;\nuniform float alpha;\nvoid main() {\n	vec4 t_color = texture2D(texture, v_texcoord);\n	gl_FragColor = t_color.rgba * v_color;\n	gl_FragColor *= alpha;\n}";
    Shader.preCompile2D(0, 0x200, vs, ps, null);
};
var pShader = "attribute vec4 a_CornerTextureCoordinate;\n //------------------------------------------------------------------------------------------------------\n // \u9876\u70B9\u6570\u636E vertexBuffer \u4E2D\u7684\u6570\u636E\n //------------------------------------------------------------------------------------------------------\n // \u9876\u70B9\u4F4D\u7F6E x y z\n attribute vec3 a_Position;\n // \u9876\u70B9\u901F\u5EA6\n attribute vec3 a_Velocity;\n // \u9876\u70B9\u8D77\u59CB\u989C\u8272\n attribute vec4 a_StartColor;\n // \u9876\u70B9\u7ED3\u675F\u989C\u8272\n attribute vec4 a_EndColor;\n // \u89D2\u5EA6\uFF1F\n attribute vec3 a_SizeRotation;\n // \u534A\u5F84\n attribute vec2 a_Radius;\n // \u5F27\u5EA6\n attribute vec4 a_Radian;\n // \u751F\u547D\u5468\u671F\u7F29\u653E\u5EA6 \u53731.0 * 1.5 \u8868\u793A+50%\u5BFF\u547D\n attribute float a_AgeAddScale;\n // \u53D1\u51FA\u7684\u65F6\u95F4\n attribute float a_Time;\n //------------------------------------------------------------------------------------------------------\n // \u4F20\u9012\u7ED9\u7247\u6BB5\u7740\u8272\u5668\u7684\u53C2\u6570 \n //------------------------------------------------------------------------------------------------------\n varying vec4 v_Color;\n varying vec2 v_TextureCoordinate;\n //------------------------------------------------------------------------------------------------------\n // \u4F20\u9012\u8FDB\u6765\u7684\u5E38\u91CF\uFF0C\u6BD4\u5982u_CurrentTime\u5C31\u662F\u6BCF\u5E27\u90FD\u4F1A\u4F20\u9012\u8FDB\u6765\u7684\u5E38\u91CF\uFF0C\u8868\u793A\u5F53\u524D\u65F6\u95F4\n // \u7247\u6BB5\u7740\u8272\u5668\u548C\u9876\u70B9\u7740\u8272\u5668\u90FD\u4F1A\u7528\u5230\u7684\n //------------------------------------------------------------------------------------------------------\n uniform float u_CurrentTime;\n uniform float u_Duration;\n uniform float u_EndVelocity;\n uniform vec3 u_Gravity;\n uniform vec3 u_xxxx;\n \n \n #ifdef PARTICLE3D\n  uniform mat4 u_WorldMat;\n  uniform mat4 u_View;\n  uniform mat4 u_Projection;\n  uniform vec2 u_ViewportScale;\n #else\n  uniform vec2 size;\n  uniform mat4 mmat;\n  uniform mat4 u_mmat;\n #endif\n \n vec4 ComputeParticlePosition(in vec3 position, in vec3 velocity,in float age,in float normalizedAge)\n {\n \n\tfloat startVelocity = length(velocity);//\u8D77\u59CB\u6807\u91CF\u901F\u5EA6\n\tfloat endVelocity = startVelocity * u_EndVelocity;//\u7ED3\u675F\u6807\u91CF\u901F\u5EA6\n \n\tfloat velocityIntegral = startVelocity * normalizedAge +(endVelocity - startVelocity) * normalizedAge *normalizedAge/2.0;//\u8BA1\u7B97\u5F53\u524D\u901F\u5EA6\u7684\u6807\u91CF\uFF08\u5355\u4F4D\u7A7A\u95F4\uFF09\uFF0Cvt=v0*t+(1/2)*a*(t^2)\n\t\n\tvec3 addPosition = normalize(velocity) * velocityIntegral * u_Duration;//\u8BA1\u7B97\u53D7\u81EA\u8EAB\u901F\u5EA6\u5F71\u54CD\u7684\u4F4D\u7F6E\uFF0C\u8F6C\u6362\u6807\u91CF\u5230\u77E2\u91CF    \n\taddPosition += u_Gravity * age * normalizedAge;//\u8BA1\u7B97\u53D7\u91CD\u529B\u5F71\u54CD\u7684\u4F4D\u7F6E\n\t\n\tfloat radius=mix(a_Radius.x, a_Radius.y, normalizedAge); //\u8BA1\u7B97\u7C92\u5B50\u53D7\u534A\u5F84\u548C\u89D2\u5EA6\u5F71\u54CD\uFF08\u65E0\u9700\u8BA1\u7B97\u89D2\u5EA6\u548C\u534A\u5F84\u65F6\uFF0C\u53EF\u7528\u5B8F\u5B9A\u4E49\u4F18\u5316\u5C4F\u853D\u6B64\u8BA1\u7B97\uFF09\n\tfloat radianHorizontal =mix(a_Radian.x,a_Radian.z,normalizedAge);\n\tfloat radianVertical =mix(a_Radian.y,a_Radian.w,normalizedAge);\n\t\n\tfloat r =cos(radianVertical)* radius;\n\taddPosition.y += sin(radianVertical) * radius;\n\t \n\taddPosition.x += cos(radianHorizontal) *r + u_xxxx.x;\n\taddPosition.z += sin(radianHorizontal) *r;\n   \n\t#ifdef PARTICLE3D\n\tposition+=addPosition;\n\t return  u_Projection*u_View*u_WorldMat*(vec4(position, 1.0));\n\t#else\n\taddPosition.y=-addPosition.y;//2D\u7C92\u5B50\u4F4D\u7F6E\u66F4\u65B0\u9700\u8981\u53D6\u8D1F\uFF0C2D\u7C92\u5B50\u5750\u6807\u7CFBY\u8F74\u6B63\u5411\u671D\u4E0A\n\tposition+=addPosition;\n\t return  vec4(position,1.0);\n\t#endif\n }\n \n float ComputeParticleSize(in float startSize,in float endSize, in float normalizedAge)\n {    \n\t float size = mix(startSize, endSize, normalizedAge);\n\t \n\t #ifdef PARTICLE3D\n\t //Project the size into screen coordinates.\n\t  return size * u_Projection[1][1];\n\t #else\n\t  return size;\n\t #endif\n }\n \n mat2 ComputeParticleRotation(in float rot,in float age)\n {    \n\t float rotation =rot * age;\n\t //\u8BA1\u7B972x2\u65CB\u8F6C\u77E9\u9635.\n\t float c = cos(rotation);\n\t float s = sin(rotation);\n\t return mat2(c, -s, s, c);\n }\n \n vec4 ComputeParticleColor(in vec4 startColor,in vec4 endColor,in float normalizedAge)\n {\n\t vec4 color=mix(startColor,endColor,normalizedAge);\n\t //\u786C\u7F16\u7801\u8BBE\u7F6E\uFF0C\u4F7F\u7C92\u5B50\u6DE1\u5165\u5F88\u5FEB\uFF0C\u6DE1\u51FA\u5F88\u6162,6.7\u7684\u7F29\u653E\u56E0\u5B50\u628A\u7F6E\u5F52\u4E00\u57280\u52301\u4E4B\u95F4\uFF0C\u53EF\u4EE5\u8C37\u6B4Cx*(1-x)*(1-x)*6.7\u7684\u5236\u56FE\u8868\n\t color.a *= normalizedAge * (1.0-normalizedAge) * (1.0-normalizedAge) * 6.7;\n\t\n\t return color;\n }\n \n void main()\n {\n\tfloat age = u_CurrentTime - a_Time;\n\tage *= 1.0 + a_AgeAddScale;\n\tfloat normalizedAge = clamp(age / u_Duration,0.0,1.0);\n\tgl_Position = ComputeParticlePosition(a_Position, a_Velocity, age, normalizedAge);//\u8BA1\u7B97\u7C92\u5B50\u4F4D\u7F6E\n\tfloat pSize = ComputeParticleSize(a_SizeRotation.x,a_SizeRotation.y, normalizedAge);\n\tmat2 rotation = ComputeParticleRotation(a_SizeRotation.z, age);\n\t \n\t#ifdef PARTICLE3D\n\t gl_Position.xy += (rotation*a_CornerTextureCoordinate.xy) * pSize * u_ViewportScale;\n\t#else\n\t mat4 mat=u_mmat*mmat;\n\t gl_Position=vec4((mat*gl_Position).xy,0.0,1.0);\n\t gl_Position.xy += (rotation*a_CornerTextureCoordinate.xy) * pSize*vec2(mat[0][0],mat[1][1]);\n\t gl_Position=vec4((gl_Position.x/size.x-0.5)*2.0,(0.5-gl_Position.y/size.y)*2.0,0.0,1.0);\n\t#endif\n\t\n\tv_Color = ComputeParticleColor(a_StartColor,a_EndColor, normalizedAge);\n\tv_TextureCoordinate =a_CornerTextureCoordinate.zw;\n }\n ";
static(ParticleShader, ['vs', function () { return this.vs = pShader; }, 'ps', function () { return this.ps = "#ifdef FSHIGHPRECISION\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nvarying vec4 v_Color;\nvarying vec2 v_TextureCoordinate;\nuniform sampler2D u_texture;\n\nvoid main()\n{\n	gl_FragColor=texture2D(u_texture,v_TextureCoordinate)*v_Color;\n	gl_FragColor.xyz *= v_Color.w;\n}"; }
]);
var ClientMsgSender = (function () {
    function ClientMsgSender() {
    }
    ClientMsgSender.send = function (msg, threadID) {
        if (threadID === void 0) { threadID = -1; }
        if (threadID == -1)
            threadID = ClientMsgSender.threadID;
        if (threadID == -1)
            return;
        if (ClientMain.conn)
            ClientMain.conn.sendMsg(msg, threadID);
    };
    ClientMsgSender.rpc = function (className, funcName, params, onReturn, threadID) {
        if (params === void 0) { params = []; }
        if (onReturn === void 0) { onReturn = null; }
        if (threadID === void 0) { threadID = -1; }
        if (threadID == -1)
            threadID = ClientMsgSender.threadID;
        if (threadID == -1)
            return;
        var onReturnID;
        if (onReturn) {
            onReturnID = ++ClientMsgSender.onReturnCount;
            ClientMsgSender.onReturns[onReturnID] = onReturn;
            setTimeout(function (onReturnID) {
                delete ClientMsgSender.onReturns[onReturnID];
            }, ClientMsgSender.ONRETURN_OVER_TIME, onReturnID);
        }
        else {
            onReturnID = 0;
        }
        var obj = { c: className, f: funcName, p: params, r: onReturnID };
        if (ClientMain.conn)
            ClientMain.conn.sendMsgObj(obj, threadID);
    };
    ClientMsgSender.rpcReturn = function (success, onReturnID, res, domainName, funcName) {
        var onReturn = ClientMsgSender.onReturns[onReturnID];
        delete ClientMsgSender.onReturns[onReturnID];
        if (!success) {
            trace("[#GAME_ERROR:_SERVER_DID_NOT_FIND]" + (domainName + "::" + funcName) + "[#GAME_ERROR_METHOD_OR_NO]");
            return;
        }
        onReturn && onReturn.runWith([res]);
    };
    ClientMsgSender.requestTriggerEvent = function (type, mainType, indexType, commandID, inputMessage, onCommandExecuteOver, triggerSceneObjectIndex, executorSceneObjectIndex) {
        if (inputMessage === void 0) { inputMessage = null; }
        if (onCommandExecuteOver === void 0) { onCommandExecuteOver = null; }
        if (triggerSceneObjectIndex === void 0) { triggerSceneObjectIndex = null; }
        if (executorSceneObjectIndex === void 0) { executorSceneObjectIndex = null; }
        var onReturnID;
        if (onCommandExecuteOver) {
            onReturnID = ++ClientMsgSender.onCmdReturnCount;
            ClientMsgSender.onCmdReturns[onReturnID] = onCommandExecuteOver;
        }
        else {
            onReturnID = 0;
        }
        var sendParams = [type, mainType, indexType, [commandID, inputMessage, onReturnID], triggerSceneObjectIndex, executorSceneObjectIndex];
        if (ClientMsgSender.requestTriggerEventSend) {
            ClientMsgSender.requestTriggerEventSend.runWith(sendParams);
        }
        else {
            ClientMsgSender.rpc("ServerWorld", "triggerEvent", sendParams);
        }
    };
    ClientMsgSender.cmdReturn = function (onReturnID) {
        var onReturn = ClientMsgSender.onCmdReturns[onReturnID];
        delete ClientMsgSender.onCmdReturns[onReturnID];
        onReturn && onReturn.run();
    };
    ClientMsgSender.requestListenPlayerVariable = function (isListen, type, varID) {
        ClientMsgSender.rpc("ServerWorld", "listenerPlayerVariable", [isListen, type, varID]);
    };
    ClientMsgSender.requestGetWorldVariable = function (type, varID) {
        ClientMsgSender.rpc("ServerWorld", "requestGetWorldVariable", [type, varID]);
    };
    ClientMsgSender.onReturns = {};
    ClientMsgSender.onReturnCount = 0;
    ClientMsgSender.ONRETURN_OVER_TIME = 60000;
    ClientMsgSender.onCmdReturns = {};
    ClientMsgSender.onCmdReturnCount = 0;
    ClientMsgSender.ON_CMD_RETURN_OVER_TIME = 60000;
    return ClientMsgSender;
}());
var NetConn = (function () {
    function NetConn() {
        this.jsonMsgFragmentArr = [];
        this.jsonMsgFragmentSize = 0;
        this.jsonMsgFragmentNow = 0;
        this.msgFragmentArr = [];
        this.msgFragmentSize = 0;
        this.msgFragmentNow = 0;
    }
    NetConn.prototype.connect = function (key, host, port, onConnect, onMsg, onClose) {
        if (onClose === void 0) { onClose = null; }
        this.key = key;
        this.host = host;
        this.port = port;
        this.onConnect = onConnect;
        this.onClose = onClose;
        this.onMsg = onMsg;
        var startTime = new Date().getTime();
        var ws = this.ws = new WebSocket("ws://" + host + ":" + port + "/");
        var _this = this;
        ws.onopen = function () {
            _this.onWSOpen();
        };
        ws.onclose = function (e) {
            var isTimeout = new Date().getTime() - startTime >= 2000;
            _this.onWSClose(isTimeout);
        };
        ws.onmessage = function (msg) {
            _this.onWSMessage(msg);
        };
    };
    NetConn.prototype.close = function () {
        if (this.ws) {
            this.ws.close();
            this.ws = null;
        }
    };
    NetConn.prototype.onWSOpen = function () {
        this.isConnect = true;
        this.ws.send('0' + this.key);
    };
    NetConn.prototype.onWSClose = function (isTimeout) {
        this.isConnect = false;
        this.onClose && this.onClose.runWith([isTimeout]);
    };
    NetConn.prototype.onWSMessage = function (msg) {
        var sysMsgID = msg.data.substr(0, 1);
        var msgContent = msg.data.substr(1);
        if (sysMsgID == "0") {
            if (msgContent == "onClientConnected") {
                this.onConnect && this.onConnect.run();
            }
        }
        else if (sysMsgID == "1") {
            var msgType = msgContent.substr(0, 1);
            var msgBody = msgContent.substr(1);
            if (msgType == "0") {
                this.onMsg.runWith([msgType, msgBody]);
            }
            else if (msgType == "3") {
                var fragSendIndex = parseInt(msgBody.substr(0, 3));
                this.msgFragmentSize = parseInt(msgBody.substr(3, 3));
                msgBody = msgBody.substr(6);
                this.msgFragmentArr[fragSendIndex] = msgBody;
                this.msgFragmentNow++;
                if (this.msgFragmentNow == this.msgFragmentSize) {
                    this.onMsg.runWith(["0", this.msgFragmentArr.join("")]);
                    this.msgFragmentArr.length = 0;
                    this.msgFragmentNow = 0;
                }
            }
            else if (msgType == "1") {
                this.onMsg.runWith([msgType, msgBody]);
            }
            else if (msgType == "2") {
                var fragSendIndex = parseInt(msgBody.substr(0, 3));
                this.jsonMsgFragmentSize = parseInt(msgBody.substr(3, 3));
                msgBody = msgBody.substr(6);
                this.jsonMsgFragmentArr[fragSendIndex] = msgBody;
                this.jsonMsgFragmentNow++;
                if (this.jsonMsgFragmentNow == this.jsonMsgFragmentSize) {
                    this.onMsg.runWith(["1", this.jsonMsgFragmentArr.join("")]);
                    this.jsonMsgFragmentArr.length = 0;
                    this.jsonMsgFragmentNow = 0;
                }
            }
            else if (msgType == "4") {
                this.isConnect = false;
                this.close();
            }
        }
    };
    NetConn.prototype.sendMsg = function (msg, passageID) {
        if (passageID === void 0) { passageID = 1; }
        if (this.isConnect) {
            this.ws.send("1" + passageID + ",0" + msg);
        }
    };
    NetConn.prototype.sendMsgObj = function (msgObj, passageID) {
        if (passageID === void 0) { passageID = 1; }
        if (this.isConnect) {
            this.ws.send("1" + passageID + ",1" + JSON.stringify(msgObj));
        }
    };
    return NetConn;
}());
var ClientMain = (function () {
    function ClientMain(is3D) {
        if (is3D === void 0) { is3D = false; }
        this.initTask = "ClientMainInitTask";
        if (typeof globalThis["SceneObjectModule"] == "undefined")
            globalThis["SceneObjectModule"] = SceneObjectModuleBase;
        os.init(0, 0, true, is3D);
        os["fps"] = 62;
        Game.layer = new GameLayer();
        stage.alignH = "center";
        stage.alignV = "middle";
        if (Browser.onMobile) {
        }
        SoundManager.autoStopMusic = false;
        document.addEventListener("keydown", function (e) {
            if (stage.focus instanceof Input && e.keyCode != Keyboard.TAB)
                return;
            if (os.platform == 2)
                return;
            if (!Config.USE_FN || (e.keyCode != Keyboard.F11 && e.keyCode != Keyboard.F5 && e.keyCode != Keyboard.F12)) {
                e.stopPropagation();
                window.event.returnValue = false;
            }
        });
        os.canvas.onmousewheel = function (e) {
            e = e || window.event;
            if (e.preventDefault)
                e.preventDefault();
            e.returnValue = false;
            return false;
        };
        this.init();
    }
    ClientMain.prototype.init = function () {
        this.initFrameout();
        this.initHotKey();
        FileUtils.init();
        GameCommand.init();
        Game.init();
        GameUI.init();
        this.postMessageRequestInit();
        new SyncTask(this.initTask, this.loadStartupJson, [], this);
        new SyncTask(this.initTask, this.installDataConfig, [Config.JSON_CONFIG, Config], this);
        new SyncTask(this.initTask, this.onLoadTemplateLanguage, [], this);
        new SyncTask(this.initTask, this.loadFontFile, [], this);
        new SyncTask(this.initTask, this.initConfig, [], this);
        new SyncTask(this.initTask, this.loadGameData, [], this);
        new SyncTask(this.initTask, this.installGameData, [], this);
        new SyncTask(this.initTask, this.initOver, [], this);
    };
    ClientMain.prototype.postMessageRequestInit = function () {
        window.addEventListener("message", function (event) {
            var data = event.data;
            if (!data || typeof data != "object")
                return;
            switch (data.msgType) {
                case 0:
                    Game.player.uid = data.gcUID;
                    Game.player.gcToken = data.gcToken;
                    Game.player.gcNickName = data.gcNickName;
                    LocalStorage.setJSON("gc_account", { uid: data.gcUID, gcToken: data.gcToken, gcNickName: data.gcNickName });
                    break;
                default:
                    break;
            }
        });
    };
    ClientMain.prototype.initFrameout = function () {
        os.add_ENTERFRAME(doFrameout, this);
    };
    ClientMain.prototype.initHotKey = function () {
        stage.add_KEYDOWN(function (e) {
            ClientMain.ctrlKey = e.ctrlKey;
            ClientMain.shiftKey = e.shiftKey;
            ClientMain.altKey = e.altKey;
            if ((e.altKey && e.keyCode == Keyboard.ENTER)) {
                os.fullscreen = !os.fullscreen;
            }
            else if (Config.USE_FN && e.keyCode == Keyboard.F5) {
                window.location.reload();
            }
        }, this);
        stage.add_KEYUP(function (e) {
            ClientMain.ctrlKey = e.ctrlKey;
            ClientMain.shiftKey = e.shiftKey;
            ClientMain.altKey = e.altKey;
        }, this);
        stage.on(EventObject.MOUSE_DOWN, this, function () {
            window.focus();
        });
    };
    ClientMain.prototype.onLoadTemplateLanguage = function () {
        var _this_1 = this;
        Game.data.loadTemplateLanguage(Callback.New(function () {
            SyncTask.taskOver(_this_1.initTask);
        }, this));
    };
    ClientMain.prototype.loadStartupJson = function () {
        if (!Config.RELEASE_GAME) {
            SyncTask.taskOver(this.initTask);
            return;
        }
        var __this = this;
        AssetManager.loadFileArrayBuffer("asset/json/startup.json", Callback.New(function (buffer) {
            ZipManager.zipDeCompress(buffer, function (text) {
                try {
                    var startupJsons = JSON.parse(text);
                }
                catch (e) {
                    alert("cound not find the merged version of Json!");
                    return;
                }
                var oldLoadJson1 = FileUtils.loadJsonFile;
                FileUtils.loadJsonFile = function (localURL, onFin, onErrorTips) {
                    if (onErrorTips === void 0) { onErrorTips = true; }
                    var bigJsonCacheObj = startupJsons[localURL];
                    if (bigJsonCacheObj) {
                        onFin.delayRun(0, null, [bigJsonCacheObj]);
                        return;
                    }
                    oldLoadJson1.apply(FileUtils, [localURL, onFin, onErrorTips]);
                };
                SyncTask.taskOver(__this.initTask);
            }, 'gc_zip', true);
        }, this));
    };
    ClientMain.prototype.installDataConfig = function (url, configObj) {
        var _this_1 = this;
        FileUtils.loadJsonFile(url, new Callback(function (cfgJson) {
            ObjectUtils.clone(cfgJson, configObj);
            GameImage.init();
            _this_1.GCAS_init(function () {
                SyncTask.taskOver(_this_1.initTask);
            });
            if (Config.RELEASE_GAME && (os.platform == 2 || os.platform == 3 || os.platform == 4)) {
                var url = Config.GC_CLOUD_PLATFORM + "/index.php/apis/statistics/re";
                var code = Config.gameSID + "&" + Config.gameProjectName + "&" + Config.templateID + "&" + os.platform;
                var gameCode = window ? window.btoa(encodeURI(code)) : code;
                HttpRequest.requestServer({ url: url, gcToken: "", data: { gameCode: gameCode, type: 4 }, method: "post", responseType: "json" });
            }
        }, this));
    };
    ClientMain.prototype.GCAS_init = function (onFin) {
        if (os.platform == 0) {
            FileUtils.loadJsonFile("index.kdsrpgmd5index", Callback.New(function (md5Index) {
                if (md5Index == null) {
                    onFin();
                    return;
                }
                var o = window["Laya"];
                var cHead = window.location.origin;
                function doMappingURL(url, isLocal) {
                    if (isLocal === void 0) { isLocal = false; }
                    if (md5Index && url) {
                        var localUrl = void 0;
                        if (isLocal) {
                            localUrl = url;
                        }
                        else {
                            var urlArr = url.split("/asset/");
                            urlArr.shift();
                            localUrl = "asset/" + urlArr.join("");
                        }
                        var wArr = url.split("?");
                        wArr.shift();
                        var tail = "";
                        if (wArr.length > 0) {
                            tail = "?" + wArr.join("?");
                            localUrl = localUrl.split("?")[0];
                        }
                        var fileMappingInfo = md5Index.files[localUrl];
                        if (fileMappingInfo && fileMappingInfo.cloudMappingURL) {
                            url = cHead + "/" + fileMappingInfo.cloudMappingURL + tail;
                        }
                    }
                    return url;
                }
                o.URL.formatURL = function (url, base) {
                    url = doMappingURL(url);
                    if (!url)
                        return "null path";
                    if (url.indexOf(":") > 0)
                        return url;
                    if (o.URL.customFormat != null)
                        url = o.URL.customFormat(url, base);
                    var char1 = url.charAt(0);
                    if (char1 === ".") {
                        return o.URL.formatRelativePath((base || o.URL.basePath) + url);
                    }
                    else if (char1 === '~') {
                        return o.URL.rootPath + url.substring(1);
                    }
                    else if (char1 === "d") {
                        if (url.indexOf("data:image") === 0)
                            return url;
                    }
                    else if (char1 === "/") {
                        return url;
                    }
                    return (base || o.URL.basePath) + url;
                };
                HttpRequest.prototype.send = function (url, data, method, responseType, headers) {
                    url = doMappingURL(url);
                    (method === void 0) && (method = "get");
                    (responseType === void 0) && (responseType = "text");
                    this._responseType = responseType;
                    this._data = null;
                    var _this = this;
                    var http = this._http;
                    http.open(method, url, true);
                    if (headers) {
                        for (var i = 0; i < headers.length; i++) {
                            http.setRequestHeader(headers[i++], headers[i]);
                        }
                    }
                    else if (!Render.isConchApp) {
                        if (!data || (typeof data == 'string'))
                            http.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
                        else
                            http.setRequestHeader("Content-Type", "application/json");
                    }
                    http.responseType = responseType !== "arraybuffer" ? "text" : "arraybuffer";
                    http.onerror = function (e) {
                        _this._onError(e);
                    };
                    http.onabort = function (e) {
                        _this._onAbort(e);
                    };
                    http.onprogress = function (e) {
                        _this._onProgress(e);
                    };
                    http.onload = function (e) {
                        _this._onLoad(e);
                    };
                    http.send(data);
                };
                Object.defineProperty(UIComponent.UIVideo.prototype, "videoURL", {
                    get: function () {
                        return this._videoURL;
                    },
                    set: function (v) {
                        this._videoURL = v;
                        if (!this.videoElement)
                            return;
                        this._metaDataLoaded = false;
                        var url = doMappingURL(v, true);
                        this.videoElement.src = url;
                    },
                    enumerable: false,
                    configurable: true
                });
                var _loadFontFile = FontLoadManager.loadFontFile;
                FontLoadManager.loadFontFile = function (fontList, callBack) {
                    if (callBack === void 0) { callBack = null; }
                    for (var i_10 = 0; i_10 < fontList.length; i_10++) {
                        fontList[i_10].path = doMappingURL(fontList[i_10].path, true);
                    }
                    return _loadFontFile.apply(this, [fontList, callBack]);
                };
                onFin();
            }, this));
        }
        else {
            onFin();
        }
    };
    ClientMain.prototype.loadFontFile = function () {
        if (Config.startupPreloadFonts == null)
            Config.startupPreloadFonts = true;
        if (Config.startupPreloadFonts) {
            var list = Config.FONTS ? Config.FONTS : [];
            var __this = this;
            FontLoadManager.loadFontFile(list, Callback.New(function () {
                SyncTask.taskOver(__this.initTask);
            }, this));
        }
        else {
            SyncTask.taskOver(this.initTask);
        }
    };
    ClientMain.prototype.initConfig = function () {
        Config.init();
        stage.width = Config.WINDOW_WIDTH;
        stage.height = Config.WINDOW_HEIGHT;
        stage.bgColor = Config.STAGE_BACKGROUND_COLOR;
        stage.scaleMode = "showall";
        SyncTask.taskOver(this.initTask);
    };
    ClientMain.prototype.loadGameData = function () {
        var task = new AsynTask(Callback.New(SyncTask.taskOver, this, [this.initTask]));
        var onloadDataOver = Callback.New(task.complete, task, []);
        task.execute(Game.data.loadDialogList(onloadDataOver));
        task.execute(Game.data.loadTileList(onloadDataOver));
        task.execute(Game.data.loadAutoTileList(onloadDataOver));
        if (Config.SINGLE_PLAYER_CORE)
            task.execute(Game.data.loadCustomCommandType(onloadDataOver));
        task.execute(Game.data.loadDataStructureList(onloadDataOver));
        task.execute(Game.data.loadCustomModuleList(onloadDataOver));
        task.execute(Game.data.loadGameAttributeConfig(onloadDataOver));
        task.execute(Game.data.loadSceneObjectModuleList(onloadDataOver));
        task.execute(Game.data.loadSceneObjectModelList(onloadDataOver));
        task.execute(Game.data.loadProjectUICompSetting(onloadDataOver));
        task.execute(Game.data.loadUIList(onloadDataOver));
        task.execute(Game.data.loadCustomEventType(onloadDataOver));
        task.execute(Game.data.loadMaterialList(onloadDataOver));
    };
    ClientMain.prototype.installGameData = function () {
        CustomCompositeSetting.runCode(Game.data);
        Shader2D.initMaterial();
        SyncTask.taskOver(this.initTask);
    };
    ClientMain.prototype.initOver = function () {
        Config.TILE_SPLIT_SIZE_LOCK = true;
        EventUtils.happen(ClientWorld, ClientWorld.EVENT_BEFORE_INITED);
        EventUtils.happen(ClientWorld, ClientWorld.EVENT_INITED);
    };
    ClientMain.prototype.startLogin = function (onLoginSuccess, onLoginFail) {
        if (onLoginFail === void 0) { onLoginFail = null; }
        ClientMain.conn = new NetConn();
        ClientMain.conn.connect(Game.playerKey, Config.GAME_SERVER_HOST, Config.GAME_SERVER_PORT, null, new Callback(this.onServerMsg, this), onLoginFail);
        var si = setInterval(function () {
            if (ClientMsgSender.threadID != null) {
                onLoginSuccess && onLoginSuccess.run();
                clearInterval(si);
            }
        }, 0);
    };
    ClientMain.prototype.onServerMsg = function (msgType, msgContent) {
        if (msgType == "0") {
            EventUtils.happen(ClientWorld, ClientWorld.EVENT_STRING_MESSAGE, [msgContent]);
        }
        else {
            try {
                var msgObj = JSON.parse(msgContent);
                var domainObj = window[msgObj.c];
                var func = domainObj[msgObj.f];
            }
            catch (e) {
            }
            func.apply(domainObj, msgObj.p);
        }
    };
    return ClientMain;
}());
var __setFrameoutFunc = [];
var __fCount = 0;
var setFrameout = function (func, frame) {
    var arg = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        arg[_i - 2] = arguments[_i];
    }
    var t = new Date().getTime() + "_" + Math.random();
    __setFrameoutFunc.push([func, __fCount, frame, arg, t]);
    return t;
};
var clearFrameout = function (t) {
    var m = ArrayUtils.matchAttributes(__setFrameoutFunc, { 4: t }, true, "==", true);
    if (m.length == 1) {
        __setFrameoutFunc.splice(m[0], 1);
    }
};
var doFrameout = function () {
    __fCount++;
    var __execSetFrameoutFunc = [];
    for (var s = 0; s < __setFrameoutFunc.length; s++) {
        var arr = __setFrameoutFunc[s];
        if (__fCount - arr[1] >= arr[2]) {
            __execSetFrameoutFunc.push(arr);
            __setFrameoutFunc.splice(s, 1);
            s--;
        }
    }
    var len = __execSetFrameoutFunc.length;
    for (var s = 0; s < len; s++) {
        var arr = __execSetFrameoutFunc[s];
        arr[0].apply(this, arr[3]);
    }
};















var ClientPlayer = (function (_super) {
    __extends(ClientPlayer, _super);
    function ClientPlayer(isMyPlayer) {
        if (isMyPlayer === void 0) { isMyPlayer = false; }
        var _this_1 = _super.call(this) || this;
        if (isMyPlayer)
            _this_1.initMyPlayer();
        return _this_1;
    }
    ClientPlayer.prototype.initMyPlayer = function () {
        this.variable = new Variable();
        this.event = new EventDispatcher();
        this.requestSyncPlayerVars = [[], [], []];
    };
    ClientPlayer.prototype.addListenerPlayerVariable = function (type, varID, onChange, isOnce, immediatelyCallback) {
        if (isOnce === void 0) { isOnce = false; }
        if (immediatelyCallback === void 0) { immediatelyCallback = true; }
        var rqArr = this.requestSyncPlayerVars[type];
        if (!rqArr[varID]) {
            rqArr[varID] = true;
            ClientMsgSender.requestListenPlayerVariable(true, type, varID);
        }
        else {
            if (immediatelyCallback) {
                var funcs = [this.variable.getVariable, this.variable.getSwitch, this.variable.getString];
                var value = funcs[type].apply(this.variable, [varID]);
                onChange.runWith([type, varID, value]);
                if (isOnce)
                    return;
            }
        }
        var typeEvent = ClientPlayer.getEventType(type, varID);
        this.event[isOnce ? "once" : "on"](typeEvent, onChange.caller, onChange.callbackFunc, onChange.args);
    };
    ClientPlayer.prototype.removeListenerPlayerVariable = function (type, varID, onChange) {
        var typeEvent = ClientPlayer.getEventType(type, varID);
        this.event.off(typeEvent, onChange.caller, onChange.callbackFunc);
        if (!this.event.hasListener(typeEvent)) {
            var rqArr = this.requestSyncPlayerVars[type];
            if (rqArr) {
                delete rqArr[varID];
                ClientMsgSender.requestListenPlayerVariable(false, type, varID);
            }
        }
    };
    ClientPlayer.playerVariableChange = function (type, varID, value) {
        var typeEvent = ClientPlayer.getEventType(type, varID);
        var funcs = [Game.player.variable.setVariable, Game.player.variable.setSwitch, Game.player.variable.setString];
        funcs[type].apply(Game.player.variable, [varID, value]);
        Game.player.event.event(typeEvent, [type, varID, value]);
    };
    ClientPlayer.getEventType = function (type, varID) {
        return "" + ClientPlayer.EVENT_TYPE + type + "_" + varID;
    };
    ClientPlayer.EVENT_TYPE = "VariableSystemEvent";
    return ClientPlayer;
}(Player));
var ClientWorld = (function () {
    function ClientWorld() {
    }
    ClientWorld.init = function () {
        ClientMain.self = new ClientMain();
    };
    ClientWorld.startLogin = function (onLoginSuccess, onLoginFail) {
        if (onLoginFail === void 0) { onLoginFail = null; }
        ClientMain.self.startLogin(onLoginSuccess, onLoginFail);
    };
    ClientWorld.logout = function () {
        ClientMain.conn.close();
    };
    ClientWorld.requestGetVariable = function (type, varID, onResponse) {
        ClientMsgSender.requestGetWorldVariable(type, varID);
        var evType = ClientWorld.getEventType(type, varID);
        EventUtils.addEventListener(ClientWorld, evType, onResponse, true);
    };
    ClientWorld.setWorldVariable = function (index, value) {
        ClientWorld.variable.setVariable(index, value);
    };
    ClientWorld.getWorldVariable = function (index) {
        return ClientWorld.variable.getVariable(index);
    };
    ClientWorld.setWorldSwitch = function (index, value) {
        ClientWorld.variable.setSwitch(index, value);
    };
    ClientWorld.getWorldSwitch = function (index) {
        return ClientWorld.variable.getSwitch(index);
    };
    ClientWorld.setWorldString = function (index, value) {
        ClientWorld.variable.setString(index, value);
    };
    ClientWorld.getWorldString = function (index) {
        return ClientWorld.variable.getString(index);
    };
    ClientWorld.addListenerVariable = function (type, varID, onChange) {
        EventUtils.addEventListener(ClientWorld, "worldVar" + type + "_" + varID, onChange);
    };
    ClientWorld.removeListenerVariable = function (type, varID, onChange) {
        EventUtils.removeEventListener(ClientWorld, "worldVar" + type + "_" + varID, onChange);
    };
    ClientWorld.getEventType = function (type, varID) {
        return "" + ClientWorld.EVENT_GET_WORLD_VAR + type + "_" + varID;
    };
    ClientWorld.reponseGetVariable = function (isSuccess, type, varID, value) {
        var arr = ["variables", "switchs", "strings"];
        ClientWorld.variable[arr[type]][varID] = value;
        var evType = this.getEventType(type, varID);
        EventUtils.happen(ClientWorld, evType, [isSuccess, type, varID, value]);
    };
    ClientWorld.EVENT_INITED = "ClientMain_EVENT_INITED";
    ClientWorld.EVENT_BEFORE_INITED = "ClientMain_EVENT_BEFORE_INITED";
    ClientWorld.EVENT_BEHAVIOR_VIEW_INITED = "BehaviorViewClientWorldInited";
    ClientWorld.EVENT_STRING_MESSAGE = "ClientMain_EVENT_STRING_MESSAGE";
    ClientWorld.EVENT_GET_WORLD_VAR = "ClientWorld_EVENT_GET_WORLD_VAR";
    ClientWorld.requestSyncVars = [[], [], []];
    ClientWorld.variable = new Variable();
    ClientWorld.uiCustomCommandPages = {};
    return ClientWorld;
}());
var GameBase = (function () {
    function GameBase() {
        this.EVENT_PAUSE_CHANGE = "GameEVENT_PAUSE_CHANGE";
        this.data = new GameData();
        this._frameCount = 0;
        this._startTime = new Date().getTime();
        this._staticTime = 0;
        this._staticInterval = 0;
        this._now = 0;
        this._timeMultiplier = 1;
        this._pause = false;
        this.__initGameTime();
    }
    GameBase.prototype.__initGameTime = function () {
        var _this_1 = this;
        EventUtils.addEventListener(ClientWorld, ClientWorld.EVENT_INITED, Callback.New(function () {
            os.add_ENTERFRAME(_this_1.onEnterFrame, _this_1);
        }, this), true);
    };
    Object.defineProperty(GameBase.prototype, "frameCount", {
        get: function () {
            return this._frameCount;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameBase.prototype, "oneFrame", {
        get: function () {
            return 1000 / os['fps'];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameBase.prototype, "now", {
        get: function () {
            return this._now;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameBase.prototype, "pause", {
        get: function () {
            return Game._pause;
        },
        set: function (v) {
            if (Game._pause == v)
                return;
            Game._pause = v;
            EventUtils.happen(this, this.EVENT_PAUSE_CHANGE);
        },
        enumerable: false,
        configurable: true
    });
    GameBase.prototype.onEnterFrame = function () {
        if (!Game._pause) {
            this._now += this._timeMultiplier * this.oneFrame;
            this._frameCount++;
        }
    };
    GameBase.prototype.setLoginData = function (playerID, worldData, heartBeatInterval) {
        Game.player.uid = playerID;
        Game.player.key = Game.playerKey;
        ClientMsgSender.heartBeatInterval = heartBeatInterval;
        var t = Math.floor(ClientMsgSender.heartBeatInterval / 2) * 1000;
        setInterval(function () {
            if (ClientMsgSender.threadID != null || ClientMsgSender.threadID != 2) {
                ClientMsgSender.rpc("ServerPlayer", "HeartBeat");
            }
        }, t);
        for (var i in worldData) {
            ClientWorld.data[i] = worldData[i];
        }
    };
    GameBase.prototype.init = function () {
        this.player = new ClientPlayer(true);
    };
    GameBase.prototype.getSaveData = function () {
        return [Game.now];
    };
    GameBase.prototype.recoverySaveData = function (data) {
        var now = new Date().getTime();
        Game._startTime = now - data[0];
    };
    return GameBase;
}());
var Game = new GameBase;















var ClientSceneLayer = (function (_super) {
    __extends(ClientSceneLayer, _super);
    function ClientSceneLayer(scene, autoUpdate) {
        if (autoUpdate === void 0) { autoUpdate = true; }
        var _this_1 = _super.call(this) || this;
        _this_1.dx = 0;
        _this_1.dy = 0;
        _this_1.xMove = 0;
        _this_1.yMove = 0;
        _this_1.dxMove = 0;
        _this_1.dyMove = 0;
        _this_1.prospectsPerX = 1.0;
        _this_1.prospectsPerY = 1.0;
        _this_1.autoUpdate = true;
        _this_1.tileLayer = new Sprite();
        _this_1.tileData = [];
        _this_1.imgWidth = 0;
        _this_1.imgHeight = 0;
        _this_1.imgBigWidth = 0;
        _this_1.imgBigHeight = 0;
        _this_1.modeType = true;
        _this_1.modeLock = false;
        _this_1.tileSplitMap = [];
        _this_1.needFlushTileSplit = {};
        _this_1.needFlushAutoPos = [];
        _this_1.hasTilingAttribute = true;
        _this_1.scene = scene;
        _this_1.autoUpdate = autoUpdate;
        _this_1.addChild(_this_1.tileLayer);
        return _this_1;
    }
    ClientSceneLayer.prototype.install = function (layerData, onFin) {
        var _this_1 = this;
        if (onFin === void 0) { onFin = null; }
        ObjectUtils.clone(layerData, this);
        this.installMaterialData(layerData.materialData);
        if (this.drawMode && !this.autoTileDataCache) {
            this.autoTileDataCache = layerData.autoTileDataCache = [];
        }
        if (this.drawMode && layerData.tileData) {
            var urls = [];
            if (!Config.EDIT_MODE) {
                for (var id in layerData.tileTexIDs) {
                    if (!layerData.tileTexIDs[id])
                        continue;
                    var tileID = MathUtils.int(id);
                    if (tileID > 0) {
                        var tileData = Game.data.tileList.data[id];
                        if (tileData && tileData.url)
                            urls.push(tileData.url);
                    }
                    else {
                        var autoTileData = Game.data.autoTileList.data[-tileID];
                        if (autoTileData && autoTileData.url)
                            urls.push(autoTileData.url);
                    }
                }
            }
            else {
                for (var id in Game.data.tileList.data) {
                    var tileData = Game.data.tileList.data[id];
                    if (tileData && tileData.url)
                        urls.push(tileData.url);
                }
                for (var id in Game.data.autoTileList.data) {
                    var autoTileData = Game.data.autoTileList.data[id];
                    if (autoTileData && autoTileData.url)
                        urls.push(autoTileData.url);
                }
            }
            if (urls.length == 0) {
                onFin && onFin.run();
                return;
            }
            this.__loadImages = urls;
            AssetManager.loadImages(urls, Callback.New(function () {
                if (_this_1.isDisposed)
                    return;
                _this_1.setTilefromJsonData();
                onFin && onFin.run();
            }, this), !Config.EDIT_MODE);
        }
        else {
            if (layerData.img) {
                this.setBigImage(layerData.img);
                onFin && onFin.run();
            }
            else {
                onFin && onFin.run();
            }
        }
    };
    ClientSceneLayer.prototype.setTilefromJsonData = function () {
        var wGrid = this.scene.gridWidth;
        var hGrid = this.scene.gridHeight;
        for (var x = 0; x < wGrid; x++) {
            if (!this.tileData[x])
                continue;
            for (var y = 0; y < hGrid; y++) {
                var myTileData = this.tileData[x][y];
                if (myTileData && myTileData.texID) {
                    var texID = myTileData.texID;
                    if (texID > 0) {
                        var tileData = Game.data.tileList.data[myTileData.texID];
                        if (!tileData)
                            continue;
                        var url = tileData.url;
                    }
                    else {
                        var autoTileData = Game.data.autoTileList.data[-texID];
                        if (!autoTileData)
                            continue;
                        var url = autoTileData.url;
                        var autoTileDataCacheX = this.autoTileDataCache[x];
                        if (autoTileDataCacheX) {
                            var autoTileDataCache = autoTileDataCacheX[y];
                            if (autoTileDataCache) {
                                var atOriTex = AssetManager.getImage(url);
                                if (!atOriTex)
                                    continue;
                                if (autoTileData.GCATMode == 0) {
                                    var atMarginTex = ClientSceneLayer.getGCAT1Texture(texID, atOriTex, autoTileDataCache.gridInfo);
                                    if (!atMarginTex)
                                        continue;
                                    myTileData.tex = atOriTex;
                                    this.drawTile(x, y, { tex: atMarginTex, texID: 0, x: 0, y: 0, w: Config.SCENE_GRID_SIZE, h: Config.SCENE_GRID_SIZE }, true);
                                    continue;
                                }
                            }
                        }
                    }
                    var tex = AssetManager.getImage(url);
                    if (!tex)
                        continue;
                    myTileData.tex = tex;
                    this.drawTile(x, y, myTileData);
                }
                else {
                    if (myTileData && myTileData.texID == null)
                        this.tileData[x][y] = null;
                }
            }
        }
        this.flushTile();
    };
    ClientSceneLayer.prototype.resizeTileSplit = function (wGrid, hGrid) {
        if (isNaN(Config.TILE_SPLIT_SIZE) || Config.TILE_SPLIT_SIZE <= 0) {
            return;
        }
        for (var w = 0; w < this.tileData.length; w++) {
            if (!this.tileData[w])
                continue;
            if (this.tileData[w].length > hGrid) {
                this.tileData[w].splice(hGrid);
            }
        }
        if (this.tileData.length > wGrid)
            this.tileData.splice(wGrid);
        var splitGridSize = Math.ceil(Config.TILE_SPLIT_SIZE / Config.SCENE_GRID_SIZE);
        var wSplit = Math.floor(wGrid / splitGridSize);
        var hSplit = Math.floor(hGrid / splitGridSize);
        this.tileLayer.removeChildren();
        var len = this.tileSplitMap.length;
        for (var x = 0; x < len; x++) {
            var tileDataColumn = this.tileSplitMap[x];
            if (!tileDataColumn)
                continue;
            for (var y = 0; y < tileDataColumn.length; y++) {
                if (!tileDataColumn[y])
                    continue;
                if (x > wSplit || y > hSplit) {
                    if (tileDataColumn[y].texture)
                        tileDataColumn[y].texture.destroy(true);
                }
            }
            tileDataColumn.length = this.tileSplitMap[x].length = hSplit;
        }
        this.tileSplitMap.length = wSplit;
        for (var x = 0; x <= wSplit; x++) {
            if (!this.tileSplitMap[x])
                this.tileSplitMap[x] = [];
            for (var y = 0; y <= hSplit; y++) {
                var splitData = this.tileSplitMap[x][y];
                if (!splitData) {
                    splitData = this.tileSplitMap[x][y] = {
                        graphics: new Graphics(),
                        graphicsMapping: [],
                        texture: null,
                        sprite: new Sprite()
                    };
                    splitData.sprite.x = x * Config.TILE_SPLIT_SIZE;
                    splitData.sprite.y = y * Config.TILE_SPLIT_SIZE;
                    for (var g = 0; g < splitGridSize; g++) {
                        splitData.graphicsMapping[g] = [];
                    }
                }
                this.tileLayer.addChild(splitData.sprite);
            }
        }
        var realSize = Scene.getRealWidth(this.scene);
        this.imgWidth = realSize.width;
        this.imgHeight = realSize.height;
    };
    ClientSceneLayer.prototype.refreshLoopShow = function () {
        if (this.drawMode) {
            this.reloadTile();
        }
        else {
            this.setBigImage(this.mapUrl);
        }
    };
    ClientSceneLayer.prototype.reloadTile = function () {
        this.clearTile(false);
        this.install({ tileData: this.tileData, tileTexIDs: this["tileTexIDs"] });
    };
    ClientSceneLayer.prototype.getTileData = function () {
        var tileData = [];
        var tileTexIDs = {};
        var wGrid = this.scene.gridWidth;
        var hGrid = this.scene.gridHeight;
        for (var x = 0; x < wGrid; x++) {
            if (!this.tileData[x])
                continue;
            if (!tileData[x])
                tileData[x] = [];
            for (var y = 0; y < hGrid; y++) {
                var oneTileData = this.tileData[x][y];
                if (oneTileData) {
                    tileData[x][y] = {
                        texID: oneTileData.texID,
                        x: oneTileData.x,
                        y: oneTileData.y
                    };
                    if (oneTileData.texID && !tileTexIDs[oneTileData.texID]) {
                        tileTexIDs[oneTileData.texID] = true;
                    }
                }
            }
        }
        return [tileData, tileTexIDs];
    };
    ClientSceneLayer.prototype.drawTile = function (xGrid, yGrid, tileData, onlyDisplay) {
        if (onlyDisplay === void 0) { onlyDisplay = false; }
        if (isNaN(Config.TILE_SPLIT_SIZE) || Config.TILE_SPLIT_SIZE <= 0) {
            return;
        }
        if (tileData && tileData.texID < 0) {
            if (!this.tileData[xGrid])
                this.tileData[xGrid] = [];
            this.tileData[xGrid][yGrid] = tileData;
            var gridP = new Point(xGrid, yGrid);
            this.needFlushAutoPos.push({ grid: gridP, gridData: tileData, refreshGrid9: true });
            return;
        }
        if (xGrid < 0 || xGrid >= this.scene.gridWidth || yGrid < 0 || yGrid >= this.scene.gridHeight)
            return;
        var needRefreshGrids = ClientSceneLayer.gridCheckModes[2];
        var len = needRefreshGrids.length;
        for (var i = 0; i < len; i++) {
            var d = needRefreshGrids[i];
            var dx = d[0] + xGrid;
            var dy = d[1] + yGrid;
            var gridData = this.tileData[dx];
            if (!gridData)
                continue;
            gridData = gridData[dy];
            if (!gridData)
                continue;
            if (gridData.texID < 0) {
                this.needFlushAutoPos.push({ grid: new Point(dx, dy), gridData: gridData, refreshGrid9: false });
                continue;
            }
        }
        var splitGridSize = Math.ceil(Config.TILE_SPLIT_SIZE / Config.SCENE_GRID_SIZE);
        var xSplit = Math.floor(xGrid / splitGridSize);
        var ySplit = Math.floor(yGrid / splitGridSize);
        var splitDataX = this.tileSplitMap[xSplit];
        if (!splitDataX)
            return;
        var splitData = splitDataX[ySplit];
        var graphics = splitData.graphics;
        var localGridX = Math.floor(xGrid % splitGridSize);
        var localGridY = Math.floor(yGrid % splitGridSize);
        var localX = Math.floor(localGridX * Config.SCENE_GRID_SIZE);
        var localY = Math.floor(localGridY * Config.SCENE_GRID_SIZE);
        var gCmdIndex = splitData.graphicsMapping[localGridX][localGridY];
        if (gCmdIndex == null) {
            if (tileData && tileData.tex) {
                var w = Config.SCENE_GRID_SIZE;
                var h = Config.SCENE_GRID_SIZE;
                if (localGridX == splitGridSize - 1)
                    w += 1;
                if (localGridY == splitGridSize - 1)
                    h += 1;
                graphics.fillTexture(tileData.tex, localX, localY, w, h, 'no-repeat', new Point(-tileData.x, -tileData.y));
                gCmdIndex = splitData.graphicsMapping[localGridX][localGridY] = graphics.cmds ? graphics.cmds.length - 1 : 0;
            }
        }
        else {
            var gCmdData = gCmdIndex == 0 && graphics.cmds == null ? graphics["_one"] : graphics.cmds[gCmdIndex];
            if (tileData && tileData.tex) {
                if (gCmdData) {
                    gCmdData[0] = tileData.tex;
                    gCmdData[1] = localX;
                    gCmdData[2] = localY;
                    gCmdData[5] = 'no-repeat';
                    gCmdData[6].x = -tileData.x;
                    gCmdData[6].y = -tileData.y;
                    gCmdData[7] = {};
                }
            }
            else {
                splitData.graphicsMapping[localGridX][localGridY] = null;
                if (graphics.cmds) {
                    graphics.cmds.splice(gCmdIndex, 1);
                    for (var x = 0; x < splitGridSize; x++) {
                        for (var y = 0; y < splitGridSize; y++) {
                            if (splitData.graphicsMapping[x][y] == null)
                                continue;
                            if (splitData.graphicsMapping[x][y] > gCmdIndex) {
                                splitData.graphicsMapping[x][y]--;
                            }
                        }
                    }
                    if (graphics.cmds.length == 0) {
                        graphics.clear();
                    }
                }
                else {
                    if (gCmdIndex == 0)
                        graphics.clear();
                }
            }
        }
        var tileSplitIndex = xSplit + "_" + ySplit;
        if (!this.needFlushTileSplit[tileSplitIndex]) {
            this.needFlushTileSplit[tileSplitIndex] = splitData;
        }
        if (!onlyDisplay) {
            if (!this.tileData[xGrid])
                this.tileData[xGrid] = [];
            this.tileData[xGrid][yGrid] = tileData;
        }
    };
    ClientSceneLayer.prototype.drawAutoTile = function (xGrid, yGrid, autoTileID, texture) {
        if (xGrid < 0 || xGrid >= this.scene.gridWidth || yGrid < 0 || yGrid >= this.scene.gridHeight)
            return;
        var tileDataX = this.tileData[xGrid];
        if (!tileDataX)
            tileDataX = this.tileData[xGrid] = [];
        var tileDataY = tileDataX[yGrid] = { tex: texture, texID: -autoTileID, x: 0, y: 0, w: 0, h: 0 };
        var gridP = new Point(xGrid, yGrid);
        this.needFlushAutoPos.push({ grid: gridP, gridData: tileDataY, refreshGrid9: true });
    };
    ClientSceneLayer.prototype.calcDrawAutoTile = function (xGrid, yGrid) {
    };
    ClientSceneLayer.prototype.flushTile = function () {
        this.flushAutoTile();
        var realSize = Scene.getRealWidth(this.scene);
        for (var i in this.needFlushTileSplit) {
            var splitData = this.needFlushTileSplit[i];
            if (!splitData.graphics.cmds && !splitData.graphics["_one"]) {
                splitData.graphics.clear();
            }
            if (splitData.texture)
                splitData.texture.destroy(true);
            var texture = AssetManager.drawToTexture(splitData.graphics, Config.TILE_SPLIT_SIZE, Config.TILE_SPLIT_SIZE, 0, 0, false, Config.TILE_LINEAR_MIN ? 0x2601 : 0x2600, Config.TILE_LINEAR_MAG ? 0x2601 : 0x2600);
            var splitSprite = splitData.sprite;
            splitSprite.removeChildren();
            var drawArea = [];
            if (this.xLoop) {
                drawArea.push([1, 0], [-1, 0]);
            }
            if (this.yLoop) {
                drawArea.push([0, 1], [0, -1]);
            }
            if (this.xLoop && this.yLoop) {
                drawArea.push([-1, -1], [1, -1], [1, 1], [-1, 1]);
            }
            for (var s = 0; s < drawArea.length; s++) {
                var loopSp = new Sprite();
                loopSp.texture = texture;
                splitSprite.addChild(loopSp);
                var drawAreaS = drawArea[s];
                loopSp.x = drawAreaS[0] * realSize.width;
                loopSp.y = drawAreaS[1] * realSize.height;
            }
            splitData.sprite.texture = texture;
            splitData.texture = texture;
        }
        this.needFlushTileSplit = [];
    };
    ClientSceneLayer.prototype.flushAutoTile = function () {
        var _this_1 = this;
        var needFlushTileGrids = [];
        var autoTileListDatas = Game.data.autoTileList.data;
        for (var i = 0; i < this.needFlushAutoPos.length; i++) {
            var posInfo = this.needFlushAutoPos[i];
            var pos = posInfo.grid;
            var tileData = posInfo.gridData;
            if (!tileData)
                continue;
            var atID = -tileData.texID;
            var atData = autoTileListDatas[atID];
            if (atData) {
                if (!atData.url)
                    tileData.tex = null;
                if (atData.GCATMode == 0)
                    this.refreshAutoTileGrid1(tileData, pos.x, pos.y, needFlushTileGrids, posInfo.refreshGrid9);
            }
        }
        needFlushTileGrids.forEach(function (needFlushTileGrid, index) {
            _this_1.drawTile(needFlushTileGrid.grid.x, needFlushTileGrid.grid.y, { tex: needFlushTileGrid.tex, texID: 0, x: needFlushTileGrid.x, y: needFlushTileGrid.y, w: needFlushTileGrid.w, h: needFlushTileGrid.h }, true);
        }, this);
        this.needFlushAutoPos.length = 0;
    };
    ClientSceneLayer.prototype.clearTile = function (isDispose) {
        if (isDispose === void 0) { isDispose = false; }
        this.needFlushAutoPos.length = 0;
        var len = this.tileSplitMap.length;
        for (var x = 0; x < len; x++) {
            for (var y = 0; y < this.tileSplitMap[x].length; y++) {
                var tileData = this.tileSplitMap[x][y];
                if (!tileData)
                    continue;
                tileData.graphics.clear();
                for (var g = 0; g < tileData.graphicsMapping.length; g++) {
                    tileData.graphicsMapping[g] = [];
                }
                if (!tileData.texture)
                    continue;
                tileData.texture.destroy(true);
            }
        }
        if (isDispose)
            this.tileSplitMap.length = 0;
    };
    ClientSceneLayer.prototype.setEditorMode = function (bool, forceShow) {
        if (forceShow === void 0) { forceShow = false; }
        if (bool == this.editorMode || !this.drawMode)
            return;
        if (bool) {
            this.lastStates = {
                scaleX: this.scaleX,
                scaleY: this.scaleY,
                rotation: this.rotation,
                opacityPer: this.opacityPer,
                filterEnabled: this.filterEnabled,
                skewX: this.skewX,
                skewY: this.skewY
            };
            this.scaleX = this.scaleY = 1;
            this.skewX = this.skewY = 0;
            this.rotation = 0;
            this.opacityPer = 1;
            this.filterEnabled = false;
        }
        else {
            if (!this.lastStates)
                return;
            this.scaleX = this.lastStates.scaleX;
            this.scaleY = this.lastStates.scaleY;
            this.rotation = this.lastStates.rotation;
            this.opacityPer = forceShow ? 1 : this.lastStates.opacityPer;
            this.filterEnabled = true;
            this.dxMove = 0;
            this.dyMove = 0;
            this.skewX = this.lastStates.skewX;
            this.skewY = this.lastStates.skewY;
        }
        this.editorMode = bool;
        this.onRender(true);
    };
    Object.defineProperty(ClientSceneLayer.prototype, "drawMode", {
        get: function () {
            return this._drawMode;
        },
        set: function (v) {
            if (v) {
                this.setBigTexture(null);
            }
            else {
                this.tileLayer.graphics.clear();
            }
            if (!this._drawMode && v) {
                this.resizeTileSplit(this.scene.gridWidth, this.scene.gridHeight);
            }
            this._drawMode = v;
        },
        enumerable: false,
        configurable: true
    });
    ClientSceneLayer.prototype.setBigImage = function (imgURL) {
        var _this_1 = this;
        if (this.drawMode)
            return;
        this.mapUrl = imgURL;
        this.graphics.clear();
        if (this.bigImageRoot) {
            this.removeChild(this.bigImageRoot);
            AssetManager.disposeAtlasSprite(this.bigImageRoot);
            this.bigImageRoot = null;
        }
        if (imgURL == null)
            return;
        if (this.__loadImages)
            AssetManager.disposeImages(this.__loadImages);
        this.__loadImages = [imgURL];
        AssetManager.loadImage(imgURL, Callback.New(function (tex) {
            _this_1.setBigTexture(tex, false);
        }, this), true);
    };
    ClientSceneLayer.prototype.setBigTexture = function (t, disposeBitImage) {
        if (disposeBitImage === void 0) { disposeBitImage = true; }
        if (this.isDisposed)
            return;
        if (disposeBitImage && this.mapUrl) {
            AssetManager.disposeImage(this.mapUrl);
            this.mapUrl = null;
        }
        if (!t) {
            this.graphics.clear();
            return;
        }
        this.imgWidth = t.width;
        this.imgHeight = t.height;
        if (t.width > os.MAX_TEXTURE_SIZE || t.height > os.MAX_TEXTURE_SIZE) {
            var bitTextureBox = this.bigImageRoot = AssetManager.bigTextureToAtlasSprite(t, this.xLoop, this.yLoop, this.imgWidth, this.imgHeight);
            this.addChildAt(bitTextureBox, 0);
            return;
        }
        this.imgBigWidth = this.xLoop ? t.width * 50 : 0;
        this.imgBigHeight = this.yLoop ? t.height * 50 : 0;
        var g = new Graphics();
        var fillW = this.xLoop ? ClientSceneLayer.prospectSize : t.width;
        var fillH = this.yLoop ? ClientSceneLayer.prospectSize : t.height;
        g.fillTexture(t, 0, 0, fillW, fillH);
        this.graphics = g;
        Callback.CallLaterBeforeRender(this.doRepaint, this);
    };
    ClientSceneLayer.prototype.setViewPort = function (rect) {
        if (!this.autoUpdate)
            return;
        this.viewRect = rect;
        if (this.editorMode) {
            this.x = 0;
            this.y = 0;
            this.tileLayer.x = 0;
            this.tileLayer.y = 0;
            return;
        }
        if ((this.prospectsPerX != 1 || this.prospectsPerY != 1 || this.xMove != 0 || this.yMove != 0 || this.skewX != 1 || this.skewY != 1) && rect) {
            var dpx = 1 - this.prospectsPerX;
            var dpy = 1 - this.prospectsPerY;
            var globalX = Math.floor(rect.x * dpx);
            var globalY = Math.floor(rect.y * dpy);
            this.x = globalX + this.dx + this.dxMove - this.imgBigWidth;
            this.y = globalY + this.dy + this.dyMove - this.imgBigHeight;
            if (this.drawMode) {
                this.tileLayer.x = this.imgBigWidth;
                this.tileLayer.y = this.imgBigHeight;
            }
        }
        else {
            this.x = this.dx;
            this.y = this.dy;
            if (this.drawMode) {
                this.tileLayer.x = this.tileLayer.y = 0;
            }
        }
        this.x = this.x;
        this.y = this.y;
    };
    ClientSceneLayer.prototype.onRender = function (LayerMoveToZero) {
        if (LayerMoveToZero === void 0) { LayerMoveToZero = false; }
        if (!this.autoUpdate)
            return;
        if (!LayerMoveToZero) {
            this.dxMove += this.xMove;
            this.dyMove += this.yMove;
            if (this.imgWidth != 0 && this.xLoop) {
                this.dxMove %= this.imgWidth * this.scaleX;
            }
            if (this.imgHeight != 0 && this.yLoop) {
                this.dyMove %= this.imgHeight * this.scaleY;
            }
        }
        else {
            this.dxMove = 0;
            this.dyMove = 0;
        }
        this.setViewPort(this.viewRect);
        this.updateChildZOrder();
    };
    ClientSceneLayer.prototype.resetAutoMove = function () {
        this.dxMove = 0;
        this.dyMove = 0;
    };
    ClientSceneLayer.prototype.updateChildZOrder = function () {
        if (this.isChangeChildZOrder) {
            var len = this.numChildren;
            var mcArray = [];
            for (var i = 0; i < len; i++) {
                mcArray.push(this.getChildAt(i));
            }
            mcArray.sort(function (a, b) {
                if (a.y == b.y && a["objectID"] && b["objectID"]) {
                    return a["objectID"] < b["objectID"] ? -1 : 1;
                }
                return a.y > b.y ? 1 : -1;
            });
            var arrLen = mcArray.length;
            for (var j = 0; j < arrLen; j++) {
                this.setChildIndex(mcArray[j], j);
            }
        }
    };
    ClientSceneLayer.prototype.dispose = function () {
        if (!this.isDisposed) {
            if (this.__loadImages)
                AssetManager.disposeImages(this.__loadImages);
            if (this.mapUrl) {
                this.mapUrl = null;
            }
            if (this.bigImageRoot) {
                AssetManager.disposeAtlasSprite(this.bigImageRoot);
                this.bigImageRoot = null;
            }
            this.clearTile(true);
            this.removeSelf();
        }
        _super.prototype.dispose.call(this);
    };
    ClientSceneLayer.GCAT1_keys_init = function () {
        if (ClientSceneLayer.GCAT1_keysX)
            return;
        ClientSceneLayer.GCAT1_keysX = [];
        ClientSceneLayer.GCAT1_keysX[1000] = [2, 4];
        ClientSceneLayer.GCAT1_keysX[100] = [0, 4];
        ClientSceneLayer.GCAT1_keysX[1100] = [1, 4];
        ClientSceneLayer.GCAT1_keysX[10] = [2, 2];
        ClientSceneLayer.GCAT1_keysX[1010] = [2, 3];
        ClientSceneLayer.GCAT1_keysX[1110] = [0, 0];
        ClientSceneLayer.GCAT1_keysX[1] = [0, 2];
        ClientSceneLayer.GCAT1_keysX[101] = [0, 3];
        ClientSceneLayer.GCAT1_keysX[1101] = [1, 0];
        ClientSceneLayer.GCAT1_keysX[11] = [1, 2];
        ClientSceneLayer.GCAT1_keysX[1011] = [0, 1];
        ClientSceneLayer.GCAT1_keysX[111] = [1, 1];
        ClientSceneLayer.GCAT1_keysX[1111] = [1, 3];
    };
    ClientSceneLayer.prototype.refreshAutoTileGrid1 = function (tileData, gridX, gridY, needFlushTileGrids, refreshGrid9) {
        if (refreshGrid9 === void 0) { refreshGrid9 = true; }
        var needRefreshGrids = ClientSceneLayer.gridCheckModes[refreshGrid9 ? 0 : 1];
        var len = refreshGrid9 ? needRefreshGrids.length : 1;
        for (var i = 0; i < len; i++) {
            var d = needRefreshGrids[i];
            var dx = d[0] + gridX;
            var dy = d[1] + gridY;
            var gridData = this.tileData[dx];
            if (!gridData)
                continue;
            gridData = gridData[dy];
            if (!gridData)
                continue;
            if (tileData.texID != gridData.texID && gridData.texID < 0) {
                this.needFlushAutoPos.push({ grid: new Point(dx, dy), gridData: gridData, refreshGrid9: false });
                continue;
            }
            this.doRefreshAutoTileGrid1(tileData.texID, gridData, dx, dy, needFlushTileGrids);
        }
    };
    ClientSceneLayer.prototype.doRefreshAutoTileGrid1 = function (refAtID, tileData, xGrid, yGrid, needFlushTileGrids) {
        if (tileData.texID != refAtID)
            return;
        var gridInfo = this.getGridInfo(xGrid, yGrid, refAtID);
        var tex = ClientSceneLayer.getGCAT1Texture(refAtID, tileData.tex, gridInfo);
        var autoTileDataCacheX = this.autoTileDataCache[xGrid];
        if (!autoTileDataCacheX)
            autoTileDataCacheX = this.autoTileDataCache[xGrid] = [];
        autoTileDataCacheX[yGrid] = { autoTexID: refAtID, gridInfo: gridInfo };
        needFlushTileGrids.push({ grid: new Point(xGrid, yGrid), tex: tex, x: 0, y: 0, w: Config.SCENE_GRID_SIZE, h: Config.SCENE_GRID_SIZE });
    };
    ClientSceneLayer.prototype.getGridInfo = function (xGrid, yGrid, autoTileID, preCoverTileData, preCoverTileStartGrid) {
        if (preCoverTileData === void 0) { preCoverTileData = null; }
        if (preCoverTileStartGrid === void 0) { preCoverTileStartGrid = null; }
        var gridPointStatusRelyOns = ClientSceneLayer.gridPointStatusRelyOns1;
        var gridInfo = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (var i = 0; i < 16; i++) {
            var gs = gridPointStatusRelyOns[i];
            var existGrid = true;
            var gsLen = gs.length;
            for (var s = 0; s < gsLen; s++) {
                var dPoint = gs[s];
                var dx = dPoint[0];
                var dy = dPoint[1];
                var refGridX = xGrid + dx;
                var refGridY = yGrid + dy;
                if (refGridX < 0 || refGridY < 0 || refGridX >= this.scene.gridWidth || refGridY >= this.scene.gridHeight) {
                    continue;
                }
                var tileData = null;
                var targetTileDataX = null;
                if (preCoverTileData) {
                    refGridX -= preCoverTileStartGrid.x;
                    refGridY -= preCoverTileStartGrid.y;
                    if (refGridX >= 0 && refGridY >= 0) {
                        tileData = preCoverTileData;
                        targetTileDataX = tileData[refGridX];
                    }
                    if (!targetTileDataX || !targetTileDataX[refGridY]) {
                        refGridX += preCoverTileStartGrid.x;
                        refGridY += preCoverTileStartGrid.y;
                        targetTileDataX = null;
                    }
                }
                if (!targetTileDataX) {
                    tileData = this.tileData;
                    targetTileDataX = tileData[refGridX];
                }
                if (!targetTileDataX) {
                    existGrid = false;
                    break;
                }
                var targetTileData = targetTileDataX[refGridY];
                if (!targetTileData || targetTileData.texID != autoTileID) {
                    existGrid = false;
                    break;
                }
            }
            if (existGrid) {
                gridInfo[i] = 1;
            }
        }
        var k1 = gridInfo[0] * 1000 + gridInfo[1] * 100 + gridInfo[2] * 10 + gridInfo[3];
        var k2 = gridInfo[4] * 1000 + gridInfo[5] * 100 + gridInfo[6] * 10 + gridInfo[7];
        var k3 = gridInfo[8] * 1000 + gridInfo[9] * 100 + gridInfo[10] * 10 + gridInfo[11];
        var k4 = gridInfo[12] * 1000 + gridInfo[13] * 100 + gridInfo[14] * 10 + gridInfo[15];
        var key = k1 * 1000000000000 + k2 * 100000000 + k3 * 10000 + k4;
        return [k1, k2, k3, k4, key];
    };
    ClientSceneLayer.getGCAT1TextureSourceRect = function (info4) {
        ClientSceneLayer.GCAT1_keys_init();
        var sourcePos = ClientSceneLayer.GCAT1_keysX[info4];
        if (!sourcePos)
            return null;
        var tileSize = Math.floor(Config.SCENE_GRID_SIZE / 2);
        var dx = -sourcePos[0] * tileSize;
        var dy = -sourcePos[1] * tileSize;
        return new Rectangle(dx, dy, tileSize, tileSize);
    };
    ClientSceneLayer.getGCAT1Texture = function (autoTileID, autoTileTex, gridInfo) {
        var GCAT1_margin_textures = ClientSceneLayer.GCAT1_margin_textures[autoTileID];
        if (!GCAT1_margin_textures)
            GCAT1_margin_textures = ClientSceneLayer.GCAT1_margin_textures[autoTileID] = [];
        var gridInfoKey = gridInfo[4];
        var marginTexture = GCAT1_margin_textures[gridInfoKey];
        if (marginTexture) {
            return marginTexture;
        }
        var r1 = this.getGCAT1TextureSourceRect(gridInfo[0]);
        var r2 = this.getGCAT1TextureSourceRect(gridInfo[1]);
        var r3 = this.getGCAT1TextureSourceRect(gridInfo[2]);
        var r4 = this.getGCAT1TextureSourceRect(gridInfo[3]);
        var g = new Graphics();
        g.fillTexture(autoTileTex, 0, 0, r1.width, r1.height, 'repeat', new Point(r1.x, r1.y));
        g.fillTexture(autoTileTex, r1.width, 0, r2.width, r2.height, 'repeat', new Point(r2.x, r2.y));
        g.fillTexture(autoTileTex, 0, r1.width, r1.width, r2.height, 'repeat', new Point(r3.x, r3.y));
        g.fillTexture(autoTileTex, r1.width, r1.width, r2.width, r2.height, 'repeat', new Point(r4.x, r4.y));
        var tex = AssetManager.drawToTexture(g, Config.SCENE_GRID_SIZE, Config.SCENE_GRID_SIZE, 0, 0);
        GCAT1_margin_textures[gridInfoKey] = tex;
        return tex;
    };
    ClientSceneLayer.clearGCAT1Texture = function (autoTileID) {
        ClientSceneLayer.GCAT1_margin_textures[-autoTileID] = null;
    };
    ClientSceneLayer.getSaveData = function (layer) {
        return {
            normalData: {
                dx: layer.dx,
                dy: layer.dy,
                scaleX: layer.scaleX,
                scaleY: layer.scaleY,
                xMove: layer.xMove,
                yMove: layer.yMove,
                alpha: layer.alpha,
                visible: layer.visible,
                rotation: layer.rotation,
                skewX: layer.skewX,
                skewY: layer.skewY,
                xLoop: layer.xLoop,
                yLoop: layer.yLoop,
                prospectsPerX: layer.prospectsPerX,
                prospectsPerY: layer.prospectsPerY,
                blendMode: layer.blendMode,
            },
            drawMode: layer.drawMode,
            mapUrl: layer.mapUrl,
            materialData: layer.getAllMaterialDatas()
        };
    };
    ClientSceneLayer.recoverySaveData = function (layer, data) {
        if (layer.drawMode != data.drawMode)
            return;
        ObjectUtils.clone(data.normalData, layer);
        if (!layer.drawMode) {
            layer.setBigImage(data.mapUrl);
        }
        layer.installMaterialData(data.materialData);
    };
    ClientSceneLayer.prospectSize = 1000000;
    ClientSceneLayer.gridCheckModes = [
        [[0, 0], [-1, -1], [0, -1], [1, -1], [-1, 0], [1, 0], [-1, 1], [0, 1], [1, 1]],
        [[0, 0]],
        [[-1, -1], [0, -1], [1, -1], [-1, 0], [1, 0], [-1, 1], [0, 1], [1, 1]]
    ];
    ClientSceneLayer.GCAT1_margin_textures = [];
    ClientSceneLayer.sourcePositions = [
        null,
        [2, 4],
        [0, 4],
        [1, 4],
        [2, 2],
        [2, 3],
        null,
        [0, 0],
        [0, 2],
        null,
        [0, 3],
        [1, 0],
        [1, 2],
        [0, 1],
        [1, 1],
        [1, 3]
    ];
    ClientSceneLayer.gridPointStatusRelyOns1 = [
        [[-1, 0], [0, -1], [-1, -1]],
        [[0, -1]],
        [[-1, 0]],
        [],
        [[0, -1]],
        [[1, 0], [1, -1], [0, -1]],
        [],
        [[1, 0]],
        [[-1, 0]],
        [],
        [[-1, 0], [0, 1], [-1, 1]],
        [[0, 1]],
        [],
        [[1, 0]],
        [[0, 1]],
        [[1, 0], [0, 1], [1, 1]]
    ];
    return ClientSceneLayer;
}(GameSprite));















var GCAnimation = (function (_super) {
    __extends(GCAnimation, _super);
    function GCAnimation() {
        var _this_1 = _super.call(this) || this;
        _this_1.autoID = ObjectUtils.getInstanceID();
        _this_1._fps = Config.ANIMATION_FPS ? Config.ANIMATION_FPS : 20;
        _this_1.silentMode = false;
        _this_1._showHitEffect = false;
        _this_1._currentFrame = 1;
        _this_1.loop = false;
        _this_1.imageSources = [null];
        _this_1._totalFrame = 0;
        _this_1._preAnimationlayers = [];
        _this_1._isloading = false;
        _this_1._isloaded = false;
        _this_1._loadState = 0;
        _this_1.isParticle = false;
        _this_1.refObjs = {};
        _this_1.topAnimation = _this_1;
        _this_1.syncLoadWhenAssetExist = !Config.EDIT_MODE;
        if (Config.EDIT_MODE) {
            _this_1.mouseEnabled = true;
        }
        return _this_1;
    }
    Object.defineProperty(GCAnimation.prototype, "id", {
        get: function () { return this._id; },
        set: function (v) {
            if (this.isDisposed || v < 0)
                return;
            if (this._id == v)
                return;
            this.___disposeAsset();
            this._id = v;
            this._loadIDRD = Math.random();
            this.loadData(v, this._loadIDRD);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GCAnimation.prototype, "fps", {
        get: function () {
            return this._fps;
        },
        set: function (v) {
            this._fps = Math.max(Math.floor(v), 1);
            this._totalPlayTime = (this._totalFrame - 1) / this._fps * 1000;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GCAnimation.prototype, "showHitEffect", {
        get: function () { return this._showHitEffect; },
        set: function (v) {
            if (this.isDisposed)
                return;
            if (this._showHitEffect != v) {
                this._showHitEffect = v;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GCAnimation.prototype, "currentFrame", {
        get: function () { return this._currentFrame; },
        set: function (v) {
            if (this.isDisposed)
                return;
            if (v <= 1)
                v = 1;
            this._currentFrame = v;
            this._startTime = Date.now() - (v - 1) * 1000 / this.fps;
            this.onRender();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GCAnimation.prototype, "isPlaying", {
        get: function () { return this._isPlaying; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GCAnimation.prototype, "target", {
        get: function () {
            return this._target;
        },
        set: function (value) {
            if (this.isDisposed)
                return;
            if (this._target) {
                this._target.removeAnimationTargetEffect(this.animationTargetLayer);
            }
            this._target = value;
            if (this._target)
                this._target.addAnimationTargetEffect(this.animationTargetLayer);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GCAnimation.prototype, "totalFrame", {
        get: function () {
            return this._totalFrame;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GCAnimation.prototype, "isLoading", {
        get: function () {
            return this._isloading;
        },
        enumerable: false,
        configurable: true
    });
    GCAnimation.prototype.clear = function () {
        os.remove_ENTERFRAME(this.onEnterFrame, this);
        for (var i = this.numChildren - 1; i >= 0; i--) {
            var layer = this.getChildAt(i);
            if (layer instanceof AnimationLayer) {
                layer.dispose();
            }
        }
        if (this.particleAni) {
            this.particleAni.emitter.stop();
            this.particleAni.stop();
            this.particleAni.offAll();
            this.particleAni.removeSelf();
            this.particleAni.destroy(true);
            this.particleAni = null;
            this.particleData = null;
        }
    };
    GCAnimation.prototype.loadData = function (animationID, loadIDRD) {
        var _this_1 = this;
        if (this.isDisposed)
            return;
        this._isloading = true;
        this._isloaded = false;
        if (animationID == 0) {
            this._isloading = false;
            this._isloaded = true;
            this.clear();
            Callback.New(this.event, this, [EventObject.LOADED]).delayRun(0);
            return;
        }
        if (Config.EDIT_MODE) {
            var animationData = Common.animationList.data[animationID];
            if (!animationData) {
                Callback.New(this.event, this, [EventObject.LOADED]).delayRun(0);
                return;
            }
            this.parseData(animationData, loadIDRD);
        }
        else {
            this._loadState = 1;
            this.___loadJsonURL = "asset/json/animation/data/ani" + animationID + ".json";
            AssetManager.loadJson(this.___loadJsonURL, Callback.New(function (animationData) {
                _this_1.parseData(animationData, loadIDRD);
            }, this), this.syncLoadWhenAssetExist);
        }
    };
    GCAnimation.prototype.parseData = function (animationData, loadIDRD, inAniEditor) {
        if (loadIDRD === void 0) { loadIDRD = null; }
        if (inAniEditor === void 0) { inAniEditor = false; }
        var loadRandName = "loadAnimation" + this.autoID;
        if (this.isDisposed || this.topAnimation.isDisposed || (loadIDRD && this._loadIDRD != loadIDRD)) {
            this.event(GCAnimation.LOAD_EXPIRE);
            return;
        }
        if (loadIDRD && this._loadIDRD != loadIDRD)
            return;
        this._isloading = true;
        this._isloaded = false;
        if (!animationData) {
            this._isloaded = true;
            this._isloading = false;
            this.clear();
            this.event(EventObject.LOADED);
            return;
        }
        this.clear();
        if (animationData.isParticle) {
            this.particleParseData(animationData, loadIDRD, inAniEditor);
        }
        else {
            this.sFrameParseData(animationData, loadIDRD, inAniEditor);
        }
    };
    GCAnimation.prototype.particleParseData = function (animationData, loadIDRD, inAniEditor) {
        var _this_1 = this;
        if (inAniEditor === void 0) { inAniEditor = false; }
        this._id = animationData.id;
        this.isParticle = true;
        this.particleData = animationData.particleData;
        if (!this.particleData)
            return;
        var textureName = this.particleData.textureName;
        if (!textureName || textureName.length < 1) {
            this._isloading = false;
            this._isloaded = true;
            if (!loadIDRD || loadIDRD == _this._loadIDRD)
                _this.event(EventObject.LOADED);
            return;
        }
        var _this = this;
        this._loadState = 2;
        if (this.___loadPicUrls)
            this.___loadPicUrls = this.___loadPicUrls.concat([textureName]);
        else
            this.___loadPicUrls = [textureName];
        AssetManager.loadTexture(textureName, Callback.New(function (texture) {
            if (_this_1.isDisposed || _this_1.topAnimation.isDisposed || (loadIDRD && _this_1._loadIDRD != loadIDRD)) {
                _this_1.event(GCAnimation.LOAD_EXPIRE);
                return;
            }
            if (!loadIDRD || loadIDRD == _this_1._loadIDRD) {
                _this_1._isloading = false;
                _this_1._isloaded = true;
            }
            if (!texture) {
                if (!loadIDRD || loadIDRD == _this._loadIDRD)
                    _this.event(EventObject.LOADED);
                return;
            }
            var setting = new ParticleSetting();
            ObjectUtils.clone(_this.particleData, setting);
            setting.maxPartices += 1;
            if (!_this.particleAni) {
                _this.particleAni = new Particle2D(setting);
            }
            else {
                _this.particleAni.setParticleSetting(setting);
            }
            _this.onRender(false);
            if (Config.EDIT_MODE) {
                if (_this.stage && _this_1.isInherit(EUIRoot.uiSceneMain.sceneBox)) {
                    var rect = _this_1.hitArea = new Rectangle(-Config.SCENE_GRID_SIZE / 4, -Config.SCENE_GRID_SIZE / 4, Config.SCENE_GRID_SIZE - 1, Config.SCENE_GRID_SIZE - 1);
                    _this.graphics.clear();
                    _this.graphics.drawLines(rect.x, rect.y, [rect.x, rect.y, rect.right, rect.y, rect.right, rect.bottom, rect.x, rect.bottom, rect.x, rect.y], "#FFFFFF", 2);
                }
            }
            if (!loadIDRD || loadIDRD == _this._loadIDRD) {
                _this.event(EventObject.LOADED);
            }
            if (_this._isPlaying) {
                _this._isPlaying = false;
                _this.play(true);
            }
        }, this), this.syncLoadWhenAssetExist);
    };
    GCAnimation.prototype.refreshParticleSetting = function () {
        if (!this.particleData || !this.particleData.textureName || this.particleData.textureName.length < 1) {
            if (this.particleAni) {
                this.particleAni.emitter.stop();
                this.particleAni.stop();
            }
            return;
        }
        var _this = this;
        this._loadState = 2;
        if (this.___loadPicUrls)
            this.___loadPicUrls = this.___loadPicUrls.concat([this.particleData.textureName]);
        else
            this.___loadPicUrls = [this.particleData.textureName];
        this._isloading = true;
        this._isloaded = false;
        AssetManager.loadTexture(this.particleData.textureName, Callback.New(function (texture) {
            if (!texture)
                return;
            this._isloading = false;
            this._isloaded = true;
            var setting = new ParticleSetting();
            ObjectUtils.clone(_this.particleData, setting);
            setting.maxPartices += 1;
            if (!_this.particleAni) {
                _this.particleAni = new Particle2D(setting);
            }
            else {
                _this.particleAni.setParticleSetting(setting);
            }
            if (_this._isPlaying) {
                _this._isPlaying = false;
                _this.play(true);
            }
        }, this), this.syncLoadWhenAssetExist);
    };
    GCAnimation.prototype.sFrameParseData = function (animationData, loadIDRD, inAniEditor) {
        var _this_1 = this;
        if (inAniEditor === void 0) { inAniEditor = false; }
        var loadRandName = "loadAnimation" + this.autoID;
        if (Config.EDIT_MODE)
            this.graphics.clear();
        this._id = animationData.id;
        this._totalFrame = animationData.totalFrame;
        this._totalPlayTime = (this._totalFrame - 1) / this._fps * 1000;
        this.imageSources = animationData.imageSources;
        this.isParticle = false;
        this._preAnimationlayers.length = 0;
        this.animationTargetLayer = null;
        var picUrls = animationData.imageSources.reduce(function (pv, v) { if (v && pv.indexOf(v.url) == -1)
            pv.push(v.url); return pv; }, []);
        if (this.___loadPicUrls)
            this.___loadPicUrls = this.___loadPicUrls.concat(picUrls);
        else
            this.___loadPicUrls = picUrls;
        this._loadState = 2;
        AssetManager.loadImages(picUrls, Callback.New(function () {
            if (_this_1.isDisposed || _this_1.topAnimation.isDisposed || (loadIDRD && _this_1._loadIDRD != loadIDRD)) {
                _this_1.event(GCAnimation.LOAD_EXPIRE);
                return;
            }
            var layers = animationData.layers;
            var isHighLayer = false;
            for (var index = 0; index < layers.length; index++) {
                var layerData = layers[index];
                var layer = GCAnimation.createAnimationLayer(layerData);
                layer.topAnimation = _this_1.topAnimation;
                layer.inAniEditor = inAniEditor;
                if (layer instanceof AnimationTargetLayer && _this_1.animationTargetLayer) {
                    isHighLayer = true;
                    continue;
                }
                else if (layer instanceof AnimationTargetLayer)
                    _this_1.animationTargetLayer = layer;
                if (layer instanceof AnimationAnimationLayer) {
                    new SyncTask(loadRandName);
                    layer.once(EventObject.LOADED, _this_1, function (loadRandName) {
                        SyncTask.taskOver(loadRandName);
                    }, [loadRandName]);
                    layer.once(GCAnimation.LOAD_EXPIRE, _this_1, function (loadRandName) {
                        SyncTask.taskOver(loadRandName);
                    }, [loadRandName]);
                }
                GCAnimation.setAnimationLayerData(layer, layerData);
                _this_1._preAnimationlayers.push(layer);
                layer.animation = _this_1;
                _this_1.addChild(layer);
                layer.showFrame(0);
            }
            _this_1._loadState = 3;
            new SyncTask(loadRandName, function (loadRandName) {
                if (_this_1.isDisposed || _this_1.topAnimation.isDisposed || (loadIDRD && _this_1._loadIDRD != loadIDRD)) {
                    _this_1.event(GCAnimation.LOAD_EXPIRE);
                    SyncTask.taskOver(loadRandName);
                    return;
                }
                if (_this_1._openAutoHitArea || _this_1.mouseEnabled) {
                    _this_1.openAutoHitArea(_this_1._openAutoHitAreaForce);
                }
                if (!loadIDRD || loadIDRD == _this_1._loadIDRD) {
                    _this_1._isloading = false;
                    _this_1._isloaded = true;
                }
                _this_1.target = _this_1.target;
                _this_1.updateParent();
                _this_1.onRender(false);
                if (!loadIDRD || loadIDRD == _this_1._loadIDRD) {
                    _this_1.event(EventObject.LOADED);
                }
                if (_this_1._isPlaying) {
                    _this_1._isPlaying = false;
                    if (isNaN(_this_1._currentFrame) || isNaN(_this_1._startTime)) {
                        _this_1.gotoAndPlay();
                    }
                    else {
                        _this_1.play(true);
                    }
                }
                SyncTask.clear(loadRandName);
            }, [loadRandName], _this_1);
        }, this), this.syncLoadWhenAssetExist, true, this.prerender);
    };
    GCAnimation.prototype.addToGameSprite = function (target, lowLayer, highLayer) {
        if (this.isDisposed)
            return;
        this.target = target;
        this._lowLayer = lowLayer;
        this._highLayer = highLayer;
        this.updateParent();
    };
    GCAnimation.prototype.removeFromGameSprite = function () {
        this.addToGameSprite(null, null, null);
    };
    GCAnimation.prototype.updateParent = function () {
        var _this_1 = this;
        if (this.isDisposed || !this._isloaded)
            return;
        if (this._lowLayer != null || this._highLayer != null) {
            var isLowLayer = true;
            this._preAnimationlayers.forEach(function (element) {
                if (element.type == AnimationItemType.Target) {
                    isLowLayer = false;
                }
                else {
                    if (isLowLayer) {
                        if (_this_1._lowLayer)
                            _this_1._lowLayer.addChild(element);
                    }
                    else {
                        if (_this_1._highLayer)
                            _this_1._highLayer.addChild(element);
                    }
                }
            });
        }
        else {
            this._preAnimationlayers.forEach(function (v) { return _this_1.addChild(v); });
        }
    };
    GCAnimation.prototype.dispose = function () {
        if (!this.isDisposed) {
            os.remove_ENTERFRAME(this.onEnterFrame, this);
            this.stop(this.currentFrame);
            this.___clearTask();
            this.___disposeAsset();
            this._preAnimationlayers.forEach(function (element) {
                element.dispose();
            });
            this._preAnimationlayers = [];
            this.target = null;
            this.topAnimation = null;
            this._lowLayer = null;
            this._highLayer = null;
            this.animationTargetLayer = null;
            if (this.particleAni) {
                this.particleAni.offAll();
                this.particleAni.removeSelf();
                this.particleAni.destroy(true);
                this.particleAni = null;
                this.particleData = null;
            }
        }
        _super.prototype.dispose.call(this);
    };
    GCAnimation.prototype.___clearTask = function () {
        SyncTask.clear("loadAnimation" + this.autoID);
        GCAnimation.getChildrenLayers(this).forEach(function (layer) {
            if (layer instanceof AnimationAnimationLayer) {
                if (layer.animationInstance)
                    layer.animationInstance.___clearTask();
            }
        });
    };
    GCAnimation.prototype.___disposeAsset = function () {
        if (this._loadState == 3) {
            var needDisposeAnis = [];
            GCAnimation.getChildrenLayers(this).forEach(function (layer) {
                if (layer instanceof AnimationAnimationLayer) {
                    if (layer.animationInstance)
                        needDisposeAnis.push(layer.animationInstance);
                }
            });
            for (var i = 0; i < needDisposeAnis.length; i++) {
                var aniLayer = needDisposeAnis[i];
                aniLayer.___disposeAsset();
                aniLayer.__isDisposed = true;
            }
            AssetManager.disposeJson(this.___loadJsonURL);
            AssetManager.disposeImages(this.___loadPicUrls);
        }
        else if (this._loadState == 2) {
            AssetManager.disposeJson(this.___loadJsonURL);
            AssetManager.disposeImages(this.___loadPicUrls);
        }
        else if (this._loadState == 1) {
            AssetManager.disposeJson(this.___loadJsonURL);
        }
        this.___loadJsonURL = null;
        this.___loadPicUrls = null;
        this._loadState = 0;
    };
    GCAnimation.prototype.gotoAndPlay = function (frame) {
        if (frame === void 0) { frame = 1; }
        if (frame <= 1)
            frame = 1;
        this._currentFrame = frame;
        this._startTime = Date.now() - (frame - 1) * 1000 / this.fps;
        this.play();
    };
    GCAnimation.prototype.play = function (forcePlay) {
        if (forcePlay === void 0) { forcePlay = false; }
        if (this.isDisposed)
            return;
        if (!this.isParticle && this.layerAnimationSign) {
            return;
        }
        if (!this._isPlaying || forcePlay) {
            if (this.isLoading) {
                this._isPlaying = true;
                return;
            }
            if (!this._isPlaying) {
                this._currentFrame = ((this._currentFrame - 1) % this._totalFrame) + 1;
                this._startTime = Date.now() - (this._currentFrame - 1) * 1000 / this.fps;
                this.event(GCAnimation.PLAY_START);
            }
            this._isPlaying = true;
            if (this.isParticle) {
                if (!this.particleData || !this.particleData.textureName || !this.particleAni)
                    return;
                if (!this.particleAni.displayedInStage)
                    this.addChild(this.particleAni);
                this.particleAni.scaleX = 1.001;
                this.particleAni.emitter.start();
                this.particleAni.play();
                return;
            }
            function refreshAnimationShowHitEffect(ani, showHitEffect) {
                ani.showHitEffect = showHitEffect;
                GCAnimation.getChildrenLayers(ani).forEach(function (layer) {
                    if (layer instanceof AnimationAnimationLayer) {
                        if (layer.animationInstance)
                            refreshAnimationShowHitEffect(layer.animationInstance, showHitEffect);
                    }
                });
            }
            refreshAnimationShowHitEffect(this, this.showHitEffect);
            os.remove_ENTERFRAME(this.onEnterFrame, this);
            os.add_ENTERFRAME(this.onEnterFrame, this);
            this.onEnterFrame();
        }
    };
    GCAnimation.prototype.stop = function (frame) {
        if (frame === void 0) { frame = 1; }
        if (this.isDisposed)
            return;
        if (frame <= 1)
            frame = 1;
        if (this._isPlaying) {
            this._isPlaying = false;
            this.event(GCAnimation.PLAY_STOP);
            os.remove_ENTERFRAME(this.onEnterFrame, this);
            if (this.particleAni) {
                this.particleAni.emitter.stop();
                this.particleAni.stop();
            }
        }
        this.currentFrame = frame;
        var animationAudioLayers = GCAnimation.getAllLayers(this).filter(function (v) { return v instanceof AnimationAudioLayer; });
        animationAudioLayers.forEach(function (v) {
            v.stopAudio();
        });
        var animationAnimationLayers = GCAnimation.getAllLayers(this).filter(function (v) { return v instanceof AnimationAnimationLayer; });
        animationAnimationLayers.forEach(function (v) {
            if (v.animationInstance)
                v.animationInstance.stop(frame);
        });
    };
    Object.defineProperty(GCAnimation.prototype, "__renderEnabled", {
        get: function () {
            return this.displayedInStage || (this._lowLayer && this._lowLayer.stage) || (this._highLayer && this._highLayer.stage) || (this._target && this._target.stage);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GCAnimation.prototype, "__inEditorRenderEnabled", {
        get: function () {
            return !Config.EDIT_MODE || (Config.EDIT_MODE && this.__renderEnabled);
        },
        enumerable: false,
        configurable: true
    });
    GCAnimation.prototype.onEnterFrame = function () {
        if (this.isDisposed)
            return;
        if (!this.__inEditorRenderEnabled)
            return;
        if (this._totalFrame <= 0)
            return;
        var now = Date.now();
        var dt = now - this._startTime;
        if (this._totalPlayTime == 0) {
            this._currentFrame = 1;
        }
        else {
            if (!this.loop) {
                this._currentFrame = ((dt) * this.fps / 1000) + 1;
            }
            else {
                this._currentFrame = ((dt % this._totalPlayTime) * this.fps / 1000) + 1;
            }
        }
        this.onRender();
        if (!this.loop && dt >= this._totalPlayTime) {
            this.currentFrame = this._totalFrame;
            this.stop(this.currentFrame);
            this.event(GCAnimation.PLAY_COMPLETED);
        }
    };
    GCAnimation.prototype.onRender = function (sendEvent) {
        var _this_1 = this;
        if (sendEvent === void 0) { sendEvent = true; }
        if (this.isDisposed || this.topAnimation.isDisposed)
            return;
        if (this._isloading)
            return;
        if (!this.__inEditorRenderEnabled)
            return;
        this.refObjs = {};
        GCAnimation.getChildrenLayers(this).forEach(function (layer) {
            layer.showFrame(_this_1._currentFrame - 1);
        });
        if (sendEvent)
            this.event(GCAnimation.RENDER);
    };
    GCAnimation.prototype.updateTotalFrame = function () {
        var totalFrame = GCAnimation.getAllLayers(this).reduce(function (pv, cv) {
            var v = cv.frames.reduce(function (pv1, cv1) {
                return Math.max(pv1, cv1.index + 1);
            }, 0);
            return Math.max(v, pv);
        }, 0);
        return this._totalFrame = totalFrame;
    };
    GCAnimation.prototype.addAnimationLayer = function (layer, toIndex) {
        if (toIndex === void 0) { toIndex = -1; }
        if (!Config.EDIT_MODE)
            return;
        if (toIndex == -1 || toIndex > this.numChildren)
            this.addChild(layer);
        else
            this.addChildAt(layer, toIndex);
        layer.materialData = [{ materials: [] }];
        layer.materialsDataExit = true;
        layer.installMaterialData(layer.materialData);
        layer.animation = this;
        layer.inAniEditor = true;
        layer.showFrame(this.currentFrame - 1);
    };
    GCAnimation.prototype.toAnimationData = function () {
        var animationData = {};
        animationData.id = this.id;
        if (this.isParticle) {
            animationData.totalFrame = 0;
            animationData.imageSources = [null];
            animationData.layers = [];
            if (this.particleData)
                this.particleData.textureName = this.particleData.textureName.replace("?texture", "");
            animationData.particleData = this.particleData;
        }
        else {
            animationData.totalFrame = this.totalFrame;
            animationData.imageSources = this.imageSources;
            animationData.layers = GCAnimation.getChildrenLayers(this).map(function (v) { return v.toAnimationLayerData(); });
            animationData.particleData = null;
        }
        animationData.isParticle = this.isParticle;
        return animationData;
    };
    GCAnimation.getAllLayers = function (sprite) {
        var childrenLayers = GCAnimation.getChildrenLayers(sprite);
        var layers = [];
        childrenLayers.forEach(function (v) {
            layers.push(v);
            layers = layers.concat(GCAnimation.getAllLayers(v));
        });
        return layers;
    };
    GCAnimation.getChildrenLayers = function (sprite) {
        if ((!Config.EDIT_MODE || Config.BEHAVIOR_EDIT_MODE) && sprite instanceof GCAnimation) {
            if (sprite._preAnimationlayers)
                return sprite._preAnimationlayers;
        }
        var layers = [];
        for (var i = 0; i < sprite.numChildren; i++) {
            var child = sprite.getChildAt(i);
            if (child instanceof AnimationLayer) {
                layers.push(child);
            }
        }
        return layers;
    };
    GCAnimation.createAnimationLayer = function (layerdata) {
        var cls = AnimationLayer.typeClsMap[layerdata.type];
        var layer = new cls();
        return layer;
    };
    GCAnimation.setAnimationLayerData = function (aniLayer, layerdata) {
        aniLayer.setData(layerdata);
    };
    GCAnimation.prototype.on = function (type, caller, listener, args) {
        var t = _super.prototype.on.apply(this, arguments);
        if (this.hasMouseEvent)
            this.openAutoHitArea();
        return t;
    };
    ;
    GCAnimation.prototype.once = function (type, caller, listener, args) {
        var _this_1 = this;
        var t = _super.prototype.once.apply(this, [type, caller, function (caller, listener, args, e) {
                listener.apply(caller, args ? args.concat([e]) : [e]);
                if (!_this_1.hasMouseEvent)
                    _this_1.closeAutoHitArea();
            }, [caller, listener, args]]);
        if (this.hasMouseEvent)
            this.openAutoHitArea();
        return t;
    };
    ;
    GCAnimation.prototype.off = function (type, caller, listener, onceOnly) {
        var t = _super.prototype.off.apply(this, arguments);
        if (!this.hasMouseEvent)
            this.closeAutoHitArea();
        return t;
    };
    ;
    GCAnimation.prototype.offAll = function (type) {
        var t = _super.prototype.offAll.apply(this, arguments);
        if (!this.hasMouseEvent)
            this.closeAutoHitArea();
        return t;
    };
    ;
    GCAnimation.prototype.openAutoHitArea = function (force) {
        if (force === void 0) { force = false; }
        if (this.isDisposed)
            return;
        this._openAutoHitArea = true;
        this._openAutoHitAreaForce = force;
        if (force)
            this.mouseEnabled = true;
        var len = this._preAnimationlayers.length;
        for (var i = 0; i < len; i++) {
            var aniLayer = this._preAnimationlayers[i];
            aniLayer.openAutoHitArea(force);
        }
    };
    GCAnimation.prototype.closeAutoHitArea = function (force) {
        if (force === void 0) { force = false; }
        if (this.isDisposed || Config.EDIT_MODE)
            return;
        if (this._openAutoHitAreaForce && !force)
            return;
        this._openAutoHitArea = false;
        this._openAutoHitAreaForce = false;
        var len = this._preAnimationlayers.length;
        for (var i = 0; i < len; i++) {
            var aniLayer = this._preAnimationlayers[i];
            aniLayer.closeAutoHitArea(force);
        }
    };
    GCAnimation.RENDER = "RENDER";
    GCAnimation.PLAY_START = "playStart";
    GCAnimation.PLAY_STOP = "playStop";
    GCAnimation.PLAY_COMPLETED = "playCompleted";
    GCAnimation.SIGNAL = "Animation_SIGNAL";
    GCAnimation.LOAD_EXPIRE = "AvatarLOAD_EXPIRE";
    return GCAnimation;
}(GameSprite));
window['Animation'] = GCAnimation;















var AnimationLayer = (function (_super) {
    __extends(AnimationLayer, _super);
    function AnimationLayer() {
        var _this_1 = _super.call(this) || this;
        _this_1.frames = [];
        _this_1._frameinterpolationEnabled = true;
        _this_1._frameIndex = 0;
        _this_1._isOpenAutoHitArea = false;
        if (Config.EDIT_MODE) {
            _this_1.mouseEnabled = true;
        }
        _this_1.blendMode = "normal";
        return _this_1;
    }
    Object.defineProperty(AnimationLayer.prototype, "animation", {
        get: function () {
            if (!this._animation)
                return this.parent ? (this.parent.animation ? this.parent.animation : this.parent) : null;
            return this._animation;
        },
        set: function (v) { this._animation = v; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimationLayer.prototype, "isHitEffect", {
        get: function () { return this._isHitEffect; },
        set: function (v) {
            if (this._isHitEffect != v) {
                this._isHitEffect = v;
                this.updateFrame();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimationLayer.prototype, "frameinterpolationEnabled", {
        get: function () { return this._frameinterpolationEnabled; },
        set: function (v) {
            var _this_1 = this;
            if (this._frameinterpolationEnabled != v) {
                this._frameinterpolationEnabled = v;
                var framedata = this.frames.filter(function (v) { return v.index == _this_1._frameIndex; })[0];
                if (framedata)
                    framedata.frameinterpolationEnabled = v;
                this.updateFrame();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimationLayer.prototype, "frameIndex", {
        get: function () {
            return this._frameIndex;
        },
        enumerable: false,
        configurable: true
    });
    AnimationLayer.prototype.setData = function (data) {
        this.name = data.name;
        this.type = data.type;
        this.frames = data.frames;
        this._isHitEffect = data.isHitEffect;
        for (var i = 0; i < data.children.length; i++) {
            var layerdata = data.children[i];
            var cls = AnimationLayer.typeClsMap[layerdata.type];
            var layer = new cls();
            layer.topAnimation = this.topAnimation;
            layer.setData(layerdata);
            this.addChild(layer);
        }
        this.showOnEditor = !data.ishide;
        this.mouseEventEnabledInEditor = !data.islock;
    };
    AnimationLayer.prototype.fixFramesMaterialsData = function () {
        this.frames.forEach(function (v) {
            if (!v.materialData)
                v.materialData = [{ materials: [] }];
            delete v.hue;
            delete v.blur;
            delete v.tonal_r;
            delete v.tonal_g;
            delete v.tonal_b;
            delete v.tonal_gray;
            delete v.tonal_mr;
            delete v.tonal_mg;
            delete v.tonal_mb;
        });
    };
    AnimationLayer.prototype.openAutoHitArea = function (force) {
        if (force === void 0) { force = false; }
        this._openAutoHitAreaForce = force;
        this._isOpenAutoHitArea = true;
        return true;
    };
    AnimationLayer.prototype.closeAutoHitArea = function (force) {
        if (force === void 0) { force = false; }
        if (this._openAutoHitAreaForce && !force)
            return false;
        this._isOpenAutoHitArea = false;
        this._openAutoHitAreaForce = false;
        return true;
    };
    AnimationLayer.prototype.updateFrame = function () {
        this.showFrame(this._frameIndex);
    };
    AnimationLayer.prototype.showFrame = function (frameIndex) {
        var _this_1 = this;
        if (frameIndex < 0)
            return;
        var preFrameIndex = this._frameIndex;
        var animationFrame = this.getFrameData(frameIndex);
        this.fromAnimationFrameData(animationFrame);
        GCAnimation.getChildrenLayers(this).forEach(function (layer) {
            layer.showFrame(frameIndex);
        });
        if (!this.animation || !this.animation.isPlaying)
            return;
        var frames = this.frames;
        var signalNames = frames.filter(function (f) { return f.signalId && ((preFrameIndex < f.index || _this_1._frameIndex < preFrameIndex) && f.index <= _this_1._frameIndex); }).map(function (v) { return v.signalId; });
        signalNames.forEach(function (signalID) {
            if (signalID > 0) {
                _this_1.animation.event(GCAnimation.SIGNAL, [signalID]);
            }
        });
    };
    AnimationLayer.prototype.setOffset = function () {
        var topAnimation = this.topAnimation;
        if (topAnimation) {
            if (topAnimation.offsetX) {
                this.x += topAnimation.offsetX;
            }
            if (topAnimation.offsetY) {
                this.y += topAnimation.offsetY;
            }
        }
    };
    AnimationLayer.prototype.getCurrentKeyFrame = function () {
        return this.getKeyFrameData(this.frameIndex);
    };
    AnimationLayer.prototype.getKeyFrameData = function (frameIndex) {
        return this.frames.filter(function (f) { return f.index == frameIndex; })[0];
    };
    AnimationLayer.prototype.getFrameData = function (frameIndex) {
        var frames = this.frames;
        var frame;
        if (frames.length == 0) {
            frame = this.toAnimationFrameData();
            frame.index = frameIndex;
            return frame;
        }
        ;
        if (frameIndex < frames[0].index) {
            frame = ObjectUtils.depthClone(frames[0]);
            frame.index = frameIndex;
            return frame;
        }
        if (frameIndex > frames[frames.length - 1].index) {
            frame = ObjectUtils.depthClone(frames[frames.length - 1]);
            frame.index = frameIndex;
            return frame;
        }
        frame = frames.filter(function (v) { return v.index == frameIndex; })[0];
        if (frame)
            return frame;
        var result = frames.reduce(function (pv, cv, ci) {
            if (!pv) {
                var pf = frames[ci], nf = frames[ci + 1];
                if (pf.index < frameIndex && frameIndex < nf.index)
                    pv = { pf: pf, nf: nf };
            }
            return pv;
        }, null);
        if (!result)
            return frame;
        var interpolationEnabled = false;
        if (result.nf.trans != null) {
            interpolationEnabled = result.nf.trans && result.nf.trans.transType != 3;
        }
        else {
            interpolationEnabled = (result.nf.frameinterpolationEnabled == null || result.nf.frameinterpolationEnabled);
        }
        if (interpolationEnabled) {
            frame = this.interpolationFrame(result.pf, result.nf, frameIndex);
        }
        else {
            if (frameIndex + 1 > frames[frames.length - 1].index) {
                frame = ObjectUtils.depthClone(frames[frames.length - 1]);
            }
            else {
                frame = ObjectUtils.depthClone(result.pf);
            }
            frame.index = frameIndex;
            if (result.nf.trans == null)
                frame.frameinterpolationEnabled = result.nf.frameinterpolationEnabled;
        }
        return frame;
    };
    AnimationLayer.prototype.remove = function () {
        this.removeSelf();
    };
    AnimationLayer.prototype.isOnKeyFrame = function () {
        var _this_1 = this;
        var framedata = this.frames.filter(function (v) { return v.index == _this_1._frameIndex; })[0];
        return !!framedata;
    };
    AnimationLayer.prototype.saveCurrentFrameData = function (canNew) {
        var _this_1 = this;
        if (canNew === void 0) { canNew = false; }
        var framedata = this.frames.filter(function (v) { return v.index == _this_1._frameIndex; })[0];
        if (framedata) {
            this.toAnimationFrameData(framedata);
        }
        else if (canNew) {
            var newFrameData = this.toAnimationFrameData();
            this.frames.push(newFrameData);
            this.frames.sort(function (a, b) { return a.index - b.index; });
            this.animation && this.animation.updateTotalFrame();
        }
    };
    AnimationLayer.prototype.fromAnimationFrameData = function (framedata) {
        if (!framedata)
            return;
        this._frameIndex = framedata.index;
        if (framedata.trans == null) {
            if (framedata.frameinterpolationEnabled == null)
                framedata.frameinterpolationEnabled = true;
            this.frameinterpolationEnabled = framedata.frameinterpolationEnabled;
        }
    };
    AnimationLayer.prototype.toAnimationFrameData = function (framedata) {
        framedata = framedata || {};
        framedata.index = this._frameIndex;
        if (framedata.trans == null) {
            framedata.frameinterpolationEnabled = this.frameinterpolationEnabled;
        }
        if (this.materialsDataExit) {
            framedata.materialData = ObjectUtils.depthClone(this.materialData);
        }
        return framedata;
    };
    AnimationLayer.prototype.toAnimationLayerData = function () {
        this.saveCurrentFrameData();
        var data = {
            type: this.type,
            name: this.name,
            children: GCAnimation.getChildrenLayers(this).map(function (v) { return v.toAnimationLayerData(); }),
            frames: this.frames,
            isHitEffect: !!this.isHitEffect,
            ishide: !this.showOnEditor,
            islock: !this.mouseEventEnabledInEditor
        };
        return data;
    };
    AnimationLayer.prototype.interpolationFrame = function (pf, nf, frameIndex) {
        return { index: frameIndex, frameinterpolationEnabled: nf.frameinterpolationEnabled, trans: nf.trans, materialData: [{ materials: [] }] };
    };
    AnimationLayer.prototype.refreshInterpolationFrameMaterials = function (frame, pf, nf, value) {
        frame.materialData = [{ materials: [] }];
        var pfmaterials = pf.materialData[0].materials;
        var nfmaterials = nf.materialData[0].materials;
        for (var i = 0; i < pfmaterials.length; i++) {
            var pmaterial = pfmaterials[i];
            var material = {};
            var nmaterial = nfmaterials[i];
            for (var key in pmaterial) {
                if (typeof pmaterial[key] != "boolean" && typeof pmaterial[key] != "number" && typeof pmaterial[key] != "string")
                    continue;
                var pvalue = pmaterial[key];
                if (typeof pvalue != "number")
                    material[key] = pvalue;
                else
                    material[key] = (nmaterial[key] - pmaterial[key]) * value + pmaterial[key];
            }
            frame.materialData[0].materials.push(material);
        }
    };
    AnimationLayer.prototype.setFrameMaterialsEffect = function (materialData) {
        if (!this.materialData || !materialData)
            return;
        var frameMaterials = materialData[0];
        if (!frameMaterials || !frameMaterials.materials)
            return;
        for (var i = 0; i < frameMaterials.materials.length; i++) {
            var frameMaterialsData = frameMaterials.materials[i];
            if (!frameMaterialsData)
                continue;
            var materialValues = {};
            for (var key in frameMaterialsData) {
                var frameMaterial = frameMaterialsData[key];
                if (typeof frameMaterial != "boolean" && typeof frameMaterial != "number" && typeof frameMaterial != "string")
                    continue;
                if (typeof frameMaterial == "number") {
                    materialValues["mu" + frameMaterialsData.id + "_" + key] = frameMaterial;
                }
            }
            this.setMaterialValueFast(materialValues, i);
        }
    };
    AnimationLayer.prototype.refreshInterpolationFrameTonal = function (frame, pf, nf, value, tween) {
        if (!tween)
            return;
        frame.hue = Math.round(tween(value, pf.hue, nf.hue - pf.hue, 1));
        frame.blur = tween(value, pf.blur, nf.blur - pf.blur, 1);
        frame.tonal_r = Math.round(tween(value, pf.tonal_r, nf.tonal_r - pf.tonal_r, 1));
        frame.tonal_g = Math.round(tween(value, pf.tonal_g, nf.tonal_g - pf.tonal_g, 1));
        frame.tonal_b = Math.round(tween(value, pf.tonal_b, nf.tonal_b - pf.tonal_b, 1));
        frame.tonal_gray = Math.round(tween(value, pf.tonal_gray, nf.tonal_gray - pf.tonal_gray, 1));
        frame.tonal_mr = tween(value, pf.tonal_mr, nf.tonal_mr - pf.tonal_mr, 1);
        frame.tonal_mg = tween(value, pf.tonal_mg, nf.tonal_mg - pf.tonal_mg, 1);
        frame.tonal_mb = tween(value, pf.tonal_mb, nf.tonal_mb - pf.tonal_mb, 1);
    };
    AnimationLayer.prototype.checkMaterialsTransChange = function (frameData) {
        if (this.frames.length <= 1)
            return false;
        var currentFrameData = this.materialData;
        if (!frameData.materialData || !currentFrameData)
            return false;
        var materialsA = frameData.materialData[0];
        var materialsB = currentFrameData[0];
        if (!materialsA || !materialsA.materials || !materialsB || !materialsB.materials)
            return false;
        var isChange = false;
        for (var i = 0; i < materialsA.materials.length; i++) {
            var materialA = materialsA.materials[i];
            var materialB = materialsB.materials[i];
            if (!materialA || !materialB)
                continue;
            for (var key in materialA) {
                var frameMaterial = materialA[key];
                if (typeof frameMaterial != "boolean" && typeof frameMaterial != "number" && typeof frameMaterial != "string")
                    continue;
                if (!isChange && typeof frameMaterial != "number" && frameMaterial != materialB[key]) {
                    isChange = true;
                }
                materialB[key] = frameMaterial;
            }
        }
        return isChange;
    };
    AnimationLayer.typeClsMap = {};
    return AnimationLayer;
}(GameSprite));















var AnimationRefObjLayer = (function (_super) {
    __extends(AnimationRefObjLayer, _super);
    function AnimationRefObjLayer() {
        var _this_1 = _super.call(this) || this;
        _this_1.isRefObj = true;
        _this_1.type = AnimationItemType.RefObj;
        _this_1.pivotType = 0;
        _this_1.hitArea = new HitArea();
        _this_1.hitArea.hit = new Graphics();
        _this_1.on(EventObject.RESIZE, _this_1, _this_1.refresh);
        return _this_1;
    }
    Object.defineProperty(AnimationRefObjLayer.prototype, "color", {
        get: function () { return this.data.color; },
        set: function (v) { this.data.color = v; if (this.currentFramedata)
            this.refresh(); },
        enumerable: false,
        configurable: true
    });
    ;
    Object.defineProperty(AnimationRefObjLayer.prototype, "line", {
        get: function () { return this.data.line; },
        set: function (v) { this.data.line = v; if (this.currentFramedata)
            this.refresh(); },
        enumerable: false,
        configurable: true
    });
    ;
    Object.defineProperty(AnimationRefObjLayer.prototype, "editor", {
        get: function () { return Editor; },
        enumerable: false,
        configurable: true
    });
    ;
    AnimationRefObjLayer.prototype.setData = function (data) {
        _super.prototype.setData.call(this, data);
        this.refObjId = data.refObjId;
        if (Config.EDIT_MODE)
            this.data = Game.data.animationRefObjList.data[this.refObjId];
        else
            this.data = new AvatarRefObjData();
    };
    AnimationRefObjLayer.prototype.toAnimationLayerData = function () {
        var data = _super.prototype.toAnimationLayerData.call(this);
        data.refObjId = this.refObjId;
        return data;
    };
    AnimationRefObjLayer.prototype.showFrame = function (frameIndex) {
        var _this_1 = this;
        if (!this.animation)
            return;
        _super.prototype.showFrame.call(this, frameIndex);
        var showEnable = true;
        if (Config.EDIT_MODE && EUIWindowAnimation.InAniEditor(this.animation) && this.animation.topAnimation == this.animation)
            showEnable = this.showOnEditor;
        else
            showEnable = false;
        this.visible = showEnable;
        if (!this.animation || !this.animation.topAnimation)
            return;
        if (!this.animation.topAnimation.refObjs[this.refObjId])
            this.animation.topAnimation.refObjs[this.refObjId] = [];
        var isDispaly = function (sp) {
            if (!sp || sp == _this_1.topAnimation)
                return true;
            else if (!sp.visible)
                return false;
            else
                return isDispaly(sp.parent);
        };
        var isShow = isDispaly(this.parent);
        if (!isShow)
            return;
        this.currentFramedata.pointPostion = this.getPointPostion();
        this.animation.topAnimation.refObjs[this.refObjId].push(this.currentFramedata);
    };
    AnimationRefObjLayer.prototype.fromAnimationFrameData = function (framedata) {
        _super.prototype.fromAnimationFrameData.call(this, framedata);
        if (!framedata)
            return;
        this.currentFramedata = ObjectUtils.depthClone(framedata);
        this.x = this.x;
        this.y = this.y;
        this.refresh();
    };
    AnimationRefObjLayer.prototype.toAnimationFrameData = function (framedata) {
        framedata = _super.prototype.toAnimationFrameData.call(this, framedata);
        framedata.radius = this.currentFramedata.radius;
        framedata.type = this.currentFramedata.type;
        framedata.x = this.currentFramedata.x;
        framedata.y = this.currentFramedata.y;
        framedata.width = this.currentFramedata.width;
        framedata.height = this.currentFramedata.height;
        framedata.rotation = this.currentFramedata.rotation;
        if (this.currentFramedata.points)
            framedata.points = ObjectUtils.depthClone(this.currentFramedata.points);
        if (this.currentFramedata.boundingBox)
            framedata.boundingBox = ObjectUtils.depthClone(this.currentFramedata.boundingBox);
        return framedata;
    };
    AnimationRefObjLayer.prototype.interpolationFrame = function (pf, nf, frameIndex) {
        var frame = _super.prototype.interpolationFrame.call(this, pf, nf, frameIndex);
        var t = (frameIndex - pf.index) / (nf.index - pf.index);
        var value = GameUtils.getValueByTransData(nf.trans, t);
        frame.type = pf.type;
        var getPointsXOrY = function (isX, _frame) {
            if (_frame === void 0) { _frame = frame; }
            var min;
            var _points = _frame.type == 4 ? _frame.points.concat([]).splice(0, 4) : _frame.points;
            _points.forEach(function (v, i) {
                if (isX ? (i % 2 == 0) : (i % 2 != 0)) {
                    if (min == null)
                        min = v;
                    else if (v < min)
                        min = v;
                }
            });
            if (!min)
                min = 0;
            return min;
        };
        var getPointsWOrH = function (isW, _frame) {
            if (_frame === void 0) { _frame = frame; }
            var max;
            var _points = _frame.type == 4 ? _frame.points.concat([]).splice(0, 4) : _frame.points;
            _points.forEach(function (v, i) {
                if (isW ? (i % 2 == 0) : (i % 2 != 0)) {
                    if (max == null)
                        max = v;
                    else if (v > max)
                        max = v;
                }
            });
            if (!max)
                max = 0;
            return max - getPointsXOrY(isW, _frame);
        };
        var setPointsXorY = function (isX, v) {
            var min = getPointsXOrY(isX);
            frame.points = frame.points.map(function (c, i) {
                if (isX ? (i % 2 == 0) : (i % 2 != 0))
                    return c - min + v;
                else
                    return c;
            });
        };
        if (pf.type == -1 || nf.type == -1) {
            frame.x = pf.x;
            frame.y = pf.y;
            frame.width = pf.width;
            frame.height = pf.height;
            frame.radius = pf.radius;
            frame.rotation = pf.rotation;
            if (pf.points)
                frame.points = ObjectUtils.depthClone(pf.points);
            if (pf.boundingBox)
                frame.boundingBox = ObjectUtils.depthClone(pf.boundingBox);
            return frame;
        }
        else if ((pf.type == nf.type && pf.type != 3) || (pf.type == nf.type && pf.type == 3 && pf.points.length == nf.points.length)) {
            frame.x = (nf.x - pf.x) * value + pf.x;
            frame.y = (nf.y - pf.y) * value + pf.y;
            frame.width = (nf.width - pf.width) * value + pf.width;
            frame.height = (nf.height - pf.height) * value + pf.height;
            frame.rotation = (nf.rotation - pf.rotation) * value + pf.rotation;
            frame.radius = (nf.radius - pf.radius) * value + pf.radius;
            frame.points = [];
            for (var i_14 = 0; i_14 < pf.points.length; i_14++) {
                frame.points.push((nf.points[i_14] - pf.points[i_14]) * value + pf.points[i_14]);
            }
            if (pf.type == 3 || pf.type == 4)
                frame.boundingBox = new Rectangle(getPointsXOrY(true), getPointsXOrY(false), getPointsWOrH(true), getPointsWOrH(false));
            return frame;
        }
        frame.x = pf.x;
        frame.y = pf.y;
        frame.width = pf.width;
        frame.height = pf.height;
        frame.radius = pf.radius;
        frame.rotation = pf.rotation;
        if (pf.points)
            frame.points = ObjectUtils.depthClone(pf.points);
        if (pf.boundingBox)
            frame.boundingBox = ObjectUtils.depthClone(pf.boundingBox);
        var pfx = pf.type != 3 && pf.type != 4 ? pf.x : getPointsXOrY(true, pf);
        var pfy = pf.type != 3 && pf.type != 4 ? pf.y : getPointsXOrY(false, pf);
        var nfx = nf.type != 3 && nf.type != 4 ? nf.x : getPointsXOrY(true, nf);
        var nfy = nf.type != 3 && nf.type != 4 ? nf.y : getPointsXOrY(false, nf);
        if (pf.type != 3 && pf.type != 4) {
            frame.x = (nfx - pfx) * value + pfx;
            frame.y = (nfy - pfy) * value + pfy;
        }
        else {
            setPointsXorY(true, (nfx - pfx) * value + pfx);
            setPointsXorY(false, (nfy - pfy) * value + pfy);
        }
        if (pf.type != 3 && pf.type != 4) {
            var pfw = pf.type == 1 ? pf.radius * 2 : pf.width;
            var pfh = pf.type == 1 ? pf.radius * 2 : pf.height;
            var nfw = nf.type == 1 ? nf.radius * 2 : nf.width;
            var nfh = nf.type == 1 ? nf.radius * 2 : nf.height;
            if (pf.type == 1) {
                var a = ((nfw - pfw) * value + pfw) / 2;
                var b = ((nfh - pfh) * value + pfh) / 2;
                frame.radius = a > b ? a : b;
            }
            else {
                frame.width = (nfw - pfw) * value + pfw;
                frame.height = (nfh - pfh) * value + pfh;
            }
        }
        if (pf.type == 3 || pf.type == 4)
            frame.boundingBox = new Rectangle(getPointsXOrY(true), getPointsXOrY(false), getPointsWOrH(true), getPointsWOrH(false));
        return frame;
    };
    AnimationRefObjLayer.prototype.getPointPostion = function () {
        var frameData = this.currentFramedata;
        var points = [];
        var points1 = [];
        switch (frameData.type) {
            case 0:
                points = [0, 0, frameData.width, 0, frameData.width, frameData.height, 0, frameData.height];
                break;
            case 1:
                points = [this.x + frameData.radius, this.y + frameData.radius];
                break;
            case 2:
                points = [frameData.width / 2, 0, frameData.width, frameData.height, 0, frameData.height];
                break;
            case 3:
                points = ObjectUtils.depthClone(frameData.points);
                break;
            case 4:
                points = ObjectUtils.depthClone(frameData.points);
                break;
            case 5:
                points = [this.x, this.y, this.x + frameData.width, this.y, this.x + frameData.width, this.y + frameData.height, this.x, this.y + frameData.height];
                break;
        }
        for (var i_15 = 0; i_15 < points.length - 1; i_15 += 2) {
            var point = new Point(points[i_15], points[i_15 + 1]);
            points1[Math.floor(i_15 / 2)] = point;
        }
        var _this = this;
        var get = function (sp) {
            if (!sp || sp == _this.topAnimation)
                return;
            else {
                for (var i_16 = 0; i_16 < points1.length; i_16++)
                    points1[i_16] = _this.transformPoint(points1[i_16], sp);
                get(sp.parent);
            }
        };
        if (frameData.type == 0 || frameData.type == 2)
            get(this);
        else
            get(this.parent);
        return points1;
    };
    AnimationRefObjLayer.prototype.transformPoint = function (point, rectangle) {
        var x = rectangle.x, y = rectangle.y, rotation = rectangle.rotation;
        var radians = MathUtils.angle2Radian(rotation);
        var xTransformed = point.x * Math.cos(radians) - point.y * Math.sin(radians) + x;
        var yTransformed = point.x * Math.sin(radians) + point.y * Math.cos(radians) + y;
        return new Point(xTransformed, yTransformed);
    };
    Object.defineProperty(AnimationRefObjLayer.prototype, "width", {
        get: function () {
            return this.rType == 1 ? this.radius * 2 : this.currentFramedata.width;
        },
        set: function (v) {
            if (this.currentFramedata.type == 6)
                return;
            if (v < 1)
                v = 1;
            if (this.rType == 1) {
                if (this.radius !== v / 2) {
                    this.radius = v / 2;
                    this.event(EventObject.RESIZE);
                }
            }
            else {
                if (this.currentFramedata.width !== v) {
                    this.currentFramedata.width = v;
                    this.event(EventObject.RESIZE);
                }
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimationRefObjLayer.prototype, "height", {
        get: function () {
            return this.rType == 1 ? this.radius * 2 : this.currentFramedata.height;
        },
        set: function (v) {
            if (this.currentFramedata.type == 6)
                return;
            if (v < 1)
                v = 1;
            if (this.rType == 1) {
                if (this.radius !== v / 2) {
                    this.radius = v / 2;
                    this.event(EventObject.RESIZE);
                }
            }
            else {
                if (this.currentFramedata.height !== v) {
                    this.currentFramedata.height = v;
                    this.event(EventObject.RESIZE);
                }
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimationRefObjLayer.prototype, "x", {
        get: function () {
            return this.rType == 3 || this.rType == 4 ? this.pointsX : this.currentFramedata.x;
        },
        set: function (v) {
            if (this.rType != 3 && this.rType != 4)
                this.currentFramedata.x = v;
            else
                this.pointsX = v;
            this["_x"] = v;
            var p = this["_parent"];
            if (p && p._repaint === 0) {
                p._repaint = 1;
                p.parentRepaint();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimationRefObjLayer.prototype, "y", {
        get: function () {
            return this.rType == 3 || this.rType == 4 ? this.pointsY : this.currentFramedata.y;
        },
        set: function (v) {
            if (this.rType != 3 && this.rType != 4)
                this.currentFramedata.y = v;
            else
                this.pointsY = v;
            this["_y"] = v;
            var p = this["_parent"];
            if (p && p._repaint === 0) {
                p._repaint = 1;
                p.parentRepaint();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimationRefObjLayer.prototype, "rotation", {
        get: function () {
            return this.rType == 0 || this.rType == 2 ? this.currentFramedata.rotation : 0;
        },
        set: function (v) {
            var style = this.getStyle();
            if (style && style._tf.rotate !== v) {
                if (this.isCanRotation)
                    this.currentFramedata.rotation = v;
                style.setRotate(v);
                this["_tfChanged"] = true;
                this.conchModel && this.conchModel.rotate(v);
                this["_renderType"] |= 0x04;
                var p = this["_parent"];
                if (p && p._repaint === 0) {
                    p._repaint = 1;
                    p.parentRepaint();
                }
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimationRefObjLayer.prototype, "isCanRotation", {
        get: function () {
            if (this.rType != 0 && this.rType != 2)
                return false;
            if (!Config.EDIT_MODE)
                return true;
            var systemCommands = this.editor.customSystemEnableds;
            if (this.rType == 0) {
                if (systemCommands.animationHelper0 == 2)
                    return false;
            }
            else if (this.rType == 2) {
                if (systemCommands.animationHelper2 == 2)
                    return false;
            }
            return true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimationRefObjLayer.prototype, "pointsX", {
        get: function () {
            var min;
            var _points = this.rType == 4 ? this.points.concat([]).splice(0, 4) : this.points;
            _points.forEach(function (v, i) {
                if (i % 2 == 0) {
                    if (min == null)
                        min = v;
                    else if (v < min)
                        min = v;
                }
            });
            if (!min)
                min = 0;
            return min;
        },
        set: function (v) {
            var min = this.pointsX;
            this.points = this.points.map(function (c, i) {
                if (i % 2 == 0)
                    return c - min + v;
                else
                    return c;
            });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimationRefObjLayer.prototype, "pointsY", {
        get: function () {
            var min;
            var _points = this.rType == 4 ? this.points.concat([]).splice(0, 4) : this.points;
            _points.forEach(function (v, i) {
                if (i % 2 != 0) {
                    if (min == null)
                        min = v;
                    else if (v < min)
                        min = v;
                }
            });
            if (!min)
                min = 0;
            return min;
        },
        set: function (v) {
            var min = this.pointsY;
            this.points = this.points.map(function (c, i) {
                if (i % 2 != 0)
                    return c - min + v;
                else
                    return c;
            });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimationRefObjLayer.prototype, "pointsW", {
        get: function () {
            var max;
            var _points = this.rType == 4 ? this.points.concat([]).splice(0, 4) : this.points;
            _points.forEach(function (v, i) {
                if (i % 2 == 0) {
                    if (max == null)
                        max = v;
                    else if (v > max)
                        max = v;
                }
            });
            if (!max)
                max = 0;
            return max - this.pointsX;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimationRefObjLayer.prototype, "pointsH", {
        get: function () {
            var max;
            var _points = this.rType == 4 ? this.points.concat([]).splice(0, 4) : this.points;
            _points.forEach(function (v, i) {
                if (i % 2 != 0) {
                    if (max == null)
                        max = v;
                    else if (v > max)
                        max = v;
                }
            });
            if (!max)
                max = 0;
            return max - this.pointsY;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimationRefObjLayer.prototype, "rePoints", {
        get: function () {
            var _this_1 = this;
            var points = this.points.concat([this.points[0], this.points[1]]);
            points = points.map(function (v, i) {
                if (i % 2 == 0)
                    return v - _this_1.x;
                else
                    return v - _this_1.y;
            }, this);
            return points;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimationRefObjLayer.prototype, "rType", {
        get: function () {
            return this.currentFramedata.type;
        },
        set: function (v) {
            this.currentFramedata.type = v;
            if (this.currentFramedata.type == 1 && this.currentFramedata.radius == null)
                this.currentFramedata.radius = 20;
            if (this.currentFramedata.type == 3 && (this.currentFramedata.points == null || this.currentFramedata.points.length < 6)) {
                this.currentFramedata.points = [0, 0, 100, 0, 50, -100];
            }
            if (this.currentFramedata.type == 4 && (this.currentFramedata.points == null || this.currentFramedata.points.length < 4)) {
                this.currentFramedata.points = [0, 0, 100, 0];
            }
            this.refresh();
            this.reBoundingBox();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimationRefObjLayer.prototype, "radius", {
        get: function () {
            return this.currentFramedata.radius;
        },
        set: function (v) {
            if (v < 1)
                v = 1;
            this.currentFramedata.radius = v;
            this.refresh();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimationRefObjLayer.prototype, "points", {
        get: function () {
            return this.currentFramedata.points;
        },
        set: function (v) {
            this.currentFramedata.points = v;
            this.reBoundingBox();
            this["_x"] = this.pointsX;
            this["_y"] = this.pointsY;
            var p = this["_parent"];
            if (p && p._repaint === 0) {
                p._repaint = 1;
                p.parentRepaint();
            }
            this.refresh();
        },
        enumerable: false,
        configurable: true
    });
    AnimationRefObjLayer.prototype.reBoundingBox = function () {
        if (this.rType == 3 || this.rType == 4)
            this.currentFramedata.boundingBox = new Rectangle(this.pointsX, this.pointsY, this.pointsW, this.pointsH);
    };
    AnimationRefObjLayer.prototype.refreshHelperSetting = function () {
        this.rotation = this.rType == 0 || this.rType == 2 ? this.rotation : 0;
        this.pivotX = this.pivotY = this.rType == 1 ? this.radius : 0;
        this.pivotType = this.rType == 1 ? 1 : 0;
    };
    AnimationRefObjLayer.prototype.refresh = function () {
        if (!Config.EDIT_MODE)
            return;
        this.refreshHelperSetting();
        this.graphics.clear();
        this.hitArea.hit.clear();
        var points = [];
        switch (this.rType) {
            case 0:
                if (!this.line)
                    this.graphics.drawRect(0, 0, this.width, this.height, this.color);
                else
                    this.graphics.drawLines(0, 0, [0, 0, 0, this.height, this.width, this.height, this.width, 0, 0, 0], this.color, 2);
                this.hitArea.hit.drawRect(0, 0, this.width, this.height, this.color);
                break;
            case 1:
                this.drawEllipse(this.width / 2, this.height / 2, this.width / 2, this.height / 2);
                break;
            case 2:
                points = [0, this.height, this.width, this.height, this.width / 2, 0, 0, this.height];
                if (!this.line)
                    this.graphics.drawPoly(0, 0, points, this.color, this.color, 0);
                else
                    this.graphics.drawLines(0, 0, points, this.color, 2);
                this.hitArea.hit.drawPoly(0, 0, points, this.color, this.color, 0);
                break;
            case 3:
                points = this.rePoints;
                this.graphics.drawLines(0, 0, points, this.color, 2);
                this.hitArea.hit.drawPoly(0, 0, points, this.color, this.color, 0);
                break;
            case 4:
                points = this.rePoints.splice(0, 4);
                this.graphics.drawLines(0, 0, points, this.color, 2);
                var distance = Math.sqrt(Math.pow((points[2] - points[0]), 2) + Math.pow((points[3] - points[1]), 2));
                var range = 5;
                var _points = [
                    points[0] + (points[3] - points[1]) / distance * range,
                    points[1] - (points[2] - points[0]) / distance * range,
                    points[2] + (points[3] - points[1]) / distance * range,
                    points[3] - (points[2] - points[0]) / distance * range,
                    points[2] - (points[3] - points[1]) / distance * range,
                    points[3] + (points[2] - points[0]) / distance * range,
                    points[0] - (points[3] - points[1]) / distance * range,
                    points[1] + (points[2] - points[0]) / distance * range,
                ];
                this.hitArea.hit.drawPoly(0, 0, _points, this.color, this.color, 0);
                break;
            case 5:
                this.drawEllipse(this.width / 2, this.height / 2, this.width / 2, this.height / 2);
                break;
        }
    };
    AnimationRefObjLayer.prototype.drawEllipse = function (x, y, radiusX, radiusY) {
        var points = [];
        for (var i_17 = 0; i_17 <= 360; i_17++) {
            var angle = (i_17 * Math.PI) / 180;
            var cx = x + radiusX * Math.cos(angle);
            var cy = y + radiusY * Math.sin(angle);
            points.push(cx);
            points.push(cy);
        }
        if (this.line) {
            this.graphics.drawLines(0, 0, points, this.color, 2);
        }
        else {
            if (radiusX != radiusY)
                this.graphics.drawPoly(0, 0, points, this.color, this.color, 0);
            else
                this.graphics.drawCircle(radiusX, radiusX, radiusX, this.color, this.color, 0);
        }
        this.hitArea.hit.drawPoly(0, 0, points, this.color, this.color, 0);
    };
    AnimationRefObjLayer.prototype.getTypeLabel = function () {
        var label = "";
        if (this.editor.customSystemEnableds.animationHelper0 != 1)
            label += "[#GAME_RECTANGULAR],";
        if (this.editor.customSystemEnableds.animationHelper1 != 1)
            label += "[#GAME_CIRCULAR],";
        if (this.editor.customSystemEnableds.animationHelper2 != 1)
            label += "[#GAME_TRIANGLE],";
        if (this.editor.customSystemEnableds.animationHelper3 != 1)
            label += "[#GAME_POLYGON],";
        if (this.editor.customSystemEnableds.animationHelper4 != 1)
            label += "[#GAME_LINE_SEGMENT],";
        if (this.editor.customSystemEnableds.animationHelper5 != 1)
            label += "[#GAME_OVAL],";
        if (this.editor.customSystemEnableds.animationHelper6 != 1)
            label += "[#GAME_THERE_IS_NO]";
        return label.trim().replace(/^,|,$/g, "");
    };
    AnimationRefObjLayer.prototype.getTypeIndex = function () {
        var rIndex = [];
        if (this.editor.customSystemEnableds.animationHelper0 != 1)
            rIndex.push(0);
        if (this.editor.customSystemEnableds.animationHelper1 != 1)
            rIndex.push(1);
        if (this.editor.customSystemEnableds.animationHelper2 != 1)
            rIndex.push(2);
        if (this.editor.customSystemEnableds.animationHelper3 != 1)
            rIndex.push(3);
        if (this.editor.customSystemEnableds.animationHelper4 != 1)
            rIndex.push(4);
        if (this.editor.customSystemEnableds.animationHelper5 != 1)
            rIndex.push(5);
        if (this.editor.customSystemEnableds.animationHelper6 != 1)
            rIndex.push(-1);
        return rIndex.indexOf(this.rType) != -1 ? rIndex.indexOf(this.rType) : 0;
    };
    AnimationRefObjLayer.prototype.setTypeIndex = function (v) {
        var rIndex = [];
        if (this.editor.customSystemEnableds.animationHelper0 != 1)
            rIndex.push(0);
        if (this.editor.customSystemEnableds.animationHelper1 != 1)
            rIndex.push(1);
        if (this.editor.customSystemEnableds.animationHelper2 != 1)
            rIndex.push(2);
        if (this.editor.customSystemEnableds.animationHelper3 != 1)
            rIndex.push(3);
        if (this.editor.customSystemEnableds.animationHelper4 != 1)
            rIndex.push(4);
        if (this.editor.customSystemEnableds.animationHelper5 != 1)
            rIndex.push(5);
        if (this.editor.customSystemEnableds.animationHelper6 != 1)
            rIndex.push(-1);
        this.rType = rIndex[v] == null ? 0 : rIndex[v];
    };
    return AnimationRefObjLayer;
}(AnimationLayer));
AnimationLayer.typeClsMap[AnimationItemType.RefObj] = AnimationRefObjLayer;















var AnimationTargetLayer = (function (_super) {
    __extends(AnimationTargetLayer, _super);
    function AnimationTargetLayer() {
        var _this_1 = _super !== null && _super.apply(this, arguments) || this;
        _this_1.type = AnimationItemType.Target;
        _this_1.showEnable = true;
        return _this_1;
    }
    AnimationTargetLayer.prototype._updateView = function () {
        if (!this.animation)
            return;
        var target = this.animation.target;
        if (!target || target.isDisposed)
            return;
        if (target instanceof GameSprite) {
            target.refreshTargetEffect(false);
        }
    };
    AnimationTargetLayer.prototype._installTargetEffect = function () {
        if (!this.animation)
            return;
        var target = this.animation.target;
        if (!target || target.isDisposed)
            return;
        if (target instanceof GameSprite) {
            target.refreshTargetEffect();
        }
    };
    AnimationTargetLayer.prototype.setData = function (data) {
        _super.prototype.setData.call(this, data);
        if (this.frames[0] && this.frames[0].materialData) {
            this.materialData = ObjectUtils.depthClone(this.frames[0].materialData);
        }
        else if (Config.EDIT_MODE && this.inAniEditor) {
            this.fixFramesMaterialsData();
            this.materialData = [{ materials: [] }];
        }
        if (this.materialData) {
            this.materialsDataExit = true;
            this.installMaterialData(this.materialData);
        }
    };
    AnimationTargetLayer.prototype.showFrame = function (frameIndex) {
        if (!this.animation)
            return;
        if (Config.EDIT_MODE && EUIWindowAnimation.InAniEditor(this.animation)) {
            if (!this.animation.isPlaying) {
                this.showEnable = this.showOnEditor;
            }
            else {
                this.showEnable = this.showOnEditor && ((this.animation.showHitEffect && this.isHitEffect) || (!this.isHitEffect));
            }
        }
        else {
            this.showEnable = (this.animation.showHitEffect && this.isHitEffect) || !this.isHitEffect;
        }
        if (!this.showEnable) {
            this._frameIndex = frameIndex;
            this.refreshTonal();
            return;
        }
        _super.prototype.showFrame.call(this, frameIndex);
    };
    AnimationTargetLayer.prototype.refreshTonal = function () {
        this.x = this.y = this.rotation = this.hue = this.blur = 0;
        this.alpha = this.scaleX = this.scaleY = 1;
        this.setTonal(0, 0, 0, 0, 1, 1, 1);
    };
    AnimationTargetLayer.prototype.fromAnimationFrameData = function (framedata) {
        _super.prototype.fromAnimationFrameData.call(this, framedata);
        if (this.destroyed)
            return;
        if (!framedata)
            return;
        this.x = framedata.x;
        this.y = framedata.y;
        this.rotation = framedata.rotation;
        this.opacity = framedata.alpha;
        if (framedata.scaleX == undefined)
            framedata.scaleX = 1;
        if (framedata.scaleY == undefined)
            framedata.scaleY = 1;
        this.scaleX = framedata.scaleX;
        this.scaleY = framedata.scaleY;
        if (this.materialsDataExit) {
            if (this.checkMaterialsTransChange(framedata)) {
                this.installMaterialData(this.materialData);
                this._installTargetEffect();
            }
            else {
                this.setFrameMaterialsEffect(framedata.materialData);
                this._updateView();
            }
        }
        else if (!Config.EDIT_MODE || !this.inAniEditor || Config.BEHAVIOR_EDIT_MODE) {
            this.hue = framedata.hue;
            this.blur = framedata.blur;
            this.setTonal(framedata.tonal_r, framedata.tonal_g, framedata.tonal_b, framedata.tonal_gray, framedata.tonal_mr, framedata.tonal_mg, framedata.tonal_mb);
            this._updateView();
        }
    };
    AnimationTargetLayer.prototype.toAnimationFrameData = function (framedata) {
        framedata = _super.prototype.toAnimationFrameData.call(this, framedata);
        if (this.showEnable) {
            framedata.x = this.x;
            framedata.y = this.y;
            framedata.rotation = this.rotation;
            framedata.alpha = this.opacity;
            framedata.scaleX = this.scaleX;
            framedata.scaleY = this.scaleY;
        }
        return framedata;
    };
    AnimationTargetLayer.prototype.interpolationFrame = function (pf, nf, frameIndex) {
        var frame = _super.prototype.interpolationFrame.call(this, pf, nf, frameIndex);
        if (pf.scaleX == undefined)
            pf.scaleX = 1;
        if (pf.scaleY == undefined)
            pf.scaleY = 1;
        frame.horizontalReversal = pf.horizontalReversal;
        var t = (frameIndex - pf.index) / (nf.index - pf.index);
        if (this.materialsDataExit) {
            var value = GameUtils.getValueByTransData(nf.trans, t);
            frame.x = (nf.x - pf.x) * value + pf.x;
            frame.y = (nf.y - pf.y) * value + pf.y;
            frame.rotation = (nf.rotation - pf.rotation) * value + pf.rotation;
            frame.alpha = (nf.alpha - pf.alpha) * value + pf.alpha;
            frame.scaleX = (nf.scaleX - pf.scaleX) * value + pf.scaleX;
            frame.scaleY = (nf.scaleY - pf.scaleY) * value + pf.scaleY;
            if (pf.materialData && nf.materialData) {
                this.refreshInterpolationFrameMaterials(frame, pf, nf, t);
            }
        }
        else {
            var tween = GameUtils.getTween(nf.tweenID)[0];
            frame.tweenID = nf.tweenID;
            frame.x = tween(t, pf.x, nf.x - pf.x, 1);
            frame.y = tween(t, pf.y, nf.y - pf.y, 1);
            frame.rotation = tween(t, pf.rotation, nf.rotation - pf.rotation, 1);
            frame.alpha = tween(t, pf.alpha, nf.alpha - pf.alpha, 1);
            frame.scaleX = tween(t, pf.scaleX, nf.scaleX - pf.scaleX, 1);
            frame.scaleY = tween(t, pf.scaleY, nf.scaleY - pf.scaleY, 1);
            this.refreshInterpolationFrameTonal(frame, pf, nf, t, tween);
        }
        return frame;
    };
    return AnimationTargetLayer;
}(AnimationLayer));
AnimationLayer.typeClsMap[AnimationItemType.Target] = AnimationTargetLayer;















var UIComponent;
(function (UIComponent) {
    var UIBase = (function (_super) {
        __extends(UIBase, _super);
        function UIBase() {
            var _this_1 = _super.call(this) || this;
            _this_1.condition = [];
            _this_1.hasCommand = [];
            _this_1.isOpen = true;
            _this_1.materialData = [{ materials: [] }];
            _this_1._needLoad = true;
            _this_1.modifyWidthHeightEnabled = true;
            _this_1.mouseEventEnabledData = true;
            _this_1.lock = false;
            _this_1.id = ObjectUtils.getRandID();
            _this_1.className = "UIBase";
            _this_1.mouseEventEnabled = true;
            if (!Config.EDIT_MODE) {
                _this_1.add_DISPLAY(_this_1.initCondition, _this_1, [true]);
                _this_1.add_UNDISPLAY(_this_1.initCondition, _this_1, [false]);
            }
            return _this_1;
        }
        UIBase.prototype.installDefaultValue = function () {
            if (GameUI.uiCompSetting) {
                var compInfo = GameUI.uiCompSetting[this.className];
                if (!compInfo)
                    return;
                for (var varName in compInfo.defalutValue) {
                    var value = compInfo.defalutValue[varName];
                    this[varName] = value;
                }
            }
        };
        UIBase.prototype.refImageRecord = function (index, imageURL) {
            if (this.___currentRequestLoadImages && this.___currentRequestLoadImages[index]) {
                AssetManager.disposeImage(this.___currentRequestLoadImages[index]);
            }
            if (!this.___currentRequestLoadImages)
                this.___currentRequestLoadImages = [];
            this.___currentRequestLoadImages[index] = imageURL;
        };
        UIBase.prototype.dispose = function () {
            if (!this.isDisposed) {
                var uiArr = this.getAllUIChildren();
                for (var s in uiArr) {
                    var ui = uiArr[s];
                    ui.dispose();
                }
                this.initCondition(false);
            }
            _super.prototype.dispose.call(this);
        };
        UIBase.prototype.constructorInit = function (uiID, syncLoadedEventWhenAssetExist) {
            if (syncLoadedEventWhenAssetExist === void 0) { syncLoadedEventWhenAssetExist = false; }
            this._syncLoadedEventWhenAssetExist = syncLoadedEventWhenAssetExist;
            this._commondID = uiID + "_" + this.id;
            if (!Config.EDIT_MODE) {
                if (this.guiRoot && !this.guiRoot.onlyForPreload) {
                    EventUtils.happen(UIBase, UIBase.EVENT_COMPONENT_CONSTRUCTOR_INIT, [this]);
                }
            }
            this.installMaterialData(this.materialData);
        };
        UIBase.prototype.loadAssetTest = function () {
        };
        UIBase.prototype.initCondition = function (isListen) {
            if (!Game.player) {
                return;
            }
            if (this.condition.length != 0) {
                if (!this.onConditionCheckCB)
                    this.onConditionCheckCB = new Callback(this.onConditionCheck, this);
                for (var i = 0; i < this.condition.length; i++) {
                    var condition = this.condition[i];
                    if (condition.type <= 1) {
                        var type = condition.type == 0 ? 1 : 0;
                        if (isListen) {
                            Game.player.addListenerPlayerVariable(type, condition.varID, this.onConditionCheckCB);
                        }
                        else
                            Game.player.removeListenerPlayerVariable(type, condition.varID, this.onConditionCheckCB);
                    }
                    else if (condition.type == 3) {
                        if (isListen) {
                            ClientWorld.addListenerVariable(0, condition.varID, this.onConditionCheckCB);
                        }
                        else
                            ClientWorld.removeListenerVariable(0, condition.varID, this.onConditionCheckCB);
                    }
                    else if (condition.type == 4) {
                        if (isListen) {
                            ClientWorld.addListenerVariable(1, condition.varID, this.onConditionCheckCB);
                        }
                        else
                            ClientWorld.removeListenerVariable(1, condition.varID, this.onConditionCheckCB);
                    }
                }
                if (isListen && this.firstConditionCheckCount == null) {
                    this.firstConditionCheckCount = this.condition.length;
                }
                this.onConditionCheck();
            }
        };
        UIBase.prototype.onConditionCheck = function () {
            if (!Game.player)
                return;
            var lastVisible = this.visible;
            var visible = true;
            for (var i = 0; i < this.condition.length; i++) {
                var condition = this.condition[i];
                var bool = true;
                if (typeof SinglePlayerGame == "undefined" && condition.type >= 3)
                    continue;
                if (condition.type == 0) {
                    bool = Game.player.variable.getSwitch(condition.varID) == condition.value;
                }
                else if (condition.type == 4) {
                    bool = ClientWorld.getWorldSwitch(condition.varID) == condition.value;
                }
                else {
                    var varValue = condition.type == 1 ? Game.player.variable.getVariable(condition.varID) : ClientWorld.getWorldVariable(condition.varID);
                    if ((condition.compare == 0 && varValue !== condition.value) ||
                        (condition.compare == 1 && varValue < condition.value) ||
                        (condition.compare == 2 && varValue <= condition.value) ||
                        (condition.compare == 3 && varValue > condition.value) ||
                        (condition.compare == 4 && varValue >= condition.value) ||
                        (condition.compare == 5 && varValue === condition.value)) {
                        bool = false;
                    }
                }
                if (!bool) {
                    visible = false;
                    break;
                }
            }
            if (this.firstConditionCheckCount > 0) {
                this.firstConditionCheckCount--;
            }
            if (this.firstConditionCheckCount == 0 || Config.SINGLE_PLAYER_CORE) {
                this.visible = visible;
            }
        };
        UIBase.prototype.inEditorInit = function () {
        };
        UIBase.prototype.inEditorInfo = function () {
            return "";
        };
        UIBase.prototype.inEditorCurrentOperactionLayer = function (isInCurrentLayer) {
            this._isInCurrentLayer = isInCurrentLayer;
        };
        UIBase.prototype.inEditorDatabase = function () {
        };
        UIBase.prototype.getAllUIChildren = function () {
            var allChildren = this["_childs"];
            var uiArr = [];
            for (var i = 0; i < allChildren.length; i++) {
                var ui = allChildren[i];
                if (ui instanceof UIComponent.UIBase && ui["_needLoad"]) {
                    uiArr.push(ui);
                }
            }
            return uiArr;
        };
        UIBase.EVENT_COMPONENT_CONSTRUCTOR_INIT = "UIBase_EVENT_COMPONENT_CONSTRUCTOR_INIT";
        UIBase.ON_VISIBLE_CHANGE = "UIBaseVisible";
        UIBase.BASE_ATTRS = ["x", "y", "width", "height", "rotation", "show", "opacity", "mouseEventEnabledData", "blend"];
        UIBase.BASE_ATTRS_OBJ = { x: true, y: true, width: true, height: true, rotation: true, show: true, opacity: true, mouseEventEnabledData: true, blend: true };
        UIBase.systemReservationWords = ["id", "name", "guiRoot", "onConditionCheckCB", "firstConditionCheckCount", "_isInCurrentLayer", "_syncLoadedEventWhenAssetExist", "data", "_commondID", "__forceChange",
            "isDisposed", "_tonalFilter", "_lastGameFilters", "_finalFilters", "_tips", "tips", "mouseThrough", "autoSize", "viewport", "cacheAs", "cacheAsBitmap", "graphics", "scrollRect", "mask", "parent",
            "texture", "x", "y", "_x", "_y", "left", "right", "top", "bottom", "className"];
        return UIBase;
    }(GameSprite));
    UIComponent.UIBase = UIBase;
})(UIComponent || (UIComponent = {}));
getset(false, UIComponent.UIBase.prototype, 'visible', function () {
    return this._style.visible;
}, function (value) {
    if (this._style && this._style.visible !== value) {
        this.getStyle().visible = value;
        this.conchModel && this.conchModel.visible(value);
        this.parentRepaint();
        this.event(UIComponent.UIBase.ON_VISIBLE_CHANGE);
    }
});















(function (UIComponent) {
    var UIBitmap = (function (_super) {
        __extends(UIBitmap, _super);
        function UIBitmap() {
            var _this_1 = _super.call(this) || this;
            _this_1._image = "";
            _this_1._grid9 = "0,0,0,0,0";
            _this_1._defaultSkins = ["asset/image/picture/control/uibitmap.png", "editorAsset/img/ui_pic.png", "editorAsset/img/ui_string.png"];
            _this_1._flip = false;
            _this_1._pivotType = 0;
            _this_1._isTile = false;
            _this_1._defaultStateImage = true;
            _this_1._uiImage = new UIImage();
            _this_1.addChild(_this_1._uiImage);
            _this_1.className = "UIBitmap";
            _this_1.on(EventObject.RESIZE, _this_1, _this_1.onResize);
            if (!Config.EDIT_MODE) {
                _this_1.add_DISPLAY(_this_1.onAdded, _this_1);
                _this_1.add_UNDISPLAY(_this_1.onRemoved, _this_1);
            }
            else {
                EventUtils.addEventListenerFunction(EnginePlug, EnginePlug.EVENT_TEXTURE_UPDATE, _this_1.onTextureUpdate, _this_1);
            }
            return _this_1;
        }
        UIBitmap.prototype.loadAssetTest = function () {
            var _this_1 = this;
            var varID = GameUtils.getVarID(this.image);
            if (varID != 0) {
                if (typeof SinglePlayerGame == "undefined" && (!ClientMain.conn || !ClientMain.conn.isConnect)) {
                    this.event(GameUI.EVENT_TEST_LOAD_CHILD_UI);
                    return;
                }
                var cb;
                Game.player.addListenerPlayerVariable(2, varID, cb = Callback.New(function (typeID, varID, value) {
                    doLoadAssetTest.apply(_this_1, [value]);
                    setTimeout(function () {
                        Game.player.removeListenerPlayerVariable(2, varID, cb);
                    }, 5000);
                }, this), true);
                return;
            }
            function doLoadAssetTest(imageURL) {
                AssetManager.loadImage(imageURL, Callback.New(function () {
                    this.event(GameUI.EVENT_TEST_LOAD_CHILD_UI);
                }, this), this._syncLoadedEventWhenAssetExist, false);
            }
            doLoadAssetTest.apply(this, [this.image]);
        };
        UIBitmap.prototype.dispose = function () {
            if (!this.isDisposed) {
                if (Config.EDIT_MODE) {
                    EventUtils.removeEventListenerFunction(EnginePlug, EnginePlug.EVENT_TEXTURE_UPDATE, this.onTextureUpdate, this);
                }
                var varID = GameUtils.getVarID(this.image);
                if (varID != 0 && this._onVarChange) {
                    Game.player.removeListenerPlayerVariable(2, varID, this._onVarChange);
                }
                if (this.___currentRequestLoadImages)
                    AssetManager.disposeImages(this.___currentRequestLoadImages);
                if (this._texture) {
                    this._texture.offAll();
                    this._texture = null;
                }
                this._uiImage.removeSelf();
                this._uiImage.offAll();
                this._uiImage.destroy(true);
                this._uiImage = null;
            }
            _super.prototype.dispose.call(this);
        };
        UIBitmap.prototype.onTextureUpdate = function (url, tex, newTex) {
            if (this.stage && !this._imageByTexture && url == this._image) {
                this._uiImage.skin = this._image + "?r=" + Math.random();
            }
        };
        UIBitmap.prototype.inEditorInit = function () {
            this.width = 100;
            this.height = 100;
            this.image = this._defaultSkins[0];
            this._grid9 = "0,0,0,0,0";
            this._emptyImage = true;
            this.installDefaultValue();
        };
        Object.defineProperty(UIBitmap.prototype, "_source", {
            get: function () {
                var varID = GameUtils.getVarID(this.image);
                if (varID != 0)
                    return null;
                return AssetManager.getImage(this.image);
            },
            enumerable: false,
            configurable: true
        });
        UIBitmap.prototype.onResize = function () {
            if (this.isDisposed)
                return;
            if (this._imageByTexture) {
                this._uiImage.graphics.clear();
                this._uiImage.graphics.drawTexture(this.texture, 0, 0, this.width, this.height);
            }
            else {
                this.onImageChange(this._image, this.__imageURLAutoID);
            }
            this.refreshFlip();
        };
        UIBitmap.prototype.inEditorInfo = function () {
            var varID = GameUtils.getVarID(this.image);
            if (this._source) {
                return "[#GAME_ORIGINAL_SIZE]" + this._source.width + "," + this._source.height + " " + this.mouseEnabled;
            }
            return varID != 0 ? "[#GAME_STRING_VARIABLE][" + MathUtils.fixIntDigit(varID.toString()) + "-" + GameListData.getName(Game.data.playerStringNameList, varID) + "]" : "";
        };
        Object.defineProperty(UIBitmap.prototype, "defaultStateImage", {
            get: function () {
                return this._defaultStateImage;
            },
            set: function (v) {
                this._defaultStateImage = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIBitmap.prototype, "image", {
            get: function () {
                return this._image;
            },
            set: function (v) {
                var _this_1 = this;
                if (this.isDisposed)
                    return;
                this.__imageURLAutoID = ObjectUtils.getInstanceID();
                var lastImage = this.image;
                this._texture = null;
                this._imageByTexture = false;
                if (!Config.EDIT_MODE) {
                    var lastVarID = GameUtils.getVarID(this._image);
                    if (lastVarID != 0 && this._onVarChange)
                        Game.player.removeListenerPlayerVariable(2, lastVarID, this._onVarChange);
                }
                if (this._image != v) {
                    this._uiImage.skin = null;
                }
                this._image = v;
                var varID = GameUtils.getVarID(this._image);
                if (!Config.EDIT_MODE) {
                    if (this.displayedInStage && varID != 0) {
                        this._onVarChange = Callback.New(function (__imageURLAutoID, typeID, varID, value) {
                            _this_1.onImageChange(value, __imageURLAutoID);
                        }, this, [this.__imageURLAutoID]);
                        Game.player.addListenerPlayerVariable(2, varID, this._onVarChange);
                    }
                }
                if (varID == 0 || Config.EDIT_MODE)
                    this.onImageChange(v, this.__imageURLAutoID);
                if (lastImage != v && !this.__forceChange)
                    this.event(EventObject.CHANGE);
            },
            enumerable: false,
            configurable: true
        });
        UIBitmap.prototype.setImageForce = function (v) {
            this.__forceChange = true;
            this.image = v;
            this.__forceChange = false;
        };
        Object.defineProperty(UIBitmap.prototype, "pivotType", {
            get: function () {
                return this._pivotType;
            },
            set: function (v) {
                this._pivotType = v;
                this.refreshPivotType();
            },
            enumerable: false,
            configurable: true
        });
        UIBitmap.prototype.refreshPivotType = function () {
            if (this.pivotType == 1) {
                this.pivotX = this.width * 0.5;
                this.pivotY = this.height * 0.5;
            }
            else {
                this.pivotX = 0;
                this.pivotY = 0;
            }
        };
        Object.defineProperty(UIBitmap.prototype, "grid9Width", {
            get: function () {
                return this._uiImage.width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIBitmap.prototype, "grid9Height", {
            get: function () {
                return this._uiImage.height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIBitmap.prototype, "grid9Skin", {
            get: function () {
                return this._image;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIBitmap.prototype, "grid9", {
            get: function () {
                return this._grid9;
            },
            set: function (v) {
                if (!v || v == "")
                    v = "0,0,0,0,0";
                this._grid9 = this._uiImage.sizeGrid = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIBitmap.prototype, "texture", {
            get: function () {
                return this._texture;
            },
            set: function (v) {
                this.__imageURLAutoID = ObjectUtils.getInstanceID();
                this._texture = v;
                this._uiImage.graphics.clear();
                if (this.isTile) {
                    this._uiImage.graphics.fillTexture(v, 0, 0, this.width, this.height);
                }
                else {
                    this._uiImage.graphics.drawTexture(v, 0, 0, this.width, this.height);
                }
                this._imageByTexture = true;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIBitmap.prototype, "flip", {
            get: function () {
                return this._flip;
            },
            set: function (v) {
                this._flip = v;
                this.refreshFlip();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIBitmap.prototype, "isTile", {
            get: function () {
                return this._isTile;
            },
            set: function (v) {
                this._isTile = v;
                this.refreshTileMode();
            },
            enumerable: false,
            configurable: true
        });
        UIBitmap.prototype.onAdded = function (e) {
            var _this_1 = this;
            if (this.isDisposed)
                return;
            var varID = GameUtils.getVarID(this.image);
            if (varID != 0) {
                this._onVarChange = Callback.New(function (__imageURLAutoID, typeID, varID, value) {
                    _this_1.onImageChange(value, __imageURLAutoID);
                }, this, [this.__imageURLAutoID]);
                Game.player.addListenerPlayerVariable(2, varID, this._onVarChange);
            }
        };
        UIBitmap.prototype.onRemoved = function (e) {
            var varID = GameUtils.getVarID(this.image);
            if (varID != 0 && this._onVarChange) {
                Game.player.removeListenerPlayerVariable(2, varID, this._onVarChange);
            }
        };
        UIBitmap.prototype.onImageChange = function (v, imageURLAutoID, force) {
            var _this_1 = this;
            if (imageURLAutoID === void 0) { imageURLAutoID = null; }
            if (force === void 0) { force = false; }
            if (this instanceof UIComponent.UIVideo)
                return;
            if (this.isDisposed || this._imageByTexture || (imageURLAutoID != this.__imageURLAutoID))
                return;
            var varID = GameUtils.getVarID(v);
            this._uiImage.width = this.width;
            this._uiImage.height = this.height;
            if (Config.EDIT_MODE) {
                if (varID != 0) {
                    v = this._defaultSkins[2];
                    ;
                }
            }
            else {
                if (varID != 0) {
                    this.refreshPivotType();
                    return;
                }
            }
            if (v != this._uiImage.skin || force) {
                this.refImageRecord(0, v);
                this._uiImage.graphics.clear();
                this._uiImage.skin = !this.isTile ? v : null;
                AssetManager.loadImage(v, Callback.New(function (tex) {
                    if (_this_1.isDisposed || (imageURLAutoID != _this_1.__imageURLAutoID))
                        return;
                    if (_this_1.useDPCoord && (_this_1.width == 0 || _this_1.height == 0)) {
                        _this_1.width = _this_1._uiImage.width = _this_1.dpWidth;
                        _this_1.height = _this_1._uiImage.height = _this_1.dpHeight;
                    }
                    _this_1._texture = tex;
                    var editorFirst = _this_1._defaultSkins.indexOf(v) == -1 && _this_1._emptyImage;
                    if ((editorFirst || ((_this_1.width == 0 || _this_1.height == 0) && _this_1._defaultStateImage)) && tex) {
                        if (_this_1.useDPCoord) {
                            _this_1._dpTextureWidth = tex.width;
                            _this_1._dpTextureHeight = tex.height;
                            _this_1._dpDirty = true;
                            _this_1.dpCoordToRealCoord();
                        }
                        _this_1.width = _this_1._uiImage.width = tex.width;
                        _this_1.height = _this_1._uiImage.height = tex.height;
                        _this_1._defaultStateImage = false;
                        _this_1._emptyImage = false;
                    }
                    if (_this_1.isTile) {
                        _this_1._uiImage.graphics.fillTexture(tex, 0, 0, _this_1.width, _this_1.height);
                    }
                    _this_1.event(EventObject.LOADED);
                }, this), true);
            }
            else {
                this._uiImage.skin = v;
            }
            this.refreshPivotType();
        };
        UIBitmap.prototype.refreshFlip = function () {
            if (this.flip) {
                this._uiImage.scaleX = -1;
                this._uiImage.x = this.width;
            }
            else {
                this._uiImage.scaleX = 1;
                this._uiImage.x = 0;
            }
        };
        UIBitmap.prototype.refreshTileMode = function () {
            this.onImageChange(this._image, this.__imageURLAutoID, true);
        };
        UIBitmap.customCompFunctionNames = ["image", "grid9", "flip", "pivotType", "isTile"];
        return UIBitmap;
    }(UIComponent.UIBase));
    UIComponent.UIBitmap = UIBitmap;
})(UIComponent || (UIComponent = {}));















(function (UIComponent) {
    var UIButton = (function (_super) {
        __extends(UIButton, _super);
        function UIButton() {
            var _this_1 = _super.call(this) || this;
            _this_1._image1 = "";
            _this_1._image2 = "";
            _this_1._image3 = "";
            _this_1._grid9img1 = "0,0,0,0,0";
            _this_1._grid9img2 = "0,0,0,0,0";
            _this_1._grid9img3 = "0,0,0,0,0";
            _this_1._color = "#000000";
            _this_1._smooth = false;
            _this_1._state = 1;
            _this_1._image = new UIImage();
            _this_1.addChild(_this_1._image);
            _this_1._tfBox = new Sprite();
            _this_1._tf = new UIComponent.UIString();
            _this_1._tf.mouseEventEnabled = false;
            _this_1._tfBox.addChild(_this_1._tf);
            _this_1.addChild(_this_1._tfBox);
            _this_1.className = "UIButton";
            _this_1.add_MOUSEOVER(_this_1.onmouseover, _this_1);
            _this_1.add_MOUSEOUT(_this_1.onmouseout, _this_1);
            _this_1.add_MOUSEDOWN(_this_1.onmousedown, _this_1);
            _this_1.add_MOUSEUP(_this_1.onmouseup, _this_1);
            _this_1.on(EventObject.RESIZE, _this_1, _this_1.onResize);
            _this_1.color = "#999999";
            _this_1.align = 1;
            _this_1.valign = 1;
            _this_1.fontSize = 16;
            return _this_1;
        }
        Object.defineProperty(UIButton.prototype, "image1", {
            get: function () {
                return this._image1;
            },
            set: function (v) {
                if (this.isDisposed)
                    return;
                this._image1 = v;
                this.refImageRecord(0, v);
                AssetManager.loadImage(v);
                this.onImageChange(v, 1);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "image2", {
            get: function () {
                return this._image2;
            },
            set: function (v) {
                if (this.isDisposed)
                    return;
                this._image2 = v;
                this.refImageRecord(1, v);
                AssetManager.loadImage(v);
                this.onImageChange(v, 2);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "image3", {
            get: function () {
                return this._image3;
            },
            set: function (v) {
                if (this.isDisposed)
                    return;
                this._image3 = v;
                this.refImageRecord(2, v);
                AssetManager.loadImage(v);
                this.onImageChange(v, 3);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "smooth", {
            get: function () {
                return this._smooth;
            },
            set: function (v) {
                this._smooth = v;
                this._tf.smooth = v;
            },
            enumerable: false,
            configurable: true
        });
        UIButton.prototype.inEditorInit = function () {
            this.label = "Button";
            this.width = 216;
            this.height = 54;
            this.image1 = "asset/image/picture/control/btn_normal.png";
            this.image2 = "asset/image/picture/control/btn_over.png";
            this.image3 = "asset/image/picture/control/btn_click.png";
            this.installDefaultValue();
        };
        UIButton.prototype.onImageChange = function (v, index) {
            this.setState(this._state);
        };
        UIButton.prototype.clearMouseEvent = function () {
            this.remove_MOUSEOVER(this.onmouseover, this);
            this.remove_MOUSEOUT(this.onmouseout, this);
            this.remove_MOUSEDOWN(this.onmousedown, this);
            this.remove_MOUSEUP(this.onmouseup, this);
        };
        UIButton.prototype.loadAssetTest = function () {
            var _this_1 = this;
            AssetManager.loadImages([this.image1, this.image2, this.image3], Callback.New(function () {
                _this_1.event(GameUI.EVENT_TEST_LOAD_CHILD_UI);
            }, this), this._syncLoadedEventWhenAssetExist, false);
        };
        UIButton.prototype.dispose = function () {
            if (!this.isDisposed) {
                if (this.___currentRequestLoadImages)
                    AssetManager.disposeImages(this.___currentRequestLoadImages);
                this._tf.dispose();
                this._tf = null;
                this._tfBox.removeSelf();
                this._tfBox = null;
                this._image.removeSelf();
                this._image = null;
            }
            _super.prototype.dispose.call(this);
        };
        Object.defineProperty(UIButton.prototype, "grid9img1Width", {
            get: function () {
                return this.width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "grid9img1Height", {
            get: function () {
                return this.height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "grid9img1Skin", {
            get: function () {
                return this._image1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "grid9img1", {
            get: function () {
                return this._grid9img1;
            },
            set: function (v) {
                if (!v || v == "")
                    v = "0,0,0,0,0";
                this._grid9img1 = v;
                this.refresImage(1);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "grid9img2Width", {
            get: function () {
                return this.width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "grid9img2Height", {
            get: function () {
                return this.height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "grid9img2Skin", {
            get: function () {
                return this._image2;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "grid9img2", {
            get: function () {
                return this._grid9img2;
            },
            set: function (v) {
                if (!v || v == "")
                    v = "0,0,0,0,0";
                this._grid9img2 = v;
                this.refresImage(2);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "grid9img3Width", {
            get: function () {
                return this.width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "grid9img3Height", {
            get: function () {
                return this.height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "grid9img3Skin", {
            get: function () {
                return this._image3;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "grid9img3", {
            get: function () {
                return this._grid9img3;
            },
            set: function (v) {
                if (!v || v == "")
                    v = "0,0,0,0,0";
                this._grid9img3 = v;
                this.refresImage(3);
            },
            enumerable: false,
            configurable: true
        });
        UIButton.prototype.refresImage = function (state) {
            var url = this["image" + this._state];
            if (url != this._image.skin)
                return;
            this._image.sizeGrid = this["grid9img" + this._state];
        };
        Object.defineProperty(UIButton.prototype, "label", {
            get: function () {
                return this._tf.text;
            },
            set: function (v) {
                this._tf.text = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "align", {
            get: function () {
                return this._tf.align;
            },
            set: function (v) {
                this._tf.align = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "valign", {
            get: function () {
                return this._tf.valign;
            },
            set: function (v) {
                this._tf.valign = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "bold", {
            get: function () {
                return this._tf.bold;
            },
            set: function (v) {
                this._tf.bold = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "italic", {
            get: function () {
                return this._tf.italic;
            },
            set: function (v) {
                this._tf.italic = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "font", {
            get: function () {
                return this._tf.font;
            },
            set: function (v) {
                this._tf.font = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (v) {
                this._color = v;
                this.setFontColorState(this._state);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "overColor", {
            get: function () {
                return this._overColor ? this._overColor : this._color;
            },
            set: function (v) {
                this._overColor = v;
                this.setFontColorState(this._state);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "clickColor", {
            get: function () {
                return this._clickColor ? this._clickColor : this._color;
            },
            set: function (v) {
                this._clickColor = v;
                this.setFontColorState(this._state);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "fontSize", {
            get: function () {
                return this._tf.fontSize;
            },
            set: function (v) {
                this._tf.fontSize = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "letterSpacing", {
            get: function () {
                return this._tf.letterSpacing;
            },
            set: function (v) {
                this._tf.letterSpacing = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "textDx", {
            get: function () {
                return this._tf.x;
            },
            set: function (v) {
                this._tf.x = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "textDy", {
            get: function () {
                return this._tf.y;
            },
            set: function (v) {
                this._tf.y = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "textStroke", {
            get: function () {
                return this._tf.stroke;
            },
            set: function (v) {
                this._tf.stroke = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "textStrokeColor", {
            get: function () {
                return this._tf.strokeColor;
            },
            set: function (v) {
                this._tf.strokeColor = v;
            },
            enumerable: false,
            configurable: true
        });
        UIButton.prototype.onmouseover = function (e) {
            if (e.target == this)
                this.setState(2);
        };
        UIButton.prototype.onmouseout = function (e) {
            if (e.target == this)
                this.setState(1);
        };
        UIButton.prototype.onmousedown = function (e) {
            if (e.target == this)
                this.setState(3);
        };
        UIButton.prototype.onmouseup = function (e) {
            if (e.target == this)
                this.setState(2);
        };
        UIButton.prototype.onResize = function () {
            if (this.isDisposed)
                return;
            this.setState(this._state);
            this._tf.width = this.width;
            this._tf.height = this.height;
        };
        UIButton.prototype.setState = function (state) {
            if (this.isDisposed)
                return;
            this._state = state;
            this.graphics.clear();
            var url = this["image" + this._state];
            if (url) {
                this._image.skin = url;
                this._image.width = this.width;
                this._image.height = this.height;
                this._image.sizeGrid = this["grid9img" + this._state];
            }
            else {
                this._image.skin = null;
            }
            this.setFontColorState(state);
        };
        UIButton.prototype.setFontColorState = function (state) {
            switch (state) {
                case 1:
                    this._tf.color = this._color;
                    break;
                case 2:
                    this._tf.color = this._overColor ? this._overColor : this._color;
                    break;
                case 3:
                    this._tf.color = this._clickColor ? this._clickColor : this._color;
                    break;
            }
        };
        UIButton.customCompFunctionNames = ["label", "image1", "grid9img1", "image2", "grid9img2", "image3", "grid9img3", "fontSize", "color", "overColor",
            "clickColor", "bold", "italic", "smooth", "align", "valign", "letterSpacing", "font", "textDx", "textDy", "textStroke", "textStrokeColor"];
        return UIButton;
    }(UIComponent.UIBase));
    UIComponent.UIButton = UIButton;
})(UIComponent || (UIComponent = {}));















(function (UIComponent) {
    var UICheckBox = (function (_super) {
        __extends(UICheckBox, _super);
        function UICheckBox() {
            var _this_1 = _super.call(this) || this;
            _this_1._grid9img1 = "0,0,0,0,0";
            _this_1._grid9img2 = "0,0,0,0,0";
            _this_1._image = new UIImage();
            _this_1.addChild(_this_1._image);
            _this_1.className = "UICheckBox";
            _this_1._selected = false;
            _this_1.on(EventObject.RESIZE, _this_1, _this_1.refresh);
            if (!Config.EDIT_MODE) {
                _this_1.add_CLICK(function () {
                    this.selected = !this.selected;
                }, _this_1);
            }
            else {
                EventUtils.addEventListenerFunction(EnginePlug, EnginePlug.EVENT_TEXTURE_UPDATE, _this_1.onTextureUpdate, _this_1);
            }
            return _this_1;
        }
        UICheckBox.prototype.inEditorInit = function () {
            this.width = 14;
            this.height = 14;
            this.image1 = "asset/image/picture/control/check_unselected.png";
            this.image2 = "asset/image/picture/control/check_selected.png";
            this.installDefaultValue();
        };
        UICheckBox.prototype.loadAssetTest = function () {
            AssetManager.loadImages([this.image1, this.image2], Callback.New(function () {
                this.event(GameUI.EVENT_TEST_LOAD_CHILD_UI);
            }, this), this._syncLoadedEventWhenAssetExist, false);
        };
        UICheckBox.prototype.dispose = function () {
            if (!this.isDisposed) {
                if (Config.EDIT_MODE) {
                    EventUtils.removeEventListenerFunction(EnginePlug, EnginePlug.EVENT_TEXTURE_UPDATE, this.onTextureUpdate, this);
                }
                if (this.___currentRequestLoadImages)
                    AssetManager.disposeImages(this.___currentRequestLoadImages);
                this._image.removeSelf();
                this._image.offAll();
                this._image = null;
            }
            _super.prototype.dispose.call(this);
        };
        UICheckBox.prototype.onTextureUpdate = function (url, tex, newTex) {
            if (this.stage && (url == this._image1) || (url == this._image2)) {
                this.refresh();
            }
        };
        Object.defineProperty(UICheckBox.prototype, "image1", {
            get: function () {
                return this._image1;
            },
            set: function (v) {
                this._image1 = v;
                this.refImageRecord(0, v);
                AssetManager.loadImage(v);
                this.refresh();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UICheckBox.prototype, "image2", {
            get: function () {
                return this._image2;
            },
            set: function (v) {
                this._image2 = v;
                this.refImageRecord(1, v);
                AssetManager.loadImage(v);
                ;
                this.refresh();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UICheckBox.prototype, "selected", {
            get: function () {
                return this._selected;
            },
            set: function (v) {
                if (v != this._selected) {
                    this._selected = v;
                    this.refresh();
                    if (!this.__forceChange) {
                        this.event(EventObject.CHANGE);
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        UICheckBox.prototype.setSelectedForce = function (v) {
            this.__forceChange = true;
            this.selected = v;
            this.__forceChange = false;
        };
        Object.defineProperty(UICheckBox.prototype, "grid9img1Width", {
            get: function () {
                return this._image.width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UICheckBox.prototype, "grid9img1Height", {
            get: function () {
                return this._image.height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UICheckBox.prototype, "grid9img1Skin", {
            get: function () {
                return this._image1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UICheckBox.prototype, "grid9img1", {
            get: function () {
                return this._grid9img1;
            },
            set: function (v) {
                if (!v || v == "")
                    v = "0,0,0,0,0";
                this._grid9img1 = v;
                this.refresh();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UICheckBox.prototype, "grid9img2Width", {
            get: function () {
                return this._image.width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UICheckBox.prototype, "grid9img2Height", {
            get: function () {
                return this._image.height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UICheckBox.prototype, "grid9img2Skin", {
            get: function () {
                return this._image2;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UICheckBox.prototype, "grid9img2", {
            get: function () {
                return this._grid9img2;
            },
            set: function (v) {
                if (!v || v == "")
                    v = "0,0,0,0,0";
                this._grid9img2 = v;
                this.refresh();
            },
            enumerable: false,
            configurable: true
        });
        UICheckBox.prototype.refresh = function () {
            var _this_1 = this;
            if (this.isDisposed)
                return;
            this.graphics.clear();
            var url = this._selected ? this.image2 : this.image1;
            var gridText = this._selected ? this._grid9img2 : this._grid9img1;
            if (url) {
                AssetManager.loadImage(url, Callback.New(function (url, tex) {
                    if (_this_1.isDisposed)
                        return;
                    var thisUrl = _this_1._selected ? _this_1.image2 : _this_1.image1;
                    if (thisUrl != url)
                        return;
                    _this_1._image.skin = url;
                    _this_1._image.width = _this_1.width;
                    _this_1._image.height = _this_1.height;
                    _this_1._image.sizeGrid = gridText;
                }, this, [url]), true, false);
            }
        };
        Object.defineProperty(UICheckBox.prototype, "onChangeFragEvent", {
            get: function () {
                return this._onChangeFragEvent;
            },
            set: function (v) {
                this._onChangeFragEvent = v;
                if (v) {
                    this.off(EventObject.CHANGE, this, this.onChange_private);
                    this.on(EventObject.CHANGE, this, this.onChange_private);
                }
                else {
                    this.off(EventObject.CHANGE, this, this.onChange_private);
                }
            },
            enumerable: false,
            configurable: true
        });
        UICheckBox.prototype.onChange_private = function () {
            if (Config.SINGLE_PLAYER_CORE) {
                if (this._onChangeFragEvent && this.guiRoot && !this.guiRoot.onlyForPreload) {
                    CommandPage.startTriggerFragmentEvent(this._onChangeFragEvent, Game.player.sceneObject, Game.player.sceneObject);
                }
            }
        };
        UICheckBox.customCompFunctionNames = ["selected", "image1", "grid9img1", "image2", "grid9img2", "onChangeFragEvent"];
        return UICheckBox;
    }(UIComponent.UIBase));
    UIComponent.UICheckBox = UICheckBox;
})(UIComponent || (UIComponent = {}));















(function (UIComponent) {
    var UIComboBox = (function (_super) {
        __extends(UIComboBox, _super);
        function UIComboBox() {
            var _this_1 = _super.call(this) || this;
            _this_1._displayItemSize = 5;
            _this_1._selectedIndex = 0;
            _this_1._itemAlign = 0;
            _this_1._itemValign = 1;
            _this_1._itemBold = false;
            _this_1._itemItalic = false;
            _this_1._itemFont = "";
            _this_1._itemOverColor = "#FFFFFF";
            _this_1._itemOverBgColor = "#000000";
            _this_1._itemFontSize = 12;
            _this_1._itemLetterSpacing = 0;
            _this_1._itemTextDx = 2;
            _this_1._itemTextDy = 0;
            _this_1._itemTextStroke = 0;
            _this_1._itemTextStrokeColor = "#000000";
            _this_1._listScrollBg = "asset/image/picture/control/uicomboboxbg.png";
            _this_1._listScrollBar = "asset/image/picture/control/uicomboboxslider.png";
            _this_1._isOpen = false;
            _this_1._smooth = false;
            _this_1._root = new Sprite();
            _this_1.addChild(_this_1._root);
            _this_1.className = "UIComboBox";
            _this_1._bgImg = new UIComponent.UIBitmap();
            _this_1._tf = new UIComponent.UIString();
            _this_1._root.addChild(_this_1._bgImg);
            _this_1._root.addChild(_this_1._tf);
            _this_1._tf.valign = 1;
            _this_1._tf.align = 1;
            if (!Config.EDIT_MODE) {
                _this_1.on(EventObject.MOUSE_DOWN, _this_1, _this_1.onMouseDown);
                _this_1._list = new UIComponent.UIList();
                _this_1._list.alpha = _this_1._listAlpha;
                _this_1._list.spaceY = 0;
                _this_1._list.overImageOnTop = false;
                _this_1._list.overImageAlpha = 1;
                _this_1._list.onCreateItem = Callback.New(function (ui, data, index) {
                    ui.on(EventObject.MOUSE_DOWN, _this_1, _this_1.closeList, [index]);
                    ui.hitArea = new Rectangle(0, 0, _this_1.width, _this_1.itemHeight);
                    if (_this_1.itemFont)
                        ui.label.font = _this_1.itemFont;
                    ui.label.color = _this_1.itemColor;
                    ui.label.smooth = _this_1.smooth;
                    ui.label.align = _this_1.itemAlign;
                    ui.label.valign = _this_1.itemValign;
                    ui.label.fontSize = _this_1.itemFontSize;
                    ui.label.letterSpacing = _this_1.itemLetterSpacing;
                    ui.label.bold = _this_1.itemBold;
                    ui.label.italic = _this_1.itemItalic;
                    ui.label.x = _this_1.itemTextDx;
                    ui.label.y = _this_1.itemTextDy;
                    ui.label.stroke = _this_1.itemTextStroke;
                    ui.label.strokeColor = _this_1.itemTextStrokeColor;
                    ui.label.height = _this_1.itemHeight;
                    ui.label.width = _this_1.width;
                    ui.on(EventObject.MOUSE_OVER, _this_1, _this_1.onItemOver, [ui]);
                    ui.on(EventObject.MOUSE_OUT, _this_1, _this_1.onItemOut, [ui]);
                }, _this_1);
                _this_1._list.on(EventObject.MOUSE_DOWN, _this_1, function (e) {
                    e.stopPropagation();
                });
                _this_1._list.scrollShowType = 2;
            }
            _this_1.on(EventObject.RESIZE, _this_1, _this_1.onResize);
            _this_1.width = 200;
            _this_1.height = 30;
            _this_1.itemHeight = 20;
            _this_1.listBgColor = "#FFFFFF";
            _this_1.listAlpha = 1;
            _this_1.color = "#FFFFFF";
            _this_1.itemColor = "#000000";
            _this_1.fontSize = 16;
            if (Config.EDIT_MODE) {
                _this_1._tf.text = "[#GAME_TEXT_OPTIONS]";
                _this_1.itemLabels = "[#GAME_CHOICE_1],[#GAME_CHOICE_2],[#GAME_CHOICE_3]";
            }
            return _this_1;
        }
        UIComboBox.prototype.dispose = function () {
            if (!this.isDisposed) {
                os.remove_ENTERFRAME(this.refreshListPosition, this);
                this._bgImg.dispose();
                this._bgImg = null;
                this._tf.dispose();
                this._tf = null;
                if (this._list)
                    this._list.dispose();
                this._list = null;
                this._root.removeSelf();
                this._root.offAll();
                this._root = null;
            }
            _super.prototype.dispose.call(this);
        };
        UIComboBox.prototype.inEditorInit = function () {
            this._bgImg.image = "asset/image/picture/control/uicombobox.png";
            this.installDefaultValue();
        };
        UIComboBox.prototype.loadAssetTest = function () {
            AssetManager.loadImages([this._bgImg.image, this._listScrollBg, this._listScrollBar], Callback.New(function () {
                this.event(GameUI.EVENT_TEST_LOAD_CHILD_UI);
            }, this), this._syncLoadedEventWhenAssetExist, false);
        };
        UIComboBox.prototype.onResize = function (e) {
            if (this.isDisposed)
                return;
            this._bgImg.width = this.width;
            this._bgImg.height = this.height;
            this._tf.width = this.width;
            this._tf.height = this.height;
            if (this._list) {
                this._list.width = this.width;
                this._list.itemWidth = this.width;
                this._list.height = 200;
            }
        };
        Object.defineProperty(UIComboBox.prototype, "bgSkin", {
            get: function () {
                return this._bgImg.image;
            },
            set: function (v) {
                this._bgImg.image = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "align", {
            get: function () {
                return this._tf.align;
            },
            set: function (v) {
                v = Math.floor(v);
                this._tf.align = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "valign", {
            get: function () {
                return this._tf.valign;
            },
            set: function (v) {
                v = Math.floor(v);
                this._tf.valign = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "bold", {
            get: function () {
                return this._tf.bold;
            },
            set: function (v) {
                this._tf.bold = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "italic", {
            get: function () {
                return this._tf.italic;
            },
            set: function (v) {
                this._tf.italic = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "font", {
            get: function () {
                return this._tf.font;
            },
            set: function (v) {
                this._tf.font = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "color", {
            get: function () {
                return this._tf.color;
            },
            set: function (v) {
                this._tf.color = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "fontSize", {
            get: function () {
                return this._tf.fontSize;
            },
            set: function (v) {
                this._tf.fontSize = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "letterSpacing", {
            get: function () {
                return this._tf.letterSpacing;
            },
            set: function (v) {
                this._tf.letterSpacing = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "textDx", {
            get: function () {
                return this._tf.x;
            },
            set: function (v) {
                this._tf.x = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "textDy", {
            get: function () {
                return this._tf.y;
            },
            set: function (v) {
                this._tf.y = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "textStroke", {
            get: function () {
                return this._tf.stroke;
            },
            set: function (v) {
                this._tf.stroke = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "textStrokeColor", {
            get: function () {
                return this._tf.strokeColor;
            },
            set: function (v) {
                this._tf.strokeColor = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "bgGrid9Width", {
            get: function () {
                return this._bgImg.width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "bgGrid9Height", {
            get: function () {
                return this._bgImg.height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "bgGrid9Skin", {
            get: function () {
                return this._bgImg.image;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "bgGrid9", {
            get: function () {
                var gridText = this._bgImg.grid9;
                if (!gridText || gridText == "")
                    gridText = "0,0,0,0,0";
                return gridText;
            },
            set: function (v) {
                if (!v || v == "")
                    v = "0,0,0,0,0";
                this._bgImg.grid9 = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "smooth", {
            get: function () {
                return this._smooth;
            },
            set: function (v) {
                this._smooth = v;
                this._tf.smooth = v;
            },
            enumerable: false,
            configurable: true
        });
        UIComboBox.prototype.onMouseDown = function (e) {
            var _this_1 = this;
            if (!this._itemLabelArr || this._list.stage)
                return;
            this._overItem = null;
            this._list.itemModelClass = ComboboxListRender;
            var arr = [];
            var itemLabels = this._itemLabelArr;
            for (var i = 0; i < itemLabels.length; i++) {
                var item = new UIListItemData();
                item.label = itemLabels[i];
                arr.push(item);
            }
            this._list.items = arr;
            stage.addChild(this._list);
            this.refreshListPosition();
            this._list.height = this.itemHeight * Math.min(this.displayItemSize, itemLabels.length);
            this._list.graphics.clear();
            this._list.graphics.drawRect(0, 0, this._list.width, this.itemHeight * itemLabels.length, this.listBgColor);
            this._list.overImage.image = "";
            this._list.overImage.graphics.clear();
            this._list.overImage.graphics.drawRect(0, 0, this.width, this.itemHeight, this.itemOverBgColor);
            if (this.selectedIndex >= 0 && this.selectedIndex < itemLabels.length) {
                this._list["_overImageBox"].y = this.selectedIndex * this.itemHeight;
                this._overItem = this._list.getItemUI(this.selectedIndex);
                this._overItem.label.color = this.itemOverColor;
            }
            this._isOpen = true;
            this.event(UIComboBox.OPEN);
            Callback.CallLater(function () {
                stage.once(EventObject.MOUSE_DOWN, _this_1, _this_1.closeList, [null]);
                os.add_ENTERFRAME(_this_1.refreshListPosition, _this_1);
            }, this);
        };
        UIComboBox.prototype.refreshListPosition = function () {
            if (!this._list || !this._list.stage)
                return;
            var p = new Point(0, this.height);
            var gp = this.localToGlobal(p);
            this._list.x = gp.x;
            this._list.y = gp.y;
        };
        UIComboBox.prototype.onItemOver = function (ui) {
            if (this._overItem)
                this._overItem.label.color = this.itemColor;
            this._overItem = ui;
            ui.label.color = this.itemOverColor;
        };
        UIComboBox.prototype.onItemOut = function (ui) {
            if (this._overItem)
                this._overItem.label.color = this.itemColor;
            this._overItem = ui;
            ui.label.color = this.itemColor;
        };
        UIComboBox.prototype.closeList = function (selIndex, e) {
            if (selIndex != null)
                this.selectedIndex = selIndex;
            stage.off(EventObject.MOUSE_DOWN, this, this.closeList);
            os.remove_ENTERFRAME(this.refreshListPosition, this);
            this._list.removeSelf();
            this._isOpen = false;
            this.event(UIComboBox.CLOSE);
        };
        Object.defineProperty(UIComboBox.prototype, "selectedIndex", {
            get: function () {
                return this._selectedIndex;
            },
            set: function (v) {
                this._selectedIndex = v;
                if (Config.EDIT_MODE)
                    return;
                if (v >= 0 && v < this._itemLabelArr.length) {
                    this._tf.text = this._itemLabelArr[v];
                }
                else {
                    this._tf.text = "";
                }
                if (!this.__forceChange)
                    this.event(EventObject.CHANGE);
            },
            enumerable: false,
            configurable: true
        });
        UIComboBox.prototype.setSelectedForce = function (v) {
            this.__forceChange = true;
            this.selectedIndex = v;
            this.__forceChange = false;
        };
        Object.defineProperty(UIComboBox.prototype, "itemLabels", {
            get: function () {
                return this._itemLabels;
            },
            set: function (v) {
                if (v == null)
                    return;
                this._itemLabels = v;
                this._itemLabelArr = v.split(",");
                this.selectedIndex = this.selectedIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "itemHeight", {
            get: function () {
                return this._itemHeight;
            },
            set: function (v) {
                this._itemHeight = v;
                if (this._list)
                    this._list.itemHeight = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "displayItemSize", {
            get: function () {
                return this._displayItemSize;
            },
            set: function (v) {
                this._displayItemSize = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "listScrollBg", {
            get: function () {
                return this._listScrollBg;
            },
            set: function (v) {
                this._listScrollBg = v;
                if (this._list)
                    this._list.vScrollBg = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "listScrollBar", {
            get: function () {
                return this._listScrollBar;
            },
            set: function (v) {
                this._listScrollBar = v;
                if (this._list)
                    this._list.vScrollBar = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "listBgColor", {
            get: function () {
                return this._listBgColor;
            },
            set: function (v) {
                this._listBgColor = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "listAlpha", {
            get: function () {
                return this._listAlpha;
            },
            set: function (v) {
                this._listAlpha = v;
                if (this._list)
                    this._list.alpha = this._listAlpha;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "itemAlign", {
            get: function () {
                return this._itemAlign;
            },
            set: function (v) {
                v = Math.floor(v);
                this._itemAlign = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "itemValign", {
            get: function () {
                return this._itemValign;
            },
            set: function (v) {
                v = Math.floor(v);
                this._itemValign = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "itemBold", {
            get: function () {
                return this._itemBold;
            },
            set: function (v) {
                this._itemBold = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "itemItalic", {
            get: function () {
                return this._itemItalic;
            },
            set: function (v) {
                this._itemItalic = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "itemFont", {
            get: function () {
                return this._itemFont;
            },
            set: function (v) {
                this._itemFont = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "itemColor", {
            get: function () {
                return this._itemColor;
            },
            set: function (v) {
                this._itemColor = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "itemOverColor", {
            get: function () {
                return this._itemOverColor;
            },
            set: function (v) {
                this._itemOverColor = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "itemOverBgColor", {
            get: function () {
                return this._itemOverBgColor;
            },
            set: function (v) {
                this._itemOverBgColor = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "itemFontSize", {
            get: function () {
                return this._itemFontSize;
            },
            set: function (v) {
                this._itemFontSize = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "itemLetterSpacing", {
            get: function () {
                return this._itemLetterSpacing;
            },
            set: function (v) {
                this._itemLetterSpacing = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "itemTextDx", {
            get: function () {
                return this._itemTextDx;
            },
            set: function (v) {
                this._itemTextDx = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "itemTextDy", {
            get: function () {
                return this._itemTextDy;
            },
            set: function (v) {
                this._itemTextDy = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "itemTextStroke", {
            get: function () {
                return this._itemTextStroke;
            },
            set: function (v) {
                this._itemTextStroke = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "itemTextStrokeColor", {
            get: function () {
                return this._itemTextStrokeColor;
            },
            set: function (v) {
                this._itemTextStrokeColor = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "isComboBoxOpen", {
            get: function () {
                return this._isOpen;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIComboBox.prototype, "onChangeFragEvent", {
            get: function () {
                return this._onChangeFragEvent;
            },
            set: function (v) {
                this._onChangeFragEvent = v;
                if (v) {
                    this.off(EventObject.CHANGE, this, this.onChange_private);
                    this.on(EventObject.CHANGE, this, this.onChange_private);
                }
                else {
                    this.off(EventObject.CHANGE, this, this.onChange_private);
                }
            },
            enumerable: false,
            configurable: true
        });
        UIComboBox.prototype.onChange_private = function () {
            if (Config.SINGLE_PLAYER_CORE) {
                if (this._onChangeFragEvent && this.guiRoot && !this.guiRoot.onlyForPreload) {
                    CommandPage.startTriggerFragmentEvent(this._onChangeFragEvent, Game.player.sceneObject, Game.player.sceneObject);
                }
            }
        };
        UIComboBox.OPEN = "UIComboBox_OPEN";
        UIComboBox.CLOSE = "UIComboBox_CLOSE";
        UIComboBox.customCompFunctionNames = ["itemLabels", "selectedIndex", "bgSkin", "bgGrid9", "fontSize", "color", "bold", "italic", "smooth", "align", "valign", "letterSpacing", "font", "textDx", "textStroke", "textStrokeColor", "displayItemSize", "listScrollBg", "listScrollBar", "listAlpha", "listBgColor", "itemHeight", "itemFontSize", "itemColor", "itemBold", "itemItalic", "itemAlign", "itemValign", "itemLetterSpacing", "itemFont", "itemOverColor", "itemOverBgColor", "itemTextDx", "itemTextDy", "itemTextStroke", "itemTextStrokeColor", "onChangeFragEvent", "isComboBoxOpen"];
        return UIComboBox;
    }(UIComponent.UIBase));
    UIComponent.UIComboBox = UIComboBox;
    var ComboboxListRender = (function (_super) {
        __extends(ComboboxListRender, _super);
        function ComboboxListRender() {
            var _this_1 = _super.call(this) || this;
            _this_1.label = new UIComponent.UIString();
            _this_1.label.wordWrap = false;
            _this_1.addChild(_this_1.label);
            return _this_1;
        }
        ComboboxListRender.prototype.dispose = function () {
            if (this.label)
                this.label.dispose();
            this.label = null;
            _super.prototype.destroy.call(this, true);
        };
        return ComboboxListRender;
    }(Sprite));
})(UIComponent || (UIComponent = {}));















(function (UIComponent) {
    var UIGUI = (function (_super) {
        __extends(UIGUI, _super);
        function UIGUI() {
            var _this_1 = _super.call(this) || this;
            _this_1._guiID = 0;
            _this_1._root = new Sprite();
            _this_1._instanceClassName = "";
            _this_1.addChild(_this_1._root);
            _this_1.className = "UIGUI";
            _this_1.modifyWidthHeightEnabled = false;
            _this_1._lastRect = _this_1.getSelfBounds().clone();
            return _this_1;
        }
        UIGUI.prototype.inEditorInit = function () {
            this.clear(0);
            this.installDefaultValue();
        };
        UIGUI.prototype.loadAssetTest = function () {
            if (Config.EDIT_MODE) {
                Callback.New(checkUIRoot, this).delayRun(0);
            }
            else {
                checkUIRoot.call(this);
            }
            function checkUIRoot() {
                if (this._ui) {
                    this._ui.once(EventObject.LOADED, this, this.event, [EventObject.LOADED]);
                    this._ui["loadAssetTest"](true);
                }
                else {
                    this.event(EventObject.LOADED);
                }
            }
        };
        Object.defineProperty(UIGUI.prototype, "guiID", {
            get: function () {
                return this._guiID;
            },
            set: function (v) {
                if (this._guiID != v) {
                    this.loadGUI(v);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIGUI.prototype, "instanceClassName", {
            get: function () {
                return this._instanceClassName;
            },
            set: function (v) {
                this._instanceClassName = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIGUI.prototype, "root", {
            get: function () {
                return this._ui;
            },
            enumerable: false,
            configurable: true
        });
        UIGUI.prototype.loadGUI = function (guiID) {
            var _this_1 = this;
            this._guiID = guiID;
            this.clear(guiID);
            if (guiID == 0)
                return;
            if (Config.EDIT_MODE) {
                Callback.New(function () {
                    if (_this_1.isDeepLoop(_this_1._guiID)) {
                        gcide_canvasbuilder.AlertUtils.alert("[#GAME_LOOP_NESTING_IS_NOT_ALLOWED!]");
                        var p = _this_1.parent;
                        while (p) {
                            if (p instanceof UIGUI) {
                                p.guiID = 0;
                            }
                            if (p instanceof UIComponent.UIList) {
                                p.itemModelGUI = 0;
                            }
                            p = p.parent;
                        }
                        _this_1.loadGUI(0);
                        return;
                    }
                    var uiData = Common.uiList.data[guiID];
                    if (!uiData) {
                        return;
                    }
                    _this_1._ui = GameUI.parse(uiData.uiDisplayData);
                    _this_1._ui.once(EventObject.LOADED, _this_1, function () {
                        _this_1.event(GameUI.EVENT_TEST_LOAD_CHILD_UI);
                    });
                    os.add_ENTERFRAME(_this_1.onEditorCheckLoaded, _this_1);
                    if (_this_1._root)
                        _this_1._root.addChild(_this_1._ui);
                    EUIRoot.dataBaseWindow.win7.off(EUIWindowUI.EVENT_GUI_DATA_SYNC_COMPLETE, _this_1, _this_1.onGUIDataChange);
                    EUIRoot.dataBaseWindow.win7.on(EUIWindowUI.EVENT_GUI_DATA_SYNC_COMPLETE, _this_1, _this_1.onGUIDataChange);
                }, this).delayRun(0);
            }
            else {
                var ui = GameUI.load(guiID, true);
                if (this._root)
                    this._root.addChild(ui);
                this._ui = ui;
                this.event(EventObject.LOADED);
            }
        };
        UIGUI.prototype.onGUIDataChange = function (syncGUIID) {
            if (syncGUIID == this.guiID) {
                EUIRoot.dataBaseWindow.win7.off(EUIWindowUI.EVENT_GUI_DATA_SYNC_COMPLETE, this, this.onGUIDataChange);
                this.loadGUI(this.guiID);
            }
        };
        UIGUI.prototype.isDeepLoop = function (guiID) {
            var p = this.parent;
            while (p) {
                if (p instanceof UIGUI) {
                    if (p.guiID == guiID)
                        return true;
                }
                if (p instanceof UIComponent.UIList) {
                    if (p.itemModelGUI == guiID)
                        return true;
                }
                if (p instanceof UIComponent.UIRoot) {
                    if (p.guiID == guiID)
                        return true;
                }
                p = p.parent;
            }
            return false;
        };
        UIGUI.prototype.clear = function (guiID) {
            this.graphics.clear();
            if (this._root)
                this._root.removeChildren();
            if (!guiID) {
                this._lastRect = new Rectangle;
                this.graphics.drawRect(0, 0, 100, 100, "#000000");
                this.width = 100;
                this.height = 100;
                this.event(EventObject.LOADED);
            }
            else {
                this.width = 0;
                this.height = 0;
            }
        };
        UIGUI.prototype.dispose = function () {
            if (!this.isDisposed) {
                os.remove_ENTERFRAME(this.onEditorCheckLoaded, this);
                if (Config.EDIT_MODE) {
                    EUIRoot.dataBaseWindow.win7.off(EUIWindowUI.EVENT_GUI_DATA_SYNC_COMPLETE, this, this.onGUIDataChange);
                }
                if (this._ui)
                    this._ui.dispose();
                this._ui = null;
                this._root.removeSelf();
                this._root.offAll();
                this._root.destroy(true);
                this._root = null;
            }
            _super.prototype.dispose.call(this);
        };
        UIGUI.prototype.onEditorCheckLoaded = function () {
            if (this.isDisposed)
                return;
            var rect = this.getSelfBounds();
            if (!rect.equals(this._lastRect)) {
                this._lastRect = rect.clone();
                this.hitArea = rect;
                os.remove_ENTERFRAME(this.onEditorCheckLoaded, this);
                this.event(EventObject.LOADED);
            }
        };
        UIGUI.customCompFunctionNames = ["guiID", "instanceClassName"];
        return UIGUI;
    }(UIComponent.UIBase));
    UIComponent.UIGUI = UIGUI;
})(UIComponent || (UIComponent = {}));















(function (UIComponent) {
    var UIRoot = (function (_super) {
        __extends(UIRoot, _super);
        function UIRoot(isRoot, guiID) {
            if (isRoot === void 0) { isRoot = false; }
            if (guiID === void 0) { guiID = null; }
            var _this_1 = _super.call(this) || this;
            _this_1._myScrollRect = new Rectangle(0, 0, 0, 0);
            _this_1._enabledLimitView = false;
            _this_1._scrollShowType = 2;
            _this_1._scrollWidth = 16;
            _this_1._vScroollBarImage1 = "";
            _this_1._vScroollBarImage2 = "";
            _this_1._hScroollBarImage1 = "";
            _this_1._hScroollBarImage2 = "";
            _this_1._slowmotionType = 0;
            _this_1._rollRatio = 0.95;
            _this_1.guiID = guiID;
            _this_1._isRoot = isRoot;
            _this_1.className = "UIRoot";
            _this_1._vScrollBar = new VScrollBar();
            _this_1._hScrollBar = new HScrollBar();
            _this_1._vScrollBar.showButtons = false;
            _this_1._hScrollBar.showButtons = false;
            if (Config.EDIT_MODE) {
                _this_1.width = _this_1._contentWidth = 100;
                _this_1.height = _this_1._contentHeight = 100;
            }
            _this_1._vScrollBar.tick = 0.00001;
            _this_1._hScrollBar.tick = 0.00001;
            _this_1._vScrollBar.max = 100;
            _this_1._vScrollBar.min = 0;
            _this_1._hScrollBar.max = 100;
            _this_1._hScrollBar.min = 0;
            _this_1._vScrollValue = 0;
            _this_1._hScrollValue = 0;
            _this_1._enabledWheel = true;
            _this_1.on(EventObject.MOUSE_WHEEL, _this_1, _this_1.onMouseWheel);
            _this_1.on(EventObject.RESIZE, _this_1, _this_1.onResize);
            _this_1._vScrollBar.add_CHANGE(_this_1.onScrollBarChange, _this_1, [1]);
            _this_1._hScrollBar.add_CHANGE(_this_1.onScrollBarChange, _this_1, [2]);
            _this_1.onResize();
            return _this_1;
        }
        UIRoot.prototype.inEditorInit = function () {
            this._vScroollBarImage1 = "asset/image/picture/control/vscroll_bg.png";
            this._vScroollBarImage2 = "asset/image/picture/control/vscroll_bar.png";
            this._hScroollBarImage1 = "asset/image/picture/control/hscroll_bg.png";
            this._hScroollBarImage2 = "asset/image/picture/control/hscroll_bar.png";
            this.installDefaultValue();
        };
        UIRoot.prototype.inEditorCurrentOperactionLayer = function (isInCurrentLayer) {
            _super.prototype.inEditorCurrentOperactionLayer.call(this, isInCurrentLayer);
            this.enabledLimitView = this.enabledLimitView;
        };
        Object.defineProperty(UIRoot.prototype, "enabledLimitView", {
            get: function () {
                return this._enabledLimitView;
            },
            set: function (v) {
                if (this.destroyed)
                    return;
                this._enabledLimitView = v;
                this.scrollRect = (v && (!Config.EDIT_MODE || (Config.EDIT_MODE && !this._isInCurrentLayer))) ? this._myScrollRect : null;
                if (v) {
                    this.addChild(this._vScrollBar);
                    this.addChild(this._hScrollBar);
                    if (Config.EDIT_MODE) {
                        this._vScrollBar.mouseEnabled = this._hScrollBar.mouseEnabled = false;
                    }
                    else {
                        this._vScrollBar.mouseEnabled = this._hScrollBar.mouseEnabled = true;
                    }
                    this.refresh();
                }
                else {
                    this.removeChild(this._vScrollBar);
                    this.removeChild(this._hScrollBar);
                }
                this.refreshSlowmotion();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIRoot.prototype, "enabledWheel", {
            get: function () {
                return this._enabledWheel;
            },
            set: function (v) {
                this._enabledWheel = v;
                if (this._enabledWheel) {
                    this.on(EventObject.MOUSE_WHEEL, this, this.onMouseWheel);
                }
                else {
                    this.off(EventObject.MOUSE_WHEEL, this, this.onMouseWheel);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIRoot.prototype, "scrollShowType", {
            get: function () {
                return this._scrollShowType;
            },
            set: function (v) {
                v = Math.floor(v);
                this._scrollShowType = v;
                this.refresh();
                if (!this._vScrollBar.visible && this._vScrollValue != 0)
                    this.vScrollValue = 0;
                if (!this._hScrollBar.visible && this._hScrollValue != 0)
                    this.hScrollValue = 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIRoot.prototype, "scrollWidth", {
            get: function () {
                return this._scrollWidth;
            },
            set: function (v) {
                if (this.isDisposed)
                    return;
                this._scrollWidth = v;
                this.vScrollBar = this.vScrollBar;
                this.hScrollBar = this.hScrollBar;
                this.vScrollBg = this.vScrollBg;
                this.hScrollBg = this.hScrollBg;
                this.onResize();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIRoot.prototype, "vScrollBg", {
            get: function () {
                return this._vScroollBarImage1;
            },
            set: function (v) {
                if (this.isDisposed)
                    return;
                this.refImageRecord(0, v);
                AssetManager.loadImage(v);
                this._vScroollBarImage1 = v;
                this._vScrollBar.slider["_bg"].skin = v;
                this._vScrollBar.slider["_bg"].width = this._scrollWidth;
                this._vScrollBar.slider["setBarPoint"]();
                this._vScrollBar.slider["callLater"](this._vScrollBar.slider["changeValue"]);
                this.refreshScrollPos();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIRoot.prototype, "vScrollBar", {
            get: function () {
                return this._vScroollBarImage2;
            },
            set: function (v) {
                if (this.isDisposed)
                    return;
                this.refImageRecord(1, v);
                this._vScroollBarImage2 = v;
                AssetManager.loadImage(v, Callback.New(this.setVScrollBarSkin, this, [v]), true);
            },
            enumerable: false,
            configurable: true
        });
        UIRoot.prototype.setVScrollBarSkin = function (v) {
            if (this.isDisposed)
                return;
            if (!this._vScrollBar.slider)
                return;
            if (v != this._vScroollBarImage2)
                return;
            this._vScrollBar.slider.bar.skin = v;
            this._vScrollBar.slider.bar.width = this._scrollWidth;
            this._vScrollBar.slider["setBarPoint"]();
            this._vScrollBar.slider["callLater"](this._vScrollBar.slider["changeValue"]);
            this.onResize();
        };
        Object.defineProperty(UIRoot.prototype, "hScrollBg", {
            get: function () {
                return this._hScroollBarImage1;
            },
            set: function (v) {
                if (this.isDisposed)
                    return;
                this.refImageRecord(2, v);
                AssetManager.loadImage(v);
                this._hScroollBarImage1 = v;
                this._hScrollBar.slider["_bg"].skin = v;
                this._hScrollBar.slider["_bg"].height = this._scrollWidth;
                this._hScrollBar.slider["setBarPoint"]();
                this._hScrollBar.slider["callLater"](this._hScrollBar.slider["changeValue"]);
                this.refreshScrollPos();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIRoot.prototype, "hScrollBar", {
            get: function () {
                return this._hScroollBarImage2;
            },
            set: function (v) {
                if (this.isDisposed)
                    return;
                this.refImageRecord(3, v);
                this._hScroollBarImage2 = v;
                AssetManager.loadImage(v, Callback.New(this.setHScrollBarSkin, this, [v]), true);
            },
            enumerable: false,
            configurable: true
        });
        UIRoot.prototype.setHScrollBarSkin = function (v) {
            if (this.isDisposed)
                return;
            if (!this._hScrollBar.slider)
                return;
            if (v != this._hScroollBarImage2)
                return;
            this._hScrollBar.slider.bar.skin = v;
            this._hScrollBar.slider.bar.height = this._scrollWidth;
            this._hScrollBar.slider["setBarPoint"]();
            this._hScrollBar.slider["callLater"](this._hScrollBar.slider["changeValue"]);
            this.onResize();
        };
        UIRoot.prototype.calcTotalContentSize = function () {
            var maxH = 0, maxW = 0;
            for (var i = this.numChildren - 1; i > -1; i--) {
                var comp = this.getChildAt(i);
                if (comp == this._vScrollBar || comp == this._hScrollBar)
                    continue;
                var compRect = comp.getBounds();
                if (compRect.isEmpty()) {
                    compRect = new Rectangle(comp.x, comp.y, comp.width ? comp.width : 0, comp.height ? comp.height : 0);
                }
                if (comp.width != 0) {
                    compRect.width = comp.width;
                }
                if (comp.height != 0) {
                    compRect.height = comp.height;
                }
                maxH = Math.max(compRect.bottom, maxH, 1);
                maxW = Math.max(compRect.right, maxW, 1);
            }
            return { maxW: maxW, maxH: maxH };
        };
        UIRoot.prototype.refresh = function () {
            if (this.isDisposed || this.destroyed)
                return;
            if (this._enabledLimitView) {
                var c = this.calcTotalContentSize();
                var maxH = c.maxH, maxW = c.maxW;
                if (this.scrollShowType == 0) {
                    this._vScrollBar.visible = this._hScrollBar.visible = false;
                }
                else if (this.scrollShowType == 1) {
                    this._vScrollBar.visible = this._hScrollBar.visible = true;
                    maxH += this._scrollWidth;
                    maxW += this._scrollWidth;
                }
                else if (this.scrollShowType == 2) {
                    this._vScrollBar.visible = (this.height / maxH) < 1;
                    this._hScrollBar.visible = (this.width / maxW) < 1;
                    if (this._vScrollBar.visible)
                        maxW += this._scrollWidth;
                    if (this._hScrollBar.visible)
                        maxH += this._scrollWidth;
                }
                else if (this.scrollShowType == 3) {
                    this._vScrollBar.visible = true;
                    this._hScrollBar.visible = false;
                    maxW += this._scrollWidth;
                }
                else if (this.scrollShowType == 4) {
                    this._vScrollBar.visible = false;
                    this._hScrollBar.visible = true;
                    maxH += this._scrollWidth;
                }
                this._vScrollBar.thumbPercent = maxH == 0 ? 1 : Math.min(this.height / maxH, 1);
                this._hScrollBar.thumbPercent = maxW == 0 ? 1 : Math.min(this.width / maxW, 1);
                this._hScrollBar.disabled = this.width >= maxW;
                this._vScrollBar.disabled = this.height >= maxH;
                var lastContentW = this._contentWidth;
                var lastContentH = this._contentHeight;
                this._contentWidth = maxW;
                this._contentHeight = maxH;
                if (this._vScrollBar.disabled) {
                    this._vScrollBar.value = 0;
                    this._vScrollValue = 0;
                }
                else {
                    var perV = (lastContentH - this.height) / (this._contentHeight - this.height);
                    this._vScrollBar.value *= perV;
                    this._vScrollValue = this._vScrollBar.value;
                }
                if (this._hScrollBar.disabled) {
                    this._hScrollBar.value = 0;
                    this._hScrollValue = 0;
                }
                else {
                    var perH = (lastContentW - this.width) / (this._contentWidth - this.width);
                    this._hScrollBar.value *= perH;
                    this._hScrollValue = this._hScrollBar.value;
                }
            }
            this._myScrollRect.width = this.width;
            this._myScrollRect.height = this.height;
            this._vScrollBar.height = this.height;
            this._hScrollBar.width = this.width - (this._vScrollBar.displayedInStage && this._vScrollBar.visible ? this._vScrollBar.width : 0);
        };
        UIRoot.prototype.refreshScrollPos = function () {
            this._vScrollBar.x = this.width - this._vScrollBar.width + this._myScrollRect.x;
            this._vScrollBar.y = this._myScrollRect.y;
            this._hScrollBar.y = this.height - this._hScrollBar.height + this._myScrollRect.y;
            this._hScrollBar.x = this._myScrollRect.x;
        };
        UIRoot.prototype.onResize = function () {
            if (this.isDisposed)
                return;
            this.refresh();
            this.refreshScrollPos();
            this.enabledLimitView = this.enabledLimitView;
        };
        UIRoot.prototype.onMouseWheel = function (e) {
            if (this.isDisposed)
                return;
            if (Config.EDIT_MODE || !this._enabledLimitView)
                return;
            if (!this._contentHeight || !this._contentWidth)
                return;
            var float = e.delta < 0 ? -1 : 1;
            var vScrollEnabled = this.scrollShowType != 0 && this.scrollShowType != 4 && !this._vScrollBar.disabled;
            var hScrollEnabled = this.scrollShowType != 0 && this.scrollShowType != 3 && !this._hScrollBar.disabled;
            if (!vScrollEnabled && !hScrollEnabled)
                return;
            if (vScrollEnabled) {
                if (!hScrollEnabled || !ClientMain.shiftKey) {
                    if (this._contentHeight - this.scrollWidth <= this.height)
                        return;
                    var px = Math.min(Math.max(this._contentHeight * 0.01 * Math.abs(e.delta), 10), 50);
                    var per = px * 100 / this._contentHeight;
                    this._vScrollBar.value -= per * float;
                }
            }
            if (hScrollEnabled) {
                if (!vScrollEnabled || ClientMain.shiftKey) {
                    if (this._contentWidth - this.scrollWidth <= this.width)
                        return;
                    var px = Math.min(Math.max(this._contentWidth * 0.01 * Math.abs(e.delta), 10), 50);
                    var per = px * 100 / this._contentWidth;
                    this._hScrollBar.value -= per * float;
                }
            }
        };
        UIRoot.prototype.onScrollBarChange = function (mode) {
            if (!this._vScrollBar.disabled) {
                this._myScrollRect.y = MathUtils.float(this._vScrollBar.value / 100 * (this._contentHeight - this.height));
            }
            else {
                this._myScrollRect.y = 0;
            }
            if (!this._hScrollBar.disabled) {
                this._myScrollRect.x = MathUtils.float(this._hScrollBar.value / 100 * (this._contentWidth - this.width));
            }
            else {
                this._myScrollRect.x = 0;
            }
            this.refreshScrollPos();
            this.event(UIRoot.SCROLL, [mode == 1 ? true : false]);
        };
        Object.defineProperty(UIRoot.prototype, "vScrollValue", {
            get: function () {
                return this._vScrollValue;
            },
            set: function (value) {
                if (!this._enabledLimitView)
                    return;
                if (!this._contentHeight || !this._contentWidth)
                    return;
                var vScrollEnabled = !this._vScrollBar.disabled;
                if (!vScrollEnabled)
                    return;
                this._vScrollValue = Math.min(Math.max(this._vScrollBar.min, value), this._vScrollBar.max);
                this._vScrollBar.value = this._vScrollValue;
                this._vScrollValue = this._vScrollBar.value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIRoot.prototype, "hScrollValue", {
            get: function () {
                return this._hScrollValue;
            },
            set: function (value) {
                if (!this._enabledLimitView)
                    return;
                if (!this._contentHeight || !this._contentWidth)
                    return;
                var hScrollEnabled = !this._hScrollBar.disabled;
                if (!hScrollEnabled)
                    return;
                this._hScrollValue = Math.min(Math.max(this._hScrollBar.min, value), this._hScrollBar.max);
                this._hScrollBar.value = this._hScrollValue;
                this._hScrollValue = this._hScrollBar.value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIRoot.prototype, "slowmotionType", {
            get: function () {
                return this._slowmotionType;
            },
            set: function (v) {
                this._slowmotionType = v;
                this.refreshSlowmotion();
            },
            enumerable: false,
            configurable: true
        });
        UIRoot.prototype.refreshSlowmotion = function () {
            this.off(EventObject.MOUSE_DOWN, this, this.onMouseDown);
            if (this._enabledLimitView && ((this._slowmotionType == 0 && (os.platform == 4 || os.platform == 3)) || this._slowmotionType == 1)) {
                this.on(EventObject.MOUSE_DOWN, this, this.onMouseDown);
            }
        };
        UIRoot.prototype.onMouseDown = function (e) {
            if (Config.EDIT_MODE)
                return;
            stage.on(EventObject.MOUSE_UP, this, this.onStageMouseUp);
            stage.on(EventObject.MOUSE_OUT, this, this.onStageMouseUp);
            if (this.checkMouseDown(e.target)) {
                this.mouseEnabled = false;
                return;
            }
            stage.on(EventObject.MOUSE_MOVE, this, this.onStageMouseMove);
            timer.clear(this, this.tweenMoveX);
            timer.clear(this, this.tweenMoveY);
            this._lastPoint || (this._lastPoint = new Point());
            this._lastPoint.setTo(stage.mouseX, stage.mouseY);
            this._lastPoint2 || (this._lastPoint2 = new Point());
            this._lastPoint2.setTo(stage.mouseX, stage.mouseY);
            this._lastValuePoint || (this._lastValuePoint = new Point());
            this._lastValuePoint.setTo(this._myScrollRect.x, this._myScrollRect.y);
            this._offsetXList || (this._offsetXList = []);
            this._offsetXList.length = 0;
            this._offsetYList || (this._offsetYList = []);
            this._offsetYList.length = 0;
            this._lastOffset || (this._lastOffset = new Point());
        };
        UIRoot.prototype.onStageMouseUp = function () {
            stage.off(EventObject.MOUSE_UP, this, this.onStageMouseUp);
            stage.off(EventObject.MOUSE_OUT, this, this.onStageMouseUp);
            stage.off(EventObject.MOUSE_MOVE, this, this.onStageMouseMove);
            this.mouseEnabled = true;
            if (this.scrollShowType != 3 && !this._hScrollBar.disabled) {
                if (!this._offsetXList) {
                    return;
                }
                if (this._offsetXList.length < 1) {
                    this._offsetXList[0] = stage.mouseX - this._lastPoint2.x;
                }
                var offset = 0;
                var n = Math.min(this._offsetXList.length, 3);
                for (var i = 0; i < n; i++) {
                    offset += this._offsetXList[this._offsetXList.length - 1 - i];
                }
                this._lastPoint.x = offset / n;
                offset = Math.abs(this._lastPoint.x);
                if (offset < 2) {
                    return;
                }
                if (offset > 60)
                    this._lastPoint.x = this._lastPoint.x > 0 ? 60 : -60;
                timer.frameLoop(1, this, this.tweenMoveX);
            }
            if (this.scrollShowType != 4 && !this._vScrollBar.disabled) {
                if (!this._offsetYList) {
                    return;
                }
                if (this._offsetYList.length < 1) {
                    this._offsetYList[0] = stage.mouseY - this._lastPoint2.y;
                }
                var offset = 0;
                var n = Math.min(this._offsetYList.length, 3);
                for (var i = 0; i < n; i++) {
                    offset += this._offsetYList[this._offsetYList.length - 1 - i];
                }
                this._lastPoint.y = offset / n;
                offset = Math.abs(this._lastPoint.y);
                if (offset < 2) {
                    return;
                }
                if (offset > 60)
                    this._lastPoint.y = this._lastPoint.y > 0 ? 60 : -60;
                timer.frameLoop(1, this, this.tweenMoveY);
            }
        };
        UIRoot.prototype.onStageMouseMove = function () {
            var posx = stage.mouseX - this._lastPoint.x;
            var posy = stage.mouseY - this._lastPoint.y;
            if (Math.abs(posx) > 10 || Math.abs(posy) > 10) {
                this.mouseEnabled = false;
            }
            else {
                return;
            }
            this._lastOffset.x = stage.mouseX - this._lastPoint2.x;
            this._lastOffset.y = stage.mouseY - this._lastPoint2.y;
            this._offsetXList.push(this._lastOffset.x);
            this._offsetYList.push(this._lastOffset.y);
            this._lastPoint2.setTo(stage.mouseX, stage.mouseY);
            if (this.scrollShowType != 3 && !this._hScrollBar.disabled) {
                var maxx = MathUtils.float(this._hScrollBar.max / 100 * (this._contentWidth - this.width));
                this._myScrollRect.x = Math.min(Math.max(0, this._lastValuePoint.x - posx), maxx);
            }
            if (this.scrollShowType != 4 && !this._vScrollBar.disabled) {
                var maxy = MathUtils.float(this._vScrollBar.max / 100 * (this._contentHeight - this.height));
                this._myScrollRect.y = Math.min(Math.max(0, this._lastValuePoint.y - posy), maxy);
            }
            this.refreshScrollPos();
            this.refreshSliderPos();
        };
        UIRoot.prototype.refreshSliderPos = function () {
            if (!this._hScrollBar.disabled) {
                var valuex = MathUtils.float(this._myScrollRect.x * 100 / (this._contentWidth - this.width));
                this._hScrollValue = Math.min(Math.max(this._hScrollBar.min, valuex), this._hScrollBar.max);
                if (this._hScrollBar['_value'] != this._hScrollValue) {
                    this._hScrollBar.slider['_value'] = this._hScrollValue;
                    this._hScrollBar.slider['changeValue']();
                    this._hScrollBar['_value'] = this._hScrollValue = this._hScrollBar.slider['_value'];
                    this.event(UIRoot.SCROLL, [false]);
                }
            }
            if (!this._vScrollBar.disabled) {
                var valuey = MathUtils.float(this._myScrollRect.y * 100 / (this._contentHeight - this.height));
                this._vScrollValue = Math.min(Math.max(this._vScrollBar.min, valuey), this._vScrollBar.max);
                if (this._vScrollBar['_value'] != this._vScrollValue) {
                    this._vScrollBar.slider['_value'] = this._vScrollValue;
                    this._vScrollBar.slider['changeValue']();
                    this._vScrollBar['_value'] = this._vScrollValue = this._vScrollBar.slider['_value'];
                    this.event(UIRoot.SCROLL, [true]);
                }
            }
        };
        UIRoot.prototype.checkMouseDown = function (disp) {
            var bool = false;
            if (disp == this._hScrollBar || disp == this._vScrollBar)
                bool = true;
            var parent = disp.parent;
            while (parent && parent != this) {
                if (parent == this._hScrollBar || parent == this._vScrollBar) {
                    bool = true;
                    break;
                }
                parent = parent.parent;
            }
            return bool;
        };
        UIRoot.prototype.tweenMoveX = function () {
            this._lastOffset.x *= this._rollRatio;
            if (this.scrollShowType != 3 && !this._hScrollBar.disabled) {
                var maxx = MathUtils.float(this._hScrollBar.max / 100 * (this._contentWidth - this.width));
                this._myScrollRect.x -= this._lastOffset.x;
                this._myScrollRect.x = Math.min(Math.max(0, this._myScrollRect.x), maxx);
            }
            this.refreshScrollPos();
            this.refreshSliderPos();
            if (Math.abs(this._lastOffset.x) < 1) {
                timer.clear(this, this.tweenMoveX);
            }
        };
        UIRoot.prototype.tweenMoveY = function () {
            this._lastOffset.y *= this._rollRatio;
            if (this.scrollShowType != 4 && !this._vScrollBar.disabled) {
                var maxy = MathUtils.float(this._vScrollBar.max / 100 * (this._contentHeight - this.height));
                this._myScrollRect.y -= this._lastOffset.y;
                this._myScrollRect.y = Math.min(Math.max(0, this._myScrollRect.y), maxy);
            }
            this.refreshScrollPos();
            this.refreshSliderPos();
            if (Math.abs(this._lastOffset.y) < 1) {
                timer.clear(this, this.tweenMoveY);
            }
        };
        UIRoot.prototype.addChild = function (node) {
            var node = _super.prototype.addChild.call(this, node);
            if (this._enabledLimitView && node instanceof UIComponent.UIBase) {
                node.on(EventObject.RESIZE, this, this.onNodeChildResize);
            }
            this.refreshAddchild();
            return node;
        };
        ;
        UIRoot.prototype.addChildren = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            _super.prototype.addChildren.apply(this, args);
            this.refreshAddchild();
        };
        ;
        UIRoot.prototype.addChildAt = function (node, index) {
            var node = _super.prototype.addChildAt.call(this, node, index);
            if (this._enabledLimitView && node instanceof UIComponent.UIBase) {
                node.on(EventObject.RESIZE, this, this.onNodeChildResize);
            }
            this.refreshAddchild();
            return node;
        };
        ;
        UIRoot.prototype.removeChildAt = function (index) {
            var node = _super.prototype.removeChildAt.call(this, index);
            if (this._enabledLimitView && node instanceof UIComponent.UIBase) {
                node.off(EventObject.RESIZE, this, this.onNodeChildResize);
                this.onNodeChildResize();
            }
            return node;
        };
        ;
        UIRoot.prototype.onNodeChildResize = function () {
            Callback.CallLaterBeforeRender(this.refresh, this);
        };
        UIRoot.prototype.refreshAddchild = function () {
            if (this._enabledLimitView) {
                _super.prototype.addChild.call(this, this._vScrollBar);
                _super.prototype.addChild.call(this, this._hScrollBar);
            }
            Callback.CallLaterBeforeRender(this.doRefreshAddchild, this);
        };
        UIRoot.prototype.doRefreshAddchild = function () {
            if (this.isDisposed)
                return;
            this.refresh();
        };
        UIRoot.prototype.constructorInit = function (uiID, syncLoadedEventWhenAssetExist) {
            if (syncLoadedEventWhenAssetExist === void 0) { syncLoadedEventWhenAssetExist = false; }
            _super.prototype.constructorInit.apply(this, arguments);
            this.loadAssetTest();
        };
        UIRoot.prototype.loadAssetTest = function (checkAllChildren) {
            if (checkAllChildren === void 0) { checkAllChildren = false; }
            if (this._isRoot || checkAllChildren) {
                var uiRoots = [];
                function onLoadedCheck(ui) {
                    count--;
                    if (count <= 0) {
                        setTimeout(function (uiRoots) {
                            for (var i in uiRoots) {
                                var ro = uiRoots[i];
                                if (ro.stage) {
                                    ro.refresh();
                                }
                            }
                        }, 0, uiRoots);
                        if (this["prerender"]) {
                            AssetManager.prerender(this);
                        }
                        this.event(EventObject.LOADED);
                    }
                }
                uiRoots.push(this);
                var uiArr = this.getAllUIChildren();
                var count = uiArr.length + 1;
                this.once(GameUI.EVENT_TEST_LOAD_CHILD_UI, this, onLoadedCheck, [this]);
                this.loadSelfAssetTest();
                for (var s in uiArr) {
                    var ui = uiArr[s];
                    ui.once(GameUI.EVENT_TEST_LOAD_CHILD_UI, this, onLoadedCheck, [ui]);
                    if (ui.className == "UIRoot") {
                        ui.loadSelfAssetTest();
                        uiRoots.push(ui);
                    }
                    else {
                        ui["loadAssetTest"]();
                    }
                }
            }
        };
        UIRoot.prototype.loadSelfAssetTest = function () {
            if (this.isDisposed)
                return;
            var mySkins = [this._vScroollBarImage1, this._vScroollBarImage2, this._hScroollBarImage1, this._hScroollBarImage2];
            AssetManager.loadImages(mySkins, Callback.New(function () {
                this.event(GameUI.EVENT_TEST_LOAD_CHILD_UI);
            }, this), this._syncLoadedEventWhenAssetExist, false);
        };
        UIRoot.prototype.disposeSelfAsset = function () {
            if (!this.___currentRequestLoadImages)
                return;
            AssetManager.disposeImages(this.___currentRequestLoadImages);
        };
        UIRoot.prototype.dispose = function () {
            if (!this.isDisposed) {
                if (this.guiID) {
                    var uiRoot = GameUI.get(this.guiID);
                    if (uiRoot == this) {
                        var guiID = this.guiID;
                        this.guiID = null;
                        GameUI.dispose(guiID);
                        return;
                    }
                }
                this.disposeSelfAsset();
                this._vScrollBar.removeSelf();
                this._vScrollBar.offAll();
                this._vScrollBar = null;
                this._hScrollBar.removeSelf();
                this._hScrollBar.offAll();
                this._hScrollBar = null;
            }
            _super.prototype.dispose.call(this);
        };
        UIRoot.customCompFunctionNames = ["enabledLimitView", "scrollShowType", "hScrollBar", "hScrollBg", "vScrollBar", "vScrollBg", "scrollWidth",
            "slowmotionType", "enabledWheel", "hScrollValue", "vScrollValue"];
        UIRoot.SCROLL = "UIROOT_EVENT_SCROLL";
        return UIRoot;
    }(UIComponent.UIBase));
    UIComponent.UIRoot = UIRoot;
    var GUI_BASE = (function (_super) {
        __extends(GUI_BASE, _super);
        function GUI_BASE(guiID) {
            var _this_1 = _super.call(this, true, guiID) || this;
            _this_1.compsIDInfo = {};
            var data = Game.data.uiList.data[guiID];
            if (!data)
                return _this_1;
            GameUI.parse(data.uiDisplayData, false, null, guiID, _this_1);
            return _this_1;
        }
        return GUI_BASE;
    }(UIRoot));
    UIComponent.GUI_BASE = GUI_BASE;
})(UIComponent || (UIComponent = {}));















(function (UIComponent) {
    var UISlider = (function (_super) {
        __extends(UISlider, _super);
        function UISlider() {
            var _this_1 = _super.call(this) || this;
            _this_1._image1 = "";
            _this_1._image2 = "";
            _this_1._image3 = "";
            _this_1._blockFillMask = new UIImage();
            _this_1._blockFillMode = 2;
            _this_1._isBindingVarID = false;
            _this_1._bindingVarID = -1;
            _this_1._bgImg = new UIImage();
            _this_1._blockImg = new UIImage();
            _this_1._blockFillImg = new UIImage();
            _this_1._blockGrid9 = "0,0,0,0,0";
            _this_1._bgGrid9 = "0,0,0,0,0";
            _this_1._blockFillGrid9 = "0,0,0,0,0";
            _this_1.addChild(_this_1._bgImg);
            _this_1._bgImg.addChild(_this_1._blockImg);
            _this_1.className = "UISlider";
            _this_1.on(EventObject.RESIZE, _this_1, _this_1.refreshSize);
            if (!Config.EDIT_MODE) {
                _this_1.on(EventObject.DISPLAY, _this_1, _this_1.onDisplay);
                _this_1.on(EventObject.UNDISPLAY, _this_1, _this_1.unDisplay);
                _this_1._onVarChange = Callback.New(_this_1.onVarChange, _this_1);
                _this_1._blockImg.add_MOUSEDOWN(_this_1.onMouseDown, _this_1);
                _this_1._bgImg.add_MOUSEDOWN(function (e) {
                    if (e.target != _this_1._bgImg)
                        return;
                    if (_this_1.step == 0)
                        return;
                    var blockTex = AssetManager.getImage(_this_1.image2);
                    if (!blockTex)
                        return;
                    if (_this_1._blockFillMode == 1 || _this_1._blockFillMode == 2) {
                        if (!_this_1._blockFillImg.stage)
                            _this_1._bgImg.addChildAt(_this_1._blockFillImg, 0);
                    }
                    var lastValue = _this_1._value;
                    var per = 0;
                    if (_this_1.transverseMode) {
                        _this_1._blockImg.x = _this_1._bgImg.mouseX - blockTex.width * 0.5;
                        if (_this_1._blockPosMode == 0) {
                            _this_1._blockImg.x = Math.max(Math.min(_this_1._blockImg.x, _this_1.width - blockTex.width), 0);
                            per = _this_1._blockImg.x / (_this_1.width - blockTex.width);
                        }
                        else if (_this_1._blockPosMode == 1) {
                            _this_1._blockImg.x = Math.max(Math.min(_this_1._blockImg.x, _this_1.width - blockTex.width * 0.5), -blockTex.width * 0.5);
                            per = (_this_1._blockImg.x + blockTex.width * 0.5) / _this_1.width;
                        }
                        else if (_this_1._blockPosMode == 2) {
                            _this_1._blockImg.x = Math.max(Math.min(_this_1._blockImg.x, _this_1.width), -blockTex.width);
                            per = (_this_1._blockImg.x + blockTex.width) / (_this_1.width + blockTex.width);
                        }
                        var width = void 0;
                        if (_this_1._blockPosMode == 0)
                            width = _this_1._blockImg.x + blockTex.width * _this_1._value / _this_1._max;
                        else if (_this_1._blockPosMode == 1)
                            width = _this_1._blockImg.x + blockTex.width * 0.5;
                        else if (_this_1._blockPosMode == 2)
                            width = (_this_1._blockImg.x * _this_1.width + _this_1.width * blockTex.width) / (_this_1.width + blockTex.width);
                        if (_this_1._blockFillImg.stage) {
                            if (_this_1._fillStrething) {
                                _this_1._blockFillImg.width = _this_1.width;
                                _this_1._blockFillMask.x = -_this_1.width + width;
                            }
                            else {
                                _this_1._blockFillImg.width = width;
                            }
                        }
                    }
                    else {
                        _this_1._blockImg.y = _this_1._bgImg.mouseY - blockTex.height * 0.5;
                        if (_this_1._blockPosMode == 0) {
                            _this_1._blockImg.y = Math.max(Math.min(_this_1._blockImg.y, _this_1.height - blockTex.height), 0);
                            per = _this_1._blockImg.y / (_this_1.height - blockTex.height);
                        }
                        else if (_this_1._blockPosMode == 1) {
                            _this_1._blockImg.y = Math.max(Math.min(_this_1._blockImg.y, _this_1.height - blockTex.height * 0.5), -blockTex.height * 0.5);
                            per = (_this_1._blockImg.y + blockTex.height * 0.5) / _this_1.height;
                        }
                        else if (_this_1._blockPosMode == 2) {
                            _this_1._blockImg.y = Math.max(Math.min(_this_1._blockImg.y, _this_1.height), -blockTex.height);
                            per = (_this_1._blockImg.y + blockTex.height) / (_this_1.height + blockTex.height);
                        }
                        var height = void 0;
                        if (_this_1._blockPosMode == 0)
                            height = _this_1._blockImg.y + blockTex.height * _this_1._value / _this_1._max;
                        else if (_this_1._blockPosMode == 1)
                            height = _this_1._blockImg.y + blockTex.height * 0.5;
                        else if (_this_1._blockPosMode == 2)
                            height = (_this_1._blockImg.y * _this_1.height + _this_1.height * blockTex.height) / (_this_1.height + blockTex.height);
                        if (_this_1._blockFillImg.stage) {
                            if (_this_1._fillStrething) {
                                _this_1._blockFillImg.height = _this_1.height;
                                _this_1._blockFillMask.y = -_this_1.height + height;
                            }
                            else {
                                _this_1._blockFillImg.height = height;
                            }
                        }
                    }
                    per = Math.max(Math.min(per, 1), 0);
                    var value = (_this_1.max - _this_1.min == 0) ? 0 : (per * (_this_1.max - _this_1.min) + _this_1.min);
                    var pow = Math.pow(10, (_this_1._step + "").length - 1);
                    value = Math.round(Math.round(value / _this_1._step) * _this_1._step * pow) / pow;
                    value = Math.max(Math.min(value, _this_1.max), _this_1.min);
                    if (value != lastValue) {
                        _this_1.setValue(value, false, true);
                    }
                    _this_1.onMouseDown(e);
                }, _this_1);
            }
            _this_1.min = 0;
            _this_1.max = 100;
            _this_1.width = 191;
            _this_1.height = 6;
            _this_1.step = 1;
            _this_1.value = 50;
            _this_1.transverseMode = true;
            _this_1.blockPosMode = 0;
            _this_1.fillStrething = false;
            return _this_1;
        }
        UISlider.prototype.inEditorInit = function () {
            this.image1 = "asset/image/picture/control/slider_bg.png";
            this.image2 = "asset/image/picture/control/slider_block.png";
            this.image3 = "asset/image/picture/control/slider_bgfill.png";
            this.installDefaultValue();
        };
        UISlider.prototype.loadAssetTest = function () {
            AssetManager.loadImages([this.image1, this.image2, this.image3], Callback.New(function () {
                this.event(GameUI.EVENT_TEST_LOAD_CHILD_UI);
            }, this), this._syncLoadedEventWhenAssetExist, false);
        };
        UISlider.prototype.dispose = function () {
            if (!this.isDisposed) {
                if (this.___currentRequestLoadImages)
                    AssetManager.disposeImages(this.___currentRequestLoadImages);
                this._bgImg.removeSelf();
                this._bgImg.offAll();
                this._bgImg = null;
                this._blockImg.removeSelf();
                this._blockImg.offAll();
                this._blockImg = null;
                this._blockFillImg.removeSelf();
                this._blockFillImg.offAll();
                this._blockFillImg = null;
                this._blockFillMask.removeSelf();
                this._blockFillMask.offAll();
                this._blockFillMask = null;
                if (!Config.EDIT_MODE) {
                    var varID = this._bindingVarID;
                    if (varID != 0 && this.className == "UISlider" && Game.player) {
                        Game.player.removeListenerPlayerVariable(0, varID, this._onVarChange);
                    }
                }
            }
            _super.prototype.dispose.call(this);
        };
        UISlider.prototype.onDisplay = function () {
            this.refreshBindingVarID();
        };
        UISlider.prototype.unDisplay = function () {
            var varID = this._bindingVarID;
            if (varID != 0) {
                Game.player.removeListenerPlayerVariable(0, varID, this._onVarChange);
            }
        };
        Object.defineProperty(UISlider.prototype, "image1", {
            get: function () {
                return this._image1;
            },
            set: function (v) {
                if (this.isDisposed)
                    return;
                this._image1 = v;
                this.refImageRecord(0, v);
                AssetManager.loadImage(v);
                this.refresh();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "image2", {
            get: function () {
                return this._image2;
            },
            set: function (v) {
                if (this.isDisposed)
                    return;
                this._image2 = v;
                this.refImageRecord(1, v);
                AssetManager.loadImage(v);
                this.refresh();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "image3", {
            get: function () {
                return this._image3;
            },
            set: function (v) {
                if (this.isDisposed)
                    return;
                this._image3 = v;
                this.refImageRecord(2, v);
                AssetManager.loadImage(v);
                this.refresh();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "blockFillMode", {
            get: function () {
                return this._blockFillMode;
            },
            set: function (v) {
                v = Math.floor(v);
                this._blockFillMode = v;
                this.refreshSize();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "blockPosMode", {
            get: function () {
                return this._blockPosMode;
            },
            set: function (v) {
                this._blockPosMode = v;
                v = Math.floor(v);
                this.refreshSize();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "fillStrething", {
            get: function () {
                return this._fillStrething;
            },
            set: function (v) {
                this._fillStrething = v;
                if (this._fillStrething) {
                    this._blockFillMask.skin = this.image3;
                    this._blockFillImg.mask = this._blockFillMask;
                }
                else {
                    this._blockFillImg.mask = null;
                }
                this.refreshSize();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "transverseMode", {
            get: function () {
                return this._transverseMode;
            },
            set: function (v) {
                this._transverseMode = v;
                this.refreshSize();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "min", {
            get: function () {
                return this._min;
            },
            set: function (v) {
                this._min = v;
                this.refreshSize();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "max", {
            get: function () {
                return this._max;
            },
            set: function (v) {
                this._max = v;
                this.refreshSize();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "value", {
            get: function () {
                return this._value;
            },
            set: function (v) {
                v = Math.max(Math.min(v, this.max), this.min);
                this.setValue(v, true, false);
            },
            enumerable: false,
            configurable: true
        });
        UISlider.prototype.setValueForce = function (v) {
            this.__forceChange = true;
            this.value = v;
            this.__forceChange = false;
        };
        UISlider.prototype.setValue = function (v, isRefreshSize, force) {
            if (this._isBindingVarID && this._bindingVarID && Config.SINGLE_PLAYER_CORE) {
                Game.player.variable.setVariable(this._bindingVarID, v);
                return;
            }
            if (force) {
                this._value = v;
                if (isRefreshSize)
                    this.refreshSize();
                this.event(EventObject.CHANGE);
            }
            else if (v != this._value) {
                var lastValue = this._value;
                this._value = v;
                if (isRefreshSize)
                    this.refreshSize();
                if (this._value != lastValue) {
                    if (!this.__forceChange)
                        this.event(EventObject.CHANGE);
                }
            }
        };
        Object.defineProperty(UISlider.prototype, "isBindingVarID", {
            get: function () {
                return this._isBindingVarID;
            },
            set: function (v) {
                this._isBindingVarID = v;
                this.refreshBindingVarID();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "bindingVarID", {
            get: function () {
                return this._bindingVarID;
            },
            set: function (v) {
                this._bindingVarID = v;
                this.refreshBindingVarID();
            },
            enumerable: false,
            configurable: true
        });
        UISlider.prototype.refreshBindingVarID = function () {
            if (!Config.EDIT_MODE) {
                if (this._isBindingVarID && this._isBindingVarID) {
                    if (this.displayedInStage) {
                        Game.player.removeListenerPlayerVariable(0, this._bindingVarID, this._onVarChange);
                        Game.player.addListenerPlayerVariable(0, this._bindingVarID, this._onVarChange);
                    }
                }
            }
        };
        UISlider.prototype.onVarChange = function (typeID, varID, value) {
            if (value != this._value) {
                var lastValue = this._value;
                this._value = value;
                this.refreshSize();
                if (this._value != lastValue) {
                    if (!this.__forceChange)
                        this.event(EventObject.CHANGE);
                }
            }
        };
        Object.defineProperty(UISlider.prototype, "step", {
            get: function () {
                return this._step;
            },
            set: function (v) {
                this._step = v;
            },
            enumerable: false,
            configurable: true
        });
        UISlider.prototype.onmouseover = function (e) {
        };
        UISlider.prototype.onmouseout = function (e) {
        };
        UISlider.prototype.onMouseDown = function (e) {
            if (this._blockFillMode == 1)
                return;
            var rect = new Rectangle();
            var blockTex = AssetManager.getImage(this.image2);
            if (!blockTex)
                return;
            if (this.transverseMode) {
                var posX = 0;
                if (this._blockPosMode == 1)
                    posX = -blockTex.width * 0.5;
                else if (this._blockPosMode == 2)
                    posX = -blockTex.width;
                var posW = this.width - blockTex.width;
                if (this._blockPosMode == 1)
                    posW = this.width;
                else if (this._blockPosMode == 2)
                    posW = this.width + blockTex.width;
                rect.x = posX;
                rect.y = (this.height - blockTex.height) / 2;
                rect.width = posW;
                rect.height = 0;
            }
            else {
                var posY = 0;
                if (this._blockPosMode == 1)
                    posY = -blockTex.height * 0.5;
                else if (this._blockPosMode == 2)
                    posY = -blockTex.height;
                var posH = this.height - blockTex.height;
                if (this._blockPosMode == 1)
                    posH = this.height;
                else if (this._blockPosMode == 2)
                    posH = this.height + blockTex.height;
                rect.x = (this.width - blockTex.width) / 2;
                rect.y = posY;
                rect.width = 0;
                rect.height = posH;
            }
            this._blockImg.startDrag(rect);
            this._blockImg.on(EventObject.DRAG_MOVE, this, this.onMouseDrag);
            stage.once(EventObject.MOUSE_UP, this, this.onMouseUp);
        };
        UISlider.prototype.onMouseDrag = function () {
            if (this.step == 0)
                return;
            if (this._blockFillMode == 1 || this._blockFillMode == 2) {
                if (!this._blockFillImg.stage)
                    this._bgImg.addChildAt(this._blockFillImg, 0);
            }
            var lastValue = this._value;
            var blockTex = AssetManager.getImage(this.image2);
            var per = 0;
            if (this.transverseMode) {
                var width = void 0;
                if (this._blockPosMode == 0)
                    width = this._blockImg.x + blockTex.width * this._value / this._max;
                else if (this._blockPosMode == 1)
                    width = this._blockImg.x + blockTex.width * 0.5;
                else if (this._blockPosMode == 2)
                    width = (this._blockImg.x * this.width + this.width * blockTex.width) / (this.width + blockTex.width);
                if (this._blockFillImg.stage) {
                    if (this._fillStrething) {
                        this._blockFillImg.width = this.width;
                        this._blockFillMask.x = -this.width + width;
                    }
                    else {
                        this._blockFillImg.width = width;
                    }
                }
                if (this._blockPosMode == 0)
                    per = this._blockImg.x / (this.width - blockTex.width);
                else if (this._blockPosMode == 1)
                    per = (this._blockImg.x + blockTex.width * 0.5) / this.width;
                else if (this._blockPosMode == 2)
                    per = (this._blockImg.x + blockTex.width) / (this.width + blockTex.width);
            }
            else {
                var height = void 0;
                if (this._blockPosMode == 0)
                    height = this._blockImg.y + blockTex.height * this._value / this._max;
                else if (this._blockPosMode == 1)
                    height = this._blockImg.y + blockTex.height * 0.5;
                else if (this._blockPosMode == 2)
                    height = (this._blockImg.y * this.height + this.height * blockTex.height) / (this.height + blockTex.height);
                if (this._blockFillImg.stage) {
                    if (this._fillStrething) {
                        this._blockFillImg.height = this.height;
                        this._blockFillMask.y = -this.height + height;
                    }
                    else {
                        this._blockFillImg.height = height;
                    }
                }
                if (this._blockPosMode == 0)
                    per = this._blockImg.y / (this.height - blockTex.height);
                else if (this._blockPosMode == 1)
                    per = (this._blockImg.y + blockTex.height * 0.5) / this.height;
                else if (this._blockPosMode == 2)
                    per = (this._blockImg.y + blockTex.height) / (this.height + blockTex.height);
            }
            per = Math.max(Math.min(per, 1), 0);
            var value = (this.max - this.min == 0) ? 0 : (per * (this.max - this.min) + this.min);
            var pow = Math.pow(10, (this._step + "").length - 1);
            value = Math.round(Math.round(value / this._step) * this._step * pow) / pow;
            value = Math.max(Math.min(value, this.max), this.min);
            if (value != lastValue) {
                this.setValue(value, false, true);
            }
        };
        UISlider.prototype.onMouseUp = function () {
            this._blockImg.stopDrag();
            this._blockImg.off(EventObject.DRAG_MOVE, this, this.onMouseDrag);
        };
        Object.defineProperty(UISlider.prototype, "blockGrid9Width", {
            get: function () {
                return this._blockImg.width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "blockGrid9Height", {
            get: function () {
                return this._blockImg.height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "blockGrid9Skin", {
            get: function () {
                return this._blockImg.skin;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "blockGrid9", {
            get: function () {
                return this._blockGrid9;
            },
            set: function (v) {
                if (!v || v == "")
                    v = "0,0,0,0,0";
                this._blockGrid9 = this._blockImg.sizeGrid = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "bgGrid9Width", {
            get: function () {
                return this._bgImg.width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "bgGrid9Height", {
            get: function () {
                return this._bgImg.height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "bgGrid9Skin", {
            get: function () {
                return this._bgImg.skin;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "bgGrid9", {
            get: function () {
                return this._bgGrid9;
            },
            set: function (v) {
                if (!v || v == "")
                    v = "0,0,0,0,0";
                this._bgGrid9 = this._bgImg.sizeGrid = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "blockFillGrid9Width", {
            get: function () {
                return this._blockFillImg.width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "blockFillGrid9Height", {
            get: function () {
                return this._blockFillImg.height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "blockFillGrid9Skin", {
            get: function () {
                return this._blockFillImg.skin;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "blockFillGrid9", {
            get: function () {
                return this._blockFillGrid9;
            },
            set: function (v) {
                if (!v || v == "")
                    v = "0,0,0,0,0";
                this._blockFillGrid9 = this._blockFillImg.sizeGrid = v;
            },
            enumerable: false,
            configurable: true
        });
        UISlider.prototype.refresh = function () {
            var _this_1 = this;
            if (this.isDisposed)
                return;
            AssetManager.loadImages([this.image1, this.image2, this.image3], Callback.New(function (image1, image2, image3) {
                if (_this_1.isDisposed)
                    return;
                if (_this_1.image1 != image1 || _this_1.image2 != image2 || _this_1.image3 != image3)
                    return;
                _this_1._bgImg.skin = _this_1.image1;
                _this_1._blockImg.skin = _this_1.image2;
                _this_1._blockFillImg.skin = _this_1.image3;
                if (_this_1._fillStrething)
                    _this_1._blockFillMask.skin = _this_1.image3;
                _this_1.refreshSize();
            }, this, [this.image1, this.image2, this.image3]), true, false);
        };
        UISlider.prototype.refreshSize = function () {
            if (this.isDisposed)
                return;
            this._bgImg.width = this.width;
            this._bgImg.height = this.height;
            var blockTex = AssetManager.getImage(this.image2);
            this._value = Math.max(Math.min(this._value, this.max), this.min);
            var per = (this.max - this.min == 0) ? 0 : ((this._value - this.min) / (this.max - this.min));
            if (this.transverseMode) {
                if (this._blockFillMode == 1 || this._blockFillMode == 2) {
                    if (!this._blockFillImg.stage)
                        this._bgImg.addChildAt(this._blockFillImg, 0);
                    this._blockFillImg.x = 0;
                    this._blockFillImg.y = 0;
                    this._blockFillImg.height = this.height;
                    if (this._fillStrething) {
                        this._blockFillImg.width = this.width;
                        this._blockFillMask.width = this.width;
                        this._blockFillMask.height = this.height;
                        this._blockFillMask.x = -this.width + per * this.width;
                    }
                    else {
                        this._blockFillImg.width = per * this.width;
                    }
                }
                if (this._blockFillMode == 0 || this._blockFillMode == 2) {
                    if (!this._blockImg.stage)
                        this._bgImg.addChild(this._blockImg);
                    if (blockTex) {
                        var pos = per * (this.width - blockTex.width);
                        if (this._blockPosMode == 1)
                            pos = per * this.width - blockTex.width * 0.5;
                        else if (this._blockPosMode == 2)
                            pos = per * (this.width + blockTex.width) - blockTex.width;
                        this._blockImg.x = pos;
                        this._blockImg.y = (this.height - blockTex.height) / 2;
                        this._blockImg.width = blockTex.width;
                        this._blockImg.height = blockTex.height;
                    }
                }
            }
            else {
                if (this._blockFillMode == 1 || this._blockFillMode == 2) {
                    if (!this._blockFillImg.stage)
                        this._bgImg.addChildAt(this._blockFillImg, 0);
                    this._blockFillImg.x = 0;
                    this._blockFillImg.y = 0;
                    this._blockFillImg.width = this.width;
                    if (this._fillStrething) {
                        this._blockFillImg.height = this.height;
                        this._blockFillMask.height = this.height;
                        this._blockFillMask.width = this.width;
                        this._blockFillMask.y = -this.height + per * this.height;
                    }
                    else {
                        this._blockFillImg.height = per * this.height;
                    }
                }
                if (this._blockFillMode == 0 || this._blockFillMode == 2) {
                    if (!this._blockImg.stage)
                        this._bgImg.addChild(this._blockImg);
                    if (blockTex) {
                        var pos = per * (this.height - blockTex.height);
                        if (this._blockPosMode == 1)
                            pos = per * this.height - blockTex.height * 0.5;
                        else if (this._blockPosMode == 2)
                            pos = per * (this.height + blockTex.height) - blockTex.height;
                        this._blockImg.y = pos;
                        this._blockImg.x = (this.width - blockTex.width) / 2;
                        this._blockImg.width = blockTex.width;
                        this._blockImg.height = blockTex.height;
                    }
                }
            }
            if (this._blockFillMode != 1) {
                if (!this._blockImg.stage)
                    this._bgImg.addChild(this._blockImg);
            }
            else {
                this._blockImg.removeSelf();
            }
            if (this._blockFillMode == 0 || this.value == this.min) {
                this._blockFillImg.removeSelf();
            }
        };
        Object.defineProperty(UISlider.prototype, "onChangeFragEvent", {
            get: function () {
                return this._onChangeFragEvent;
            },
            set: function (v) {
                this._onChangeFragEvent = v;
                if (v) {
                    this.off(EventObject.CHANGE, this, this.onChange_private);
                    this.on(EventObject.CHANGE, this, this.onChange_private);
                }
                else {
                    this.off(EventObject.CHANGE, this, this.onChange_private);
                }
            },
            enumerable: false,
            configurable: true
        });
        UISlider.prototype.onChange_private = function () {
            if (Config.SINGLE_PLAYER_CORE) {
                if (this._onChangeFragEvent && this.guiRoot && !this.guiRoot.onlyForPreload) {
                    CommandPage.startTriggerFragmentEvent(this._onChangeFragEvent, Game.player.sceneObject, Game.player.sceneObject);
                }
            }
        };
        UISlider.customCompFunctionNames = ["image1", "bgGrid9", "image2", "blockGrid9", "image3", "blockFillGrid9", "step", "min", "max", "value",
            "transverseMode", "blockFillMode", "blockPosMode", "fillStrething", "isBindingVarID", "bindingVarID", "onChangeFragEvent"];
        return UISlider;
    }(UIComponent.UIBase));
    UIComponent.UISlider = UISlider;
})(UIComponent || (UIComponent = {}));















(function (UIComponent) {
    var UIString = (function (_super) {
        __extends(UIString, _super);
        function UIString(inputMode) {
            if (inputMode === void 0) { inputMode = false; }
            var _this_1 = _super.call(this) || this;
            _this_1._shadowEnabled = false;
            _this_1._shadowColor = "#000000";
            _this_1._shadowDx = 1;
            _this_1._shadowDy = 1;
            _this_1._align = 0;
            _this_1._valign = 0;
            _this_1._overflow = 0;
            _this_1._fontSize = 16;
            _this_1._stroke = 0;
            _this_1._strokeColor = "#000000";
            _this_1._lastVarID = 0;
            _this_1._smooth = false;
            _this_1.className = "UIString";
            _this_1._tf = inputMode ? new TextInput() : new Label();
            _this_1._tf.wordWrap = !inputMode;
            _this_1._input = inputMode;
            _this_1.on(EventObject.RESIZE, _this_1, _this_1.onResize);
            _this_1.addChild(_this_1._tf);
            _this_1._tf.font = Config.DEFAULT_FONT ? Config.DEFAULT_FONT : "Arial";
            _this_1._needLoad = false;
            _this_1.width = 200;
            _this_1.height = 30;
            _this_1.fontSize = 16;
            if (!Config.EDIT_MODE) {
                _this_1._onVarChange = Callback.New(_this_1.onVarChange, _this_1);
                _this_1.add_DISPLAY(_this_1.onAdded, _this_1);
                _this_1.add_UNDISPLAY(_this_1.onRemoved, _this_1);
                _this_1.mouseEventEnabled = false;
            }
            else {
                _this_1.tips = Callback.New(function () {
                    return this.inEditorInfo();
                }, _this_1);
            }
            return _this_1;
        }
        UIString.prototype.dispose = function () {
            if (!this.isDisposed) {
                if (!Config.EDIT_MODE) {
                    var varID = this._lastVarID;
                    if (varID != 0 && this.className == "UIString") {
                        Game.player.removeListenerPlayerVariable(2, varID, this._onVarChange);
                    }
                }
                this._tf.removeSelf();
                this._tf.offAll();
                this._tf.destroy(true);
                this._tf = null;
                if (this._tf2) {
                    this._tf2.removeSelf();
                    this._tf2.offAll();
                    this._tf2.destroy(true);
                    this._tf2 = null;
                }
            }
            _super.prototype.dispose.call(this);
        };
        UIString.prototype.inEditorInit = function () {
            this.text = "[#GAME_STRING]";
            this.mouseEventEnabledData = false;
            this.installDefaultValue();
        };
        UIString.prototype.onResize = function () {
            if (this.isDisposed)
                return;
            this._tf.width = this.width;
            this._tf.height = this.height;
        };
        Object.defineProperty(UIString.prototype, "textWidth", {
            get: function () {
                return this._tf.textField.textWidth;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "textHeight", {
            get: function () {
                return this._tf.textField.textHeight;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "textLength", {
            get: function () {
                return this.text.length;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "smooth", {
            get: function () {
                return this._smooth;
            },
            set: function (v) {
                this._smooth = v;
                this.refreshStroke();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "text", {
            get: function () {
                return this._tf.text;
            },
            set: function (v) {
                if (this.isDisposed)
                    return;
                if (Config.EDIT_MODE) {
                    var varID = GameUtils.getVarID(v);
                    if (varID != 0) {
                        setText.call(this, v);
                        return;
                    }
                }
                setText.call(this, v);
                if (!Config.EDIT_MODE) {
                    var varID = GameUtils.getVarID(this.text);
                    if (varID != 0) {
                        setText.call(this, "");
                        if (this._lastVarID != 0)
                            Game.player.removeListenerPlayerVariable(2, this._lastVarID, this._onVarChange);
                        if (this.displayedInStage)
                            Game.player.addListenerPlayerVariable(2, varID, this._onVarChange);
                        this._lastVarID = varID;
                    }
                }
                function setText(v) {
                    if (this.__forceChange) {
                        this._tf.changeText(v);
                    }
                    else {
                        this._tf.text = v;
                    }
                    if (this._shadowEnabled) {
                        if (this._tf.text && !this._tf2.stage)
                            this.addChildAt(this._tf2, 0);
                        this._tf2.color = this._shadowColor;
                        if (this.__forceChange) {
                            this._tf2.changeText(this._tf.text);
                        }
                        else {
                            this._tf2.text = this._tf.text;
                        }
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        UIString.prototype.setTextForce = function (v) {
            this.__forceChange = true;
            this.text = v;
            this.__forceChange = false;
        };
        Object.defineProperty(UIString.prototype, "varID", {
            get: function () {
                return this._lastVarID;
            },
            set: function (v) {
                v = Math.floor(v);
                this.text = "$" + v;
                this._lastVarID = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "color", {
            get: function () {
                return this._tf.color;
            },
            set: function (v) {
                this._tf.color = v;
                this.width += 1;
                this.width -= 1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "fontSize", {
            get: function () {
                return this._fontSize;
            },
            set: function (v) {
                this._fontSize = v;
                this.refreshStroke();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "leading", {
            get: function () {
                return this._tf.leading;
            },
            set: function (v) {
                this._tf.leading = v;
                if (this._shadowEnabled)
                    this._tf2.leading = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "letterSpacing", {
            get: function () {
                return this._tf.letterSpacing;
            },
            set: function (v) {
                this._tf.letterSpacing = v;
                if (this._shadowEnabled)
                    this._tf2.letterSpacing = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "align", {
            get: function () {
                return this._align;
            },
            set: function (v) {
                v = Math.floor(v);
                this._align = v;
                switch (v) {
                    case 0:
                        this._tf.align = "left";
                        if (this._shadowEnabled)
                            this._tf2.align = "left";
                        break;
                    case 1:
                        this._tf.align = "center";
                        if (this._shadowEnabled)
                            this._tf2.align = "center";
                        break;
                    case 2:
                        this._tf.align = "right";
                        if (this._shadowEnabled)
                            this._tf2.align = "right";
                        break;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "valign", {
            get: function () {
                return this._valign;
            },
            set: function (v) {
                v = Math.floor(v);
                this._valign = v;
                switch (v) {
                    case 0:
                        this._tf.valign = "top";
                        if (this._shadowEnabled)
                            this._tf2.valign = "top";
                        break;
                    case 1:
                        this._tf.valign = "middle";
                        if (this._shadowEnabled)
                            this._tf2.valign = "middle";
                        break;
                    case 2:
                        this._tf.valign = "bottom";
                        if (this._shadowEnabled)
                            this._tf2.valign = "bottom";
                        break;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "bold", {
            get: function () {
                return this._tf.bold;
            },
            set: function (v) {
                this._tf.bold = v;
                if (this._shadowEnabled)
                    this._tf2.bold = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "italic", {
            get: function () {
                return this._tf.italic;
            },
            set: function (v) {
                this._tf.italic = v;
                if (this._shadowEnabled)
                    this._tf2.italic = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "width", {
            get: function () {
                return this._tf.width;
            },
            set: function (v) {
                this._tf.width = v;
                if (this._shadowEnabled)
                    this._tf2.width = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "height", {
            get: function () {
                return this._tf.height;
            },
            set: function (v) {
                this._tf.height = v;
                if (this._shadowEnabled)
                    this._tf2.height = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "font", {
            get: function () {
                return this._tf.font;
            },
            set: function (v) {
                this._tf.font = v;
                if (this._shadowEnabled)
                    this._tf2.font = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "overflow", {
            get: function () {
                return this._overflow;
            },
            set: function (v) {
                v = Math.floor(v);
                this._overflow = v;
                this._tf.overflow = v == 1 ? "hidden" : "visible";
                this._tf.text = this._tf.text;
                this.width += 1;
                this.width -= 1;
                if (this._shadowEnabled) {
                    this._tf2.overflow = v == 1 ? "hidden" : "visible";
                    this._tf2.color = this._shadowColor;
                    this._tf2.text = this._tf.text;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "wordWrap", {
            get: function () {
                return this._tf.wordWrap;
            },
            set: function (v) {
                this._tf.wordWrap = v;
                if (this._shadowEnabled)
                    this._tf2.wordWrap = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "stroke", {
            get: function () {
                return this._stroke;
            },
            set: function (v) {
                if (this._stroke != v) {
                    this._stroke = v;
                    this.refreshStroke();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "strokeColor", {
            get: function () {
                return this._strokeColor;
            },
            set: function (v) {
                if (this._strokeColor != v) {
                    this._strokeColor = v;
                    this.refreshStroke();
                }
            },
            enumerable: false,
            configurable: true
        });
        UIString.prototype.refreshStroke = function () {
            var realStroke = this._stroke;
            if (realStroke == 0 && this._smooth)
                realStroke = 0.001;
            if (realStroke > 0) {
                this._tf.stroke = realStroke * 2;
                this._tf.strokeColor = this._strokeColor;
                this._tf.fontSize = this._fontSize * 2;
                this._tf.scale(0.5, 0.5);
                if (this.shadowEnabled) {
                    this._tf2.stroke = realStroke * 2;
                    this._tf2.strokeColor = this._strokeColor;
                    this._tf2.fontSize = this._fontSize * 2;
                    this._tf2.scale(0.5, 0.5);
                }
            }
            else {
                this._tf.stroke = 0;
                this._tf.fontSize = this._fontSize;
                this._tf.scale(1, 1);
                if (this.shadowEnabled) {
                    this._tf2.stroke = 0;
                    this._tf2.fontSize = this._fontSize;
                    this._tf2.scale(1, 1);
                }
            }
        };
        Object.defineProperty(UIString.prototype, "shadowEnabled", {
            get: function () {
                return this._shadowEnabled;
            },
            set: function (v) {
                this._shadowEnabled = v;
                if (this._shadowEnabled) {
                    if (!this._tf2)
                        this._tf2 = this._input ? new TextInput() : new Label();
                    this._tf2.mouseEnabled = false;
                    this.addChildAt(this._tf2, 0);
                    this._tf2.font = this._tf.font;
                    this._tf2.bold = this._tf.bold;
                    this._tf2.italic = this._tf.italic;
                    this._tf2.valign = this._tf.valign;
                    this._tf2.align = this._tf.align;
                    this._tf2.fontSize = this._tf.fontSize;
                    this._tf2.leading = this._tf.leading;
                    this._tf2.overflow = this._tf.overflow;
                    this._tf2.wordWrap = this._tf.wordWrap;
                    this._tf2.color = this._shadowColor;
                    this._tf2.text = this._tf.text;
                    this._tf2.width = this._tf.width;
                    this._tf2.height = this._tf.height;
                    this._tf2.letterSpacing = this._tf.letterSpacing;
                    this._tf2.x = this._shadowDx;
                    this._tf2.y = this._shadowDy;
                    if (this._input) {
                        this._tf.remove_FOCUS(this.onInputFoucs, this);
                        this._tf.add_FOCUS(this.onInputFoucs, this);
                        this._tf.remove_FOCUS(this.onInputBlur, this);
                        this._tf.add_BLUR(this.onInputBlur, this);
                    }
                    this.refreshStroke();
                }
                else
                    this.removeChild(this._tf2);
            },
            enumerable: false,
            configurable: true
        });
        UIString.prototype.onInputFoucs = function () {
            if (this.shadowEnabled && this._tf2)
                this._tf2.removeSelf();
        };
        UIString.prototype.onInputBlur = function () {
            if (this.shadowEnabled && this._tf2) {
                this._tf2.color = this._shadowColor;
                this._tf2.text = this._tf.text;
                this._tf2.x = this._shadowDx;
                this._tf2.y = this._shadowDy;
                this.addChildAt(this._tf2, 0);
            }
        };
        Object.defineProperty(UIString.prototype, "shadowColor", {
            get: function () {
                return this._shadowColor;
            },
            set: function (v) {
                this._shadowColor = v;
                if (this._shadowEnabled)
                    this._tf2.color = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "shadowDx", {
            get: function () {
                return this._shadowDx;
            },
            set: function (v) {
                this._shadowDx = v;
                if (this._shadowEnabled)
                    this._tf2.x = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "shadowDy", {
            get: function () {
                return this._shadowDy;
            },
            set: function (v) {
                this._shadowDy = v;
                if (this._shadowEnabled)
                    this._tf2.y = v;
            },
            enumerable: false,
            configurable: true
        });
        UIString.prototype.inEditorInfo = function () {
            var varID = GameUtils.getVarID(this.text);
            if (varID != 0) {
                var varName = GameListData.getName(Game.data.playerStringNameList, varID);
                return "[" + MathUtils.fixIntDigit(varID.toString()) + ":" + varName + "]";
            }
            else {
                return "";
            }
        };
        UIString.prototype.onAdded = function (e) {
            var varID = this._lastVarID;
            if (varID != 0) {
                Game.player.addListenerPlayerVariable(2, varID, this._onVarChange);
            }
        };
        UIString.prototype.onRemoved = function (e) {
            var varID = this._lastVarID;
            if (varID != 0) {
                Game.player.removeListenerPlayerVariable(2, varID, this._onVarChange);
            }
        };
        UIString.prototype.onVarChange = function (typeID, varID, value) {
            this._tf.text = value.toString();
            if (this._shadowEnabled)
                this._tf2.text = this._tf.text;
        };
        Object.defineProperty(UIString.prototype, "onChangeFragEvent", {
            get: function () {
                return this._onChangeFragEvent;
            },
            set: function (v) {
                this._onChangeFragEvent = v;
                if (v) {
                    this.off(EventObject.CHANGE, this, this.onChange_private);
                    this.on(EventObject.CHANGE, this, this.onChange_private);
                }
                else {
                    this.off(EventObject.CHANGE, this, this.onChange_private);
                }
            },
            enumerable: false,
            configurable: true
        });
        UIString.prototype.onChange_private = function () {
            if (Config.SINGLE_PLAYER_CORE && !(this instanceof UIComponent.UIInput)) {
                if (this._onChangeFragEvent && this.guiRoot && !this.guiRoot.onlyForPreload) {
                    CommandPage.startTriggerFragmentEvent(this._onChangeFragEvent, Game.player.sceneObject, Game.player.sceneObject);
                }
            }
        };
        UIString.customCompFunctionNames = ["text", "fontSize", "color", "bold", "italic", "smooth", "align", "valign", "leading", "letterSpacing", "font", "wordWrap", "overflow", "shadowEnabled", "shadowColor", "shadowDx", "shadowDy", "stroke", "strokeColor", "onChangeFragEvent", "textWidth", "textHeight", "textLength"];
        return UIString;
    }(UIComponent.UIBase));
    UIComponent.UIString = UIString;
    ObjectUtils.redefinedEventFunc("UIComponent.UIString", [EventObject.ENTER, EventObject.INPUT, EventObject.CHANGE, EventObject.FOCUS, EventObject.BLUR], "_tf");
})(UIComponent || (UIComponent = {}));















(function (UIComponent) {
    var UISwitch = (function (_super) {
        __extends(UISwitch, _super);
        function UISwitch() {
            var _this_1 = _super.call(this) || this;
            _this_1.className = "UISwitch";
            _this_1._selected = 1;
            if (!Config.EDIT_MODE) {
                _this_1._selected = 0;
                _this_1._onVarChange = Callback.New(_this_1.onVarChange, _this_1);
                _this_1.add_DISPLAY(_this_1.onAdded, _this_1);
                _this_1.add_UNDISPLAY(_this_1.onRemoved, _this_1);
                _this_1.offAll(EventObject.CLICK);
            }
            else {
                _this_1._previewselected = true;
            }
            return _this_1;
        }
        Object.defineProperty(UISwitch.prototype, "switchID", {
            get: function () {
                return this.getVarID();
            },
            set: function (v) {
                v = Math.floor(v);
                var lastVarID = this.getVarID();
                if (lastVarID != 0)
                    Game.player.removeListenerPlayerVariable(1, lastVarID, this._onVarChange);
                this._selected = v;
                var varID = this.getVarID();
                if (this.displayedInStage && varID != 0)
                    Game.player.addListenerPlayerVariable(1, varID, this._onVarChange);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UISwitch.prototype, "selected", {
            get: function () {
                return this._selected;
            },
            set: function (v) {
                this._selected = v;
                if (!Config.EDIT_MODE) {
                    this.switchID = v;
                }
            },
            enumerable: false,
            configurable: true
        });
        UISwitch.prototype.onVarChange = function (typeID, varID, value) {
            this.onChange_private();
            this.refresh();
        };
        Object.defineProperty(UISwitch.prototype, "previewselected", {
            get: function () {
                return this._previewselected;
            },
            set: function (v) {
                if (!Config.EDIT_MODE)
                    return;
                this._previewselected = v;
                var url = this._previewselected ? this.image2 : this.image1;
                var gridText = this._previewselected ? this._grid9img2 : this._grid9img1;
                if (url) {
                    this._image.skin = url;
                    this._image.width = this.width;
                    this._image.height = this.height;
                    this._image.sizeGrid = gridText;
                }
            },
            enumerable: false,
            configurable: true
        });
        UISwitch.prototype.getVarID = function () {
            return this._selected;
        };
        UISwitch.prototype.onAdded = function (e) {
            var varID = this.getVarID();
            if (varID != 0) {
                Game.player.addListenerPlayerVariable(1, varID, this._onVarChange);
            }
        };
        UISwitch.prototype.onRemoved = function (e) {
            var varID = this.getVarID();
            if (varID != 0) {
                Game.player.removeListenerPlayerVariable(1, varID, this._onVarChange);
            }
        };
        UISwitch.prototype.refresh = function () {
            var _this_1 = this;
            if (this.isDisposed)
                return;
            this.graphics.clear();
            if (!Config.EDIT_MODE) {
                var varID = this.getVarID();
                if (varID) {
                    var switchBool = Game.player.variable.getSwitch(varID);
                    if (switchBool) {
                        var url = this.image2;
                        var gridText = this._grid9img2;
                    }
                    else {
                        url = this.image1;
                        gridText = this._grid9img1;
                    }
                    if (url) {
                        AssetManager.loadImage(url, Callback.New(function (url, tex) {
                            if (_this_1.isDisposed)
                                return;
                            var varID = _this_1.getVarID();
                            var thisUrl = Game.player.variable.getSwitch(varID) ? _this_1.image2 : _this_1.image1;
                            if (thisUrl != url)
                                return;
                            _this_1._image.skin = url;
                            _this_1._image.width = _this_1.width;
                            _this_1._image.height = _this_1.height;
                            _this_1._image.sizeGrid = gridText;
                        }, this, [url]), true, false);
                    }
                }
            }
            else {
                var url = this._previewselected ? this.image2 : this.image1;
                var gridText = this._previewselected ? this._grid9img2 : this._grid9img1;
                if (url) {
                    AssetManager.loadImage(url, Callback.New(function (url, tex) {
                        if (_this_1.isDisposed)
                            return;
                        var thisUrl = _this_1._previewselected ? _this_1.image2 : _this_1.image1;
                        if (thisUrl != url)
                            return;
                        _this_1._image.skin = url;
                        _this_1._image.width = _this_1.width;
                        _this_1._image.height = _this_1.height;
                        _this_1._image.sizeGrid = gridText;
                    }, this, [url]), true, false);
                }
            }
        };
        UISwitch.prototype.dispose = function () {
            if (!this.isDisposed) {
                if (!Config.EDIT_MODE) {
                    var varID = this.getVarID();
                    if (varID != 0 && this.className == "UISwitch") {
                        Game.player.removeListenerPlayerVariable(1, varID, this._onVarChange);
                    }
                }
                _super.prototype.dispose.call(this);
            }
        };
        UISwitch.customCompFunctionNames = ["selected", "image1", "grid9img1", "image2", "grid9img2", "previewselected"];
        return UISwitch;
    }(UIComponent.UICheckBox));
    UIComponent.UISwitch = UISwitch;
})(UIComponent || (UIComponent = {}));















(function (UIComponent) {
    var UITabBox = (function (_super) {
        __extends(UITabBox, _super);
        function UITabBox() {
            var _this_1 = _super.call(this) || this;
            _this_1._selectedIndex = -1;
            _this_1._rowMode = false;
            _this_1._grid9img1 = "0,0,0,0,0";
            _this_1._grid9img2 = "0,0,0,0,0";
            _this_1._spacing = 0;
            _this_1._labelSelectedColor = "#FFFFFF";
            _this_1._labelColor = "#666666";
            _this_1._labelSize = 16;
            _this_1._labelLetterSpacing = 0;
            _this_1._labelAlign = 1;
            _this_1._labelValign = 1;
            _this_1._labelBold = false;
            _this_1._labelItalic = false;
            _this_1._tabRoot = new Sprite();
            _this_1._itemButtons = [];
            _this_1._itemLabels = [];
            _this_1._labelDx = 0;
            _this_1._labelDy = 0;
            _this_1._labelStroke = 0;
            _this_1._labelStrokeColor = "#000000";
            _this_1._smooth = false;
            _this_1.addChild(_this_1._tabRoot);
            _this_1.className = "UITabBox";
            if (Config.EDIT_MODE) {
                _this_1.modifyWidthHeightEnabled = false;
                EventUtils.addEventListenerFunction(EnginePlug, EnginePlug.EVENT_TEXTURE_UPDATE, _this_1.onTextureUpdate, _this_1);
            }
            _this_1.rowMode = false;
            _this_1.spacing = 5;
            _this_1.selectedIndex = 0;
            _this_1._labelFont = Config.DEFAULT_FONT;
            return _this_1;
        }
        UITabBox.prototype.inEditorInit = function () {
            this.itemWidth = 141;
            this.itemHeight = 41;
            this.width = 433;
            this.height = 41;
            this._labelDx = 0;
            this._labelDy = 0;
            this.itemImage1 = "asset/image/picture/control/tab_unselected.png";
            this.itemImage2 = "asset/image/picture/control/tab_selected.png";
            this.items = "[#GAME_LABEL_ITEM]1,[#GAME_LABEL_ITEM]2,[#GAME_LABEL_ITEM]3";
            this.installDefaultValue();
        };
        UITabBox.prototype.loadAssetTest = function () {
            var _this_1 = this;
            AssetManager.loadImages([this.itemImage1, this.itemImage2], Callback.New(function () {
                _this_1.event(GameUI.EVENT_TEST_LOAD_CHILD_UI);
            }, this), this._syncLoadedEventWhenAssetExist, false);
        };
        UITabBox.prototype.dispose = function () {
            if (!this.isDisposed) {
                if (Config.EDIT_MODE) {
                    EventUtils.removeEventListenerFunction(EnginePlug, EnginePlug.EVENT_TEXTURE_UPDATE, this.onTextureUpdate, this);
                }
                this.clearItems();
                this._tabRoot.removeSelf();
                this._tabRoot.offAll();
                this._tabRoot = null;
            }
            _super.prototype.dispose.call(this);
        };
        UITabBox.prototype.onTextureUpdate = function (url, tex, newTex) {
            if (this.stage && (url == this.itemImage1) || (url == this.itemImage2)) {
                this.refreshButtonImage(true);
            }
        };
        Object.defineProperty(UITabBox.prototype, "selectedIndex", {
            get: function () {
                return this._selectedIndex;
            },
            set: function (v) {
                v = Math.floor(v);
                if (this._selectedIndex != v) {
                    this._selectedIndex = v;
                    this.refreshSelected();
                    this.onSelected();
                    if (!this.__forceChange)
                        this.event(EventObject.CHANGE);
                }
            },
            enumerable: false,
            configurable: true
        });
        UITabBox.prototype.setSelectedForce = function (v) {
            this.__forceChange = true;
            this.selectedIndex = v;
            this.__forceChange = false;
        };
        Object.defineProperty(UITabBox.prototype, "items", {
            get: function () {
                return this._items;
            },
            set: function (v) {
                this._items = v;
                this.refreshItems();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "length", {
            get: function () {
                return this._itemButtons.length;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "itemImage1", {
            get: function () {
                return this._itemImage1;
            },
            set: function (v) {
                this._itemImage1 = v;
                this.refreshButtonImage();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "itemImage2", {
            get: function () {
                return this._itemImage2;
            },
            set: function (v) {
                this._itemImage2 = v;
                this.refreshButtonImage();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "grid9img1Width", {
            get: function () {
                return this.itemWidth;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "grid9img1Height", {
            get: function () {
                return this.itemHeight;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "grid9img1Skin", {
            get: function () {
                return this._itemImage1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "grid9img1", {
            get: function () {
                return this._grid9img1;
            },
            set: function (v) {
                if (!v || v == "")
                    v = "0,0,0,0,0";
                this._grid9img1 = v;
                this.refreshButtonImage(false);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "grid9img2Width", {
            get: function () {
                return this.itemWidth;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "grid9img2Height", {
            get: function () {
                return this.itemHeight;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "grid9img2Skin", {
            get: function () {
                return this._itemImage2;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "grid9img2", {
            get: function () {
                return this._grid9img2;
            },
            set: function (v) {
                if (!v || v == "")
                    v = "0,0,0,0,0";
                this._grid9img2 = v;
                this.refreshButtonImage(false);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "smooth", {
            get: function () {
                return this._smooth;
            },
            set: function (v) {
                this._smooth = v;
                this.refreshItems();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "rowMode", {
            get: function () {
                return this._rowMode;
            },
            set: function (v) {
                this._rowMode = v;
                this.refreshItemSize();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "itemWidth", {
            get: function () {
                return this._itemWidth;
            },
            set: function (v) {
                this._itemWidth = v;
                this.refreshItemSize();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "itemHeight", {
            get: function () {
                return this._itemHeight;
            },
            set: function (v) {
                this._itemHeight = v;
                this.refreshItemSize();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "spacing", {
            get: function () {
                return this._spacing;
            },
            set: function (v) {
                this._spacing = v;
                this.refreshItemSize();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "labelFont", {
            get: function () {
                return this._labelFont;
            },
            set: function (v) {
                this._labelFont = v;
                this.refreshLabels();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "labelSelectedColor", {
            get: function () {
                return this._labelSelectedColor;
            },
            set: function (v) {
                this._labelSelectedColor = v;
                this.refreshSelected();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "labelColor", {
            get: function () {
                return this._labelColor;
            },
            set: function (v) {
                this._labelColor = v;
                this.refreshSelected();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "labelSize", {
            get: function () {
                return this._labelSize;
            },
            set: function (v) {
                this._labelSize = v;
                this.refreshLabels();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "labelLetterSpacing", {
            get: function () {
                return this._labelLetterSpacing;
            },
            set: function (v) {
                this._labelLetterSpacing = v;
                this.refreshLabels();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "labelAlign", {
            get: function () {
                return this._labelAlign;
            },
            set: function (v) {
                v = Math.floor(v);
                this._labelAlign = v;
                this.refreshLabels();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "labelValign", {
            get: function () {
                return this._labelValign;
            },
            set: function (v) {
                v = Math.floor(v);
                this._labelValign = v;
                this.refreshLabels();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "labelBold", {
            get: function () {
                return this._labelBold;
            },
            set: function (v) {
                this._labelBold = v;
                this.refreshLabels();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "labelItalic", {
            get: function () {
                return this._labelItalic;
            },
            set: function (v) {
                this._labelItalic = v;
                this.refreshLabels();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "labelDx", {
            get: function () {
                return this._labelDx;
            },
            set: function (v) {
                this._labelDx = v;
                this.refreshLabels();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "labelDy", {
            get: function () {
                return this._labelDy;
            },
            set: function (v) {
                this._labelDy = v;
                this.refreshLabels();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "labelStroke", {
            get: function () {
                return this._labelStroke;
            },
            set: function (v) {
                this._labelStroke = v;
                this.refreshLabels();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "labelStrokeColor", {
            get: function () {
                return this._labelStrokeColor;
            },
            set: function (v) {
                this._labelStrokeColor = v;
                this.refreshLabels();
            },
            enumerable: false,
            configurable: true
        });
        UITabBox.prototype.clearItems = function () {
            for (var i = 0; i < this._itemButtons.length; i++) {
                var button = this._itemButtons[i];
                button.dispose();
                var label = this._itemLabels[i];
                label.dispose();
            }
            this._itemButtons = [];
            this._itemLabels = [];
        };
        UITabBox.prototype.refreshItems = function () {
            this.clearItems();
            if (!this.items)
                return;
            var itemArr = this.items.split(",");
            for (var i = 0; i < itemArr.length; i++) {
                var button = new UIComponent.UIButton;
                button["_needLoad"] = false;
                button.clearMouseEvent();
                var label = new UIComponent.UIString;
                label.text = itemArr[i];
                label.valign = 1;
                label.smooth = this.smooth;
                label.overflow = 1;
                button.addChild(label);
                this._tabRoot.addChild(button);
                this._itemLabels.push(label);
                this._itemButtons.push(button);
                if (!Config.EDIT_MODE) {
                    button.add_CLICK(this.setSelectedIndex, this, [i]);
                }
                else {
                    button.mouseEnabled = false;
                    label.mouseEnabled = false;
                }
            }
            this.refreshButtonImage();
            this.refreshItemSize();
            this.refreshLabels();
            this.refreshSelected();
            this.onSelected();
        };
        UITabBox.prototype.refreshItemSize = function () {
            var _width = 433;
            var _height = 41;
            for (var i = 0; i < this._itemButtons.length; i++) {
                var button = this._itemButtons[i];
                var label = this._itemLabels[i];
                label.width = this.itemWidth;
                label.height = this.itemHeight;
                button.width = this.itemWidth;
                button.height = this.itemHeight;
                if (this.rowMode) {
                    button.x = 0;
                    button.y = (this.itemHeight + this.spacing) * i;
                    if (i == this._itemButtons.length - 1) {
                        _width = this.itemWidth;
                        _height = button.y + this.itemHeight;
                    }
                }
                else {
                    button.x = (this.itemWidth + this.spacing) * i;
                    button.y = 0;
                    if (i == this._itemButtons.length - 1) {
                        _width = button.x + this.itemWidth;
                        _height = this.itemHeight;
                    }
                }
            }
            this.width = _width;
            this.height = _height;
        };
        UITabBox.prototype.refreshButtonImage = function (refreshImage) {
            if (refreshImage === void 0) { refreshImage = true; }
            if (this.isDisposed)
                return;
            for (var i = 0; i < this._itemButtons.length; i++) {
                var button = this._itemButtons[i];
                if (refreshImage) {
                    button.image1 = this.itemImage1;
                    button.image2 = this.itemImage2;
                }
                button.grid9img1 = this.grid9img1;
                button.grid9img2 = this.grid9img2;
            }
        };
        UITabBox.prototype.refreshLabels = function () {
            for (var i = 0; i < this._itemButtons.length; i++) {
                var label = this._itemLabels[i];
                label.font = this.labelFont;
                label.fontSize = this.labelSize;
                label.letterSpacing = this.labelLetterSpacing;
                label.bold = this.labelBold;
                label.italic = this.labelItalic;
                label.align = this.labelAlign;
                label.valign = this.labelValign;
                label.stroke = this.labelStroke;
                label.strokeColor = this.labelStrokeColor;
                label.x = this._labelDx;
                label.y = this._labelDy;
            }
        };
        UITabBox.prototype.refreshSelected = function () {
            for (var i = 0; i < this._itemButtons.length; i++) {
                var button = this._itemButtons[i];
                var label = this._itemLabels[i];
                label.color = this.labelColor;
                button.setState(1);
            }
            if (this.selectedIndex < 0 || this.selectedIndex >= this._itemButtons.length)
                return;
            this._itemButtons[this.selectedIndex].setState(2);
            this._itemLabels[this.selectedIndex].color = this.labelSelectedColor;
        };
        UITabBox.prototype.setSelectedIndex = function (v) {
            this.selectedIndex = v;
        };
        UITabBox.prototype.onSelected = function () {
            if (Config.EDIT_MODE)
                return;
            var len = Math.min(this._itemButtons.length, this.numChildren - 1);
            for (var i = 1; i <= len; i++) {
                var btn = this.getChildAt(i);
                btn.visible = false;
            }
            if (this.selectedIndex < 0 || this.selectedIndex >= len)
                return;
            this.getChildAt(this.selectedIndex + 1).visible = true;
        };
        UITabBox.prototype.addChild = function (node) {
            var n = _super.prototype.addChild.call(this, node);
            this.onSelected();
            return n;
        };
        UITabBox.prototype.addChildAt = function (node, index) {
            var n = _super.prototype.addChildAt.call(this, node, index);
            this.onSelected();
            return n;
        };
        UITabBox.prototype.addChildren = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var n = _super.prototype.addChildren.apply(this, args);
            this.onSelected();
        };
        Object.defineProperty(UITabBox.prototype, "onChangeFragEvent", {
            get: function () {
                return this._onChangeFragEvent;
            },
            set: function (v) {
                this._onChangeFragEvent = v;
                if (v) {
                    this.off(EventObject.CHANGE, this, this.onChange_private);
                    this.on(EventObject.CHANGE, this, this.onChange_private);
                }
                else {
                    this.off(EventObject.CHANGE, this, this.onChange_private);
                }
            },
            enumerable: false,
            configurable: true
        });
        UITabBox.prototype.onChange_private = function () {
            if (Config.SINGLE_PLAYER_CORE) {
                if (this._onChangeFragEvent && this.guiRoot && !this.guiRoot.onlyForPreload) {
                    CommandPage.startTriggerFragmentEvent(this._onChangeFragEvent, Game.player.sceneObject, Game.player.sceneObject);
                }
            }
        };
        UITabBox.customCompFunctionNames = ["selectedIndex", "itemImage1", "grid9img1", "itemImage2", "grid9img2", "itemWidth", "itemHeight", "items", "rowMode", "spacing",
            "labelSize", "labelColor", "labelFont", "labelBold", "labelItalic", "smooth", "labelAlign", "labelValign", "labelLetterSpacing", "labelSelectedColor", "labelDx", "labelDy",
            "labelStroke", "labelStrokeColor", "onChangeFragEvent"];
        return UITabBox;
    }(UIComponent.UIBase));
    UIComponent.UITabBox = UITabBox;
})(UIComponent || (UIComponent = {}));















(function (UIComponent) {
    var UIVariable = (function (_super) {
        __extends(UIVariable, _super);
        function UIVariable() {
            var _this_1 = _super.call(this) || this;
            _this_1.className = "UIVariable";
            _this_1._tf.text = "";
            return _this_1;
        }
        UIVariable.prototype.dispose = function () {
            if (!this.isDisposed) {
                if (!Config.EDIT_MODE) {
                    var varID = this._lastVarID;
                    if (varID != 0 && this.className == "UIVariable" && Game.player) {
                        Game.player.removeListenerPlayerVariable(0, varID, this._onVarChange);
                    }
                }
            }
            _super.prototype.dispose.call(this);
        };
        UIVariable.prototype.inEditorInit = function () {
            _super.prototype.inEditorInit.call(this);
            this.varID = 1;
            this.installDefaultValue();
        };
        Object.defineProperty(UIVariable.prototype, "text", {
            get: function () {
                return this._tf.text;
            },
            set: function (v) {
                if (this.isDisposed)
                    return;
                if (Config.EDIT_MODE) {
                    var varID = GameUtils.getVarID(v);
                    if (varID != 0) {
                        setText.call(this, v);
                        return;
                    }
                }
                if (!Config.EDIT_MODE) {
                    var varID = GameUtils.getVarID(v);
                    if (varID != 0) {
                        this._tf.changeText("");
                        if (this._shadowEnabled) {
                            this._tf2.color = this._shadowColor;
                            this._tf2.changeText("");
                        }
                        if (this._lastVarID != 0)
                            Game.player.removeListenerPlayerVariable(0, this._lastVarID, this._onVarChange);
                        if (this.displayedInStage)
                            Game.player.addListenerPlayerVariable(0, varID, this._onVarChange);
                        this._lastVarID = varID;
                    }
                    else {
                        setText.call(this, v);
                    }
                }
                else {
                    setText.call(this, v);
                }
                function setText(v) {
                    if (this.__forceChange) {
                        this._tf.changeText(v);
                    }
                    else {
                        this._tf.text = v;
                    }
                    if (this._shadowEnabled) {
                        this._tf2.color = this._shadowColor;
                        if (this.__forceChange) {
                            this._tf2.changeText(this._tf.text);
                        }
                        else {
                            this._tf2.text = this._tf.text;
                        }
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        UIVariable.prototype.inEditorInfo = function () {
            var varName = GameListData.getName(Game.data.playerVariableNameList, this.varID);
            return "[" + MathUtils.fixIntDigit(this.varID) + ":" + varName + "]";
        };
        UIVariable.prototype.onAdded = function (e) {
            if (this.varID == 0)
                return;
            Game.player.addListenerPlayerVariable(0, this.varID, this._onVarChange);
        };
        UIVariable.prototype.onRemoved = function (e) {
            if (this.varID == 0)
                return;
            Game.player.removeListenerPlayerVariable(0, this.varID, this._onVarChange);
        };
        UIVariable.prototype.onVarChange = function (typeID, varID, value) {
            this._tf.text = value.toString();
            if (this._shadowEnabled) {
                this._tf2.color = this._shadowColor;
                this._tf2.text = this._tf.text;
            }
        };
        UIVariable.customCompFunctionNames = ["varID", "fontSize", "color", "bold", "italic", "smooth", "align", "valign", "leading", "letterSpacing",
            "font", "wordWrap", "overflow", "shadowEnabled", "shadowColor", "shadowDx", "shadowDy", "stroke", "strokeColor", "onChangeFragEvent", "textWidth", "textHeight", "textLength"];
        return UIVariable;
    }(UIComponent.UIString));
    UIComponent.UIVariable = UIVariable;
})(UIComponent || (UIComponent = {}));















(function (UIComponent) {
    var UIVideo = (function (_super) {
        __extends(UIVideo, _super);
        function UIVideo(editorCompMode) {
            if (editorCompMode === void 0) { editorCompMode = true; }
            var _this_1 = _super.call(this) || this;
            _this_1._videoURL = "";
            _this_1._muted = false;
            _this_1._playbackRate = 1;
            _this_1._volume = 1;
            _this_1._currentTime = 0;
            _this_1._loop = false;
            _this_1._playType = 0;
            _this_1.isPlaying = false;
            _this_1.className = "UIVideo";
            if (Config.EDIT_MODE && editorCompMode) {
                _this_1.editorCompMode = true;
            }
            _this_1._dpTextureWidth = 1000;
            _this_1._dpTextureHeight = 1000;
            _this_1.width = 1000;
            _this_1.height = 1000;
            _this_1._uiImage.width = _this_1.width;
            _this_1._uiImage.height = _this_1.height;
            _this_1._dpDirty = true;
            _this_1.onResize();
            if (_this_1.editorCompMode) {
                return _this_1;
            }
            if (Config.EDIT_MODE) {
                _this_1.add_DISPLAY(_this_1.onAdded, _this_1);
                _this_1.add_UNDISPLAY(_this_1.onRemoved, _this_1);
            }
            var __this = _this_1;
            var video = _this_1.videoElement = document.createElement("video");
            if (os.platform != 2 && os.platform != 4) {
                video.muted = true;
                os.canvas.addEventListener("click", function () {
                    if (!__this.muted)
                        video.muted = false;
                    __this.canSetMuted = true;
                    os.canvas.removeEventListener("click", arguments.callee);
                });
            }
            video.style.position = "absolute";
            video.style.zIndex = "9999999999";
            video.width = 1;
            video.height = 1;
            video.style.opacity = "0.1";
            video.addEventListener("loadedmetadata", function () {
                __this.event(EventObject.LOADED);
                if (__this.stage && __this.videoElement && __this._playType == 0 && !__this._metaDataLoaded) {
                    __this.videoElement.play();
                    __this.isPlaying = true;
                    __this.event(UIVideo.PLAY_START);
                }
                __this._metaDataLoaded = true;
                if (__this.videoTex && __this.videoTex.bitmap)
                    __this.videoTex.bitmap.activeResource();
                stage.on(EventObject.RENDER, __this, __this.onVideoRender);
            });
            video.addEventListener("error", function () {
                __this.event(EventObject.ERROR);
            });
            video.addEventListener("ended", function () {
                __this.isPlaying = false;
                __this.event(EventObject.COMPLETE);
            });
            var tex = _this_1.videoTex = new Texture(video);
            _this_1.videoTex.bitmap.size(1, 1);
            _this_1.texture = tex;
            return _this_1;
        }
        UIVideo.prototype.clear = function () {
            this._playType = 0;
            this._metaDataLoaded = false;
            stage.off(EventObject.RENDER, this, this.onVideoRender);
        };
        UIVideo.prototype.dispose = function () {
            if (!this.isDisposed) {
                this.clear();
                if (this.videoTex) {
                    this.videoTex.bitmap.disposeResource();
                    this.videoTex.destroy(true);
                    this.videoTex = null;
                }
                if (this.videoElement) {
                    this.videoElement.removeEventListener("loadedmetadata", arguments.callee);
                    this.videoElement.removeEventListener("error", arguments.callee);
                    this.videoElement.removeEventListener("ended", arguments.callee);
                    this.pause();
                    this.videoElement.src = null;
                    this.videoElement["srcObject"] = null;
                    if (this.videoElement.parentNode)
                        document.body.removeChild(this.videoElement);
                    this.videoElement = null;
                }
            }
            _super.prototype.dispose.call(this);
        };
        UIVideo.prototype.inEditorInit = function () {
            this.width = 100;
            this.height = 100;
            this.installDefaultValue();
        };
        UIVideo.prototype.loadAssetTest = function () {
            this.event(GameUI.EVENT_TEST_LOAD_CHILD_UI);
        };
        Object.defineProperty(UIVideo.prototype, "duration", {
            get: function () {
                if (!this.videoElement)
                    return NaN;
                return this.videoElement.duration;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIVideo.prototype, "networkState", {
            get: function () {
                if (!this.videoElement)
                    return 0;
                return this.videoElement.networkState;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIVideo.prototype, "videoURL", {
            get: function () {
                return this._videoURL;
            },
            set: function (v) {
                this._videoURL = v;
                if (!this.videoElement)
                    return;
                this._metaDataLoaded = false;
                this.videoElement.src = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIVideo.prototype, "playbackRate", {
            get: function () {
                return this._playbackRate;
            },
            set: function (v) {
                this._playbackRate = v;
                if (!this.videoElement)
                    return;
                this.videoElement.playbackRate = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIVideo.prototype, "volume", {
            get: function () {
                return this._volume;
            },
            set: function (v) {
                this._volume = v;
                if (!this.videoElement)
                    return;
                this.videoElement.volume = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIVideo.prototype, "currentTime", {
            get: function () {
                if (!this.videoElement)
                    return this._currentTime;
                return this.videoElement.currentTime;
            },
            set: function (v) {
                this._currentTime = v;
                if (!this.videoElement)
                    return;
                this.videoElement.currentTime = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIVideo.prototype, "playType", {
            get: function () {
                return this._playType;
            },
            set: function (v) {
                this._playType = v;
                if (v == 0) {
                    this.play();
                }
                else if (v == 1) {
                    this.stop();
                }
                else {
                    this.pause();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIVideo.prototype, "muted", {
            get: function () {
                return this._muted;
            },
            set: function (v) {
                this._muted = v;
                if (!this.videoElement)
                    return;
                if (this._muted) {
                    this.videoElement.muted = true;
                }
                else {
                    if (os.platform == 2 || this.canSetMuted)
                        this.videoElement.muted = false;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIVideo.prototype, "loop", {
            get: function () {
                return this._loop;
            },
            set: function (v) {
                this._loop = v;
                if (!this.videoElement)
                    return;
                this.videoElement.loop = v;
            },
            enumerable: false,
            configurable: true
        });
        UIVideo.prototype.play = function () {
            this._playType = 0;
            if (!this.videoElement)
                return;
            if (this.stage && this._metaDataLoaded) {
                this.isPlaying = true;
                this.videoElement.play();
                this.event(UIVideo.PLAY_START);
            }
        };
        UIVideo.prototype.stop = function () {
            this._playType = 1;
            if (!this.videoElement)
                return;
            this.videoElement.load();
            this.isPlaying = false;
            this.event(UIVideo.PLAY_STOP);
        };
        UIVideo.prototype.pause = function (changePlayState) {
            if (changePlayState === void 0) { changePlayState = true; }
            if (changePlayState)
                this._playType = 2;
            if (!this.videoElement)
                return;
            this.videoElement.pause();
            this.isPlaying = false;
            this.event(UIVideo.PLAY_PAUSE);
        };
        UIVideo.prototype.onResize = function () {
            Callback.CallLaterBeforeRender(this.doResize, this);
            _super.prototype.onResize.call(this);
        };
        UIVideo.prototype.doResize = function () {
            if (this.isDisposed)
                return;
            if (this.editorCompMode) {
                this.graphics.clear();
                if (this.useDPCoord) {
                    var scale = Math.max(this.scaleX, this.scaleY);
                    if (scale != 0) {
                        this.graphics.drawRect(0, 0, this.width, this.height, "#000000", "#EEEEEE", Math.ceil(5 / scale));
                    }
                }
                else {
                    this.graphics.drawRect(0, 0, this.width, this.height, "#000000", "#EEEEEE", 2);
                }
            }
            if (this.videoElement && this.videoTex.bitmap) {
                this.videoTex.bitmap.size(this.width, this.height);
            }
        };
        UIVideo.prototype.onVideoRender = function () {
            if (!this.videoTex)
                return;
            this.videoTex.bitmap.reloadCanvasData();
            if (this.getMaterialPassLength() > 0) {
                var materialPassages = this.getAllMaterialDatas();
                for (var i_18 = 0; i_18 < materialPassages.length; i_18++) {
                    var ms = materialPassages[i_18];
                    if (ms.materials && ms.materials.length > 0) {
                        this.setMaterialDirty();
                        break;
                    }
                }
            }
        };
        UIVideo.prototype.onAdded = function (e) {
            if (!this.videoElement)
                return;
            this.playType = this.playType;
            if (!this.videoElement.parentNode)
                document.body.appendChild(this.videoElement);
        };
        UIVideo.prototype.onRemoved = function (e) {
            if (!this.videoElement)
                return;
            this.pause(false);
            if (this.videoElement.parentNode)
                document.body.removeChild(this.videoElement);
        };
        Object.defineProperty(UIVideo.prototype, "onLoadedFragEvent", {
            get: function () {
                return this._onLoadedFragEvent;
            },
            set: function (v) {
                this._onLoadedFragEvent = v;
                if (v) {
                    this.off(EventObject.LOADED, this, this.onLoaded_private);
                    this.on(EventObject.LOADED, this, this.onLoaded_private);
                }
                else {
                    this.off(EventObject.LOADED, this, this.onLoaded_private);
                }
            },
            enumerable: false,
            configurable: true
        });
        UIVideo.prototype.onLoaded_private = function () {
            if (Config.SINGLE_PLAYER_CORE && this._onLoadedFragEvent && this.guiRoot && !this.guiRoot.onlyForPreload) {
                CommandPage.startTriggerFragmentEvent(this._onLoadedFragEvent, Game.player.sceneObject, Game.player.sceneObject);
            }
        };
        Object.defineProperty(UIVideo.prototype, "onErrorFragEvent", {
            get: function () {
                return this._onErrorFragEvent;
            },
            set: function (v) {
                this._onErrorFragEvent = v;
                if (v) {
                    this.off(EventObject.ERROR, this, this.onError_private);
                    this.on(EventObject.ERROR, this, this.onError_private);
                }
                else {
                    this.off(EventObject.ERROR, this, this.onError_private);
                }
            },
            enumerable: false,
            configurable: true
        });
        UIVideo.prototype.onError_private = function () {
            if (Config.SINGLE_PLAYER_CORE && this._onErrorFragEvent && this.guiRoot && !this.guiRoot.onlyForPreload) {
                CommandPage.startTriggerFragmentEvent(this._onErrorFragEvent, Game.player.sceneObject, Game.player.sceneObject);
            }
        };
        Object.defineProperty(UIVideo.prototype, "onCompleteFragEvent", {
            get: function () {
                return this._onCompleteFragEvent;
            },
            set: function (v) {
                this._onCompleteFragEvent = v;
                if (v) {
                    this.off(EventObject.COMPLETE, this, this.onComplete_private);
                    this.on(EventObject.COMPLETE, this, this.onComplete_private);
                }
                else {
                    this.off(EventObject.COMPLETE, this, this.onComplete_private);
                }
            },
            enumerable: false,
            configurable: true
        });
        UIVideo.prototype.onComplete_private = function () {
            if (Config.SINGLE_PLAYER_CORE && this._onCompleteFragEvent && this.guiRoot && !this.guiRoot.onlyForPreload) {
                CommandPage.startTriggerFragmentEvent(this._onCompleteFragEvent, Game.player.sceneObject, Game.player.sceneObject);
            }
        };
        UIVideo.PLAY_START = "UIVideo_PLAY_START";
        UIVideo.PLAY_STOP = "UIVideo_PLAY_STOP";
        UIVideo.PLAY_PAUSE = "UIVideo_PLAY_PAUSE";
        UIVideo.customCompFunctionNames = ["videoURL", "playType", "volume", "playbackRate", "currentTime", "muted", "loop", "pivotType", "flip", "onLoadedFragEvent", "onErrorFragEvent", "onCompleteFragEvent", "duration", "networkState", "isPlaying"];
        return UIVideo;
    }(UIComponent.UIBitmap));
    UIComponent.UIVideo = UIVideo;
})(UIComponent || (UIComponent = {}));















var Avatar = (function (_super) {
    __extends(Avatar, _super);
    function Avatar() {
        var _this_1 = _super.call(this) || this;
        _this_1.autoID = ObjectUtils.getInstanceID();
        _this_1.isLoading = false;
        _this_1._loadState = 0;
        _this_1.picUrls = [];
        _this_1.oriMode = 8;
        _this_1._fps = 12;
        _this_1._currentFrame = 1;
        _this_1.ori = 2;
        _this_1.actIndex = -1;
        _this_1.actID = 0;
        _this_1.actionListArr = [];
        _this_1.avatarList = [];
        _this_1._body = new GameSprite();
        _this_1._bodyGraphics = new GameSprite();
        _this_1.autoFlip = true;
        _this_1._actionPlayCompleteRecord = 0;
        _this_1._refObjs = {};
        _this_1.helperType = 0;
        _this_1.helperSetting = {};
        _this_1.syncLoadWhenAssetExist = !Config.EDIT_MODE;
        _this_1.addChild(_this_1._body);
        _this_1._body.addChild(_this_1._bodyGraphics);
        return _this_1;
    }
    Object.defineProperty(Avatar.prototype, "gameDataAvatarList", {
        get: function () {
            return Common.avatarList;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Avatar.prototype, "gameDataAvatarURL", {
        get: function () {
            return "asset/json/avatar/data/avatar";
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Avatar.prototype, "disposeAvatarAsset", {
        get: function () {
            return AssetManager.disposeAvatarAsset;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Avatar.prototype, "myClass", {
        get: function () {
            return Avatar;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Avatar.prototype, "id", {
        get: function () { return this._id; },
        set: function (v) {
            if (this.isDisposed || v < 0)
                return;
            if (v == this.id)
                return;
            this.___disposeAsset();
            this._id = v;
            this._loadIDRD = Math.random();
            this.loadData(v, this._loadIDRD);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Avatar.prototype, "fps", {
        get: function () { return this._fps; },
        set: function (v) {
            v = MathUtils.int(v);
            if (this._fps == v)
                return;
            this._fps = v <= 0 ? 1 : v;
            for (var i = 0; i < this.avatarList.length; i++) {
                var avatarPart = this.avatarList[i];
                if (avatarPart == this)
                    continue;
                avatarPart.fps = v;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Avatar.prototype, "currentFrame", {
        get: function () {
            return this._currentFrame;
        },
        set: function (v) {
            this.setCurrentFrame(v);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Avatar.prototype, "refObjs", {
        get: function () {
            if (Config.EDIT_MODE)
                return this._refObjs;
            else
                return this.currentFrameRefObjs;
        },
        set: function (helpers) {
            this._refObjs = helpers;
        },
        enumerable: false,
        configurable: true
    });
    Avatar.prototype.loadData = function (avatarID, loadIDRD, topAvatar) {
        var _this_1 = this;
        if (topAvatar === void 0) { topAvatar = null; }
        this.isLoading = true;
        if (!Config.EDIT_MODE && avatarID == 0) {
            this.isLoading = false;
            this.clear();
            Callback.New(this.event, this, [EventObject.LOADED]).delayRun(0);
            return;
        }
        if (Config.EDIT_MODE) {
            var avatarList = this.gameDataAvatarList;
            this.parseData(avatarList.data[avatarID], avatarList, loadIDRD, topAvatar);
        }
        else {
            this._loadState = 1;
            this.___loadJsonURL = this.gameDataAvatarURL + avatarID + ".json";
            AssetManager.loadJson(this.___loadJsonURL, Callback.New(function (avatarJson) {
                _this_1.parseData(avatarJson, null, loadIDRD, topAvatar);
            }, this), this.syncLoadWhenAssetExist);
        }
    };
    Avatar.prototype.clear = function (clearTexture) {
        if (clearTexture === void 0) { clearTexture = true; }
        for (var i = 0; i < this.avatarList.length; i++) {
            var avatarPart = this.avatarList[i];
            if (avatarPart == this)
                continue;
            this.removePart(avatarPart);
            i--;
        }
        if (clearTexture)
            this._bodyGraphics.texture = null;
        this.actionListArr = [];
    };
    Avatar.prototype.parseData = function (avatarJson, avatarListData, loadIDRD, topAvatar) {
        var _this_1 = this;
        if (avatarListData === void 0) { avatarListData = null; }
        if (loadIDRD === void 0) { loadIDRD = null; }
        if (topAvatar === void 0) { topAvatar = null; }
        var loadRandName = "loadAvatar" + this.autoID;
        this._id = avatarJson ? avatarJson.id : null;
        this.topAvatar = topAvatar ? topAvatar : this;
        if (this.isDisposed || this.topAvatar.isDisposed || (loadIDRD && this._loadIDRD != loadIDRD)) {
            this.event(Avatar.LOAD_EXPIRE);
            return;
        }
        if (!avatarJson) {
            if (Config.EDIT_MODE && Common.avatarList.data[0]) {
                this.parseData(Common.avatarList.data[0], Common.avatarList, loadIDRD);
                return;
            }
            this.clear(false);
            this.event(EventObject.LOADED);
            return;
        }
        var oriArr = [1, 2, 3, 4, 6, 7, 8, 9];
        this.picUrls = avatarJson.picUrls;
        var h = Callback.New(function () {
            if (_this_1.isDisposed || _this_1.topAvatar.isDisposed || (loadIDRD && _this_1._loadIDRD != loadIDRD)) {
                _this_1.event(Avatar.LOAD_EXPIRE);
                return;
            }
            _this_1.clear(false);
            _this_1.oriMode = avatarJson.oriMode;
            if (avatarJson.autoFlip == null)
                avatarJson.autoFlip = true;
            if (avatarJson.id == 0)
                avatarJson.autoFlip = false;
            _this_1.autoFlip = avatarJson.autoFlip;
            _this_1.helperType = avatarJson.helperType;
            _this_1.name = avatarJson.name;
            for (var i = 0; i < avatarJson.actionListArr.length; i++) {
                var actData = avatarJson.actionListArr[i];
                var act = new AvatarAction();
                act.id = actData.id;
                act.oriMode = avatarJson.oriMode;
                var frameImageInfoData = actData.frameImageInfo;
                for (var s = 0; s < frameImageInfoData.length; s++) {
                    var oriActData = frameImageInfoData[s];
                    var ori = GameUtils.getOriByIndex(s, _this_1.oriMode);
                    act.frameImageInfo[ori] = [];
                    for (var f = 0; f < oriActData.length; f++) {
                        var frameData = oriActData[f];
                        var aImg = new AvatarFrameImage();
                        aImg.index = f;
                        aImg.picUrlIndex = frameData.picUrlIndex;
                        frameData.rect[2] = frameData.rect[2] ? frameData.rect[2] : 1;
                        frameData.rect[3] = frameData.rect[3] ? frameData.rect[3] : 1;
                        aImg.rect = new Rectangle(frameData.rect[0], frameData.rect[1], frameData.rect[2], frameData.rect[3]);
                        aImg.x = frameData.x;
                        aImg.y = frameData.y;
                        aImg.width = isNaN(frameData.width) ? frameData.rect[2] : frameData.width;
                        aImg.height = isNaN(frameData.height) ? frameData.rect[3] : frameData.height;
                        aImg.rotation = frameData.rotation ? frameData.rotation : 0;
                        if (frameData.alpha == null)
                            frameData.alpha = 1;
                        aImg.alpha = frameData.alpha;
                        aImg.hue = frameData.hue;
                        aImg.blur = frameData.blur;
                        aImg.tonal_r = frameData.tonal_r;
                        aImg.tonal_g = frameData.tonal_g;
                        aImg.tonal_b = frameData.tonal_b;
                        aImg.tonal_gray = frameData.tonal_gray;
                        aImg.tonal_mr = frameData.tonal_mr;
                        aImg.tonal_mg = frameData.tonal_mg;
                        aImg.tonal_mb = frameData.tonal_mb;
                        aImg.wait_type = frameData.wait_type;
                        aImg.wait_count = frameData.wait_count;
                        aImg.isAnchor = frameData.isAnchor;
                        aImg.anchorX = frameData.anchorX;
                        aImg.anchorY = frameData.anchorY;
                        aImg.frameHelper = frameData.frameHelper;
                        var imgUrl = _this_1.picUrls[aImg.picUrlIndex];
                        var tex = AssetManager.getClipTexture(imgUrl, -aImg.rect.x, -aImg.rect.y, aImg.rect.width, aImg.rect.height);
                        aImg.tex = tex;
                        act.frameImageInfo[ori][f] = aImg;
                    }
                }
                _this_1.actionListArr[i] = act;
            }
            if (avatarJson.refObjs)
                _this_1.refObjs = avatarJson.refObjs;
            if (avatarJson.helperSetting)
                _this_1.helperSetting = avatarJson.helperSetting;
            _this_1.selfCenterlineAlignMode = avatarJson.selfCenterlineAlignMode;
            if (!Config.EDIT_MODE && avatarJson.refObjs && JSON.stringify(avatarJson.refObjs) != "{}" && _this_1.helperType)
                Avatar.generateAllframeHelper(_this_1.actionListArr, _this_1.refObjs);
            for (var i = 0; i < avatarJson.parts.length; i++) {
                var partData = ObjectUtils.depthClone(avatarJson.parts[i]);
                if (partData.id == 0) {
                    if (!_this_1.partData)
                        _this_1.partData = partData;
                    _this_1.addChild(_this_1._body);
                    _this_1.avatarList.push(_this_1);
                    continue;
                }
                new SyncTask(loadRandName);
                var avatarPart = new _this_1.myClass();
                avatarPart.prerender = _this_1.prerender;
                avatarPart.syncLoadWhenAssetExist = _this_1.syncLoadWhenAssetExist;
                avatarPart._loadIDRD = loadIDRD;
                avatarPart.once(EventObject.LOADED, _this_1, function (loadRandName, i, partData) {
                    SyncTask.taskOver(loadRandName);
                }, [loadRandName, i, partData]);
                avatarPart.once(Avatar.LOAD_EXPIRE, _this_1, function (loadRandName, i, partData) {
                    SyncTask.taskOver(loadRandName);
                }, [loadRandName, i, partData]);
                avatarPart.partData = partData;
                if (avatarListData) {
                    avatarPart.parseData(avatarListData.data[partData.id], avatarListData, loadIDRD);
                }
                else {
                    avatarPart.loadData(partData.id, loadIDRD, topAvatar);
                }
                _this_1.addPart(avatarPart);
                var avatarPartobj = {};
                ObjectUtils.clone(partData, avatarPartobj);
                delete avatarPartobj["id"];
                ObjectUtils.clone(avatarPartobj, avatarPart);
            }
            _this_1._loadState = 3;
            new SyncTask(loadRandName, function (loadRandName) {
                if (this.isDisposed || this.topAvatar.isDisposed || (loadIDRD && this._loadIDRD != loadIDRD)) {
                    this.event(Avatar.LOAD_EXPIRE);
                    SyncTask.taskOver(loadRandName);
                    return;
                }
                if (this._openAutoHitArea) {
                    this.openAutoHitArea(this._openAutoHitAreaForce);
                }
                if (!loadIDRD || loadIDRD == this._loadIDRD) {
                    this.isLoading = false;
                }
                if (this.actIndex != -1) {
                    this.actionIndex = this.actIndex;
                }
                else if (this.actID != 0) {
                    this.actionID = this.actID;
                }
                else {
                    this.actionID = 1;
                }
                this.delayOnRender(false, true, null, false);
                if (!loadIDRD || loadIDRD == this._loadIDRD) {
                    this.event(EventObject.LOADED);
                }
                SyncTask.clear(loadRandName);
            }, [loadRandName], _this_1);
        }, this);
        this._loadState = 2;
        AssetManager.loadImages(this.picUrls, h, this.syncLoadWhenAssetExist, true, this.prerender);
    };
    Avatar.prototype.dispose = function () {
        if (!this.isDisposed) {
            this.___clearTask();
            this.stop(0, false);
            this.___disposeAsset();
            this.avatarList = [];
            this._bodyGraphics.dispose();
            this._bodyGraphics = null;
            this._body.dispose();
            this._body = null;
            this.topAvatar = null;
        }
        _super.prototype.dispose.call(this);
    };
    Avatar.prototype.___clearTask = function () {
        SyncTask.clear("loadAvatar" + this.autoID);
        for (var i = 0; i < this.avatarList.length; i++) {
            var avatarPart = this.avatarList[i];
            if (avatarPart == this)
                continue;
            avatarPart.___clearTask();
        }
    };
    Avatar.prototype.___disposeAsset = function () {
        if (this._loadState == 3) {
            for (var i = 0; i < this.avatarList.length; i++) {
                var avatarPart = this.avatarList[i];
                if (avatarPart == this)
                    continue;
                avatarPart.___disposeAsset();
                avatarPart.__isDisposed = true;
            }
            AssetManager.disposeJson(this.___loadJsonURL);
            AssetManager.disposeImages(this.picUrls);
        }
        else if (this._loadState == 2) {
            AssetManager.disposeJson(this.___loadJsonURL);
            AssetManager.disposeImages(this.picUrls);
        }
        else if (this._loadState == 1) {
            AssetManager.disposeJson(this.___loadJsonURL);
        }
        this._loadState = 0;
    };
    Object.defineProperty(Avatar.prototype, "realBound", {
        get: function () {
            if (this.isDisposed)
                return;
            var myRect = this.getSelfBounds();
            return myRect;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Avatar.prototype, "orientation", {
        get: function () {
            return this.ori;
        },
        set: function (v) {
            if (this.fixedOrientation)
                return;
            if ((v != 8 && v != 2) || this.oriMode > 2) {
                this.userChangeOrientation = true;
                for (var i in this.avatarList) {
                    if (this.avatarList[i] == this)
                        continue;
                    this.avatarList[i].orientation = v;
                }
                this.ori = v;
                this.delayOnRender(false);
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Avatar.prototype, "actionIndex", {
        get: function () {
            return this.actIndex;
        },
        set: function (index) {
            var lastActID = this.actionID;
            var oldActionIndex = this.actIndex;
            this.actIndex = index;
            this.waitRender_waitCount = null;
            var act = this.actionList[index];
            for (var i = 0; i < this.avatarList.length; i++) {
                var avatarPart = this.avatarList[i];
                if (avatarPart == this)
                    continue;
                if (act) {
                    avatarPart.actionID = act.id;
                }
                else {
                    avatarPart.actionIndex = index;
                }
            }
            if (oldActionIndex != this.actIndex) {
                this.event(Avatar.CHANGE_ACTION, [lastActID, this.actionID]);
            }
            this.delayOnRender(false);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Avatar.prototype, "actionID", {
        get: function () {
            var avatarAct = this.actionListArr[this.actIndex];
            return avatarAct ? avatarAct.id : this.actID;
        },
        set: function (id) {
            var lastActID = this.actionID;
            this.actID = id;
            this.waitRender_waitCount = null;
            var arr = ArrayUtils.matchAttributes(this.actionListArr, { id: id }, true);
            if (arr.length == 0) {
                this.actionIndex = -1;
                return;
            }
            ;
            var avatarAct = arr[0];
            var index = this.actionListArr.indexOf(avatarAct);
            var oldActionIndex = this.actIndex;
            this.actIndex = index;
            for (var i = 0; i < this.avatarList.length; i++) {
                var avatarPart = this.avatarList[i];
                if (avatarPart == this)
                    continue;
                avatarPart.actionID = id;
            }
            if (oldActionIndex != this.actIndex) {
                this.event(Avatar.CHANGE_ACTION, [lastActID, id]);
            }
            this.delayOnRender(false);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Avatar.prototype, "actionList", {
        get: function () {
            return this.actionListArr;
        },
        enumerable: false,
        configurable: true
    });
    Avatar.prototype.hasActionID = function (actionID) {
        return ArrayUtils.matchAttributes(this.actionListArr, { id: actionID }, true)[0] != null;
    };
    Avatar.prototype.changePart = function (avatar, partIndex) {
        var oldAvatar = this.avatarList[partIndex];
        var idx = this.getChildIndex(oldAvatar);
        this.removeChildAt(idx);
        this.addChildAt(avatar, idx);
        avatar.orientation = this.orientation;
        avatar.actionID = this.actionID;
        this.avatarList[partIndex] = avatar;
    };
    Avatar.prototype.addPart = function (avatar, partIndex) {
        if (partIndex === void 0) { partIndex = -1; }
        if (partIndex == -1) {
            this.avatarList.push(avatar);
            this.addChild(avatar);
        }
        else {
            this.avatarList.splice(partIndex, 0, avatar);
            this.addChildAt(avatar, partIndex);
        }
        avatar.fps = this.fps;
        avatar.orientation = this.orientation;
        avatar.actionID = this.actionID;
        return partIndex == -1 ? this.avatarList.length - 1 : partIndex;
    };
    Avatar.prototype.removePart = function (avatar, isDispose) {
        if (isDispose === void 0) { isDispose = false; }
        var partIdx = this.avatarList.indexOf(avatar);
        this.avatarList.splice(partIdx, 1);
        this.removeChild(avatar);
        if (isDispose)
            avatar.dispose();
        return partIdx;
    };
    Avatar.prototype.removePartAt = function (partIndex, isDispose) {
        if (isDispose === void 0) { isDispose = false; }
        var avatar = this.avatarList.splice(partIndex, 1)[0];
        if (isDispose)
            avatar.dispose();
        this.removeChild(avatar);
    };
    Avatar.prototype.addPartByAvatar = function (partID, part, partIndex) {
        if (partIndex === void 0) { partIndex = -1; }
        if (this.isLoading)
            return;
        if (!(part instanceof Avatar))
            return;
        if (this.getPartByPartID(partID))
            return;
        if (!part.partData)
            part.partData = {};
        part.partData.id = part.id;
        part.partData.partID = partID;
        if (partIndex == -1) {
            this.avatarList.push(part);
            this.addChild(part);
        }
        else {
            this.avatarList.splice(partIndex, 0, part);
            this.addChildAt(part, partIndex);
        }
        part.fps = this.fps;
        part.orientation = this.orientation;
        part.actionID = this.actionID;
        part.topAvatar = this.topAvatar;
        if (this._openAutoHitArea)
            part.openAutoHitArea();
        return true;
    };
    Avatar.prototype.addPartByID = function (partID, avatarID, partIndex) {
        if (partIndex === void 0) { partIndex = -1; }
        if (this.isLoading)
            return;
        if (this.getPartByPartID(partID))
            return;
        var newAvatar = new this.myClass();
        newAvatar.id = avatarID;
        return this.addPartByAvatar(partID, newAvatar);
    };
    Avatar.prototype.removePartByPartID = function (partID, disposeOldPart) {
        if (disposeOldPart === void 0) { disposeOldPart = true; }
        if (this.isLoading)
            return;
        var part = this.getPartByPartID(partID);
        if (!part)
            return null;
        if (this.removePartByAvatar(part, disposeOldPart))
            return part;
        else
            return null;
    };
    Avatar.prototype.removePartByAvatar = function (part, disposeOldPart) {
        if (disposeOldPart === void 0) { disposeOldPart = true; }
        if (this.isLoading)
            return;
        var partIdx = this.avatarList.indexOf(part);
        if (partIdx == -1)
            return false;
        this.avatarList.splice(partIdx, 1);
        this.removeChild(part);
        if (disposeOldPart)
            part.dispose();
        else
            part.topAvatar = part;
        return true;
    };
    Avatar.prototype.changePartByAvatar = function (newPart, partID) {
        if (this.isLoading)
            return;
        if (!(newPart instanceof Avatar))
            return;
        var success = false;
        for (var i = 0; i < this.PartLength; i++) {
            var part = this.avatarList[i];
            if (part == this)
                continue;
            if (part.partData.partID == partID) {
                if (!newPart.partData)
                    newPart.partData = {};
                newPart.partData.id = newPart.id;
                newPart.partData.partID = partID;
                var oldPartIndex = this.getChildIndex(part);
                this.addChildAt(newPart, oldPartIndex);
                var oldPart = this.removeChildAt(oldPartIndex + 1);
                if (oldPart) {
                    var avatarPartobj = {};
                    ObjectUtils.clone(oldPart.partData, avatarPartobj);
                    delete avatarPartobj["id"];
                    ObjectUtils.cloneExcludeNonExistentAttribute(oldPart, avatarPartobj);
                    ObjectUtils.clone(avatarPartobj, newPart);
                    ObjectUtils.clone(avatarPartobj, newPart.partData);
                    oldPart.dispose();
                }
                this.avatarList[i] = newPart;
                newPart.fps = this.fps;
                newPart.orientation = this.orientation;
                newPart.actionID = this.actionID;
                if (this._openAutoHitArea)
                    newPart.openAutoHitArea();
                success = true;
                break;
            }
        }
        return success;
    };
    Avatar.prototype.changePartByAvatarID = function (newAvatarID, partID) {
        if (this.isLoading)
            return;
        if (!this.getPartByPartID(partID))
            return;
        var newPart = new this.myClass();
        newPart.syncLoadWhenAssetExist = true;
        newPart.id = newAvatarID;
        return this.changePartByAvatar(newPart, partID);
    };
    Avatar.prototype.getPartByPartID = function (partID) {
        return ArrayUtils.matchAttributesD2(this.avatarList, "partData", { partID: partID }, true)[0];
    };
    Avatar.prototype.getPartAt = function (partIndex) {
        return this.avatarList[partIndex];
    };
    Avatar.prototype.getPartByID = function (avatarID) {
        var m = ArrayUtils.matchAttributes(this.avatarList, { id: avatarID }, true, "==");
        return m[0];
    };
    Avatar.prototype.getPartIndex = function (avatar) {
        return this.avatarList.indexOf(avatar);
    };
    Object.defineProperty(Avatar.prototype, "PartLength", {
        get: function () {
            return this.avatarList.length;
        },
        enumerable: false,
        configurable: true
    });
    Avatar.prototype.setCurrentFrame = function (v) {
        if (v <= 1)
            v = 1;
        this._currentFrame = v;
        this.waitRender_waitCount = null;
        this.resetFrameState();
        for (var i = 0; i < this.avatarList.length; i++) {
            var avatarPart = this.avatarList[i];
            if (avatarPart == this)
                continue;
            avatarPart.setCurrentFrame(v);
        }
        this.delayOnRender(false, true, v);
    };
    Avatar.prototype.getCurrentFrame = function () {
        return this._currentFrame;
    };
    Object.defineProperty(Avatar.prototype, "frameCount", {
        get: function () {
            var avatarAct = this.actionListArr[this.actIndex];
            return avatarAct ? avatarAct.getFrameLength(this.ori, true) : 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Avatar.prototype, "totalFrame", {
        get: function () {
            return this.frameCount;
        },
        enumerable: false,
        configurable: true
    });
    Avatar.prototype.gotoAndPlay = function (frame) {
        if (frame === void 0) { frame = 1; }
        if (frame <= 1)
            frame = 1;
        this.setCurrentFrame(frame);
        this.play();
    };
    Avatar.prototype.play = function () {
        if (!this.isPlaying) {
            this.isPlaying = true;
            this.resetFrameState();
            os.add_ENTERFRAME(this.onRender, this);
        }
        this.delayOnRender(false);
    };
    Avatar.prototype.stop = function (frame, immediatelyRender) {
        if (frame === void 0) { frame = 1; }
        if (immediatelyRender === void 0) { immediatelyRender = true; }
        if (frame <= 1)
            frame = 1;
        if (this.isPlaying) {
            this.isPlaying = false;
            os.remove_ENTERFRAME(this.onRender, this);
        }
        this.setCurrentFrame(frame);
        if (immediatelyRender)
            this.delayOnRender(false);
    };
    Avatar.prototype.delayOnRender = function (autoPlay, useMapping, playFrame, sendEvent) {
        if (autoPlay === void 0) { autoPlay = true; }
        if (useMapping === void 0) { useMapping = true; }
        if (playFrame === void 0) { playFrame = null; }
        if (sendEvent === void 0) { sendEvent = true; }
        if (this.forceRender) {
            this.waitRender_waitCount = null;
            this.onRender.apply(this, [autoPlay, useMapping, playFrame, sendEvent, true]);
        }
        else {
            Callback.CallLaterBeforeRender(this.onRender, this, arguments);
        }
    };
    Avatar.prototype.onRender = function (autoPlay, useMapping, playFrame, sendEvent, forceRender, selfCenterlineAlignModeOffset, forceFlip, isPart) {
        if (autoPlay === void 0) { autoPlay = true; }
        if (useMapping === void 0) { useMapping = true; }
        if (playFrame === void 0) { playFrame = null; }
        if (sendEvent === void 0) { sendEvent = true; }
        if (forceRender === void 0) { forceRender = false; }
        if (selfCenterlineAlignModeOffset === void 0) { selfCenterlineAlignModeOffset = null; }
        if (forceFlip === void 0) { forceFlip = null; }
        if (isPart === void 0) { isPart = false; }
        if (this.isLoading || this.isDisposed || (!Config.EDIT_MODE && this.id == 0))
            return false;
        if (playFrame == null) {
            if (autoPlay) {
                var now = Date.now();
                if (this.waitRender_waitCount != null) {
                    if (this.waitRender_useTime) {
                        var dtime = now - this.waitRender_startCount;
                        if (dtime < this.waitRender_waitCount) {
                            return false;
                        }
                    }
                    else {
                        var dFrame = __fCount - this.waitRender_startCount;
                        if (dFrame < this.waitRender_waitCount) {
                            return false;
                        }
                    }
                    this.waitRender_waitCount = null;
                    playFrame = this._currentFrame + 1;
                    this._startPlayTime = now;
                    this._startPlayFrame = playFrame;
                }
                else {
                    var timeIntervalMs = now - this._startPlayTime;
                    playFrame = Math.floor(timeIntervalMs / (1000 / this.fps)) + this._startPlayFrame;
                }
                if (!forceRender && playFrame == this._currentFrame && timeIntervalMs >= 5) {
                    return false;
                }
            }
            else {
                playFrame = this._currentFrame;
            }
        }
        this._currentFrame = playFrame;
        this._bodyGraphics.texture = null;
        this.currentFrameImage = null;
        var avatarAct = this.actionListArr[this.actIndex];
        if (!avatarAct) {
            return false;
        }
        var renderPlayFrame = playFrame - 1;
        var frameLength = avatarAct.getFrameLength(this.ori, useMapping);
        var currentFrame = Math.max(renderPlayFrame, 0);
        var realFrame = useMapping ? currentFrame % frameLength : currentFrame;
        var frame = avatarAct.getFrameImage(this.ori, realFrame, useMapping);
        if (frame) {
            this.currentFrameImage = frame;
            var refObjs = this.helperType ? this.currentFrameImage.frameHelper : this._refObjs;
            this.currentFrameRefObjs = refObjs ? ObjectUtils.depthClone(refObjs) : null;
            if (isPart && frame.isAnchor) {
                this.pivotX = frame.anchorX;
                this.pivotY = frame.anchorY;
                if (this.thisOriX == null)
                    this.thisOriX = this.x;
                else
                    this.x = this.thisOriX;
                if (this.thisOriY == null)
                    this.thisOriY = this.y;
                else
                    this.y = this.thisOriY;
                this.x += frame.anchorX;
                this.y += frame.anchorY;
            }
            else {
                if (this.pivotX)
                    this.x -= this.pivotX;
                if (this.pivotY)
                    this.y -= this.pivotY;
                this.pivotX = 0;
                this.pivotY = 0;
            }
            this._bodyGraphics.texture = frame.tex;
            this._bodyGraphicsFlip = (forceFlip || this.topAvatar.forceFlip) || ((this.topAvatar.oriMode % 2 == 1) && (this.topAvatar.ori == 3 || this.topAvatar.ori == 6 || this.topAvatar.ori == 9) && this.topAvatar.autoFlip);
            if (this._bodyGraphicsFlip) {
                this._bodyGraphics.scaleX = -1;
                this._bodyGraphics.x = frame.rect.width;
                if (selfCenterlineAlignModeOffset != null)
                    selfCenterlineAlignModeOffset += this.pivotX;
                if (selfCenterlineAlignModeOffset || (forceFlip || this.forceFlip)) {
                    if (this.thisOriX == null && !(isPart && frame.isAnchor)) {
                        this.thisOriX = this.x;
                    }
                    this.x = -this.thisOriX;
                    if (isPart && frame.isAnchor) {
                        this.pivotX = -frame.anchorX;
                        this.x -= frame.anchorX;
                    }
                }
                this._body.x = -frame.width - frame.x;
                if (this.currentFrameRefObjs) {
                    var _loop_2 = function (i_19) {
                        var helper = this_2.currentFrameRefObjs[i_19];
                        switch (helper.type) {
                            case 0:
                            case 2:
                            case 5:
                                helper.x = -helper.width - helper.x;
                                break;
                            case 1:
                                helper.x = -helper.x;
                                break;
                            case 3:
                            case 4:
                                helper.points && helper.boundingBox && helper.points.forEach(function (v, i) {
                                    if (i % 2 == 0)
                                        v = -helper.boundingBox.width - v;
                                });
                                if (helper.boundingBox)
                                    helper.boundingBox.x = -helper.boundingBox.width - helper.boundingBox.x;
                                break;
                        }
                        this_2.currentFrameRefObjs[i_19] = helper;
                    };
                    var this_2 = this;
                    for (var i_19 in this.currentFrameRefObjs) {
                        _loop_2(i_19);
                    }
                }
            }
            else {
                if (this.thisOriX != null && !(isPart && frame.isAnchor)) {
                    this.x = this.thisOriX;
                    this.thisOriX = null;
                }
                this._bodyGraphics.scaleX = 1;
                this._bodyGraphics.x = 0;
                this._body.x = frame.x;
            }
            this._body.y = frame.y;
            this._body.scaleX = frame.width / frame.rect.width;
            this._body.scaleY = frame.height / frame.rect.height;
            this._body.rotation = frame.rotation;
            this._body.alpha = frame.alpha;
            this._body.hue = frame.hue;
            this._body.blur = frame.blur;
            this._body.setTonal(frame.tonal_r, frame.tonal_g, frame.tonal_b, frame.tonal_gray, frame.tonal_mr, frame.tonal_mg, frame.tonal_mb);
            if (this._openAutoHitArea) {
                this._body.hitArea = new Rectangle(0, 0, frame.width / this._body.scaleX, frame.height / this._body.scaleY);
            }
            if (this.topAvatar == this) {
                if (frame.wait_type == 1) {
                    this.waitRender_startCount = __fCount;
                    this.waitRender_useTime = false;
                    this.waitRender_waitCount = Math.round(frame.wait_count * os['fps'] / this.fps);
                }
                else if (frame.wait_type == 2) {
                    this.waitRender_startCount = Date.now();
                    this.waitRender_useTime = true;
                    this.waitRender_waitCount = frame.wait_count;
                }
            }
        }
        var isRender = false;
        for (var i = 0; i < this.avatarList.length; i++) {
            var avatarPart = this.avatarList[i];
            if (avatarPart == this)
                continue;
            var partOffset = selfCenterlineAlignModeOffset || this.selfCenterlineAlignMode ? avatarPart.x + this.pivotX + (selfCenterlineAlignModeOffset ? selfCenterlineAlignModeOffset : 0) : null;
            if (avatarPart.onRender(autoPlay, useMapping, playFrame, sendEvent, forceRender, partOffset, (forceFlip || this.forceFlip), true)) {
                isRender = true;
            }
        }
        if (frame || isRender) {
            isRender = true;
        }
        if (autoPlay && currentFrame >= ((this._actionPlayCompleteRecord + 1) * frameLength - 1) + 1) {
            this._actionPlayCompleteRecord++;
            if (sendEvent)
                this.event(Avatar.ACTION_PLAY_COMPLETED);
        }
        if (isRender) {
            if (sendEvent)
                this.event(Avatar.RENDER);
        }
        return isRender;
    };
    Avatar.prototype.hitTestPoint = function (x, y) {
        if (this.isDisposed)
            return false;
        for (var i = 0; i < this.avatarList.length; i++) {
            var avatarPart = this.avatarList[i];
            if (avatarPart == this)
                continue;
            if (avatarPart.hitTestPoint(x, y)) {
                return true;
            }
        }
        if (!this.currentFrameImage)
            return false;
        var inRect = _super.prototype.hitTestPoint.call(this, x, y);
        if (!inRect) {
            return false;
        }
        var imgUrl = this.picUrls[this.currentFrameImage.picUrlIndex];
        var tex = AssetManager.getImage(imgUrl);
        if (!tex)
            return false;
        var localP = this._bodyGraphics.globalToLocal(new Point(x, y), false);
        var tx = localP.x - this.currentFrameImage.rect.x;
        var ty = localP.y - this.currentFrameImage.rect.y;
        if (!this.currentFrameImage.positiveRect.contains(tx, ty)) {
            return false;
        }
        var c = tex.getPixels(tx, ty, 1, 1);
        return c[3] != 0;
    };
    Avatar.prototype.on = function (type, caller, listener, args) {
        var t = _super.prototype.on.apply(this, arguments);
        if (this.hasMouseEvent)
            this.openAutoHitArea();
        return t;
    };
    ;
    Avatar.prototype.once = function (type, caller, listener, args) {
        var _this_1 = this;
        var t = _super.prototype.once.apply(this, [type, caller, function (caller, listener, args, e) {
                listener.apply(caller, args ? args.concat([e]) : [e]);
                if (!_this_1.hasMouseEvent)
                    _this_1.closeAutoHitArea();
            }, [caller, listener, args]]);
        if (this.hasMouseEvent)
            this.openAutoHitArea();
        return t;
    };
    ;
    Avatar.prototype.off = function (type, caller, listener, onceOnly) {
        var t = _super.prototype.off.apply(this, arguments);
        if (!this.hasMouseEvent)
            this.closeAutoHitArea();
        return t;
    };
    ;
    Avatar.prototype.offAll = function (type) {
        var t = _super.prototype.offAll.apply(this, arguments);
        if (!this.hasMouseEvent)
            this.closeAutoHitArea();
        return t;
    };
    ;
    Avatar.prototype.openAutoHitArea = function (force) {
        if (force === void 0) { force = false; }
        if (this.isDisposed)
            return;
        this._openAutoHitArea = true;
        this._openAutoHitAreaForce = force;
        this.mouseEnabled = this._body.mouseEnabled = true;
        for (var i in this.avatarList) {
            if (this.avatarList[i] == this)
                continue;
            this.avatarList[i].openAutoHitArea(force);
        }
        if (!this.isLoading && this.topAvatar == this) {
            this.delayOnRender(false, true, null, false);
        }
    };
    Avatar.prototype.closeAutoHitArea = function (force) {
        if (force === void 0) { force = false; }
        if (this.isDisposed || Config.EDIT_MODE)
            return;
        if (this._openAutoHitAreaForce && !force)
            return;
        this._openAutoHitArea = false;
        this._openAutoHitAreaForce = false;
        this.mouseEnabled = false;
        if (this._body)
            this._body.mouseEnabled = false;
        for (var i in this.avatarList) {
            if (this.avatarList[i] == this)
                continue;
            this.avatarList[i].closeAutoHitArea(force);
        }
    };
    Avatar.prototype.resetFrameState = function () {
        this._startPlayTime = new Date().getTime();
        this._startPlayFrame = this._currentFrame;
        var frameCount = this.frameCount;
        if (frameCount == 0) {
            this._actionPlayCompleteRecord = 0;
        }
        else {
            this._actionPlayCompleteRecord = Math.max(Math.floor(this._startPlayFrame / (frameCount)) - 1, 0);
        }
    };
    Avatar.generateAllframeHelper = function (actionListArr, refObjs) {
        for (var i_20 = 0; i_20 < actionListArr.length; i_20++) {
            for (var j in actionListArr[i_20].frameImageInfo) {
                var fra = actionListArr[i_20].frameImageInfo[j];
                for (var z = 0; z < fra.length; z++) {
                    if (!fra[z].frameHelper)
                        fra[z].frameHelper = Avatar.generateframeHelper(actionListArr, refObjs, { i: i_20, j: j, z: z });
                }
            }
        }
        return actionListArr;
    };
    Avatar.generateframeHelper = function (actionListArr, refObjs, frameHelperPos) {
        var fra = actionListArr[frameHelperPos.i].frameImageInfo[frameHelperPos.j];
        if (fra.length == 0)
            return ObjectUtils.depthClone(refObjs);
        for (var ss = frameHelperPos.z; ss >= 0; ss--) {
            if (fra[ss].frameHelper && JSON.stringify(fra[ss].frameHelper) != "{}")
                return ObjectUtils.depthClone(fra[ss].frameHelper);
        }
        for (var ss in actionListArr[frameHelperPos.i].frameImageInfo) {
            var _fra = actionListArr[frameHelperPos.i].frameImageInfo[ss];
            for (var ss1 = 0; ss1 < _fra.length; ss1++) {
                if (_fra[ss1].frameHelper && JSON.stringify(_fra[ss1].frameHelper) != "{}")
                    return ObjectUtils.depthClone(_fra[ss1].frameHelper);
            }
        }
        for (var ss = 0; ss < actionListArr.length; ss++) {
            for (var ss1 in actionListArr[ss].frameImageInfo) {
                var _fra = actionListArr[ss].frameImageInfo[ss1];
                for (var ss2 = 0; ss2 < _fra.length; ss2++) {
                    if (_fra[ss2].frameHelper && JSON.stringify(_fra[ss2].frameHelper) != "{}")
                        return ObjectUtils.depthClone(_fra[ss2].frameHelper);
                }
            }
        }
        return ObjectUtils.depthClone(refObjs);
    };
    Avatar.ACTION_PLAY_COMPLETED = "EVENT_PLAY_COMPLETED";
    Avatar.CHANGE_ACTION = "AvatarCHANGE_ACTION";
    Avatar.RENDER = "AvatarRENDER";
    Avatar.LOAD_EXPIRE = "AvatarLOAD_EXPIRE";
    return Avatar;
}(GameSprite));















var GameDialog = (function (_super) {
    __extends(GameDialog, _super);
    function GameDialog(dialogID, dialogList) {
        var _this_1 = _super.call(this) || this;
        _this_1.dialogBox = new UIComponent.UIBitmap();
        _this_1.headBox = new UIComponent.UIRoot();
        _this_1.optionBox = new GameSprite();
        _this_1.optionText = new GameSprite();
        _this_1.nameText = new UIComponent.UIString();
        _this_1.dialogText = new UIComponent.UIString();
        _this_1.skipAni = new GCAnimation();
        _this_1.skipAniPoint = new Point();
        _this_1.skipHeight = 0;
        _this_1.lastTextPosX = 0;
        _this_1.lastTextPosY = 0;
        _this_1.waitTimeArr = [];
        _this_1.dialogMaterialEnabled = true;
        _this_1.playTextLabels = [];
        _this_1.nameMapping = {
            dialogBox: _this_1.dialogBox,
            headBox: _this_1.headBox,
            optionBox: _this_1.optionBox,
            dialog: _this_1.dialogText,
            option: _this_1.optionText,
            nameBox: _this_1.nameText,
            skipBox: _this_1.skipAni
        };
        _this_1.id = dialogID;
        _this_1.dialogList = dialogList;
        var dialogData = _this_1.dialogData = _this_1.dialogList.data[dialogID];
        var list = [];
        for (var key in _this_1.nameMapping) {
            var data = dialogData[key];
            if (!data)
                continue;
            var content = { box: _this_1.nameMapping[key], index: data.index ? data.index : 0 };
            list.push(content);
        }
        _this_1.orderByIndex(list);
        for (var i = 0; i < list.length; i++) {
            _this_1.addChild(list[i].box);
        }
        _this_1.size(Config.WINDOW_WIDTH, Config.WINDOW_HEIGHT);
        _this_1.add_CLICK(_this_1.onSelfClick, _this_1);
        if ((!Config.EDIT_MODE || GameDialog.container) && GameDialog.maskLayer) {
            GameDialog.maskLayer.offAll(EventObject.CLICK);
            GameDialog.maskLayer.add_CLICK(function () {
                if (GameDialog.lastDialog)
                    GameDialog.lastDialog.onClick.apply(GameDialog.lastDialog, [null, false]);
            }, _this_1);
        }
        return _this_1;
    }
    GameDialog.showall = function () {
        if (!GameDialog.lastDialog)
            return;
        if (GameDialog.lastDialog.playing) {
            GameDialog.lastDialog.waitPlayerClick = false;
            GameDialog.lastDialog.forceShow = true;
            GameDialog.lastDialog.playSpeed = 5;
            GameDialog.lastDialog.playText();
            GameDialog.lastDialog.clearTextMaterials();
            if (GameDialog.showOptionWithLastDialog) {
                GameDialog.showOption(GameDialog.lastDialog.id, GameDialog.showOptionWithLastDialog, true, GameDialog.showOptionWithLastDialogParams[0], GameDialog.showOptionWithLastDialogParams[1], GameDialog.showOptionWithLastDialogParams[2]);
            }
        }
    };
    GameDialog.skip = function () {
        if (!GameDialog.lastDialog)
            return false;
        if (GameDialog.optionMode) {
            return false;
        }
        if (GameDialog.isCloseDialog)
            return false;
        if (GameDialog.showOptionWithLastDialog) {
            GameDialog.showOption(GameDialog.lastDialog.id, GameDialog.showOptionWithLastDialog, true, GameDialog.showOptionWithLastDialogParams[0], GameDialog.showOptionWithLastDialogParams[1], GameDialog.showOptionWithLastDialogParams[2]);
        }
        else {
            var lastCurrentDialogSign = GameDialog.currentDialogSign;
            GameDialog.isCloseDialog = true;
            EventUtils.happen(GameDialog, GameDialog.EVENT_DIALOG_END, [GameDialog.lastDialog]);
            if (GameDialog.currentDialogSign == lastCurrentDialogSign) {
                if (GameDialog.lastDialog) {
                    GameDialog.lastDialog.clearDelayStop();
                    GameDialog.lastDialog.delayStop = setTimeout(function (lastDialog) {
                        lastDialog.stop();
                    }, GameDialog.delayCloseTime, GameDialog.lastDialog);
                }
            }
            if (GameDialog.lastDialog.submitCallback) {
                GameDialog.lastDialog.submitCallback.run();
            }
            else {
                GameCommand.inputMessageAndContinueExecute();
            }
        }
        return true;
    };
    GameDialog.skipWaitPlayerOperation = function () {
        if (!GameDialog.lastDialog)
            return false;
        if (GameDialog.lastDialog.playing && GameDialog.lastDialog.waitPlayerClick) {
            GameDialog.lastDialog.waitPlayerClick = false;
            return true;
        }
        return false;
    };
    GameDialog.stop = function () {
        if (GameDialog.lastDialog) {
            GameDialog.lastDialog.stop();
            GameDialog.lastDialog = null;
        }
    };
    Object.defineProperty(GameDialog, "isInDialog", {
        get: function () {
            return GameDialog.lastDialog != null && GameDialog.lastDialog.stage != null && !GameDialog.isCloseDialog;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameDialog, "isPlaying", {
        get: function () {
            if (!GameDialog.lastDialog)
                return false;
            return GameDialog.lastDialog.playing;
        },
        enumerable: false,
        configurable: true
    });
    GameDialog.init = function () {
        if (this._inited)
            return;
        this._inited = true;
        this.maskLayer = new Sprite();
        this.maskLayer.size(3000, 3000);
        this.maskLayer.mouseEnabled = true;
    };
    GameDialog.showDialog = function (dialogID, head, name, speed, comicSceneObjectIndex, msg, submitCallback, audio, exp, nameColor, changeData, dialogMaterialEnabled) {
        if (submitCallback === void 0) { submitCallback = null; }
        if (dialogMaterialEnabled === void 0) { dialogMaterialEnabled = true; }
        GameDialog.currentDialogInfo = [0, dialogID, head, name, speed, comicSceneObjectIndex, msg, null, audio, exp, nameColor, changeData, dialogMaterialEnabled];
        GameDialog.currentDialogSign = ObjectUtils.getInstanceID();
        var dialog = GameDialog.getDialog(dialogID);
        dialog.dialogMaterialEnabled = dialogMaterialEnabled;
        dialog.submitCallback = submitCallback;
        if (GameDialog.lastDialog) {
            GameDialog.lastDialog.stop(true, false);
        }
        dialog.dialogText.visible = dialog.nameText.visible = dialog.headBox.visible = dialog.dialogBox.visible = true;
        dialog.optionBox.visible = false;
        if (!changeData)
            changeData = {};
        if (changeData.showOptionWithLastDialog) {
            GameDialog.showOptionWithLastDialog = changeData.showOptionWithLastDialog;
        }
        if (changeData.showOptionWithLastDialogParams) {
            GameDialog.showOptionWithLastDialogParams = changeData.showOptionWithLastDialogParams;
        }
        GameDialog.lastDialog = dialog;
        GameDialog.lastDialog.playing = true;
        GameDialog.lastComicSceneObjectIndex = comicSceneObjectIndex;
        GameDialog.optionMode = false;
        GameDialog.isCloseDialog = false;
        GameDialog.addToDialogLayer(dialog);
        EventUtils.happen(GameDialog, GameDialog.EVENT_DIALOG_START, [false, msg, [], name, head, exp, audio, speed, nameColor, changeData]);
        dialog.setContent(head, name, speed, msg, audio, exp, nameColor, changeData);
        EventUtils.happen(GameDialog, GameDialog.EVENT_AFTER_DIALOG_START, [false]);
        return dialog;
    };
    GameDialog.showOption = function (dialogID, options, isShowOptionWithLastDialog, defaultIndex, cancelIndex, hideIndexs) {
        if (isShowOptionWithLastDialog === void 0) { isShowOptionWithLastDialog = false; }
        if (defaultIndex === void 0) { defaultIndex = -1; }
        if (cancelIndex === void 0) { cancelIndex = -1; }
        if (hideIndexs === void 0) { hideIndexs = []; }
        GameDialog.currentDialogSign = ObjectUtils.getInstanceID();
        var dialog = GameDialog.getDialog(dialogID);
        if (!isShowOptionWithLastDialog && GameDialog.lastDialog &&
            GameDialog.lastDialog == dialog && !GameDialog.isCloseDialog) {
            GameDialog.showOptionWithLastDialog = options;
            GameDialog.showOptionWithLastDialogParams = [defaultIndex, cancelIndex, hideIndexs];
            if (!dialog.playing && dialog.hasSkip) {
                GameDialog.showOption(dialog.id, options, true, defaultIndex, cancelIndex, hideIndexs);
            }
            if (GameDialog.currentDialogInfo[11]) {
                GameDialog.currentDialogInfo[11].showOptionWithLastDialog = GameDialog.showOptionWithLastDialog;
                GameDialog.currentDialogInfo[11].showOptionWithLastDialogParams = GameDialog.showOptionWithLastDialogParams;
            }
            return dialog;
        }
        if (isShowOptionWithLastDialog && GameDialog.currentDialogInfo && GameDialog.currentDialogInfo[0] == 0) {
            GameDialog.currentDialogInfo = [1, dialogID, options, isShowOptionWithLastDialog, defaultIndex, cancelIndex, hideIndexs, GameDialog.currentDialogInfo];
        }
        else {
            GameDialog.currentDialogInfo = [1, dialogID, options, isShowOptionWithLastDialog, defaultIndex, cancelIndex, hideIndexs];
        }
        if (GameDialog.lastDialog) {
            GameDialog.lastDialog.stop(isShowOptionWithLastDialog ? false : true, false);
        }
        GameDialog.lastDialog = dialog;
        GameDialog.optionMode = true;
        GameDialog.isCloseDialog = false;
        dialog.clearDelayStop();
        dialog.skipAni.visible = false;
        dialog.skipAni.stop();
        dialog.dialogText.visible = dialog.nameText.visible = dialog.headBox.visible = dialog.dialogBox.visible = isShowOptionWithLastDialog;
        dialog.optionBox.visible = true;
        if (!isShowOptionWithLastDialog) {
            GameDialog.lastComicSceneObjectIndex = -1;
            dialog.dialogText.removeChildren();
            dialog.nameText.text = "";
            dialog.headBox.removeChildren();
        }
        GameDialog.showOptionWithLastDialog = null;
        GameDialog.showOptionWithLastDialogParams = [-1, -1, []];
        GameDialog.lastComicSceneObjectIndex || (GameDialog.lastComicSceneObjectIndex = -1);
        GameDialog.addToDialogLayer(dialog);
        EventUtils.happen(GameDialog, GameDialog.EVENT_DIALOG_START, [true, null, options, null, null, null, null, 5, null]);
        dialog.setOption(options, defaultIndex, cancelIndex, hideIndexs);
        EventUtils.happen(GameDialog, GameDialog.EVENT_AFTER_DIALOG_START, [true]);
        return dialog;
    };
    GameDialog.addToDialogLayer = function (dialog) {
        if (Config.EDIT_MODE) {
            if (!GameDialog.container)
                GameDialog.container = Game.layer.uiLayer;
            if (!GameDialog.containerScene)
                GameDialog.containerScene = Game.currentScene;
        }
        else {
            GameDialog.container = Game.layer.uiLayer;
            GameDialog.containerScene = Game.currentScene;
        }
        switch (GameDialog.lastComicSceneObjectIndex) {
            case -1:
                GameDialog.container.addChild(dialog);
                dialog.pos(0, 0);
                break;
            default:
                if (GameDialog.containerScene) {
                    var so = GameDialog.containerScene.sceneObjects[GameDialog.lastComicSceneObjectIndex];
                    if (so && so.inScene) {
                        GameDialog.container.addChild(dialog);
                        GameDialog.bindingSoPostion(dialog, so);
                    }
                    else {
                        GameDialog.container.addChild(dialog);
                        dialog.pos(0, 0);
                    }
                }
        }
        if (!GameDialog.optionMode) {
            GameDialog.container.addChild(GameDialog.maskLayer);
        }
        else if (GameDialog.maskLayer.stage)
            GameDialog.maskLayer.removeSelf();
    };
    GameDialog.bindingSoPostion = function (dialog, so) {
        GameDialog.refreshDialogPosition(dialog, so);
        stage.off(EventObject.RENDER, GameDialog, GameDialog.refreshDialogPosition);
        stage.on(EventObject.RENDER, GameDialog, GameDialog.refreshDialogPosition, [dialog, so]);
    };
    GameDialog.unbindingSoPosition = function () {
        stage.off(EventObject.RENDER, GameDialog, GameDialog.refreshDialogPosition);
    };
    GameDialog.refreshDialogPosition = function (dialog, so) {
        var gp = so.root.localToGlobal(new Point(0, 0));
        var posx_3 = -0.5 * (dialog.width);
        var layerPos = dialog.parent.globalToLocal(gp);
        dialog.pos(layerPos.x + posx_3, layerPos.y + -dialog.height);
    };
    GameDialog.clearCacheDialog = function () {
        GameDialog.dialogCache = [];
    };
    GameDialog.getDialog = function (dialogID) {
        GameDialog.init();
        if (dialogID == 0) {
            if (GameDialog.lastDialog)
                dialogID = GameDialog.lastDialog.id;
            else {
                dialogID = 1;
            }
        }
        var dialogData = Common.dialogList.data[dialogID];
        if (!dialogData) {
            dialogID = 1;
            dialogData = Common.dialogList.data[dialogID];
        }
        if (!dialogData) {
            console.log("[#GAME_THE_DIALOG_BOX_TEMPLATE_CANNOT_BE_FOUND]" + dialogID);
            return;
        }
        var dialog = GameDialog.dialogCache[dialogID];
        if (!dialog) {
            dialog = GameDialog.dialogCache[dialogID] = new GameDialog(dialogID, Common.dialogList);
        }
        return dialog;
    };
    GameDialog.handleText = function (text, defaultColor, dialog) {
        var re = /\[p[0-9]{1,3}\]/g;
        var arr = text.match(re);
        for (var c in arr) {
            var i = arr[c];
            var colorKey = i.substr(2, i.length - 3);
            var waitF = parseInt(colorKey);
            var waitT = "";
            dialog.waitTimeArr.push(waitF);
            for (var s = 0; s < waitF; s++) {
                waitT += GameDialog.KEY_SYMBOL_DELAY;
            }
            text = text.replace(i, waitT);
        }
        text = text.replace(/\[\.=\]/g, GameDialog.KEY_SYMBOL_WAIT_PLAYER_CLICK);
        text = text.replace(/\[\.s\]/g, GameDialog.KEY_SYMBOL_SKIP);
        return "" + text;
    };
    Object.defineProperty(GameDialog.prototype, "dialogHeadBox", {
        get: function () {
            var mode = this.dialogData.headBox.perviewMode;
            if (!mode) {
                return this.headImg;
            }
            else if (mode == 1) {
                return this.headStand;
            }
            else if (mode == 2) {
                return this.headAni;
            }
            else if (mode == 3) {
                return this.headUI;
            }
            return null;
        },
        enumerable: false,
        configurable: true
    });
    GameDialog.prototype.updateDialogPostion = function () {
        var _this_1 = this;
        var dialogData = (GameDialog.changeData && GameDialog.changeData.id == this.dialogData.id) ? this.changeDialog(GameDialog.changeData) : this.dialogData;
        if (!dialogData.dialogBox.grid9)
            dialogData.dialogBox.grid9 = "0,0,0,0,0";
        ObjectUtils.clone(dialogData.dialogBox, this.dialogBox);
        ObjectUtils.clone(dialogData.nameBox, this.nameText);
        var url = dialogData.dialogBox.image;
        if (!url)
            url = dialogData.dialogBox["skin"] ? dialogData.dialogBox["skin"] : "";
        this.dialogBox.image = url;
        this.nameText.wordWrap = false;
        this.dialogBoxMaterial = this.dialogData.dialogBox.materialData && this.dialogData.dialogBox.materialData.length > 0 && this.dialogData.dialogBox.materialData[0].materials.length > 0;
        this.dialogNameTextMaterial = this.dialogData.nameBox.materialData && this.dialogData.nameBox.materialData.length > 0 && this.dialogData.nameBox.materialData[0].materials.length > 0;
        this.headBox.x = dialogData.headBox.x;
        this.headBox.y = dialogData.headBox.y;
        this.headBox.width = dialogData.headBox.width;
        this.headBox.height = dialogData.headBox.height;
        this.headBox.scaleX = dialogData.headBox.flip ? -1 : 1;
        this.headBox.alpha = dialogData.headBox.alpha;
        this.dialogHeadBoxMaterial = this.dialogData.headBox.materialData && this.dialogData.headBox.materialData.length > 0 && this.dialogData.headBox.materialData[0].materials.length > 0;
        this.dialogText.x = dialogData.dialog.x;
        this.dialogText.y = dialogData.dialog.y;
        this.dialogText.width = dialogData.dialog.width;
        this.dialogText.height = dialogData.dialog.height;
        this.dialogText.alpha = dialogData.dialog.alpha;
        this.dialogTextMaterial = this.dialogData.dialog.materialData && this.dialogData.dialog.materialData.length > 0 && this.dialogData.dialog.materialData[0].materials.length > 0;
        this.skipAni.visible = false;
        this.skipAni.scaleX = this.skipAni.scaleY = dialogData.skipBox.scaleNumber;
        this.skipAni.once(EventObject.LOADED, this, function () {
            _this_1.skipHeight = _this_1.skipAni.getBounds().height;
        });
        this.skipAni.id = dialogData.skipBox.animationID;
        this.skipAni.loop = dialogData.skipBox.playType == 2 ? true : false;
        this.skipAniPoint.x = dialogData.skipBox.posX ? dialogData.skipBox.posX : 0;
        this.skipAniPoint.y = dialogData.skipBox.posY ? dialogData.skipBox.posY : 0;
        this.skipAni.alpha = dialogData.skipBox.alpha;
        return dialogData;
    };
    GameDialog.prototype.updateOptionPostion = function () {
        var dialogData = (GameDialog.changeData && GameDialog.changeData.id == this.dialogData.id) ? this.changeDialog(GameDialog.changeData) : this.dialogData;
        if (!dialogData.optionBox.grid9img1)
            dialogData.optionBox.grid9img1 = "0,0,0,0,0";
        if (!dialogData.optionBox.grid9img2)
            dialogData.optionBox.grid9img2 = "0,0,0,0,0";
        if (!dialogData.optionBox.grid9img3)
            dialogData.optionBox.grid9img3 = "0,0,0,0,0";
        if (!dialogData.optionBox.grid9img4)
            dialogData.optionBox.grid9img4 = "0,0,0,0,0";
        this.optionBox.x = dialogData.optionBox.x;
        this.optionBox.y = dialogData.optionBox.y;
        this.optionBox.alpha = dialogData.optionBox.alpha;
        this.dialogOptionBoxTextMaterial = this.dialogData.optionBox.materialData && this.dialogData.optionBox.materialData.length > 0 && this.dialogData.optionBox.materialData[0].materials.length > 0;
        this.optionText.x = dialogData.option.x;
        this.optionText.y = dialogData.option.y;
        this.optionText.alpha = dialogData.option.alpha;
        this.dialogOptionTextMaterial = this.dialogData.option.materialData && this.dialogData.option.materialData.length > 0 && this.dialogData.option.materialData[0].materials.length > 0;
        return dialogData;
    };
    GameDialog.prototype.orderByIndex = function (list) {
        list.sort(function (a, b) {
            if (a.index == b.index)
                return a.index < b.index ? 1 : -1;
            return a.index > b.index ? 1 : -1;
        });
    };
    GameDialog.prototype.setContent = function (head, name, playSpeed, msg, audio, exp, nameColor, changeData) {
        GameDialog.changeData = changeData;
        var dialogData = this.updateDialogPostion();
        this.changeDialogData = dialogData;
        this.clearDelayStop();
        this.playSpeed = playSpeed;
        this.playTextIndex = 0;
        this.playTextLabelIndex = 0;
        this.skipAni.visible = false;
        this.skipAni.stop();
        this.lastTextPosX = this.lastTextPosY = 0;
        this.forceShow = false;
        this.hasSkip = false;
        this.playTextLabels.length = 0;
        this.optionClear();
        this.dialogText.removeChildren();
        this.headBox.removeChildren();
        this.nameText.text = name;
        if (this.dialogMaterialEnabled && name && this.dialogNameTextMaterial) {
            this.nameText.installMaterialData(ObjectUtils.depthClone(dialogData.nameBox.materialData));
        }
        if (nameColor)
            this.nameText.color = nameColor;
        this.refreshHeadBox(head, exp);
        if (audio) {
            if (GameDialog.tschannel) {
                GameAudio.stopTS(GameDialog.tschannel);
            }
            GameDialog.tschannel = GameAudio.playTS(audio);
            if (GameDialog.tschannel) {
                GameDialog.tschannel.once(EventObject.COMPLETE, this, function (audio) {
                    GameDialog.tschannel = null;
                    EventUtils.happen(GameDialog, GameDialog.EVENT_TS_PLAY_COMPLETE, [true, audio]);
                }, [audio]);
                GameDialog.tschannel.once(EventObject.ERROR, this, function (audio) {
                    GameDialog.tschannel = null;
                    EventUtils.happen(GameDialog, GameDialog.EVENT_TS_PLAY_COMPLETE, [false, audio]);
                }, [audio]);
            }
        }
        if (this.dialogMaterialEnabled && this.dialogBoxMaterial) {
            this.dialogBox.installMaterialData(ObjectUtils.depthClone(dialogData.dialogBox.materialData));
        }
        this.waitTimeArr.length = 0;
        this.waitStart = 0;
        var textContent = GameDialog.handleText(msg, dialogData.dialog.color, this);
        var Labels = textContent.match(GameDialog.COLOR_FORMAT);
        if (!Labels) {
            EventUtils.happen(GameDialog, GameDialog.EVENT_DIALOG_WORD_PLAY_COMPLETE, [true]);
            this.playing = false;
            this.skipAni.visible = true;
            if (dialogData.skipBox.posIndex == 0) {
                this.skipAni.x = dialogData.skipBox.x;
                this.skipAni.y = dialogData.skipBox.y;
            }
            else {
                this.skipAni.x = this.dialogText.x + this.lastTextPosX + this.skipAniPoint.x + 6;
                this.skipAni.y = this.dialogText.y + this.lastTextPosY + this.skipAniPoint.y;
            }
            this.skipAni.gotoAndPlay();
            return;
        }
        if (this.dialogTextMaterial) {
            var newLabels = [];
            for (var i = 0; i < Labels.length; i++) {
                var Label = Labels[i];
                var LabelHeadIndex = Label.indexOf(">") + 1;
                var LabelHead = Label.substr(0, LabelHeadIndex);
                var LabelTailIndex = Label.lastIndexOf("<");
                var LabelTail = Label.substr(LabelTailIndex);
                var LabelContent = Label.substr(LabelHeadIndex, LabelTailIndex - LabelHeadIndex);
                for (var s = 0; s < LabelContent.length; s++) {
                    var newLabelContent = LabelHead + LabelContent[s] + LabelTail;
                    newLabels.push(newLabelContent);
                }
            }
            Labels = newLabels;
        }
        var rowIndex = 0;
        var startX = 0;
        var letterSpaceing = 0;
        for (var i = 0; i < Labels.length; i++) {
            var unitSpan = Labels[i];
            var color = unitSpan.match(/#[0-9a-zA-Z]{6,6}/g)[0];
            if (color == GameDialog.TRANS_PARENT_COLOR) {
                color = dialogData.dialog.color;
            }
            var lines = unitSpan.split("\n");
            for (var s = 0; s < lines.length; s++) {
                if (s > 0) {
                    rowIndex++;
                    startX = 0;
                    letterSpaceing = 0;
                }
                letterSpaceing = dialogData.dialog.letterSpacing ? dialogData.dialog.letterSpacing : 0;
                var text = StringUtils.clearHtmlTag(lines[s]);
                var realText = text.replace(GameDialog.KEY_SYMBOL_reg, "");
                var tf = new UIComponent.UIString();
                ObjectUtils.clone(dialogData.dialog, tf);
                tf.wordWrap = false;
                tf.text = realText;
                tf.color = color;
                tf.x = startX + letterSpaceing;
                tf.y = rowIndex * (tf.fontSize + tf.leading);
                this.lastTextPosY = tf.y + (tf.fontSize + tf.leading - this.skipHeight) * 0.5;
                var tfStartX = startX + letterSpaceing;
                startX = tfStartX + tf.textWidth;
                this.dialogText.addChild(tf);
                this.playTextLabels.push(tf);
                tf["playText"] = text;
                var minTextAreaWidth = Math.max(0, dialogData.dialog.width);
                this.refreshSkipPosition(tf, minTextAreaWidth, dialogData.dialog.align);
                if (dialogData.dialog.wordWrap) {
                    this.refreshSkipPosition(tf, minTextAreaWidth, dialogData.dialog.align);
                    if (tfStartX + tf.textWidth > minTextAreaWidth) {
                        var keySymbolMatchs = text.match(GameDialog.KEY_SYMBOL_reg);
                        var keySymbolIndexArr = {};
                        if (keySymbolMatchs) {
                            var startIndex = 0;
                            for (var m = 0; m < keySymbolMatchs.length; m++) {
                                var keySymbol = keySymbolMatchs[0];
                                var keySymbolIndex = text.indexOf(keySymbol, startIndex);
                                for (var x = 0; x < keySymbol.length; x++)
                                    keySymbolIndexArr[keySymbolIndex + x] = true;
                                startIndex = keySymbolIndex + keySymbol.length;
                            }
                        }
                        for (var g = text.length - 1; g >= 0; g--) {
                            if (keySymbolIndexArr[g])
                                continue;
                            var trySplitText = text.substr(0, g);
                            var trySplitRealText = trySplitText.replace(GameDialog.KEY_SYMBOL_reg, "");
                            tf.text = trySplitRealText;
                            if (tfStartX + tf.textWidth <= minTextAreaWidth || g == 0) {
                                tf["playText"] = trySplitText;
                                var surplusText = text.substr(g);
                                lines.splice(s + 1, 0, surplusText);
                                this.refreshSkipPosition(tf, minTextAreaWidth, dialogData.dialog.align);
                                break;
                            }
                        }
                    }
                }
                tf.text = "";
            }
        }
        this.playTextLoopMod = 1;
        if (playSpeed == 0) {
            this.playTextLoopMod = 10;
        }
        else if (playSpeed == 1) {
            this.playTextLoopMod = 7;
        }
        else if (playSpeed == 2) {
            this.playTextLoopMod = 5;
        }
        else if (playSpeed == 3) {
            this.playTextLoopMod = 3;
        }
        if (playSpeed == 5) {
            this.playText();
        }
        this.playing = this.playSpeed != 5;
        this.playTextLoop = 0;
        os.remove_ENTERFRAME(this.playText, this);
        os.add_ENTERFRAME(this.playText, this);
    };
    GameDialog.prototype.refreshSkipPosition = function (tf, textAreaWidth, align) {
        if (align == 0) {
            this.lastTextPosX = tf.x + tf.textWidth;
        }
        else if (align == 1) {
            this.lastTextPosX = tf.x + (textAreaWidth + tf.textWidth) * 0.5;
        }
        else if (align == 2) {
            this.lastTextPosX = tf.x + textAreaWidth;
        }
    };
    GameDialog.prototype.changeDialog = function (change) {
        var dialogData = new DialogData();
        for (var attID in this.dialogData) {
            var att = this.dialogData[attID];
            for (var a in att) {
                dialogData[attID][a] = att[a];
            }
        }
        if (!change)
            return dialogData;
        if (change.mode == 0) {
            for (var compID in change.atts) {
                var comp = dialogData[compID];
                if (comp) {
                    var attsValues = change.atts[compID][0];
                    var useVarAndTransitionAttrs = change.atts[compID][1];
                    for (var attName in attsValues) {
                        var attValue = attsValues[attName];
                        if (!Config.EDIT_MODE && useVarAndTransitionAttrs && useVarAndTransitionAttrs[attName].type != null) {
                            if (useVarAndTransitionAttrs[attName].type == 0) {
                                attValue = Game.player.variable.getVariable(useVarAndTransitionAttrs[attName].index);
                            }
                            else if (useVarAndTransitionAttrs[attName].type == 1) {
                                attValue = Game.player.variable.getString(useVarAndTransitionAttrs[attName].index);
                            }
                            else if (useVarAndTransitionAttrs[attName].type == 2) {
                                attValue = Game.player.variable.getSwitch(useVarAndTransitionAttrs[attName].index) ? true : false;
                            }
                        }
                        comp[attName] = attValue;
                    }
                }
            }
        }
        return dialogData;
    };
    GameDialog.prototype.dialogMoveFrameUpdate = function (m, nonTweenType) {
        var per = m.curTime / m.time;
        for (var i = 0; i < m.attrInfos.length; i++) {
            var attrInfo = m.attrInfos[i];
            if (!attrInfo.needTween) {
                if ((nonTweenType == 0 && m.curTime == 1) || (nonTweenType == 1 && per == 1)) {
                    this.changes(attrInfo.uiComp, attrInfo.compID, attrInfo.attName, attrInfo.newValue);
                }
            }
            else {
                var valuePer = GameUtils.getValueByTransData(m.transData, per);
                this.changes(attrInfo.uiComp, attrInfo.compID, attrInfo.attName, (attrInfo.newValue - attrInfo.oldValue) * valuePer + attrInfo.oldValue);
            }
        }
        m.curTime++;
    };
    GameDialog.prototype.changes = function (uiComp, compID, attName, v) {
        if (compID == "skipBox") {
            switch (attName) {
                case "scaleNumber":
                    this.skipAni.scaleX = this.skipAni.scaleY = v;
                    return;
                case "animationID":
                    this.skipAni.id = v;
                    return;
                case "playType":
                    this.skipAni.loop = v == 2 ? true : false;
                    return;
                case "posX":
                    this.skipAniPoint.x = v;
                    return;
                case "posY":
                    this.skipAniPoint.y = v;
                    return;
                case "posIndex":
                    this.dialogData.skipBox.posIndex = v;
                    return;
            }
        }
        if (compID == "headBox") {
            switch (attName) {
                case "flip":
                    this.headBox.scaleX = v ? -1 : 1;
                    return;
            }
        }
        if (compID == "dialog" && (attName != "x" && attName != "y" && attName != "height" && attName != "width")) {
            this.playTextLabels.forEach(function (a, i) {
                a[attName] = v;
            });
            return;
        }
        if (uiComp[attName])
            uiComp[attName] = v;
    };
    GameDialog.prototype.disposeHead = function () {
        if (this.headImg) {
            this.headImg.dispose();
            this.headImg = null;
        }
        if (this.headStand) {
            this.headStand.dispose();
            this.headStand = null;
        }
        if (this.headAni) {
            this.headAni.dispose();
            this.headAni = null;
        }
        if (this.headUI) {
            this.headUI.dispose();
            this.headUI = null;
        }
    };
    GameDialog.prototype.refreshHeadBox = function (param, exp) {
        if (!this.dialogData)
            return;
        var mode = this.dialogData.headBox.perviewMode;
        if (!mode) {
            if (typeof param === "string") {
                if (!this.headImg)
                    this.headImg = new UIComponent.UIBitmap();
                this.headImg.visible = false;
                if (this.headImg.image != param)
                    this.headImg.once(EventObject.LOADED, this, this.refreshBitmapSize);
                else
                    this.refreshBitmapSize();
                this.headBox.addChild(this.headImg);
                this.headImg.image = param;
            }
            else {
                param = null;
            }
        }
        else if (mode == 1) {
            var standID = MathUtils.int(param);
            if (standID > 0) {
                if (!this.headStand)
                    this.headStand = new UIComponent.UIStandAvatar();
                this.headStand.avatar.syncLoadWhenAssetExist = true;
                if (Config.EDIT_MODE)
                    this.headStand.avatar.forceRender = true;
                this.headStand.avatarID = standID;
                if (!exp || exp < 1)
                    exp = 1;
                this.headStand.actionID = exp;
                this.headStand.scale(this.changeDialogData.headBox.viewscaleX, this.changeDialogData.headBox.viewscaleY);
                this.headStand.isPlay = true;
                this.headStand.playOnce = this.changeDialogData.headBox.viewPlayOnce;
                this.headStand.avatarFPS = this.changeDialogData.headBox.viewFps;
                this.headBox.addChild(this.headStand);
            }
        }
        else if (mode == 2) {
            var aniID = MathUtils.int(param);
            if (aniID > 0) {
                if (!this.headAni)
                    this.headAni = new UIComponent.UIAnimation();
                this.headBox.addChild(this.headAni);
                this.headAni.animation.syncLoadWhenAssetExist = true;
                this.headAni.animation.showHitEffect = true;
                this.headAni.animationID = aniID;
                this.headAni.playFps = this.changeDialogData.headBox.viewFps;
                this.headAni.scale(this.changeDialogData.headBox.viewscaleX, this.changeDialogData.headBox.viewscaleY);
                this.headAni.playType = this.changeDialogData.headBox.viewPlayOnce ? 1 : 2;
            }
        }
        else if (mode == 3) {
            var uiID = MathUtils.int(param);
            if (uiID > 0) {
                if (this.headUI)
                    this.headUI.offAll(EventObject.LOADED);
                this.headUI = GameUI.load(uiID, true);
                this.headUI.visible = false;
                this.headUI.once(EventObject.LOADED, this, this.refreshUISize);
                this.headBox.addChild(this.headUI);
            }
        }
        if (this.dialogMaterialEnabled && this.dialogHeadBoxMaterial) {
            this.headBox.installMaterialData(ObjectUtils.depthClone(this.dialogData.headBox.materialData));
        }
    };
    GameDialog.prototype.refreshBitmapSize = function () {
        var tex = loader.getRes(this.headImg.image);
        if (!tex)
            return;
        if (this.changeDialogData.headBox.locksize) {
            if (!this.changeDialogData.headBox.adaptation) {
                this.headImg.width = this.headBox.width;
                this.headImg.height = this.headBox.height;
            }
            else {
                var per = GameUtils.getAutoFitSizePre(new Rectangle(0, 0, tex.width, tex.height), new Rectangle(0, 0, this.headBox.width, this.headBox.height));
                this.headImg.width = per * tex.width;
                this.headImg.height = per * tex.height;
            }
        }
        else {
            this.headImg.width = tex.width;
            this.headImg.height = tex.height;
        }
        this.headImg.visible = true;
    };
    GameDialog.prototype.refreshUISize = function () {
        var _this_1 = this;
        this.headUI.scale(1, 1);
        var uiRect = this.headUI.getBounds();
        if (!uiRect.width || !uiRect.height) {
            Callback.New(function () {
                _this_1.refreshUISize();
            }, this).delayRun(100);
        }
        else {
            if (this.changeDialogData.headBox.locksize) {
                if (!this.changeDialogData.headBox.adaptation) {
                    var perx = this.headBox.width / uiRect.width;
                    var pery = this.headBox.height / uiRect.height;
                    this.headUI.scale(perx, pery);
                }
                else {
                    var per = GameUtils.getAutoFitSizePre(new Rectangle(0, 0, uiRect.width, uiRect.height), new Rectangle(0, 0, this.headBox.width, this.headBox.height));
                    this.headUI.scale(per, per);
                }
            }
            this.headUI.visible = true;
        }
    };
    GameDialog.prototype.stop = function (disposeHead, dispatchEvent) {
        if (disposeHead === void 0) { disposeHead = true; }
        if (dispatchEvent === void 0) { dispatchEvent = true; }
        os.remove_ENTERFRAME(this.playText, this);
        if (this.parent) {
            this.parent.removeChild(this);
        }
        if (disposeHead)
            this.disposeHead();
        this.playing = false;
        GameDialog.isCloseDialog = true;
        this.clearDelayStop();
        if (GameDialog.maskLayer)
            GameDialog.maskLayer.removeSelf();
        GameDialog.unbindingSoPosition();
        if (dispatchEvent)
            EventUtils.happen(GameDialog, GameDialog.EVENT_DIALOG_CLOSE, [GameDialog.lastDialog]);
    };
    GameDialog.prototype.stopTsAudio = function () {
        if (GameDialog.tschannel) {
            GameDialog.tschannel.offAll();
            GameAudio.stopTS(GameDialog.tschannel);
            GameDialog.tschannel = null;
        }
    };
    GameDialog.prototype.clearDelayStop = function () {
        if (this.delayStop) {
            clearTimeout(this.delayStop);
            this.delayStop = null;
        }
        if (this.skipAniDelay) {
            clearTimeout(this.skipAniDelay);
            this.skipAniDelay = null;
        }
    };
    GameDialog.prototype.optionClear = function () {
        this.optionBox.removeChildren();
        this.optionText.removeChildren();
    };
    GameDialog.prototype.setOption = function (options, defaultIndex, cancelIndex, hideIndexs) {
        if (defaultIndex === void 0) { defaultIndex = -1; }
        if (cancelIndex === void 0) { cancelIndex = -1; }
        if (hideIndexs === void 0) { hideIndexs = []; }
        this.optionClear();
        var dialogData = this.updateOptionPostion();
        this.changeDialogData = dialogData;
        var column = dialogData.optionBox.column;
        if (!this.optionList) {
            this.optionList = new UIComponent.UIList();
            this.optionList.overSelectMode = true;
        }
        this.hidedIndexs = hideIndexs;
        this.optionList.itemModelClass = GameDialogOption;
        this.optionList.itemWidth = dialogData.optionBox.width;
        this.optionList.itemHeight = dialogData.optionBox.height;
        this.optionList.spaceX = dialogData.optionBox.columnSpaceing;
        this.optionList.spaceY = dialogData.optionBox.rowSpaceing;
        this.optionList.repeatX = column;
        this.optionList.width = column * (dialogData.optionBox.width + dialogData.optionBox.columnSpaceing) + this.optionList.scrollWidth;
        this.optionList.height = Math.ceil(options.length / column) * (dialogData.optionBox.height + dialogData.optionBox.rowSpaceing) + this.optionList.scrollWidth;
        this.optionList.selectImageURL = dialogData.optionBox.selectImageURL;
        this.optionList.selectImageGrid9 = dialogData.optionBox.grid9img4;
        this.optionList.once(UIComponent.UIList.ITEM_CLICK, this, this.onClick, [{ target: null }, true]);
        var items = [];
        for (var i = 0; i < options.length; i++) {
            var d = new UIListItemData();
            items.push(d);
        }
        this.optionList.items = items;
        this.optionTexts = [];
        for (var i = 0; i < options.length; i++) {
            var optionSp = this.optionList.getItemUI(i);
            optionSp.setData(dialogData);
            var opText = new UIComponent.UIString();
            ObjectUtils.clone(dialogData.option, opText);
            opText.wordWrap = false;
            opText.text = options[i];
            opText.x = optionSp.x;
            opText.y = optionSp.y;
            this.optionText.addChild(opText);
            this.optionTexts.push(opText);
            optionSp.add_MOUSEDOWN(this.onOptionMouseDown, this, [i]);
            optionSp.add_MOUSEOVER(this.onOptionMouseOver, this, [i]);
            optionSp.add_MOUSEUP(this.onOptionMouseOut, this, [i]);
            optionSp.add_MOUSEOUT(this.onOptionMouseOut, this, [i]);
            if (this.dialogMaterialEnabled && this.dialogOptionTextMaterial) {
                opText.installMaterialData(ObjectUtils.depthClone(dialogData.option.materialData));
            }
        }
        this.optionBox.addChild(this.optionList);
        UIComponent.UIList.focus = this.optionList;
        var defaultIndexHide = defaultIndex < 0 || hideIndexs.indexOf(defaultIndex) >= 0;
        var cancelIndexHide = cancelIndex < 0 || hideIndexs.indexOf(cancelIndex) >= 0;
        if (!UIComponent.UIList.KEY_BOARD_ENABLED) {
            stage.off(EventObject.KEY_DOWN, this, this.onKeyDow);
            if (!cancelIndexHide)
                stage.on(EventObject.KEY_DOWN, this, this.onKeyDow);
        }
        if (!cancelIndexHide) {
            stage.on(EventObject.RIGHT_MOUSE_DOWN, this, this.rightDown);
            var oldCancelIndex = cancelIndex;
            for (var i = 0; i < this.hidedIndexs.length; i++) {
                if (this.hidedIndexs[i] < oldCancelIndex)
                    cancelIndex -= 1;
            }
        }
        else {
            cancelIndex = -1;
        }
        if (!defaultIndexHide) {
            var oldDefaultIndex = defaultIndex;
            for (var i = 0; i < this.hidedIndexs.length; i++) {
                if (this.hidedIndexs[i] < oldDefaultIndex)
                    defaultIndex -= 1;
            }
        }
        else {
            defaultIndex = 0;
        }
        this.optionList.cancelSelectedIndex = cancelIndex;
        this.optionList.selectedIndex = defaultIndex;
        EventUtils.happen(GameDialog, GameDialog.EVENT_DIALOG_WORD_PLAY_COMPLETE, [true]);
        if (this.dialogText.visible && this.nameText.visible && this.headBox.visible && this.dialogBox.visible) {
            this.skipAni.visible = true;
            if (dialogData.skipBox.posIndex == 0) {
                this.skipAni.x = dialogData.skipBox.x;
                this.skipAni.y = dialogData.skipBox.y;
            }
            else {
                this.skipAni.x = this.dialogText.x + this.lastTextPosX + this.skipAniPoint.x + 6;
                this.skipAni.y = this.dialogText.y + this.lastTextPosY + this.skipAniPoint.y;
            }
            this.skipAni.gotoAndPlay();
        }
        if (this.dialogMaterialEnabled && this.dialogOptionBoxTextMaterial) {
            this.optionList.installMaterialData(ObjectUtils.depthClone(dialogData.optionBox.materialData));
        }
    };
    GameDialog.prototype.onKeyDow = function (e) {
        if (UIComponent.UIList.KEY_BOARD_ENABLED)
            return;
        if (e.keyCode == Keyboard.ESCAPE) {
            if (this.optionList.cancelSelectedIndex >= 0 && this.optionList.cancelSelectedIndex < this.optionList.items.length) {
                this.optionList.selectedIndex = this.optionList.cancelSelectedIndex;
                this.onClick({ target: null }, true);
            }
        }
    };
    GameDialog.prototype.rightDown = function () {
        if (this.optionList.cancelSelectedIndex >= 0 && this.optionList.cancelSelectedIndex < this.optionList.items.length) {
            this.optionList.selectedIndex = this.optionList.cancelSelectedIndex;
            this.onClick({ target: null }, true);
        }
    };
    GameDialog.prototype.onOptionMouseDown = function (index) {
        var text = this.optionText.getChildAt(index);
        if (!text)
            return;
        text.color = this.changeDialogData.option.clickColor;
    };
    GameDialog.prototype.onOptionMouseOver = function (index) {
        if (this.dialogData.optionBox.overSe) {
            GameAudio.playSE(this.optionOverSE, this.changeDialogData.optionBox.overVolume, this.changeDialogData.optionBox.overPitch);
        }
        for (var i = 0; i < this.optionText.numChildren; i++) {
            var text = this.optionText.getChildAt(i);
            if (!text)
                continue;
            if (i == index) {
                text.color = this.changeDialogData.option.overColor;
            }
            else {
                text.color = this.changeDialogData.option.color;
            }
        }
    };
    GameDialog.prototype.onOptionMouseOut = function (index) {
        var text = this.optionText.getChildAt(index);
        if (!text)
            return;
        text.color = this.changeDialogData.option.color;
    };
    GameDialog.prototype.playText = function (waitFrame) {
        var _this_1 = this;
        if (waitFrame === void 0) { waitFrame = true; }
        if (this.waitPlayerClick)
            return;
        if (waitFrame && this.playSpeed != 5 && this.playTextLoop++ % this.playTextLoopMod != 0)
            return;
        this.skipAni.visible = false;
        this.skipAni.stop();
        var tf = this.playTextLabels[this.playTextIndex];
        if (!tf) {
            this.playing = false;
            os.remove_ENTERFRAME(this.playText, this);
            if (this.changeDialogData.skipBox.posIndex == 0) {
                this.skipAni.x = this.changeDialogData.skipBox.x;
                this.skipAni.y = this.changeDialogData.skipBox.y;
            }
            else {
                this.skipAni.x = this.dialogText.x + this.lastTextPosX + this.skipAniPoint.x + 6;
                this.skipAni.y = this.dialogText.y + this.lastTextPosY + this.skipAniPoint.y;
            }
            this.skipAniDelay = setTimeout(function () {
                _this_1.skipAni.visible = true;
                _this_1.skipAni.gotoAndPlay();
                EventUtils.happen(GameDialog, GameDialog.EVENT_DIALOG_WORD_PLAY_COMPLETE, [!_this_1.forceShow]);
            }, (this.playSpeed == 5) ? 0 : this.changeDialogData.skipBox.delayTime * 1000);
            return;
        }
        var word = tf["playText"][this.playTextLabelIndex];
        if (!word) {
            this.playTextLabelIndex = 0;
            this.playTextIndex++;
            this.playText(false);
            return;
        }
        if (this.dialogMaterialEnabled && this.dialogTextMaterial && this.playSpeed != 5) {
            tf.installMaterialData(ObjectUtils.depthClone(this.dialogData.dialog.materialData));
        }
        this.playTextLabelIndex++;
        if (word == GameDialog.KEY_SYMBOL_DELAY) {
            if (this.waitStart == 0) {
                this.waitStart = this.waitTimeArr.shift();
                EventUtils.happen(GameDialog, GameDialog.EVENT_DIALOG_TEXT_WAIT_TIME, [this.waitStart]);
            }
            this.waitStart--;
        }
        else if (word == GameDialog.KEY_SYMBOL_SKIP) {
            this.hasSkip = true;
            if (!this.forceShow && this.playSpeed != 5) {
                this.playing = false;
                this.onClick(null, true, true);
            }
            return;
        }
        else if (word == GameDialog.KEY_SYMBOL_WAIT_PLAYER_CLICK) {
            if (this.playSpeed != 5) {
                if (this.changeDialogData.skipBox.posIndex == 0) {
                    this.skipAni.x = this.changeDialogData.skipBox.x;
                    this.skipAni.y = this.changeDialogData.skipBox.y;
                }
                else {
                    this.skipAni.x = this.dialogText.x + tf.x + tf.textWidth + this.skipAniPoint.x + 6;
                    this.skipAni.y = this.dialogText.y + tf.y + (tf.fontSize + tf.leading - this.skipHeight) * 0.5 + this.skipAniPoint.y;
                }
                this.skipAni.visible = true;
                this.skipAni.gotoAndPlay();
                this.waitPlayerClick = true;
                EventUtils.happen(GameDialog, GameDialog.EVENT_WAIT_PALYER_OPERATION, [0]);
            }
        }
        else {
            tf.text += word;
            if (!this.forceShow && this.playSpeed != 5)
                EventUtils.happen(GameDialog, GameDialog.EVENT_DIALOG_WORD_PLAY, [word]);
        }
        if (this.playSpeed == 5)
            this.playText();
    };
    GameDialog.prototype.clearTextMaterials = function () {
        for (var i_21 = 0; i_21 < this.playTextLabels.length; i_21++) {
            this.playTextLabels[i_21].clearMaterials();
        }
    };
    GameDialog.prototype.onSelfClick = function (e) {
        if (GameDialog.optionMode) {
            this.onClick(e, false);
        }
    };
    GameDialog.prototype.onClick = function (e, listItemClick, fromAutoPlaySkipSign) {
        if (listItemClick === void 0) { listItemClick = true; }
        if (fromAutoPlaySkipSign === void 0) { fromAutoPlaySkipSign = false; }
        if (Config.EDIT_MODE && !GameDialog.container)
            return;
        if (!listItemClick && GameDialog.optionMode)
            return;
        if (GameDialog.isCloseDialog)
            return;
        if (this.playing) {
            if (this.waitPlayerClick) {
                this.waitPlayerClick = false;
                EventUtils.happen(GameDialog, GameDialog.EVENT_WAIT_PALYER_OPERATION, [1]);
                return;
            }
            if (!GameDialog.dialogTextShowAllEnabled)
                return;
            this.forceShow = true;
            this.playSpeed = 5;
            this.playText();
            this.clearTextMaterials();
        }
        else if (GameDialog.showOptionWithLastDialog) {
            GameDialog.showOption(this.id, GameDialog.showOptionWithLastDialog, true, GameDialog.showOptionWithLastDialogParams[0], GameDialog.showOptionWithLastDialogParams[1], GameDialog.showOptionWithLastDialogParams[2]);
        }
        else {
            var lastCurrentDialogSign = GameDialog.currentDialogSign;
            GameDialog.isCloseDialog = true;
            EventUtils.happen(GameDialog, GameDialog.EVENT_DIALOG_END, [GameDialog.lastDialog, fromAutoPlaySkipSign]);
            if (GameDialog.currentDialogSign == lastCurrentDialogSign) {
                if (GameDialog.lastDialog) {
                    GameDialog.lastDialog.clearDelayStop();
                    GameDialog.lastDialog.delayStop = setTimeout(function (lastDialog) {
                        lastDialog.stop();
                    }, GameDialog.delayCloseTime, this, [GameDialog.lastDialog]);
                }
            }
            if (GameDialog.optionMode) {
                if (this.optionClickSE)
                    GameAudio.playSE(this.optionClickSE, this.changeDialogData.optionBox.clickVolume, this.changeDialogData.optionBox.clikcPitch);
                if (e.target && !(e.target.parent instanceof GameDialogOption))
                    return;
                stage.off(EventObject.KEY_DOWN, this, this.onKeyDow);
                stage.off(EventObject.RIGHT_MOUSE_DOWN, this, this.rightDown);
                var index = this.optionList.selectedIndex;
                for (var i = 0; i < this.hidedIndexs.length; i++) {
                    if (this.hidedIndexs[i] <= index) {
                        index += 1;
                        this.hidedIndexs.splice(i, 1);
                        i--;
                    }
                }
                GameCommand.inputMessageAndContinueExecute([index]);
            }
            else {
                if (GameDialog.lastDialog && GameDialog.lastDialog.submitCallback) {
                    GameDialog.lastDialog.submitCallback.run();
                }
                else {
                    GameCommand.inputMessageAndContinueExecute();
                }
            }
        }
    };
    Object.defineProperty(GameDialog.prototype, "optionClickSE", {
        get: function () {
            if (!this.changeDialogData.optionBox.clickSe)
                this.changeDialogData.optionBox.clickSe = "";
            return this.changeDialogData.optionBox.clickSe.split(",")[0];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameDialog.prototype, "optionOverSE", {
        get: function () {
            if (!this.changeDialogData.optionBox.overSe)
                this.changeDialogData.optionBox.overSe = "";
            return this.changeDialogData.optionBox.overSe.split(",")[0];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameDialog.prototype, "optionUIs", {
        get: function () {
            if (!this.optionList || !this.optionList.stage)
                return [];
            var arr = [];
            for (var i = 0; i < this.optionList.length; i++) {
                var itemUI = this.optionList.getItemUI(i);
                var btn = itemUI["opBtn"];
                arr.push(btn);
            }
            return arr;
        },
        enumerable: false,
        configurable: true
    });
    GameDialog.EVENT_DIALOG_START = "GameDialogEVENT_DIALOG_START";
    GameDialog.EVENT_AFTER_DIALOG_START = "GameDialogEVENT_AFTER_DIALOG_START";
    GameDialog.EVENT_DIALOG_END = "GameDialogEVENT_DIALOG_END";
    GameDialog.EVENT_DIALOG_CLOSE = "GameDialogEVENT_DIALOG_CLOSE";
    GameDialog.EVENT_DIALOG_WORD_PLAY = "GameDialogEVENT_DIALOG_WORD_PLAY";
    GameDialog.EVENT_DIALOG_WORD_PLAY_COMPLETE = "GameDialogEVENT_DIALOG_WORD_PLAY_COMPLETE";
    GameDialog.EVENT_TS_PLAY_COMPLETE = "GameDialogEVENT_TS_PLAY_COMPLETE";
    GameDialog.EVENT_WAIT_PALYER_OPERATION = "GameDialogEVENT_WAIT_PALYER_OPERATION";
    GameDialog.EVENT_DIALOG_TEXT_WAIT_TIME = "GameDialogEVENT_DIALOG_TEXT_WAIT_TIME";
    GameDialog.EVENT_BEFORE_RECOVERY_DIALOG = "GameDialogEVENT_BEFORE_RECOVERY_DIALOG";
    GameDialog.dialogTextShowAllEnabled = true;
    GameDialog.TRANS_PARENT_COLOR = "#FfFffF";
    GameDialog.COLOR_FORMAT = /<span style=['"]color:#[0-9a-zA-Z]{6,6}['"]>(.|\n)*?<\/span>/g;
    GameDialog.KEY_SYMBOL_DELAY = String.fromCharCode(1);
    GameDialog.KEY_SYMBOL_WAIT_PLAYER_CLICK = String.fromCharCode(2);
    GameDialog.KEY_SYMBOL_SKIP = String.fromCharCode(3);
    GameDialog.KEY_SYMBOL_reg = new RegExp(GameDialog.KEY_SYMBOL_DELAY + "|" + GameDialog.KEY_SYMBOL_WAIT_PLAYER_CLICK + "|" + GameDialog.KEY_SYMBOL_SKIP, "g");
    GameDialog.delayCloseTime = 100;
    GameDialog.dialogCache = [];
    return GameDialog;
}(Sprite));
var GameDialogOption = (function (_super) {
    __extends(GameDialogOption, _super);
    function GameDialogOption() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GameDialogOption.prototype.setData = function (dialogData) {
        if (this.isDisposed)
            return;
        var opBtn = this.opBtn = new UIComponent.UIButton();
        this.addChild(opBtn);
        opBtn.width = dialogData.optionBox.width;
        opBtn.height = dialogData.optionBox.height;
        opBtn.image1 = dialogData.optionBox.image1;
        opBtn.grid9img1 = dialogData.optionBox.grid9img1;
        opBtn.image2 = dialogData.optionBox.image2;
        opBtn.grid9img2 = dialogData.optionBox.grid9img2;
        opBtn.image3 = dialogData.optionBox.image3;
        opBtn.grid9img3 = dialogData.optionBox.grid9img3;
    };
    GameDialogOption.prototype.dispose = function () {
        if (!this.isDisposed) {
            this.__isDisposed = true;
            if (this.opBtn)
                this.opBtn.dispose();
            this.opBtn = null;
            this.destroy();
        }
        _super.prototype.disposeSelfAsset.call(this);
    };
    return GameDialogOption;
}(UIComponent.UIRoot));















var GameImage = (function (_super) {
    __extends(GameImage, _super);
    function GameImage() {
        var _this_1 = _super.call(this) || this;
        _this_1.mouseEnabled = true;
        return _this_1;
    }
    Object.defineProperty(GameImage, "imageLayer", {
        get: function () {
            if (GameImage._imageLayer) {
                return GameImage._imageLayer;
            }
            return Game.layer.imageLayer;
        },
        set: function (v) {
            GameImage._imageLayer = v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameImage, "uiLayer", {
        get: function () {
            if (GameImage._uiLayer) {
                return GameImage._uiLayer;
            }
            return Game.layer.uiLayer;
        },
        set: function (v) {
            GameImage._uiLayer = v;
        },
        enumerable: false,
        configurable: true
    });
    GameImage.init = function () {
        if (Config.CREATED_GC_VERSION && Config.SINGLE_PLAYER_CORE)
            return;
        os.add_ENTERFRAME(this.update, this, [true]);
        if (!Config.EDIT_MODE) {
            EventUtils.addEventListener(GameUI, GameUI.EVENT_CLOSE_SYSTEM_UI, Callback.New(this.onUIClose, this));
            EventUtils.addEventListener(GameUI, GameUI.EVENT_OPEN_SYSTEM_UI, Callback.New(this.onUIOpen, this));
        }
    };
    GameImage.onUIOpen = function (uiID) {
        var passageID = GameImage.UI_START_PASSAGE + uiID;
        var ui = GameUI.get(uiID);
        if (!ui)
            return;
        GameImage.imageInfos[passageID] = { image: ui };
    };
    GameImage.onUIClose = function (uiID) {
        var passageID = GameImage.UI_START_PASSAGE + uiID;
        var imageInfo = GameImage.imageInfos[passageID];
        if (imageInfo && (imageInfo.image instanceof UIComponent.UIRoot)) {
            var ui = imageInfo.image;
            if (ui) {
                delete GameImage.imageInfos[passageID];
            }
        }
    };
    GameImage.clear = function () {
        for (var i in GameImage.imageInfos) {
            var ani = GameImage.imageInfos[i].image;
            if (ani && ani.dispose) {
                ani.dispose();
            }
        }
        GameImage.imageInfos = {};
        for (var s = 0; s < this.executeGroups.length; s++) {
            var group = this.executeGroups[s];
            if (group)
                group.dispose();
        }
        this.executeGroups = [];
    };
    GameImage.clearPassageMoveEffect = function (id) {
        for (var s = 0; s < this.executeGroups.length; s++) {
            var group = this.executeGroups[s];
            group.clearPassageMoveEffect(id);
        }
    };
    GameImage.listenerImageOver = function (triggerLineID) {
        GameImage.listeningWaitImagePlayOvers.push(triggerLineID);
        var c;
        EventUtils.addEventListener(GameImage, GameImage.EVENT_PLAY_OVER, c = Callback.New(function (triggerLineID, groupTriggerLineID) {
            if (groupTriggerLineID == triggerLineID && !GameImage.isPlaying(groupTriggerLineID)) {
                ArrayUtils.remove(GameImage.listeningWaitImagePlayOvers, triggerLineID);
                GameCommand.inputMessageAndContinueExecute(null, true, 1, triggerLineID);
                EventUtils.removeEventListener(GameImage, GameImage.EVENT_PLAY_OVER, c);
            }
        }, this, [triggerLineID]));
    };
    GameImage.addImageToLayer = function (id, image) {
        var newImageInfo = {
            image: image
        };
        var insertImageInfo;
        for (var i in GameImage.imageInfos) {
            var imageInfo = GameImage.imageInfos[i];
            var layerID = parseInt(i);
            if (layerID > id && !(imageInfo.image instanceof UIComponent.UIRoot)) {
                insertImageInfo = imageInfo;
            }
        }
        if (insertImageInfo) {
            var index = GameImage.imageLayer.getChildIndex(insertImageInfo.image);
            if (index != -1) {
                GameImage.imageLayer.addChildAt(image, index);
            }
        }
        else {
            GameImage.imageLayer.addChild(image);
        }
        GameImage.imageInfos[id] = newImageInfo;
    };
    GameImage.addGroup = function (triggerLineID, imageInfos) {
        if (imageInfos.length == 0)
            return;
        var groupID = ArrayUtils.getNullPosition(GameImage.executeGroups);
        var group = GameImage.executeGroups[groupID] = new GameImageGroup;
        group.setData(triggerLineID, imageInfos);
        group.checkMainPlayOver();
    };
    GameImage.isPlaying = function (triggerLineID) {
        if (triggerLineID == -1) {
            var m = ArrayUtils.matchAttributes(GameImage.executeGroups, { isPlaying: true, mainPlayOver: false }, true);
            return m.length != 0;
        }
        var m = ArrayUtils.matchAttributes(GameImage.executeGroups, { triggerLineID: triggerLineID, isPlaying: true, mainPlayOver: false }, true);
        return m.length != 0;
    };
    GameImage.update = function (realFrame) {
        if (realFrame === void 0) { realFrame = true; }
        for (var i = 0; i < GameImage.executeGroups.length; i++) {
            var group = GameImage.executeGroups[i];
            if (!group)
                continue;
            var isRealPlayOver = group.update(realFrame);
            if (isRealPlayOver) {
                GameImage.executeGroups.splice(i, 1);
                i--;
            }
        }
    };
    GameImage.getSaveData = function () {
        var o = {};
        if (Config.CREATED_GC_VERSION && Config.SINGLE_PLAYER_CORE) {
            if (GameDialog.lastDialog && GameDialog.lastDialog.stage) {
                dialog = GameDialog.lastDialog;
                o.dialog = {};
                o.dialog.submitEnabled = GameImage.submitEnabled;
                o.dialog.childIndex = GameDialog.lastDialog.parent ? GameDialog.lastDialog.parent.getChildIndex(GameDialog.lastDialog) : null;
                o.dialog.childrenNum = GameDialog.lastDialog.parent ? GameDialog.lastDialog.parent.numChildren - 1 : null;
                if (dialog.submitCallback) {
                    o.dialog.submitCallback = dialog.submitCallback ? true : false;
                }
                o.dialog.currentDialogInfo = GameDialog.currentDialogInfo;
            }
            return o;
        }
        o.executeGroups = [];
        for (var i = 0; i < GameImage.executeGroups.length; i++) {
            var group = GameImage.executeGroups[i];
            if (group)
                o.executeGroups.push(group.getSaveData());
            else
                o.executeGroups.push(null);
        }
        o.imageInfos = [];
        for (var passageID in GameImage.imageInfos) {
            var imageInfo = GameImage.imageInfos[passageID];
            if (imageInfo.image instanceof GameImage) {
                var p = imageInfo.image;
                o.imageInfos.push([0, passageID, p.image, p.pivotType, p.x, p.y, p.width, p.height, p.rotation, p.alpha, p.blendMode]);
            }
            else if (imageInfo.image instanceof GCAnimation) {
                var a = imageInfo.image;
                o.imageInfos.push([1, passageID, a.id, a.x, a.y, a.scaleX, a.scaleY, a.rotation, a.alpha, a.loop, a.fps]);
            }
            else if (imageInfo.image instanceof UIComponent.UIStandAvatar) {
                var s = imageInfo.image;
                o.imageInfos.push([2, passageID, s.x, s.y, s.rotation, s.alpha, s.scaleX, s.scaleY, s.avatarID, s.avatarFPS, s.isPlay]);
            }
            else if (imageInfo.image instanceof UIComponent.UIRoot) {
                if (SinglePlayerGame.fileSaveConfig.ui) {
                    var u = imageInfo.image;
                    o.imageInfos.push([3, passageID, u.x, u.y, u.rotation, u.alpha, u.scaleX, u.scaleY, u.guiID]);
                }
            }
        }
        o.uis = [];
        var uiComps = [];
        o.uiComps = uiComps;
        var numchildren = Game.layer.uiLayer.numChildren;
        var dialog;
        for (var i = 0; i < numchildren; i++) {
            var ui = Game.layer.uiLayer.getChildAt(i);
            if (SinglePlayerGame.fileSaveConfig.ui && ui instanceof UIComponent.UIRoot) {
                var root = ui;
                if (GameUI.get(MathUtils.int(root.guiID))) {
                    o.uis.push(root.guiID);
                    if (SinglePlayerGame.fileSaveConfig.uiComp) {
                        var allComps = [];
                        var uiCompInfos = {};
                        uiComps.push(uiCompInfos);
                        ArrayUtils.getTreeNodeArray(root, "_childs", allComps);
                        allComps.forEach(function (comp) {
                            if (comp instanceof UIComponent.UIBase) {
                                var uiCompAtts = uiCompInfos[comp.id] = {};
                                for (var b in UIComponent.UIBase.BASE_ATTRS_OBJ) {
                                    uiCompAtts[b] = comp[b];
                                }
                                var __compCustomAttributes = GameUI["__compCustomAttributes"];
                                if (__compCustomAttributes) {
                                    var customAttrs = __compCustomAttributes[comp.className];
                                    for (var c in customAttrs) {
                                        var b = customAttrs[c];
                                        uiCompAtts[b] = comp[b];
                                    }
                                }
                            }
                        });
                    }
                }
            }
            else if (ui instanceof GameDialog && !GameDialog.isCloseDialog) {
                o.uis.push(-1);
                if (SinglePlayerGame.fileSaveConfig.uiComp)
                    uiComps.push(null);
                dialog = ui;
            }
        }
        if (dialog) {
            o.dialog = {};
            o.dialog.submitEnabled = GameImage.submitEnabled;
            if (dialog.submitCallback) {
                o.dialog.submitCallback = dialog.submitCallback ? true : false;
            }
            o.dialog.currentDialogInfo = GameDialog.currentDialogInfo;
        }
        o.listeningWaitImagePlayOvers = GameImage.listeningWaitImagePlayOvers;
        return o;
    };
    GameImage.recoverySaveData = function (o) {
        if (Config.CREATED_GC_VERSION && Config.SINGLE_PLAYER_CORE) {
            if (o.dialog) {
                var dialogType = o.dialog.currentDialogInfo.shift();
                if (dialogType == 0) {
                    if (o.dialog.submitCallback == null) {
                        EventUtils.happen(GameDialog, GameDialog.EVENT_BEFORE_RECOVERY_DIALOG);
                        GameDialog.showDialog.apply(GameDialog, o.dialog.currentDialogInfo);
                    }
                    else {
                        gameDialogLayer = i;
                    }
                }
                else if (dialogType == 1) {
                    if (o.dialog.currentDialogInfo.length <= 6)
                        o.dialog.currentDialogInfo.splice(5, 0, []);
                    if (o.dialog.currentDialogInfo[2] && o.dialog.currentDialogInfo[6]) {
                        var dialogInfo = o.dialog.currentDialogInfo[6];
                        dialogInfo.shift();
                        dialogInfo[3] = 5;
                        EventUtils.happen(GameDialog, GameDialog.EVENT_BEFORE_RECOVERY_DIALOG);
                        GameDialog.showDialog.apply(GameDialog, dialogInfo);
                    }
                    GameDialog.showOption.apply(GameDialog, o.dialog.currentDialogInfo);
                }
                if (GameDialog.lastDialog && GameDialog.lastDialog.parent && o.dialog.childIndex != null) {
                    var childrenNum = o.dialog.childrenNum;
                    var offsetIndex = void 0;
                    if (childrenNum == null)
                        offsetIndex = 0;
                    else
                        offsetIndex = (GameDialog.lastDialog.parent.numChildren - 1) - childrenNum;
                    var toIndex = Math.max(o.dialog.childIndex + offsetIndex, 0);
                    GameDialog.lastDialog.parent.setChildIndex(GameDialog.lastDialog, toIndex);
                }
            }
            return;
        }
        var uis = o.uis;
        var uiComps = o.uiComps;
        var gameDialogLayer = -1;
        for (var i = 0; i < uis.length; i++) {
            var id = uis[i];
            if (id == -1) {
                var dialogType = o.dialog.currentDialogInfo.shift();
                if (dialogType == 0) {
                    if (o.dialog.submitCallback == null) {
                        EventUtils.happen(GameDialog, GameDialog.EVENT_BEFORE_RECOVERY_DIALOG);
                        GameDialog.showDialog.apply(GameDialog, o.dialog.currentDialogInfo);
                    }
                    else {
                        gameDialogLayer = i;
                    }
                }
                else if (dialogType == 1) {
                    if (o.dialog.currentDialogInfo.length <= 6)
                        o.dialog.currentDialogInfo.splice(5, 0, []);
                    if (o.dialog.currentDialogInfo[2] && o.dialog.currentDialogInfo[6]) {
                        var dialogInfo = o.dialog.currentDialogInfo[6];
                        dialogInfo.shift();
                        dialogInfo[3] = 5;
                        EventUtils.happen(GameDialog, GameDialog.EVENT_BEFORE_RECOVERY_DIALOG);
                        GameDialog.showDialog.apply(GameDialog, dialogInfo);
                    }
                    GameDialog.showOption.apply(GameDialog, o.dialog.currentDialogInfo);
                }
            }
            else {
                var ui = GameUI.show(id);
                if (uiComps.length == uis.length) {
                    var allComps = [], nodeObjs2 = {};
                    ArrayUtils.getTreeNodeArray(ui, "_childs", allComps);
                    for (var s = 0; s < allComps.length; s++) {
                        var nodeComp = allComps[s];
                        if (nodeComp instanceof UIComponent.UIBase) {
                            nodeObjs2[nodeComp.id] = nodeComp;
                        }
                    }
                    var uiCompInfos = uiComps[i];
                    for (var compID in uiCompInfos) {
                        var uiComp = nodeObjs2[compID];
                        if (uiComp) {
                            var uiCompAtts = uiCompInfos[compID];
                            for (var attName in uiCompAtts) {
                                var value = uiCompAtts[attName];
                                uiComp[attName] = value;
                            }
                            uiComp.onConditionCheck();
                        }
                    }
                }
            }
        }
        for (var i = 0; i < o.imageInfos.length; i++) {
            var p = o.imageInfos[i];
            var type = p.shift();
            if (type == 0) {
                var img = new GameImage();
                img.image = p[1];
                img.pivotType = p[2];
                img.x = p[3];
                img.y = p[4];
                img.width = p[5];
                img.height = p[6], img.rotation = p[7], img.alpha = p[8], img.blendMode = p[9];
                GameImage.addImageToLayer(p[0], img);
            }
            else if (type == 1) {
                var ani = new GCAnimation();
                ani.id = p[1];
                ani.x = p[2];
                ani.y = p[3];
                ani.scaleX = p[4];
                ani.scaleY = p[5];
                ani.rotation = p[6];
                ani.alpha = p[7];
                ani.loop = p[8];
                ani.fps = p[9];
                GameImage.addImageToLayer(p[0], ani);
                ani.play();
            }
            else if (type == 2) {
                var sa = new UIComponent.UIStandAvatar();
                sa.avatarID = p[7];
                sa.x = p[1];
                sa.y = p[2];
                sa.rotation = p[3];
                sa.alpha = p[4];
                sa.scaleX = p[5];
                sa.scaleY = p[6];
                sa.avatarFPS = p[8];
                sa.isPlay = p[9];
                GameImage.addImageToLayer(p[0], sa);
            }
            else if (type == 3) {
                var ui = GameUI.get(p[7]);
                if (ui) {
                    ui.x = p[1];
                    ui.y = p[2];
                    ui.rotation = p[3];
                    ui.alpha = p[4];
                    ui.scaleX = p[5];
                    ui.scaleY = p[6];
                    GameImage.imageInfos[p[0]] = { image: ui };
                }
            }
        }
        for (var i = 0; i < o.executeGroups.length; i++) {
            var groupData = o.executeGroups[i];
            if (!groupData)
                continue;
            var group = new GameImageGroup;
            group.recoverySaveData(groupData);
            GameImage.executeGroups[i] = group;
            if (group["_waitDialog"] && o.dialog.submitCallback && gameDialogLayer != -1) {
                var d = o.dialog.currentDialogInfo;
                group["doShowDialog"].call(group, d[0], d[1], d[2], d[3], d[4], d[5], d[4], d[6], d[7], d[8], o.dialog.submitEnabled, true);
            }
        }
        for (var i = 0; i < o.listeningWaitImagePlayOvers.length; i++) {
            GameImage.listenerImageOver(o.listeningWaitImagePlayOvers[i]);
        }
    };
    GameImage.EVENT_PLAY_OVER = "GameImage_EVENT_PLAY_OVER";
    GameImage.UI_START_PASSAGE = 100000000;
    GameImage.executeGroups = [];
    GameImage.imageInfos = {};
    GameImage.listeningWaitImagePlayOvers = [];
    return GameImage;
}(UIComponent.UIBitmap));
var GameImageGroup = (function () {
    function GameImageGroup() {
        this.delayFrame = 0;
        this.mainPlayOver = false;
        this.executeFuncs = [];
        this.motionImages = [];
        this.motionAnimations = [];
        this.autoRotations = [];
        this.changeTonals = [];
        this.motionUICompAttrs = [];
    }
    GameImageGroup.prototype.dispose = function () {
        if (GameCommand.isNeedPlayerInput && this.triggerLineID == GameCommand.inputTriggerLine) {
            GameCommand.isNeedPlayerInput = false;
        }
        this.motionImages = null;
        this.motionAnimations = null;
        this.changeTonals = null;
        this.isDisposed = true;
    };
    GameImageGroup.prototype.clearPassageMoveEffect = function (id) {
        var arr = [this.motionImages, this.motionAnimations, this.autoRotations, this.changeTonals];
        for (var i = arr.length - 1; i >= 0; i--) {
            var mArr = arr[i];
            var m = ArrayUtils.matchAttributes(mArr, { id: id }, true);
            if (m.length == 1) {
                mArr.splice(mArr.indexOf(m[0]), 1);
            }
        }
    };
    GameImageGroup.prototype.setData = function (triggerLineID, imageInfos) {
        var _this_1 = this;
        this.triggerLineID = triggerLineID;
        imageInfos = ObjectUtils.depthClone(imageInfos);
        var funcMapping = [
            this.showImage,
            this.moveImage,
            this.autoRotation,
            this.changeTonal,
            this.deleteImage,
            this.showAnimation,
            this.moveAnimation,
            null,
            this.delay,
            this.showDialog,
            function () {
                _this_1.addDoFunction(GameAudio.playSE, arguments, true, "GameAudio", "playSE");
            },
            this.showStandAvatar,
            function () {
                var args = [];
                for (var i = 0; i < arguments.length; i++)
                    args.push(arguments[i]);
                _this_1.moveStandAvatar.apply(_this_1, args);
            },
            function () {
                var args = [];
                for (var i = 0; i < arguments.length; i++)
                    if (i != 0 && i != 7)
                        args.push(arguments[i]);
                args.unshift(arguments[7]);
                _this_1.showUI.apply(_this_1, args);
            },
            function () {
                var args = [];
                for (var i = 0; i < arguments.length; i++)
                    if (i != 0 && i != 7 && i != 9)
                        args.push(arguments[i]);
                args.unshift(arguments[9], arguments[7]);
                _this_1.moveUI.apply(_this_1, args);
            },
            this.hideUI,
            this.changeUICompAttrs
        ];
        var imageInfosClone = imageInfos.concat();
        imageInfosClone.reverse();
        var lastDialog = ArrayUtils.matchAttributes(imageInfosClone, { "0": 9 }, true)[0];
        if (lastDialog) {
            lastDialog.splice(10, 1);
            lastDialog[11] = true;
        }
        for (var i = 0; i < imageInfos.length; i++) {
            var imageInfo = imageInfos[i];
            var type = imageInfo.shift();
            funcMapping[type].apply(this, imageInfo);
        }
    };
    GameImageGroup.prototype.showImage = function (passageID, url, pivotType, x, y, width, height, rotation, alpha, blendMode) {
        if (width === void 0) { width = 0; }
        if (height === void 0) { height = 0; }
        if (rotation === void 0) { rotation = 0; }
        if (alpha === void 0) { alpha = 1; }
        if (blendMode === void 0) { blendMode = null; }
        this.executeFuncs.push({ func: this.doShowImage, params: arguments, funcName: "doShowImage", cls: null });
        this.update(false);
    };
    GameImageGroup.prototype.moveImage = function (passageID, time, pivotType, x, y, width, height, rotation, alpha, blendMode, tweenID) {
        if (pivotType === void 0) { pivotType = 0; }
        if (width === void 0) { width = 0; }
        if (height === void 0) { height = 0; }
        if (rotation === void 0) { rotation = 0; }
        if (alpha === void 0) { alpha = 1; }
        if (blendMode === void 0) { blendMode = null; }
        if (tweenID === void 0) { tweenID = null; }
        this.executeFuncs.push({ func: this.doMoveImage, params: arguments, funcName: "doMoveImage", cls: null });
        this.update(false);
    };
    GameImageGroup.prototype.autoRotation = function (passageID, angle) {
        this.executeFuncs.push({ func: this.doAutoRotation, params: arguments, funcName: "doAutoRotation", cls: null });
        this.update(false);
    };
    GameImageGroup.prototype.changeTonal = function (passageID, r, g, b, gray, t, mr, mg, mb, tweenID) {
        if (mr === void 0) { mr = 1; }
        if (mg === void 0) { mg = 1; }
        if (mb === void 0) { mb = 1; }
        if (tweenID === void 0) { tweenID = null; }
        this.executeFuncs.push({ func: this.doChangeTonal, params: arguments, funcName: "doChangeTonal", cls: null });
        this.update(false);
    };
    GameImageGroup.prototype.deleteImage = function (passageID) {
        this.executeFuncs.push({ func: this.doDeleteImage, params: arguments, funcName: "doDeleteImage", cls: null });
        this.update(false);
    };
    GameImageGroup.prototype.showAnimation = function (passageID, url, x, y, scaleX, scaleY, rotation, alpha, loop, fps) {
        if (scaleX === void 0) { scaleX = 1; }
        if (scaleY === void 0) { scaleY = 1; }
        if (rotation === void 0) { rotation = 0; }
        if (alpha === void 0) { alpha = 1; }
        if (loop === void 0) { loop = 0; }
        if (fps === void 0) { fps = 20; }
        this.executeFuncs.push({ func: this.doShowAnimation, params: arguments, funcName: "doShowAnimation", cls: null });
        this.update(false);
    };
    GameImageGroup.prototype.moveAnimation = function (passageID, time, x, y, scaleX, scaleY, rotation, alpha, tweenID) {
        if (scaleX === void 0) { scaleX = 1; }
        if (scaleY === void 0) { scaleY = 1; }
        if (rotation === void 0) { rotation = 0; }
        if (alpha === void 0) { alpha = 1; }
        if (tweenID === void 0) { tweenID = null; }
        this.executeFuncs.push({ func: this.doMoveAnimation, params: arguments, funcName: "doMoveAnimation", cls: null });
        this.update(false);
    };
    GameImageGroup.prototype.showDialog = function (dialogID, head, name, speed, comicSceneObjectIndex, msg, realComicSceneObjectIndex, audio, exp, nameColor, submit) {
        if (submit === void 0) { submit = false; }
        this.executeFuncs.push({ func: this.doShowDialog, params: arguments, funcName: "doShowDialog", cls: null });
        this.update(false);
    };
    GameImageGroup.prototype.showStandAvatar = function (passageID, x, y, rotation, alpha, scaleX, scaleY, standAvatarID, fps, isPlay, startFrame, expressionID, hue) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (rotation === void 0) { rotation = 0; }
        if (alpha === void 0) { alpha = 1; }
        if (scaleX === void 0) { scaleX = 1; }
        if (scaleY === void 0) { scaleY = 1; }
        if (standAvatarID === void 0) { standAvatarID = 1; }
        if (fps === void 0) { fps = 12; }
        if (isPlay === void 0) { isPlay = false; }
        if (startFrame === void 0) { startFrame = 0; }
        if (expressionID === void 0) { expressionID = 1; }
        if (hue === void 0) { hue = 0; }
        this.executeFuncs.push({ func: this.doShowStandAvatar, params: arguments, funcName: "doShowStandAvatar", cls: null });
        this.update(false);
    };
    GameImageGroup.prototype.moveStandAvatar = function (passageID, x, y, rotation, alpha, scaleX, scaleY, frame, fps, isPlay, startFrame, expressionID, hue, tweenID) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (rotation === void 0) { rotation = 0; }
        if (alpha === void 0) { alpha = 1; }
        if (scaleX === void 0) { scaleX = 1; }
        if (scaleY === void 0) { scaleY = 1; }
        if (frame === void 0) { frame = 30; }
        if (fps === void 0) { fps = 12; }
        if (isPlay === void 0) { isPlay = true; }
        if (startFrame === void 0) { startFrame = 1; }
        if (expressionID === void 0) { expressionID = 1; }
        if (hue === void 0) { hue = 0; }
        if (tweenID === void 0) { tweenID = 0; }
        this.executeFuncs.push({ func: this.doMoveStandAvatar, params: arguments, funcName: "doMoveStandAvatar", cls: null });
        this.update(false);
    };
    GameImageGroup.prototype.showUI = function (uiID, x, y, ro, alpha, scaleX, scaleY) {
        this.executeFuncs.push({ func: this.doShowUI, params: arguments, funcName: "doShowUI", cls: null });
        this.update(false);
    };
    GameImageGroup.prototype.moveUI = function (uiID, frame, x, y, ro, alpha, scaleX, scaleY, tweenID) {
        this.executeFuncs.push({ func: this.doMoveUI, params: arguments, funcName: "doMoveUI", cls: null });
        this.update(false);
    };
    GameImageGroup.prototype.hideUI = function (uiID) {
        this.executeFuncs.push({ func: this.doHideUI, params: arguments, funcName: "doHideUI", cls: null });
        this.update(false);
    };
    GameImageGroup.prototype.changeUICompAttrs = function (frame, trans, changeCompAttrInfo, nonTweenType, noData, immediately) {
        this.executeFuncs.push({ func: this.doChangeUICompAttrs, params: arguments, funcName: "doChangeUICompAttrs", cls: null });
        this.update(false);
    };
    GameImageGroup.prototype.addDoFunction = function (f, args, immediatelyRender, cls, funcName) {
        this.executeFuncs.push({ func: f, params: args, funcName: funcName, cls: cls });
        this.update(false);
    };
    GameImageGroup.prototype.delay = function (time) {
        this.executeFuncs.push({ func: this.doDelay, params: arguments, funcName: "doDelay", cls: null });
        this.update(false);
    };
    GameImageGroup.prototype.pause = function () {
        this._pause = true;
    };
    GameImageGroup.prototype.continue = function () {
        this._pause = false;
    };
    Object.defineProperty(GameImageGroup.prototype, "isPlaying", {
        get: function () {
            return !this._pause && (this.executeFuncs.length > 0 || this.delayFrame > 0 || this.motionImages.length > 0 || this.motionAnimations.length > 0 || this.motionUICompAttrs.length > 0);
        },
        enumerable: false,
        configurable: true
    });
    GameImageGroup.prototype.checkMainPlayOver = function () {
        if (this.delayFrame <= 0) {
            if (!this._waitDialog) {
                if (!this.mainPlayOver && this.executeFuncs.length == 0) {
                    this.mainPlayOver = true;
                    EventUtils.happen(GameImage, GameImage.EVENT_PLAY_OVER, [this.triggerLineID]);
                }
            }
        }
    };
    GameImageGroup.prototype.update = function (forwardFrame) {
        if (forwardFrame === void 0) { forwardFrame = true; }
        if (this._pause)
            return false;
        var isShowDialog = false;
        while (this.executeFuncs.length > 0) {
            if (this.delayFrame > 0 || this._waitDialog)
                break;
            var f = this.executeFuncs.shift();
            f.func.apply(this, f.params);
            isShowDialog = "doShowDialog" == f.funcName;
        }
        if (forwardFrame) {
            this.delayFrame--;
            if (this.delayFrame <= 0) {
                if (!this._waitDialog) {
                    if (!this.mainPlayOver && this.executeFuncs.length == 0) {
                        this.mainPlayOver = true;
                        EventUtils.happen(GameImage, GameImage.EVENT_PLAY_OVER, [this.triggerLineID]);
                    }
                    if (this.executeFuncs.length == 0 && this.motionImages.length == 0 && this.motionAnimations.length == 0 && this.autoRotations.length == 0 && this.changeTonals.length == 0 && this.motionUICompAttrs.length == 0) {
                        if (!isShowDialog) {
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                }
            }
            for (var i = 0; i < this.motionImages.length; i++) {
                var m = this.motionImages[i];
                var per = m.curTime / m.time;
                var imageInfo = GameImage.imageInfos[m.id];
                if (imageInfo && (imageInfo.image instanceof GameImage)) {
                    var image = imageInfo.image;
                    if (m.curTime == 1) {
                        m.x = image.x;
                        m.y = image.y;
                        m.width = image.width;
                        m.height = image.height;
                        m.rotation = image.rotation;
                        m.alpha = image.alpha;
                    }
                    var func = m.tween;
                    image.pivotType = m.pivotType;
                    image.blendMode = m.blendMode;
                    image.x = func(per, m.x, m.x2 - m.x, 1);
                    image.y = func(per, m.y, m.y2 - m.y, 1);
                    var newW = func(per, m.width, m.width2 - m.width, 1);
                    var newH = func(per, m.height, m.height2 - m.height, 1);
                    if (newW != image.width || newH != image.height) {
                        image.width = newW;
                        image.height = newH;
                    }
                    image.rotation = func(per, m.rotation, m.rotation2 - m.rotation, 1);
                    image.alpha = func(per, m.alpha, m.alpha2 - m.alpha, 1);
                }
                m.curTime++;
                if (per == 1) {
                    this.motionImages.splice(i, 1);
                    i--;
                }
            }
            for (var i = 0; i < this.motionAnimations.length; i++) {
                var a = this.motionAnimations[i];
                var per = a.curTime / a.time;
                var imageInfo = GameImage.imageInfos[a.id];
                var standAvatar;
                if (imageInfo.image instanceof UIComponent.UIStandAvatar) {
                    standAvatar = imageInfo.image;
                }
                if (imageInfo && ((imageInfo.image instanceof GCAnimation) || standAvatar || (imageInfo.image instanceof UIComponent.UIRoot))) {
                    var ani = imageInfo.image;
                    if (a.curTime == 1) {
                        a.x = ani.x;
                        a.y = ani.y;
                        a.scaleX = ani.scaleX;
                        a.scaleY = ani.scaleY;
                        a.rotation = ani.rotation;
                        a.alpha = ani.alpha;
                        if (standAvatar) {
                            a.avatarFPS = standAvatar.avatarFPS;
                            a.startFrame = standAvatar.avatar.currentFrame;
                        }
                    }
                    var func = a.tween;
                    ani.x = func(per, a.x, a.x2 - a.x, 1);
                    ani.y = func(per, a.y, a.y2 - a.y, 1);
                    ani.scaleX = func(per, a.scaleX, a.scaleX2 - a.scaleX, 1);
                    ani.scaleY = func(per, a.scaleY, a.scaleY2 - a.scaleY, 1);
                    ani.rotation = func(per, a.rotation, a.rotation2 - a.rotation, 1);
                    ani.alpha = func(per, a.alpha, a.alpha2 - a.alpha, 1);
                    if (standAvatar) {
                        standAvatar.avatarFPS = func(per, a.avatarFPS, a.saAvatarFPS2 - a.avatarFPS, 1);
                        if (!standAvatar.isPlay)
                            standAvatar.avatarFrame = func(per, a.startFrame, a.saStartFrame2 - a.startFrame, 1);
                    }
                }
                a.curTime++;
                if (per == 1) {
                    this.motionAnimations.splice(i, 1);
                    i--;
                }
            }
            for (var i = 0; i < this.motionUICompAttrs.length; i++) {
                var isDel = this.updateOneUICompAttrs(i);
                if (isDel) {
                    this.motionUICompAttrs.splice(i, 1);
                    i--;
                }
            }
            for (var i = 0; i < this.autoRotations.length; i++) {
                var roInfo = this.autoRotations[i];
                var id = roInfo.id;
                var angle = roInfo.angle;
                var imageInfo = GameImage.imageInfos[id];
                if (!imageInfo)
                    continue;
                imageInfo.image.rotation += angle;
            }
            for (var i = 0; i < this.changeTonals.length; i++) {
                var t = this.changeTonals[i];
                var l = t.tween;
                var imageInfo = GameImage.imageInfos[t.id];
                if (!imageInfo)
                    continue;
                var per = t.curTime / t.time;
                var targetObj = imageInfo.image;
                if (t.curTime == 1) {
                    t.old = targetObj.getTonal().concat();
                }
                targetObj.setTonal(l(per, t.old[0], t.r - t.old[0], 1), l(per, t.old[1], t.g - t.old[1], 1), l(per, t.old[2], t.b - t.old[2], 1), l(per, t.old[3], t.gray - t.old[3], 1), l(per, t.old[4], t.mr - t.old[4], 1), l(per, t.old[5], t.mg - t.old[5], 1), l(per, t.old[6], t.mb - t.old[6], 1));
                t.curTime++;
                if (per == 1) {
                    this.changeTonals.splice(i, 1);
                    i--;
                }
            }
        }
        return false;
    };
    GameImageGroup.prototype.updateOneUICompAttrs = function (i) {
        var c = this.motionUICompAttrs[i];
        var per = c.curTime / c.time;
        var imageInfo = GameImage.imageInfos[c.id];
        if (imageInfo && imageInfo.image instanceof UIComponent.UIBase) {
            var ui = imageInfo.image;
            if (Config.CREATED_GC_VERSION != null || c.trans) {
                var refreshTrans = false;
                if (c["lastTime"] == null || c.curTime - c["lastTime"] >= c.trans.refreshInterval / Game.oneFrame) {
                    c["lastTime"] = c.curTime;
                    refreshTrans = true;
                }
            }
            for (var compID in c.atts) {
                var compArr = c.atts[compID];
                var comp = compArr[0];
                var compAttrs = compArr[1];
                for (var attrName in compAttrs) {
                    var toValueInfo = compAttrs[attrName];
                    var newValue;
                    if (toValueInfo.useVarType == 0) {
                        newValue = Game.player.variable.getVariable(toValueInfo.userVarIndex);
                    }
                    else if (toValueInfo.useVarType == 1) {
                        newValue = Game.player.variable.getString(toValueInfo.userVarIndex);
                    }
                    else if (toValueInfo.useVarType == 2) {
                        newValue = Game.player.variable.getSwitch(toValueInfo.userVarIndex) ? true : false;
                    }
                    else {
                        newValue = toValueInfo.newValue;
                    }
                    if (toValueInfo.needTween) {
                        if (Config.CREATED_GC_VERSION != null || c.trans) {
                            if (refreshTrans) {
                                var value = GameUtils.getValueByTransData(c.trans, per);
                                comp[attrName] = toValueInfo.oldValue + (newValue - toValueInfo.oldValue) * value;
                            }
                        }
                        else {
                            var func = c.tween;
                            comp[attrName] = func(per, toValueInfo.oldValue, newValue - toValueInfo.oldValue, 1);
                        }
                    }
                    else {
                        if ((c.nonTweenType == 0 && c.curTime == 1) || (c.nonTweenType == 1 && c.curTime == c.time)) {
                            comp[attrName] = newValue;
                        }
                    }
                }
            }
        }
        c.curTime++;
        if (per == 1) {
            return true;
        }
        return false;
    };
    GameImageGroup.prototype.doShowImage = function (id, url, pivotType, x, y, width, height, rotation, alpha, blendMode) {
        if (width === void 0) { width = 0; }
        if (height === void 0) { height = 0; }
        if (rotation === void 0) { rotation = 0; }
        if (alpha === void 0) { alpha = 1; }
        if (blendMode === void 0) { blendMode = null; }
        var imageInfo = GameImage.imageInfos[id];
        this.doDeleteImage(id);
        var newImage = new GameImage();
        if (width != null)
            newImage.width = width;
        if (height != null)
            newImage.height = height;
        newImage.image = url;
        newImage.x = x;
        newImage.y = y;
        newImage.alpha = alpha;
        newImage.rotation = rotation;
        newImage.blendMode = blendMode;
        newImage.pivotType = pivotType;
        GameImage.addImageToLayer(id, newImage);
    };
    GameImageGroup.prototype.doMoveImage = function (id, time, pivotType, x, y, width, height, rotation, alpha, blendMode, tweenID) {
        if (pivotType === void 0) { pivotType = 0; }
        if (width === void 0) { width = 0; }
        if (height === void 0) { height = 0; }
        if (rotation === void 0) { rotation = 0; }
        if (alpha === void 0) { alpha = 1; }
        if (blendMode === void 0) { blendMode = null; }
        if (tweenID === void 0) { tweenID = null; }
        if (time < 1)
            time = 1;
        var imageInfo = GameImage.imageInfos[id];
        if (!imageInfo || !(imageInfo.image instanceof GameImage))
            return;
        var mArr = ArrayUtils.matchAttributes(this.motionImages, { id: id }, true);
        if (mArr.length == 1) {
            this.motionImages.splice(this.motionImages.indexOf(mArr[0]), 1);
        }
        var image = imageInfo.image;
        var m = { id: id, time: time, curTime: 1, pivotType: pivotType, blendMode: blendMode, x2: x, y2: y, width2: width, height2: height, rotation2: rotation, alpha2: alpha, tween: GameUtils.getTween(tweenID)[0], tweenID: tweenID };
        this.motionImages.push(m);
    };
    GameImageGroup.prototype.doAutoRotation = function (id, angle) {
        var imageInfo = GameImage.imageInfos[id];
        if (!imageInfo)
            return;
        var mArr = ArrayUtils.matchAttributes(this.autoRotations, { id: id }, true);
        if (mArr.length == 1) {
            this.autoRotations.splice(this.autoRotations.indexOf(mArr[0]), 1);
        }
        var m = { id: id, angle: angle };
        this.autoRotations.push(m);
    };
    GameImageGroup.prototype.doDeleteImage = function (id) {
        var imageInfo = GameImage.imageInfos[id];
        if (imageInfo) {
            GameImage.imageLayer.removeChild(imageInfo.image);
            if (imageInfo.image instanceof GCAnimation) {
                imageInfo.image.dispose();
            }
            else if (imageInfo.image instanceof UIComponent.UIStandAvatar) {
                imageInfo.image.dispose();
            }
            else if (imageInfo.image instanceof GameImage) {
                imageInfo.image.dispose();
            }
            GameImage.clearPassageMoveEffect(id);
            delete GameImage.imageInfos[id];
        }
    };
    GameImageGroup.prototype.doShowAnimation = function (id, aniId, x, y, scaleX, scaleY, rotation, alpha, loop, fps) {
        if (scaleX === void 0) { scaleX = 1; }
        if (scaleY === void 0) { scaleY = 1; }
        if (rotation === void 0) { rotation = 0; }
        if (alpha === void 0) { alpha = 1; }
        if (loop === void 0) { loop = 0; }
        if (fps === void 0) { fps = 20; }
        var imageInfo = GameImage.imageInfos[id];
        this.doDeleteImage(id);
        var animation = new GCAnimation();
        animation.id = aniId;
        animation.loop = loop == 1 ? true : false;
        animation.gotoAndPlay();
        if (scaleX)
            animation.scaleX = scaleX;
        if (scaleY)
            animation.scaleY = scaleY;
        animation.x = x;
        animation.y = y;
        animation.alpha = alpha;
        animation.rotation = rotation;
        animation.fps = fps;
        GameImage.addImageToLayer(id, animation);
    };
    GameImageGroup.prototype.doChangeTonal = function (id, r, g, b, gray, t, mr, mg, mb, tweenID) {
        if (mr === void 0) { mr = 1; }
        if (mg === void 0) { mg = 1; }
        if (mb === void 0) { mb = 1; }
        if (tweenID === void 0) { tweenID = null; }
        var imageInfo = GameImage.imageInfos[id];
        if (!imageInfo)
            return;
        var mArr = ArrayUtils.matchAttributes(this.changeTonals, { id: id }, true);
        if (mArr.length == 1) {
            this.changeTonals.splice(this.changeTonals.indexOf(mArr[0]), 1);
        }
        var m = { id: id, time: t, curTime: 1, r: r, g: g, b: b, gray: gray, mr: mr, mg: mg, mb: mb, tween: GameUtils.getTween(tweenID)[0], tweenID: tweenID };
        this.changeTonals.push(m);
    };
    GameImageGroup.prototype.doMoveAnimation = function (id, time, x, y, scaleX, scaleY, rotation, alpha, tweenID) {
        if (scaleX === void 0) { scaleX = 1; }
        if (scaleY === void 0) { scaleY = 1; }
        if (rotation === void 0) { rotation = 0; }
        if (alpha === void 0) { alpha = 1; }
        if (tweenID === void 0) { tweenID = null; }
        if (time < 1)
            time = 1;
        var imageInfo = GameImage.imageInfos[id];
        if (!imageInfo || !(imageInfo.image instanceof GCAnimation))
            return;
        var mArr = ArrayUtils.matchAttributes(this.motionAnimations, { id: id }, true);
        if (mArr.length == 1) {
            this.motionAnimations.splice(this.motionAnimations.indexOf(mArr[0]), 1);
        }
        var image = imageInfo.image;
        var m = { id: id, time: time, curTime: 1, x2: x, y2: y, scaleX2: scaleX, scaleY2: scaleY, rotation2: rotation, alpha2: alpha, tween: GameUtils.getTween(tweenID)[0], tweenID: tweenID };
        this.motionAnimations.push(m);
    };
    GameImageGroup.prototype.doShowDialog = function (dialogID, head, name, speed, comicSceneObjectIndex, msg, realComicSceneObjectIndex, audio, exp, nameColor, submitEnabled, force) {
        var _this_1 = this;
        if (submitEnabled === void 0) { submitEnabled = false; }
        if (force === void 0) { force = false; }
        if (force || !GameCommand.isNeedPlayerInput) {
            GameCommand.inputTriggerLine = this.triggerLineID;
            GameCommand.isNeedPlayerInput = true;
            this._waitDialog = true;
            GameImage.submitEnabled = submitEnabled;
            if (!submitEnabled) {
                EventUtils.addEventListener(GameDialog, GameDialog.EVENT_DIALOG_END, Callback.New(function (submitEnabled) {
                    if (_this_1.isDisposed)
                        return;
                    if (GameCommand.inputTriggerLine == _this_1.triggerLineID) {
                        GameCommand.isNeedPlayerInput = false;
                    }
                    _this_1._waitDialog = false;
                    Callback.CallLaterBeforeRender(_this_1.update, _this_1, [false]);
                }, GameDialog, [submitEnabled]), true);
            }
            GameDialog.showDialog(dialogID, head, name, speed, realComicSceneObjectIndex, msg, Callback.New(function (submitEnabled) {
                if (_this_1.isDisposed)
                    return;
                if (submitEnabled) {
                    _this_1._waitDialog = false;
                    _this_1.update(false);
                    GameCommand.inputMessageAndContinueExecute(null, true, 1, _this_1.triggerLineID);
                }
            }, this, [submitEnabled]), audio, exp, nameColor, null);
        }
        else {
            this.delayFrame += 1;
            this.executeFuncs.unshift({ func: this.doShowDialog, params: arguments, funcName: "doShowDialog", cls: null });
        }
    };
    GameImageGroup.prototype.doShowStandAvatar = function (passageID, x, y, rotation, alpha, scaleX, scaleY, standAvatarID, fps, isPlay, startFrame, expressionID, hue) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (rotation === void 0) { rotation = 0; }
        if (alpha === void 0) { alpha = 1; }
        if (scaleX === void 0) { scaleX = 1; }
        if (scaleY === void 0) { scaleY = 1; }
        if (standAvatarID === void 0) { standAvatarID = 1; }
        if (fps === void 0) { fps = 12; }
        if (isPlay === void 0) { isPlay = false; }
        if (startFrame === void 0) { startFrame = 0; }
        if (expressionID === void 0) { expressionID = 1; }
        if (hue === void 0) { hue = 0; }
        var imageInfo = GameImage.imageInfos[passageID];
        this.doDeleteImage(passageID);
        var newAvatar = new UIComponent.UIStandAvatar();
        newAvatar.avatarID = standAvatarID;
        newAvatar.x = x;
        newAvatar.y = y;
        newAvatar.alpha = alpha;
        newAvatar.rotation = rotation;
        newAvatar.scaleX = scaleX;
        newAvatar.scaleY = scaleY;
        newAvatar.avatarFPS = fps;
        newAvatar.isPlay = isPlay;
        newAvatar.avatarFrame = startFrame;
        newAvatar.actionID = expressionID;
        newAvatar.hue = hue;
        GameImage.addImageToLayer(passageID, newAvatar);
    };
    GameImageGroup.prototype.doMoveStandAvatar = function (passageID, x, y, rotation, alpha, scaleX, scaleY, frame, fps, isPlay, startFrame, expressionID, hue, tweenID) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (rotation === void 0) { rotation = 0; }
        if (alpha === void 0) { alpha = 1; }
        if (scaleX === void 0) { scaleX = 1; }
        if (scaleY === void 0) { scaleY = 1; }
        if (frame === void 0) { frame = 30; }
        if (fps === void 0) { fps = 12; }
        if (isPlay === void 0) { isPlay = true; }
        if (startFrame === void 0) { startFrame = 1; }
        if (expressionID === void 0) { expressionID = 1; }
        if (hue === void 0) { hue = 0; }
        if (tweenID === void 0) { tweenID = 0; }
        if (frame < 1)
            frame = 1;
        var imageInfo = GameImage.imageInfos[passageID];
        if (!imageInfo || !(imageInfo.image instanceof UIComponent.UIStandAvatar))
            return;
        var mArr = ArrayUtils.matchAttributes(this.motionAnimations, { id: passageID }, true);
        if (mArr.length == 1) {
            this.motionAnimations.splice(this.motionAnimations.indexOf(mArr[0]), 1);
        }
        var image = imageInfo.image;
        image.isPlay = isPlay;
        image.actionID = expressionID;
        image.hue = hue;
        var m = { saStartFrame2: startFrame, saAvatarFPS2: fps, id: passageID, time: frame, curTime: 1, x2: x, y2: y, scaleX2: scaleX, scaleY2: scaleY, rotation2: rotation, alpha2: alpha, tween: GameUtils.getTween(tweenID)[0], tweenID: tweenID };
        this.motionAnimations.push(m);
    };
    GameImageGroup.prototype.doShowUI = function (uiID, x, y, rotation, alpha, scaleX, scaleY) {
        var passageID = GameImage.UI_START_PASSAGE + uiID;
        var imageInfo = GameImage.imageInfos[passageID];
        if (imageInfo && imageInfo.image instanceof UIComponent.UIRoot) {
            var ui = imageInfo.image;
            if (!ui)
                return;
        }
        else {
            ui = GameUI.load(uiID);
            if (!ui)
                return;
            GameImage.imageInfos[passageID] = { image: ui };
        }
        ui.x = x;
        ui.y = y;
        ui.rotation = rotation;
        ui.alpha = alpha;
        ui.scaleX = scaleX;
        ui.scaleY = scaleY;
        GameImage.uiLayer.addChild(ui);
    };
    GameImageGroup.prototype.doMoveUI = function (uiID, frame, x, y, rotation, alpha, scaleX, scaleY, tweenID) {
        if (frame < 1)
            frame = 1;
        var passageID = GameImage.UI_START_PASSAGE + uiID;
        var imageInfo = GameImage.imageInfos[passageID];
        if (!imageInfo || !(imageInfo.image instanceof UIComponent.UIRoot))
            return;
        var ui = imageInfo.image;
        if (!ui)
            return;
        var mArr = ArrayUtils.matchAttributes(this.motionAnimations, { id: passageID }, true);
        if (mArr.length == 1) {
            this.motionAnimations.splice(this.motionAnimations.indexOf(mArr[0]), 1);
        }
        var m = { id: passageID, time: frame, curTime: 1, x2: x, y2: y, scaleX2: scaleX, scaleY2: scaleY, rotation2: rotation, alpha2: alpha, tween: GameUtils.getTween(tweenID)[0], tweenID: tweenID };
        this.motionAnimations.push(m);
    };
    GameImageGroup.prototype.doHideUI = function (uiID) {
        var passageID = GameImage.UI_START_PASSAGE + uiID;
        var imageInfo = GameImage.imageInfos[passageID];
        if (!imageInfo || !(imageInfo.image instanceof UIComponent.UIRoot))
            return;
        var ui = imageInfo.image;
        if (ui) {
            delete GameImage.imageInfos[passageID];
            ui.removeSelf();
            var mArr = ArrayUtils.matchAttributes(this.motionAnimations, { id: passageID }, true);
            if (mArr.length == 1) {
                this.motionAnimations.splice(this.motionAnimations.indexOf(mArr[0]), 1);
            }
        }
    };
    GameImageGroup.prototype.doChangeUICompAttrs = function (frame, trans, changeCompAttrInfo, nonTweenType, noData, immediately) {
        var isAllImmediately = immediately == null ? false : (immediately == 0 ? true : false);
        var passageID = GameImage.UI_START_PASSAGE + changeCompAttrInfo.uiID;
        var imageInfo = GameImage.imageInfos[passageID];
        if (!imageInfo || !(imageInfo.image instanceof UIComponent.UIRoot))
            return;
        var ui = imageInfo.image;
        if (!ui)
            return;
        var nodeArray1 = [], nodeObjs2 = {};
        ArrayUtils.getTreeNodeArray(ui, "_childs", nodeArray1);
        for (var s = 0; s < nodeArray1.length; s++) {
            var nodeComp = nodeArray1[s];
            if (nodeComp instanceof UIComponent.UIBase) {
                nodeObjs2[nodeComp.id] = nodeComp;
            }
        }
        var atts = {};
        for (var compID in changeCompAttrInfo.atts) {
            var nodeComp = nodeObjs2[compID];
            if (!nodeComp)
                continue;
            var needChangeAtts = changeCompAttrInfo.atts[compID][1];
            var useVarAndTransitionAttrs = changeCompAttrInfo.atts[compID][2];
            var attrInfos = {};
            for (var attrName in needChangeAtts) {
                var newValue = needChangeAtts[attrName];
                var oldValue = nodeComp[attrName];
                var needTween = typeof oldValue == "number";
                var useVarType = null;
                var userVarIndex = 0;
                if (useVarAndTransitionAttrs) {
                    var useVarAndTransition = useVarAndTransitionAttrs[attrName];
                    if (useVarAndTransition) {
                        useVarType = useVarAndTransition.type;
                        userVarIndex = useVarAndTransition.index;
                        if (!useVarAndTransition.change) {
                            needTween = false;
                        }
                    }
                }
                attrInfos[attrName] = { oldValue: oldValue, newValue: newValue, needTween: needTween, useVarType: useVarType, userVarIndex: userVarIndex };
            }
            atts[compID] = [nodeComp, attrInfos];
        }
        var m;
        var transdata = GameUtils.getTransData(trans);
        if (Config.CREATED_GC_VERSION == null && !transdata) {
            m = { id: passageID, time: frame, curTime: 1, tween: GameUtils.getTween(Number(trans))[0], tweenID: trans, trans: null, nonTweenType: nonTweenType, atts: atts };
        }
        else {
            if (!transdata)
                transdata = new TransData();
            m = { id: passageID, time: frame, curTime: 1, trans: transdata, nonTweenType: nonTweenType, atts: atts };
        }
        this.motionUICompAttrs.push(m);
        if (isAllImmediately) {
            m.time = 1;
            var isDel = this.updateOneUICompAttrs(this.motionUICompAttrs.length - 1);
            if (isDel)
                this.motionUICompAttrs.pop();
        }
    };
    GameImageGroup.prototype.doDelay = function (time) {
        if (time < 1)
            time = 1;
        this.delayFrame = time;
    };
    GameImageGroup.prototype.getSaveData = function () {
        var o = {};
        o.triggerLineID = this.triggerLineID;
        o.delayFrame = this.delayFrame;
        o.mainPlayOver = this.mainPlayOver;
        o.pause = this.pause;
        o._waitDialog = this._waitDialog;
        o.executeFuncs = [];
        for (var i = 0; i < this.executeFuncs.length; i++) {
            var executeFunc = this.executeFuncs[i];
            var executeFuncData = o.executeFuncs[i] = {};
            ObjectUtils.clone(executeFunc, executeFuncData);
            executeFuncData.params = [];
            for (var s = 0; s < executeFunc.params.length; s++)
                executeFuncData.params.push(executeFunc.params[s]);
            delete executeFuncData["func"];
        }
        o.motionImages = [];
        for (var i = 0; i < this.motionImages.length; i++) {
            var motionImage = this.motionImages[i];
            var motionImageData = o.motionImages[i] = {};
            ObjectUtils.clone(motionImage, motionImageData);
            delete motionImageData["tween"];
        }
        o.motionAnimations = [];
        for (var i = 0; i < this.motionAnimations.length; i++) {
            var motionAnimation = this.motionAnimations[i];
            var motionAnimationData = o.motionAnimations[i] = {};
            ObjectUtils.clone(motionAnimation, motionAnimationData);
            delete motionAnimationData["tween"];
        }
        o.changeTonals = [];
        for (var i = 0; i < this.motionAnimations.length; i++) {
            var changeTonal = this.changeTonals[i];
            var changeTonalData = o.changeTonals[i] = {};
            ObjectUtils.clone(changeTonal, changeTonalData);
            delete changeTonalData["tween"];
        }
        o.motionUICompAttrs = [];
        for (var i = 0; i < this.motionUICompAttrs.length; i++) {
            var motionUICompAttr = this.motionUICompAttrs[i];
            var motionUICompAttrData = o.motionUICompAttrs[i] = {};
            ObjectUtils.clone(motionUICompAttr, motionUICompAttrData);
            delete motionUICompAttrData["tween"];
            motionUICompAttrData.atts = {};
            for (var compID in motionUICompAttr.atts) {
                var c = motionUICompAttr.atts[compID];
                var compRecord = c[0];
                c[0] = null;
                motionUICompAttrData.atts[compID] = ObjectUtils.depthClone(c);
                c[0] = compRecord;
            }
        }
        o.autoRotations = this.autoRotations;
        return o;
    };
    GameImageGroup.prototype.recoverySaveData = function (o) {
        this.triggerLineID = o.triggerLineID;
        o.gameImageGroup = this;
        this.delayFrame = o.delayFrame;
        this.mainPlayOver = o.mainPlayOver;
        this.pause = o.pause;
        this._waitDialog = o._waitDialog;
        for (var i = 0; i < o.executeFuncs.length; i++) {
            var executeFuncData = o.executeFuncs[i];
            var executeFunc = this.executeFuncs[i] = {};
            ObjectUtils.clone(executeFuncData, executeFunc);
            executeFunc.func = executeFunc.cls ? globalThis[executeFunc.cls][executeFunc.funcName] : this[executeFunc.funcName];
        }
        for (var i = 0; i < o.motionImages.length; i++) {
            var motionImageData = o.motionImages[i];
            var motionImage = this.motionImages[i] = {};
            ObjectUtils.clone(motionImageData, motionImage);
            motionImage.tween = GameUtils.getTween(motionImage.tweenID)[0];
        }
        for (var i = 0; i < o.motionAnimations.length; i++) {
            var motionAnimationData = o.motionAnimations[i];
            var motionAnimation = this.motionAnimations[i] = {};
            ObjectUtils.clone(motionAnimationData, motionAnimation);
            motionAnimation.tween = GameUtils.getTween(motionAnimation.tweenID)[0];
        }
        for (var i = 0; i < o.motionAnimations.length; i++) {
            var changeTonalData = o.changeTonals[i];
            var changeTonal = this.changeTonals[i] = {};
            ObjectUtils.clone(changeTonalData, changeTonal);
            changeTonal.tween = GameUtils.getTween(changeTonal.tweenID)[0];
        }
        for (var i = 0; i < o.motionUICompAttrs.length; i++) {
            var motionUICompAttrData = o.motionUICompAttrs[i];
            var motionUICompAttr = this.motionUICompAttrs[i] = {};
            var m = this.motionUICompAttrs[i];
            ObjectUtils.clone(motionUICompAttrData, motionUICompAttr);
            motionUICompAttr.tween = GameUtils.getTween(motionUICompAttr.tweenID)[0];
            var passageID = motionUICompAttr.id;
            var uiID = passageID - GameImage.UI_START_PASSAGE;
            var ui = GameUI.get(uiID);
            if (ui) {
                var uiCompsInfo = GameUI.getAllCompChildren(ui, true);
                for (var compID in m.atts) {
                    var uiComp = uiCompsInfo.keyValue[compID];
                    if (uiComp) {
                        m.atts[compID][0] = uiComp;
                    }
                    else {
                        delete m.atts[compID];
                    }
                }
            }
        }
        this.autoRotations = o.autoRotations;
    };
    return GameImageGroup;
}());















var GameImageLayer = (function (_super) {
    __extends(GameImageLayer, _super);
    function GameImageLayer() {
        var _this_1 = _super.call(this) || this;
        _this_1.camera = new Camera();
        _this_1.cameraRecord = new Camera;
        if (Config.EDIT_MODE || Config.WINDOW_WIDTH != null) {
            _this_1.initRoot();
        }
        else {
            EventUtils.addEventListener(ClientWorld, ClientWorld.EVENT_BEFORE_INITED, Callback.New(_this_1.initRoot, _this_1), true);
        }
        return _this_1;
    }
    GameImageLayer.initDPCoord = function () {
        var code = "\n                (function(){\n                    var ___export = {};\n                    " + Config.IMAGE_LAYER_DP_COORD_JS + "\n                    if(typeof dpCoordToRealCoord != \"undefined\")___export.dpCoordToRealCoord = dpCoordToRealCoord;\n                    if(typeof realCoordToDPCoord != \"undefined\")___export.realCoordToDPCoord = realCoordToDPCoord;\n                    return ___export;\n                })();\n            ";
        GameImageLayer.dpCoordFuncObject = eval(code);
    };
    GameImageLayer.setImageSprite = function (passageID, sp) {
        if (!(sp instanceof UIComponent.GUI_BASE))
            sp.mouseEnabled = false;
        GameImageLayer.imageSprites[passageID] = { displayObject: sp };
    };
    GameImageLayer.getImageSprite = function (passageID) {
        var info = GameImageLayer.imageSprites[passageID];
        return info ? info.displayObject : null;
    };
    GameImageLayer.deletePassage = function (passageID) {
        this.clearPassageFrameUpdate(passageID);
        var spInfo = GameImageLayer.imageSprites[passageID];
        if (spInfo) {
            var displayObject = spInfo.displayObject;
            displayObject.removeSelf();
            if (displayObject instanceof GCAnimation ||
                displayObject instanceof UIComponent.UIAvatar || displayObject instanceof UIComponent.UIBitmap || displayObject instanceof UIComponent.UIAnimation ||
                (displayObject instanceof UIComponent.GUI_BASE && displayObject.useDPCoord)) {
                displayObject.dispose();
            }
            delete GameImageLayer.imageSprites[passageID];
        }
    };
    GameImageLayer.regPassageFrameUpdate = function (passageID, onUpdate, thisPtr, args, sign) {
        if (args === void 0) { args = null; }
        if (sign === void 0) { sign = null; }
        var passageFrameUpdateArr = GameImageLayer.imageFrameUpdates[passageID];
        if (!passageFrameUpdateArr)
            passageFrameUpdateArr = GameImageLayer.imageFrameUpdates[passageID] = [];
        passageFrameUpdateArr.push({ onUpdate: onUpdate, thisPtr: thisPtr, sign: sign, args: args });
        os.add_ENTERFRAME(onUpdate, thisPtr, args);
    };
    GameImageLayer.clearPassageFrameUpdate = function (passageID, sign) {
        if (sign === void 0) { sign = null; }
        var passageFrameUpdateArr = GameImageLayer.imageFrameUpdates[passageID];
        if (!passageFrameUpdateArr)
            return;
        if (sign == null) {
            for (var i = 0; i < passageFrameUpdateArr.length; i++) {
                var frameUpdateInfo = passageFrameUpdateArr[i];
                if (frameUpdateInfo) {
                    os.remove_ENTERFRAME(frameUpdateInfo.onUpdate, frameUpdateInfo.thisPtr);
                }
            }
            passageFrameUpdateArr.length = 0;
        }
        else {
            for (var i = 0; i < passageFrameUpdateArr.length; i++) {
                var frameUpdateInfo = passageFrameUpdateArr[i];
                if (frameUpdateInfo && frameUpdateInfo.sign == sign) {
                    os.remove_ENTERFRAME(frameUpdateInfo.onUpdate, frameUpdateInfo.thisPtr);
                    passageFrameUpdateArr.splice(i, 1);
                    i--;
                }
            }
        }
    };
    GameImageLayer.getPassageFrameUpdates = function () {
        return this.imageFrameUpdates;
    };
    GameImageLayer.prototype.initRoot = function () {
        if (this.inited)
            return;
        this.inited = true;
        if (!GameImageLayer.dpCoordInited) {
            GameImageLayer.dpCoordInited = true;
            GameImageLayer.initDPCoord();
        }
        var halfW = Config.WINDOW_WIDTH / 2;
        var halfH = Config.WINDOW_HEIGHT / 2;
        this.root = new GameSprite();
        if (!Config.EDIT_MODE) {
        }
        var ObliqueLineDistance = Point.distance2(0, 0, Config.WINDOW_WIDTH, Config.WINDOW_HEIGHT) + 2;
        this.rootParent = new GameSprite();
        this.rootParentSize = ObliqueLineDistance;
        this.addChild(this.rootParent);
        this.rootRotationArea = new GameSprite();
        this.rootParent.addChild(this.rootRotationArea);
        var w2 = (ObliqueLineDistance - Config.WINDOW_WIDTH) / 2;
        var h2 = (ObliqueLineDistance - Config.WINDOW_HEIGHT) / 2;
        this.rootRotationArea.addChild(this.root);
        this.x = 0;
        this.y = 0;
        this.rootRotationArea.pivotX = w2 + halfW;
        this.rootRotationArea.pivotY = h2 + halfH;
        this.rootRotationArea.x = halfW;
        this.rootRotationArea.y = halfH;
        this.rootParent.x = 0;
        this.rootParent.y = 0;
        this.root.x = w2;
        this.root.y = h2;
        this.rootRealDPostion = new Point(this.rootParent.x + this.root.x - w2, this.rootParent.y + this.root.y - halfH);
        if (!Config.EDIT_MODE) {
            this.rootParent.scrollRect = new Rectangle(0, 0, this.rootParentSize, this.rootParentSize);
        }
        this.width = Config.WINDOW_WIDTH;
        this.height = Config.WINDOW_HEIGHT;
        this.mouseThrough = true;
        ObjectUtils.agentFunction(this, "root", ["addChild", "addChildren", "addChildAt", "setChildIndex", "removeChild", "removeSelf", "removeChildByName", "removeChildAt", "removeChildren"], "Callback.CallLaterBeforeRender(this.updateFrame, this, [true]);");
        ObjectUtils.agentFunction(this, "root", ["getChildIndex", "getChildByName", "getChildAt", "replaceChild", "contains"]);
        ObjectUtils.agentFunction(this, "root", ["doRepaint", "setMaterialValueFast", "setMaterialDirty", "setMaterialsByGameSprite", "swapMaterialPass", "swapMaterialIndex", "setMaterialIndex", "clearMaterialsInPass",
            "clearMaterials", "getMaterialPassLength", "getMaterialLength", "getMaterialAt", "getMaterialByID", "removeMaterialByID", "removeMaterialAt", "removeMaterial",
            "addMaterialAtByID", "addMaterialByID", "addMaterialAt", "addMaterial", "installMaterialData", "getAllMaterialDatas"]);
        os.add_ENTERFRAME(this.updateFrame, this, [false]);
        this.on(EventObject.DISPLAY, this, this.updateFrame, [false]);
    };
    GameImageLayer.prototype.updateFrame = function (force) {
        if (force === void 0) { force = false; }
        if (!this.stage || !this.rootRotationArea)
            return;
        var isCameraDirty = force || this.cameraRecord.viewPort.x != this.camera.viewPort.x || this.cameraRecord.viewPort.y != this.camera.viewPort.y ||
            this.cameraRecord.scaleX != this.camera.scaleX || this.cameraRecord.scaleY != this.camera.scaleY ||
            this.cameraRecord.offsetX != this.camera.offsetX || this.cameraRecord.offsetY != this.camera.offsetY ||
            this.cameraRecord.z != this.camera.z;
        this.rootRotationArea.rotation = this.camera.rotation;
        var imageLength = this.root.numChildren;
        var imageArr = [];
        var elseImageArr = [];
        for (var i = 0; i < imageLength; i++) {
            var child = this.getChildAt(i);
            if (child instanceof GameSprite) {
                if (child.useDPCoord) {
                    imageArr.push(child);
                }
                else {
                    elseImageArr.push(child);
                }
            }
        }
        this.updateChildZOrder(imageArr);
        this.updateChildZOrder(elseImageArr, imageArr.length);
        if (isCameraDirty) {
            this.cameraRecord.viewPort.x = this.camera.viewPort.x;
            this.cameraRecord.viewPort.y = this.camera.viewPort.y;
            this.cameraRecord.scaleX = this.camera.scaleX;
            this.cameraRecord.scaleY = this.camera.scaleY;
            this.cameraRecord.offsetX = this.camera.offsetX;
            this.cameraRecord.offsetY = this.camera.offsetY;
            this.cameraRecord.z = this.camera.z;
            for (var i = 0; i < imageArr.length; i++) {
                var child = imageArr[i];
                child.dpCameraX = -(this.camera.viewPort.x + this.camera.offsetX);
                child.dpCameraY = -(this.camera.viewPort.y + this.camera.offsetY);
                child.dpCameraZ = this.camera.z;
                child.dpCoordToRealCoord();
            }
        }
    };
    GameImageLayer.prototype.updateChildZOrder = function (imageArr, startIndex, useZ) {
        if (imageArr === void 0) { imageArr = null; }
        if (startIndex === void 0) { startIndex = 0; }
        if (useZ === void 0) { useZ = true; }
        if (!imageArr) {
            var imageLength = this.root.numChildren;
            var imageArr = [];
            for (var i = 0; i < imageLength; i++) {
                var child = this.getChildAt(i);
                if (child instanceof GameSprite) {
                    imageArr.push(child);
                }
            }
        }
        if (useZ) {
            imageArr.sort(function (a, b) {
                if (a.dpZ == b.dpZ) {
                    return a.dpDisplayPriority < b.dpDisplayPriority ? -1 : 1;
                }
                return a.dpZ > b.dpZ ? -1 : 1;
            });
        }
        else {
            imageArr.sort(function (a, b) {
                return a.dpDisplayPriority < b.dpDisplayPriority ? -1 : 1;
            });
        }
        var arrLen = imageArr.length;
        for (var j = 0; j < arrLen; j++) {
            this.root.setChildIndex(imageArr[j], j + startIndex);
        }
    };
    Object.defineProperty(GameImageLayer.prototype, "numChildren", {
        get: function () {
            return this.root.numChildren;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameImageLayer.prototype, "filterEnabled", {
        get: function () {
            return this.root.filterEnabled;
        },
        set: function (v) {
            this.root.filterEnabled = v;
        },
        enumerable: false,
        configurable: true
    });
    GameImageLayer.imageLayerPassageData = [];
    GameImageLayer.imageSprites = {};
    GameImageLayer.imageFrameUpdates = {};
    return GameImageLayer;
}(GameSprite));















var GameLayer = (function (_super) {
    __extends(GameLayer, _super);
    function GameLayer() {
        var _this_1 = _super.call(this) || this;
        _this_1.sceneLayer = new GameSprite();
        _this_1.imageLayer = new GameImageLayer();
        _this_1.uiLayer = new GameSprite();
        _this_1.graphics.drawRect(0, 0, 1, 1, "#000000");
        _this_1.initLayer();
        return _this_1;
    }
    GameLayer.prototype.initLayer = function () {
        this.addChild(this.sceneLayer);
        this.addChild(this.imageLayer);
        this.addChild(this.uiLayer);
        stage.addChild(this);
    };
    GameLayer.prototype.refreshLayerSize = function () {
        this.scrollRect = new Rectangle(0, 0, Config.WINDOW_WIDTH, Config.WINDOW_HEIGHT);
        this.uiLayer.scrollRect = new Rectangle(0, 0, Config.WINDOW_WIDTH, Config.WINDOW_HEIGHT);
    };
    return GameLayer;
}(GameSprite));















var StandAvatar = (function (_super) {
    __extends(StandAvatar, _super);
    function StandAvatar() {
        var _this_1 = _super.call(this) || this;
        _this_1._flip = false;
        _this_1.ori = 4;
        _this_1.actID = 1;
        return _this_1;
    }
    Object.defineProperty(StandAvatar.prototype, "oriMode", {
        get: function () {
            return 1;
        },
        set: function (v) {
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StandAvatar.prototype, "flip", {
        get: function () {
            return this._flip;
        },
        set: function (v) {
            if (v == this._flip)
                return;
            this._flip = v;
            this.orientation = v ? 6 : 4;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StandAvatar.prototype, "gameDataAvatarList", {
        get: function () {
            return Common.standAvatarList;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StandAvatar.prototype, "gameDataAvatarURL", {
        get: function () {
            return "asset/json/standAvatar/data/standAvatar";
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StandAvatar.prototype, "disposeAvatarAsset", {
        get: function () {
            return AssetManager.disposeStandAvatarAsset;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StandAvatar.prototype, "myClass", {
        get: function () {
            return StandAvatar;
        },
        enumerable: false,
        configurable: true
    });
    return StandAvatar;
}(Avatar));















var AnimationAudioLayer = (function (_super) {
    __extends(AnimationAudioLayer, _super);
    function AnimationAudioLayer() {
        var _this_1 = _super !== null && _super.apply(this, arguments) || this;
        _this_1.type = AnimationItemType.Audio;
        _this_1._audioInfo = { url: "", volume: 1, pitch: 1 };
        _this_1._playAudio = false;
        return _this_1;
    }
    Object.defineProperty(AnimationAudioLayer.prototype, "audioInfo", {
        get: function () { return this._audioInfo; },
        set: function (v) {
            this._audioInfo = v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimationAudioLayer.prototype, "audioUrl", {
        get: function () {
            if (!this._audioInfo.url)
                this._audioInfo.url = "";
            return this._audioInfo.url.split(",")[0];
        },
        enumerable: false,
        configurable: true
    });
    AnimationAudioLayer.prototype.setData = function (data) {
        _super.prototype.setData.call(this, data);
        this.audioInfo = data.audioInfo || { url: "", volume: 1, pitch: 1 };
    };
    AnimationAudioLayer.prototype.toAnimationLayerData = function () {
        var data = _super.prototype.toAnimationLayerData.call(this);
        data.audioInfo = this.audioInfo;
        return data;
    };
    AnimationAudioLayer.prototype.getHitEffectVisible = function (topAnimation) {
        if (topAnimation.showHitEffect)
            return true;
        var p = this;
        while ((p instanceof GCAnimation || p instanceof AnimationLayer)) {
            if (p.isHitEffect) {
                return false;
            }
            p = p.parent;
            if (p == topAnimation)
                break;
        }
        return true;
    };
    AnimationAudioLayer.prototype.showFrame = function (frameIndex) {
        if (!this.animation || !this.topAnimation || this.topAnimation.isDisposed)
            return;
        if (!this._audioInfo)
            return;
        if (!this.animation.isPlaying)
            return;
        if (Config.EDIT_MODE && !EUIWindowAnimation.InAniEditor(this.animation))
            return;
        var topAnimation = this.topAnimation;
        if (this.animation.silentMode || (topAnimation && topAnimation.silentMode))
            return;
        var preFrameIndex = this._frameIndex;
        _super.prototype.showFrame.call(this, frameIndex);
        var showEnable = true;
        if (Config.EDIT_MODE && EUIWindowAnimation.InAniEditor(this.animation)) {
            if (!this.animation.isPlaying) {
                showEnable = this.showOnEditor;
            }
            else {
                showEnable = this.showOnEditor && this.getHitEffectVisible(topAnimation);
            }
        }
        else {
            showEnable = this.getHitEffectVisible(topAnimation);
        }
        if (!showEnable)
            this.stopAudio();
        else {
            if (this.frames.length == 0)
                return;
            var len = this.frames ? this.frames.length : 0;
            var totalFrame = this.animation.totalFrame ? this.animation.totalFrame : 0;
            var firstFrame = this.frames[0].index;
            var lastFrame = 0;
            if (len == 1) {
                lastFrame = totalFrame - 1;
            }
            else if (len >= 2) {
                lastFrame = this.frames[len - 1].index;
            }
            lastFrame = lastFrame > 0 ? lastFrame : 0;
            if (this.animation.loop && preFrameIndex > firstFrame && preFrameIndex < lastFrame && frameIndex < preFrameIndex)
                this.stopAudio();
            var isFrameSkip = (frameIndex > preFrameIndex && frameIndex - preFrameIndex > 1);
            var isCanPlay = isFrameSkip ? (preFrameIndex + 1 >= firstFrame && preFrameIndex + 1 < lastFrame) : (frameIndex >= firstFrame && frameIndex < lastFrame);
            if (isCanPlay) {
                if (this._playAudio)
                    return;
                this.stopAudio();
                this._soundChannel = GameAudio.playSE(this.audioUrl, this._audioInfo.volume, this._audioInfo.pitch, this.animation.sceneObject);
                this._playAudio = true;
            }
            else {
                this._playAudio = false;
            }
        }
    };
    AnimationAudioLayer.prototype.stopAudio = function () {
        if (this._soundChannel) {
            GameAudio.stopSE(this._soundChannel);
            this._soundChannel = null;
        }
        this._playAudio = false;
    };
    return AnimationAudioLayer;
}(AnimationLayer));
AnimationLayer.typeClsMap[AnimationItemType.Audio] = AnimationAudioLayer;















var AnimationDisplayLayer = (function (_super) {
    __extends(AnimationDisplayLayer, _super);
    function AnimationDisplayLayer() {
        var _this_1 = _super !== null && _super.apply(this, arguments) || this;
        _this_1._horizontalReversal = false;
        return _this_1;
    }
    Object.defineProperty(AnimationDisplayLayer.prototype, "horizontalReversal", {
        get: function () {
            return this._horizontalReversal;
        },
        set: function (v) {
            this._horizontalReversal = v;
        },
        enumerable: false,
        configurable: true
    });
    AnimationDisplayLayer.prototype.setData = function (data) {
        _super.prototype.setData.call(this, data);
        if (this.frames[0] && this.frames[0].materialData) {
            this.materialData = ObjectUtils.depthClone(this.frames[0].materialData);
        }
        else if (Config.EDIT_MODE && this.inAniEditor) {
            this.fixFramesMaterialsData();
            this.materialData = [{ materials: [] }];
        }
        if (this.materialData) {
            this.materialsDataExit = true;
            this.installMaterialData(this.materialData);
        }
    };
    AnimationDisplayLayer.prototype.showFrame = function (frameIndex) {
        if (!this.animation)
            return;
        _super.prototype.showFrame.call(this, frameIndex);
        var showEnable = true;
        if (Config.EDIT_MODE && EUIWindowAnimation.InAniEditor(this.animation)) {
            if (!this.animation.isPlaying) {
                showEnable = this.showOnEditor;
            }
            else {
                showEnable = this.showOnEditor && ((this.animation.showHitEffect && this.isHitEffect) || (!this.isHitEffect));
            }
        }
        else {
            showEnable = (this.animation.showHitEffect && this.isHitEffect) || !this.isHitEffect;
        }
        this.visible = showEnable;
    };
    AnimationDisplayLayer.prototype.fromAnimationFrameData = function (framedata) {
        _super.prototype.fromAnimationFrameData.call(this, framedata);
        if (!framedata)
            return;
        this.horizontalReversal = framedata.horizontalReversal;
        this.x = framedata.x;
        this.y = framedata.y;
        this.rotation = framedata.rotation;
        this.opacity = framedata.alpha;
        if (this.materialsDataExit) {
            if (this.checkMaterialsTransChange(framedata)) {
                this.installMaterialData(this.materialData);
            }
            else {
                this.setFrameMaterialsEffect(framedata.materialData);
            }
        }
        else if (!Config.EDIT_MODE || !this.inAniEditor || Config.BEHAVIOR_EDIT_MODE) {
            this.hue = framedata.hue;
            this.blur = framedata.blur;
            this.setTonal(framedata.tonal_r, framedata.tonal_g, framedata.tonal_b, framedata.tonal_gray, framedata.tonal_mr, framedata.tonal_mg, framedata.tonal_mb);
        }
    };
    AnimationDisplayLayer.prototype.toAnimationFrameData = function (framedata) {
        framedata = _super.prototype.toAnimationFrameData.call(this, framedata);
        framedata.horizontalReversal = this.horizontalReversal;
        framedata.x = this.x;
        framedata.y = this.y;
        framedata.rotation = this.rotation;
        framedata.alpha = this.opacity;
        return framedata;
    };
    AnimationDisplayLayer.prototype.interpolationFrame = function (pf, nf, frameIndex) {
        var frame = _super.prototype.interpolationFrame.call(this, pf, nf, frameIndex);
        frame.horizontalReversal = pf.horizontalReversal;
        var t = (frameIndex - pf.index) / (nf.index - pf.index);
        if (this.materialsDataExit) {
            var value = GameUtils.getValueByTransData(nf.trans, t);
            frame.x = (nf.x - pf.x) * value + pf.x;
            frame.y = (nf.y - pf.y) * value + pf.y;
            frame.rotation = (nf.rotation - pf.rotation) * value + pf.rotation;
            frame.alpha = (nf.alpha - pf.alpha) * value + pf.alpha;
            if (pf.materialData && nf.materialData) {
                this.refreshInterpolationFrameMaterials(frame, pf, nf, t);
            }
        }
        else {
            var tween = GameUtils.getTween(nf.tweenID)[0];
            frame.tweenID = nf.tweenID;
            frame.x = tween(t, pf.x, nf.x - pf.x, 1);
            frame.y = tween(t, pf.y, nf.y - pf.y, 1);
            frame.rotation = tween(t, pf.rotation, nf.rotation - pf.rotation, 1);
            frame.alpha = tween(t, pf.alpha, nf.alpha - pf.alpha, 1);
            this.refreshInterpolationFrameTonal(frame, pf, nf, t, tween);
        }
        return frame;
    };
    return AnimationDisplayLayer;
}(AnimationLayer));















var AnimationImageLayer = (function (_super) {
    __extends(AnimationImageLayer, _super);
    function AnimationImageLayer() {
        var _this_1 = _super.call(this) || this;
        _this_1.type = AnimationItemType.Image;
        _this_1._blendModeType = 0;
        _this_1._pivotX = 0;
        _this_1._pivotY = 0;
        _this_1.img = new Sprite();
        _this_1.addChild(_this_1.img);
        _this_1._defaultStateImage = true;
        _this_1.on(EventObject.RESIZE, _this_1, _this_1.onResize);
        _this_1.add_DISPLAY(_this_1.onDisplay, _this_1);
        _this_1.add_UNDISPLAY(_this_1.onUnDisplay, _this_1);
        return _this_1;
    }
    Object.defineProperty(AnimationImageLayer.prototype, "imageSource", {
        get: function () {
            return this._imageSource;
        },
        set: function (v) {
            this._imageSource = v;
            this.updateImage();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimationImageLayer.prototype, "blendModeType", {
        get: function () { return this._blendModeType; },
        set: function (v) {
            if (this._blendModeType === v)
                return;
            this._blendModeType = v;
            this.blendMode = ["normal", "lighter", "blend5-1", "blend4-1", "blend4-7", "blend4-4"][v] || "normal";
        },
        enumerable: false,
        configurable: true
    });
    AnimationImageLayer.prototype.setData = function (data) {
        _super.prototype.setData.call(this, data);
        this._defaultStateImage = false;
    };
    AnimationImageLayer.prototype.openAutoHitArea = function (force) {
        if (force === void 0) { force = false; }
        _super.prototype.openAutoHitArea.call(this, force);
        var rect = this.img.getBounds();
        this.hitArea = rect;
        this.mouseEnabled = true;
        return true;
    };
    AnimationImageLayer.prototype.closeAutoHitArea = function (force) {
        if (force === void 0) { force = false; }
        var isClosed = _super.prototype.closeAutoHitArea.call(this, force);
        if (isClosed) {
            this.hitArea = null;
            this.mouseEnabled = false;
        }
        return isClosed;
    };
    AnimationImageLayer.prototype.onDisplay = function () {
        this.updateImage();
    };
    AnimationImageLayer.prototype.onUnDisplay = function () {
    };
    AnimationImageLayer.prototype.updateImage = function () {
        if (!this.animation)
            return;
        var imageSource = this.animation.imageSources[this._imageSource];
        if (!imageSource) {
            this.img.texture = null;
            return;
        }
        var tex = AssetManager.getClipTexture(imageSource.url, -imageSource.x, -imageSource.y, imageSource.width, imageSource.height);
        this.setSouce(tex, imageSource.width, imageSource.height);
        if (this._isOpenAutoHitArea) {
            var rect = this.img.getBounds();
            this.hitArea = rect;
        }
    };
    AnimationImageLayer.prototype.showFrame = function (frameIndex) {
        _super.prototype.showFrame.call(this, frameIndex);
        this.setOffset();
    };
    AnimationImageLayer.prototype.repaint = function () {
        _super.prototype.repaint.call(this);
        this.onResize();
    };
    AnimationImageLayer.prototype.setSouce = function (v, width, height, pivotX, pivotY) {
        if (pivotX === void 0) { pivotX = 0; }
        if (pivotY === void 0) { pivotY = 0; }
        if (!this.img)
            return;
        if (v == null || v instanceof Texture) {
            this.img.texture = v;
        }
        else {
            AssetManager.loadImage(v, Callback.New(function (t) {
                if (t) {
                    this.setSouce(t, t.width, t.height);
                }
                else {
                    this.setSouce(null, 0, 0);
                }
            }, this));
            return;
        }
        this.img.width = width;
        this.img.height = height;
        if (this._defaultStateImage && (this.width == 0 || isNaN(this.width)))
            this.width = width;
        if (this._defaultStateImage && (this.height == 0 || isNaN(this.height)))
            this.height = height;
        this._pivotX = pivotX;
        this._pivotY = pivotY;
        this.onResize();
    };
    Object.defineProperty(AnimationImageLayer.prototype, "lockScale", {
        get: function () {
            return this._lockScale;
        },
        set: function (v) {
            this._lockScale = v;
            if (!v) {
                this.img.x = 0;
                this.img.y = 0;
            }
            this.onResize();
        },
        enumerable: false,
        configurable: true
    });
    AnimationImageLayer.prototype.onResize = function () {
        if (!this.img || !this.img.texture || this.img.width == 0 || this.img.height == 0)
            return;
        var scaleX = this.width / this.img.width;
        var scaleY = this.height / this.img.height;
        if (this.lockScale) {
            var scale = Math.min(scaleX, scaleY);
            this.img.scaleX = scale;
            this.img.scaleY = scale;
            var imgW = this.img.width * scale;
            var imgH = this.img.height * scale;
            this.img.x = Math.round((this.width - imgW) / 2);
            this.img.y = Math.round((this.height - imgH) / 2);
        }
        else {
            this.img.scaleX = scaleX;
            this.img.scaleY = scaleY;
        }
        if (this.width < 0 || this.height < 0) {
            this.hitArea = this.img.getBounds();
        }
        else {
            this.hitArea = null;
        }
    };
    AnimationImageLayer.prototype.interpolationFrame = function (pf, nf, frameIndex) {
        var frame = _super.prototype.interpolationFrame.call(this, pf, nf, frameIndex);
        frame.blendModeType = pf.blendModeType;
        var t = (frameIndex - pf.index) / (nf.index - pf.index);
        if (nf.trans != null) {
            var value = GameUtils.getValueByTransData(nf.trans, t);
            frame.width = (nf.width - pf.width) * value + pf.width;
            frame.height = (nf.height - pf.height) * value + pf.height;
            frame.imageSource = Math.round((nf.imageSource - pf.imageSource) * value + pf.imageSource);
        }
        else {
            var tween = GameUtils.getTween(nf.tweenID)[0];
            frame.width = tween(t, pf.width, nf.width - pf.width, 1);
            frame.height = tween(t, pf.height, nf.height - pf.height, 1);
            frame.imageSource = Math.round(tween(t, pf.imageSource, nf.imageSource - pf.imageSource, 1));
        }
        return frame;
    };
    AnimationImageLayer.prototype.fromAnimationFrameData = function (framedata) {
        _super.prototype.fromAnimationFrameData.call(this, framedata);
        if (!framedata)
            return;
        this.width = framedata.width;
        this.height = framedata.height;
        this.imageSource = framedata.imageSource;
        this.blendModeType = framedata.blendModeType;
        if (!this.animation)
            return;
        if (!this.img)
            return;
        this.img.visible = false;
        var len = this.frames ? this.frames.length : 0;
        var totalFrame = this.animation.totalFrame ? this.animation.totalFrame : 0;
        if (len == 0 || totalFrame == 0)
            return;
        var firstFrame = this.frames[0].index;
        var lastFrame = 0;
        if (len == 1) {
            lastFrame = totalFrame - 1;
        }
        else if (len >= 2) {
            lastFrame = this.frames[len - 1].index;
        }
        if (this._frameIndex >= firstFrame && this._frameIndex <= lastFrame) {
            this.img.visible = true;
        }
        else {
            this.img.visible = false;
        }
    };
    AnimationImageLayer.prototype.toAnimationFrameData = function (framedata) {
        framedata = _super.prototype.toAnimationFrameData.call(this, framedata);
        framedata.width = this.width;
        framedata.height = this.height;
        framedata.imageSource = this.imageSource;
        framedata.blendModeType = this.blendModeType;
        return framedata;
    };
    AnimationImageLayer.prototype.dispose = function () {
        if (this.img) {
            this.img["_childs"].forEach(function (v) {
                if (v instanceof GameSprite)
                    v.dispose();
            }, this);
            this.img.offAll();
            this.img.removeSelf();
            this.img.destroy(true);
            this.img = null;
        }
        _super.prototype.dispose.call(this);
    };
    return AnimationImageLayer;
}(AnimationDisplayLayer));
AnimationLayer.typeClsMap[AnimationItemType.Image] = AnimationImageLayer;















(function (UIComponent) {
    var UIAnimationPlayType;
    (function (UIAnimationPlayType) {
        UIAnimationPlayType[UIAnimationPlayType["none"] = 0] = "none";
        UIAnimationPlayType[UIAnimationPlayType["once"] = 1] = "once";
        UIAnimationPlayType[UIAnimationPlayType["loop"] = 2] = "loop";
    })(UIAnimationPlayType || (UIAnimationPlayType = {}));
    var UIAnimation = (function (_super) {
        __extends(UIAnimation, _super);
        function UIAnimation(showCircleWhenInEditor) {
            if (showCircleWhenInEditor === void 0) { showCircleWhenInEditor = true; }
            var _this_1 = _super.call(this) || this;
            _this_1._playType = UIAnimationPlayType.none;
            _this_1._aniFrame = 1;
            _this_1.className = "UIAnimation";
            _this_1.__init();
            if (Config.EDIT_MODE) {
                _this_1.modifyWidthHeightEnabled = false;
                if (showCircleWhenInEditor) {
                    _this_1._bg = new Sprite();
                    _this_1.addChild(_this_1._bg);
                    _this_1.hitArea = new Rectangle(-10, -10, 20, 20);
                    _this_1._bg.graphics.drawCircle(0, 0, 10, "#FF0000");
                    _this_1._bg.alpha = 0.4;
                }
            }
            else {
                _this_1.on(EventObject.DISPLAY, _this_1, _this_1.refreshSize);
            }
            return _this_1;
        }
        Object.defineProperty(UIAnimation.prototype, "animationID", {
            get: function () {
                return this._animation.id;
            },
            set: function (v) {
                if (this.isDisposed)
                    return;
                if (this._animation.id == v)
                    return;
                v = Math.floor(v);
                this._animation.id = v;
                this._animation.syncLoadWhenAssetExist = this.syncLoadedEventWhenAssetExist;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIAnimation.prototype, "playType", {
            get: function () { return this._playType; },
            set: function (v) { v = Math.floor(v); this._playType = v; this.updateAnimationPlayType(); },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIAnimation.prototype, "playFps", {
            get: function () { return this.animation.fps; },
            set: function (v) { this.animation.fps = v; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIAnimation.prototype, "aniFrame", {
            get: function () {
                if (Config.EDIT_MODE)
                    return this._aniFrame;
                return this.animation.currentFrame;
            },
            set: function (v) {
                v = Math.floor(v);
                this._aniFrame = v;
                this.animation.currentFrame = v;
                this.refreshSize();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIAnimation.prototype, "scaleNumber", {
            get: function () {
                return this._animation.scaleX;
            },
            set: function (v) {
                this._animation.scaleX = this._animation.scaleY = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIAnimation.prototype, "scaleNumberX", {
            get: function () {
                return this._animation.scaleX;
            },
            set: function (v) {
                this._animation.scaleX = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIAnimation.prototype, "scaleNumberY", {
            get: function () {
                return this._animation.scaleY;
            },
            set: function (v) {
                this._animation.scaleY = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIAnimation.prototype, "animation", {
            get: function () {
                return this._animation;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIAnimation.prototype, "silentMode", {
            get: function () { return this._animation.silentMode; },
            set: function (v) {
                this._animation.silentMode = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIAnimation.prototype, "showHitEffect", {
            get: function () { return this._animation.showHitEffect; },
            set: function (v) {
                this._animation.showHitEffect = v;
            },
            enumerable: false,
            configurable: true
        });
        UIAnimation.prototype.__init = function () {
            this._animation = new GCAnimation();
            this.addChildAt(this._animation, 0);
            if (Config.EDIT_MODE) {
                this._animation.openAutoHitArea();
            }
            this._animation.showHitEffect = true;
            this._animation.on(EventObject.LOADED, this, this.onAnimationLoaded);
            this.on(EventObject.DISPLAY, this, this.updateAnimationPlayType);
        };
        Object.defineProperty(UIAnimation.prototype, "syncLoadedEventWhenAssetExist", {
            set: function (v) {
                this._syncLoadedEventWhenAssetExist = v;
            },
            enumerable: false,
            configurable: true
        });
        UIAnimation.prototype.loadAssetTest = function () {
            var aniID = this.animationID;
            AssetManager.preLoadAnimationAsset(aniID, Callback.New(function () {
                this.event(GameUI.EVENT_TEST_LOAD_CHILD_UI);
            }, this), this._syncLoadedEventWhenAssetExist, true);
        };
        UIAnimation.prototype.dispose = function () {
            if (!this.isDisposed) {
                if (this._animation) {
                    this._animation.dispose();
                    this._animation = null;
                }
                if (this._bg) {
                    this._bg.removeSelf();
                    this._bg.offAll();
                    this._bg.destroy(true);
                    this._bg = null;
                }
            }
            _super.prototype.dispose.call(this);
        };
        UIAnimation.prototype.inEditorInit = function () {
            this.width = 192;
            this.height = 192;
            this.animationID = 1;
            this.installDefaultValue();
        };
        UIAnimation.prototype.onAnimationLoaded = function () {
            this.refreshSize();
        };
        UIAnimation.prototype.updateAnimationPlayType = function () {
            if (!this.stage)
                return;
            if (this.guiRoot && this.guiRoot.onlyForPreload)
                return;
            if (this.playType == UIAnimationPlayType.none)
                this._animation.stop();
            else if (this.playType == UIAnimationPlayType.once) {
                this._animation.loop = false;
                this._animation.play();
            }
            else if (this.playType == UIAnimationPlayType.loop) {
                this._animation.loop = true;
                this._animation.play(true);
            }
        };
        UIAnimation.prototype.refreshSize = function () {
            if (!this.stage)
                return;
            if (!Config.EDIT_MODE) {
                this.hitArea = this._animation.getBounds();
            }
        };
        UIAnimation.prototype.on = function (type, caller, listener, args) {
            var t = _super.prototype.on.apply(this, arguments);
            if (this.hasMouseEvent && this.animation)
                this.animation.openAutoHitArea(true);
            return t;
        };
        ;
        UIAnimation.prototype.once = function (type, caller, listener, args) {
            var _this_1 = this;
            var t = _super.prototype.once.apply(this, [type, caller, function (caller, listener, args, e) {
                    listener.apply(caller, args ? args.concat([e]) : [e]);
                    if (!_this_1.hasMouseEvent && _this_1.animation)
                        _this_1.animation.closeAutoHitArea(true);
                }, [caller, listener, args]]);
            if (this.hasMouseEvent && this.animation)
                this.animation.openAutoHitArea(true);
            return t;
        };
        ;
        UIAnimation.prototype.off = function (type, caller, listener, onceOnly) {
            var t = _super.prototype.off.apply(this, arguments);
            if (!this.hasMouseEvent && this.animation)
                this.animation.closeAutoHitArea(true);
            return t;
        };
        ;
        UIAnimation.prototype.offAll = function (type) {
            var t = _super.prototype.offAll.apply(this, arguments);
            if (!this.hasMouseEvent && this.animation)
                this.animation.closeAutoHitArea(true);
            return t;
        };
        ;
        UIAnimation.customCompFunctionNames = ["animationID", "scaleNumberX", "scaleNumberY", "aniFrame", "playFps", "playType", "showHitEffect", "silentMode"];
        return UIAnimation;
    }(UIComponent.UIBase));
    UIComponent.UIAnimation = UIAnimation;
    ObjectUtils.redefinedEventFunc("UIComponent.UIAnimation", [GCAnimation.RENDER, GCAnimation.PLAY_START, GCAnimation.PLAY_STOP, GCAnimation.PLAY_COMPLETED, GCAnimation.SIGNAL, EventObject.LOADED], "_animation", false);
})(UIComponent || (UIComponent = {}));















(function (UIComponent) {
    var UIAvatar = (function (_super) {
        __extends(UIAvatar, _super);
        function UIAvatar() {
            var _this_1 = _super.call(this) || this;
            _this_1._oriMode = 8;
            _this_1._avatarFrame = 1;
            _this_1._orientationIndex = 0;
            _this_1._isPlay = true;
            _this_1._playOnce = false;
            _this_1.className = "UIAvatar";
            if (Config.EDIT_MODE) {
                _this_1.modifyWidthHeightEnabled = false;
            }
            _this_1.__init();
            return _this_1;
        }
        UIAvatar.prototype.__init = function () {
            var _this_1 = this;
            this._avatar = new Avatar();
            if (Config.EDIT_MODE) {
                this._avatar.openAutoHitArea();
                this.mouseEnabled = true;
            }
            this.addChildAt(this._avatar, 0);
            this.avatar.on(Avatar.RENDER, this, this.refreshSize);
            this.avatar.once(EventObject.LOADED, this, function () {
                _this_1._oriMode = _this_1.avatar.oriMode;
            });
        };
        Object.defineProperty(UIAvatar.prototype, "syncLoadedEventWhenAssetExist", {
            get: function () {
                return this._syncLoadedEventWhenAssetExist;
            },
            set: function (v) {
                this._syncLoadedEventWhenAssetExist = v;
            },
            enumerable: false,
            configurable: true
        });
        UIAvatar.prototype.loadAssetTest = function () {
            AssetManager.preLoadAvatarAsset(this.avatarID, Callback.New(function () {
                this.event(GameUI.EVENT_TEST_LOAD_CHILD_UI);
            }, this), this._syncLoadedEventWhenAssetExist, true);
        };
        UIAvatar.prototype.dispose = function () {
            if (!this.isDisposed) {
                if (this._avatar) {
                    this._avatar.dispose();
                    this._avatar = null;
                }
            }
            _super.prototype.dispose.call(this);
        };
        UIAvatar.prototype.inEditorInit = function (avatarID) {
            var _this_1 = this;
            if (avatarID === void 0) { avatarID = 1; }
            this.width = 192;
            this.height = 192;
            if (!this.stage) {
                this.once(EventObject.DISPLAY, this, function () {
                    _this_1.avatarID = avatarID;
                });
            }
            else {
                this.avatarID = avatarID;
            }
            this.orientationIndex = this._orientationIndex;
            this.installDefaultValue();
        };
        Object.defineProperty(UIAvatar.prototype, "avatar", {
            get: function () { return this._avatar; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIAvatar.prototype, "avatarID", {
            get: function () {
                return this.avatar.id;
            },
            set: function (v) {
                if (this.isDisposed)
                    return;
                if (v == this.avatarID)
                    return;
                v = Math.floor(v);
                this.avatar.syncLoadWhenAssetExist = this.syncLoadedEventWhenAssetExist == null ? true : this.syncLoadedEventWhenAssetExist;
                if (Config.EDIT_MODE)
                    this.avatar.forceRender = this.avatar.syncLoadWhenAssetExist;
                this.avatar.id = v;
                if (Config.EDIT_MODE) {
                    var avatarData = Common.avatarList.data[v];
                    if (avatarData)
                        this._oriMode = avatarData.oriMode;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIAvatar.prototype, "scaleNumberX", {
            get: function () {
                return this._avatar.scaleX;
            },
            set: function (v) {
                this._avatar.scaleX = v;
                this.refreshSize();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIAvatar.prototype, "scaleNumberY", {
            get: function () {
                return this._avatar.scaleY;
            },
            set: function (v) {
                this._avatar.scaleY = v;
                this.refreshSize();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIAvatar.prototype, "orientationIndex", {
            get: function () {
                return this._orientationIndex;
            },
            set: function (v) {
                var _this_1 = this;
                if (this.avatar.isLoading) {
                    var oldVisible = this.avatar.visible;
                    this.avatar.visible = false;
                    this.avatar.once(EventObject.LOADED, this, function () {
                        if (_this_1.isDisposed || _this_1.avatar.isDisposed || _this_1.avatar.userChangeOrientation)
                            return;
                        _this_1.avatar.visible = oldVisible;
                        _this_1.orientationIndex = v;
                        _this_1.refreshSize();
                    });
                    return;
                }
                v = Math.floor(v);
                this._orientationIndex = v;
                var orientation = GameUtils.getFlipOriByIndex(v, this._oriMode);
                if (orientation == null)
                    orientation = GameUtils.getFlipOriByIndex(0, this._oriMode);
                this.orientation = orientation;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIAvatar.prototype, "orientation", {
            get: function () {
                return this.avatar.orientation;
            },
            set: function (v) {
                v = Math.floor(v);
                this._orientationIndex = GameUtils.getIndexByFlipOri(v, this._oriMode);
                this.avatar.orientation = v;
                this.refreshSize();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIAvatar.prototype, "avatarFrame", {
            get: function () {
                return this._avatarFrame;
            },
            set: function (v) {
                v = Math.floor(v);
                this._avatarFrame = v;
                this.avatar.setCurrentFrame(v);
                this.refreshSize();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIAvatar.prototype, "isPlay", {
            get: function () {
                return this._isPlay;
            },
            set: function (v) {
                this._isPlay = v;
                this.refreshPlayState();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIAvatar.prototype, "playOnce", {
            get: function () {
                return this._playOnce;
            },
            set: function (v) {
                this._playOnce = v;
                this.refreshPlayState();
            },
            enumerable: false,
            configurable: true
        });
        UIAvatar.prototype.refreshPlayState = function () {
            var _this_1 = this;
            if (this.guiRoot && this.guiRoot.onlyForPreload)
                return;
            if ((this._isPlay || this._playOnce) && !this.avatar.isPlaying)
                this.avatar.play();
            if (this._playOnce) {
                this.avatar.once(Avatar.ACTION_PLAY_COMPLETED, this, function () {
                    _this_1.avatar.stop(_this_1.avatar.totalFrame);
                });
            }
            else {
                if (!this._isPlay)
                    this.avatar.stop(this.avatar.getCurrentFrame());
            }
        };
        Object.defineProperty(UIAvatar.prototype, "avatarFPS", {
            get: function () {
                return this.avatar.fps;
            },
            set: function (v) {
                v = Math.floor(v);
                this.avatar.fps = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIAvatar.prototype, "actionIndex", {
            get: function () {
                return this.avatar.actionIndex;
            },
            set: function (v) {
                v = Math.floor(v);
                this.avatar.actionIndex = v;
                this.refreshSize();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIAvatar.prototype, "actionID", {
            get: function () {
                return this.avatar.actionID;
            },
            set: function (v) {
                v = Math.floor(v);
                this.avatar.actionID = v;
                this.refreshSize();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIAvatar.prototype, "avatarHue", {
            get: function () {
                return this.avatar.hue;
            },
            set: function (v) {
                if (v == this._avatar.hue)
                    return;
                this._avatar.hue = v;
            },
            enumerable: false,
            configurable: true
        });
        UIAvatar.prototype.refreshSize = function () {
            var _this_1 = this;
            if (Config.EDIT_MODE) {
                Callback.CallLaterBeforeRender(function () {
                    if (_this_1.avatar)
                        _this_1.hitArea = _this_1.avatar.getBounds();
                }, this);
            }
            else {
                if (this.avatar)
                    this.hitArea = this.avatar.getBounds();
            }
        };
        UIAvatar.prototype.on = function (type, caller, listener, args) {
            var t = _super.prototype.on.apply(this, arguments);
            if (this.hasMouseEvent && this.avatar)
                this.avatar.openAutoHitArea(true);
            return t;
        };
        ;
        UIAvatar.prototype.once = function (type, caller, listener, args) {
            var _this_1 = this;
            var t = _super.prototype.once.apply(this, [type, caller, function (caller, listener, args, e) {
                    listener.apply(caller, args ? args.concat([e]) : [e]);
                    if (!_this_1.hasMouseEvent && _this_1.avatar)
                        _this_1.avatar.closeAutoHitArea(true);
                }, [caller, listener, args]]);
            if (this.hasMouseEvent && this.avatar)
                this.avatar.openAutoHitArea(true);
            return t;
        };
        ;
        UIAvatar.prototype.off = function (type, caller, listener, onceOnly) {
            var t = _super.prototype.off.apply(this, arguments);
            if (!this.hasMouseEvent && this.avatar)
                this.avatar.closeAutoHitArea(true);
            return t;
        };
        ;
        UIAvatar.prototype.offAll = function (type) {
            var t = _super.prototype.offAll.apply(this, arguments);
            if (!this.hasMouseEvent && this.avatar)
                this.avatar.closeAutoHitArea(true);
            return t;
        };
        ;
        UIAvatar.customCompFunctionNames = ["avatarID", "scaleNumberX", "scaleNumberY", "orientationIndex", "avatarFPS", "playOnce", "isPlay", "avatarFrame", "actionID", "avatarHue"];
        return UIAvatar;
    }(UIComponent.UIBase));
    UIComponent.UIAvatar = UIAvatar;
    ObjectUtils.redefinedEventFunc("UIComponent.UIAvatar", [Avatar.ACTION_PLAY_COMPLETED, Avatar.RENDER, EventObject.LOADED], "_avatar", false);
})(UIComponent || (UIComponent = {}));















(function (UIComponent) {
    var UICustomGameNumber = (function (_super) {
        __extends(UICustomGameNumber, _super);
        function UICustomGameNumber() {
            var _this_1 = _super.call(this) || this;
            _this_1._customData = [1, {}, {}];
            _this_1._previewNum = 2;
            _this_1._previewFixed = 0;
            _this_1.className = "UICustomGameNumber";
            _this_1._tf.text = "";
            if (!Config.EDIT_MODE) {
                _this_1.on(EventObject.DISPLAY, _this_1, _this_1.onDisplay);
                _this_1.on(EventObject.UNDISPLAY, _this_1, _this_1.onUnDisplay);
            }
            return _this_1;
        }
        UICustomGameNumber.prototype.inEditorInit = function () {
            _super.prototype.inEditorInit.call(this);
            this.customData = this.customData;
            this.installDefaultValue();
        };
        UICustomGameNumber.prototype.onDisplay = function () {
            os.add_ENTERFRAME(this.refreshDataDisplay, this);
            this.refreshDataDisplay();
        };
        UICustomGameNumber.prototype.onUnDisplay = function () {
            os.remove_ENTERFRAME(this.refreshDataDisplay, this);
        };
        Object.defineProperty(UICustomGameNumber.prototype, "customData", {
            get: function () {
                return this._customData;
            },
            set: function (v) {
                this._customData = v;
                if (v == null) {
                    this._tf.text = "0";
                    if (this._shadowEnabled) {
                        this._tf2.color = this._shadowColor;
                        this._tf2.text = this._tf.text;
                    }
                    return;
                }
                if (Config.EDIT_MODE) {
                    this.refreshEditorDataDisplay();
                }
                else if (typeof CustomGameNumber != "undefined") {
                    var customDataDisplayID = v[0];
                    this._customDataDisplayFunc = CustomGameNumber["f" + customDataDisplayID];
                    this.refreshDataDisplay();
                }
            },
            enumerable: false,
            configurable: true
        });
        UICustomGameNumber.prototype.refreshDataDisplay = function () {
            if (this._customData == null || !this._customDataDisplayFunc) {
                this._tf.text = "";
                if (this._shadowEnabled) {
                    this._tf2.color = this._shadowColor;
                    this._tf2.text = "";
                }
                return;
            }
            var value = this._customDataDisplayFunc(null, this.customData[1]);
            if (value == null || isNaN(value)) {
                this._tf.text = "";
                if (this._shadowEnabled) {
                    this._tf2.color = this._shadowColor;
                    this._tf2.text = "";
                }
                return;
            }
            this._tf.text = value.toFixed(this._previewFixed);
            if (this._shadowEnabled) {
                this._tf2.color = this._shadowColor;
                this._tf2.text = this._tf.text;
            }
        };
        Object.defineProperty(UICustomGameNumber.prototype, "previewNum", {
            get: function () {
                return this._previewNum;
            },
            set: function (v) {
                if (v != this._previewNum) {
                    this._previewNum = v;
                    this.refreshEditorDataDisplay();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UICustomGameNumber.prototype, "previewFixed", {
            get: function () {
                return this._previewFixed;
            },
            set: function (v) {
                if (v != this._previewFixed) {
                    this._previewFixed = v;
                    this.refreshEditorDataDisplay();
                }
            },
            enumerable: false,
            configurable: true
        });
        UICustomGameNumber.prototype.inEditorInfo = function () {
            if (!this._customData || !this._customData[2])
                return "";
            var idValue = this._customData[2][0];
            var customDataDisplayID = this._customData[0];
            var dataName = CommandExecute.customMessage(idValue, Game.data.customDataDisplayList, customDataDisplayID);
            if (!dataName)
                return "";
            var str = StringUtils.clearHtmlTag1(dataName.title + dataName.content);
            if (str[str.length - 1] == " ")
                str = str.substr(0, str.length - 1);
            return str;
        };
        UICustomGameNumber.prototype.getCustomGameNumberInfo = function () {
            if (!this._customData || !this._customData[2])
                return "";
            var idValue = this._customData[2][0];
            var customDataDisplayID = this._customData[0];
            var dataName = CommandExecute.customMessage(idValue, Game.data.customDataDisplayList, customDataDisplayID);
            if (!dataName)
                return "";
            var info = StringUtils.paraseCustomMessage(dataName);
            var str = info.title;
            if (this._previewNum == 1) {
                str = info.content;
                if (str[str.length - 1] == " ")
                    str = str.substr(0, str.length - 1);
            }
            return str;
        };
        UICustomGameNumber.prototype.refreshEditorDataDisplay = function () {
            if (!Config.EDIT_MODE)
                return;
            if (this._previewNum == 0 || this._previewNum == 1) {
                var str = this.getCustomGameNumberInfo();
                if (str)
                    this._tf.text = str;
            }
            else if (this._previewNum == 2) {
                this._tf.text = Number(0).toFixed(this._previewFixed);
            }
            else if (this._previewNum == 3) {
                this._tf.text = Number(10).toFixed(this._previewFixed);
            }
            else if (this._previewNum == 4) {
                this._tf.text = Number(100).toFixed(this._previewFixed);
            }
            else if (this._previewNum == 5) {
                this._tf.text = Number(1000).toFixed(this._previewFixed);
            }
            else if (this._previewNum == 6) {
                this._tf.text = Number(10000).toFixed(this._previewFixed);
            }
            if (this._shadowEnabled) {
                this._tf2.color = this._shadowColor;
                this._tf2.text = this._tf.text;
            }
        };
        UICustomGameNumber.prototype.dispose = function () {
            if (!this.isDisposed)
                os.remove_ENTERFRAME(this.refreshDataDisplay, this);
            _super.prototype.dispose.call(this);
        };
        UICustomGameNumber.customCompFunctionNames = ["customData", "previewNum", "previewFixed", "fontSize", "color", "bold", "italic", "smooth", "align", "valign", "leading",
            "letterSpacing", "font", "wordWrap", "overflow", "shadowEnabled", "shadowColor", "shadowDx", "shadowDy", "stroke", "strokeColor", "textWidth", "textHeight", "textLength"];
        return UICustomGameNumber;
    }(UIComponent.UIString));
    UIComponent.UICustomGameNumber = UICustomGameNumber;
})(UIComponent || (UIComponent = {}));















(function (UIComponent) {
    var UICustomGameString = (function (_super) {
        __extends(UICustomGameString, _super);
        function UICustomGameString() {
            var _this_1 = _super.call(this) || this;
            _this_1._customData = [1, {}, {}];
            _this_1._inEditorText = "[STR]";
            _this_1.className = "UICustomGameString";
            _this_1._tf.text = "";
            if (!Config.EDIT_MODE) {
                _this_1.on(EventObject.DISPLAY, _this_1, _this_1.onDisplay);
                _this_1.on(EventObject.UNDISPLAY, _this_1, _this_1.onUnDisplay);
            }
            return _this_1;
        }
        UICustomGameString.prototype.inEditorInit = function () {
            _super.prototype.inEditorInit.call(this);
            this.customData = this.customData;
            this.installDefaultValue();
        };
        UICustomGameString.prototype.onDisplay = function () {
            os.add_ENTERFRAME(this.refreshDataDisplay, this);
            this.refreshDataDisplay();
        };
        UICustomGameString.prototype.onUnDisplay = function () {
            os.remove_ENTERFRAME(this.refreshDataDisplay, this);
        };
        Object.defineProperty(UICustomGameString.prototype, "customData", {
            get: function () {
                return this._customData;
            },
            set: function (v) {
                this._customData = v;
                if (v == null) {
                    this._tf.text = "0";
                    if (this._shadowEnabled) {
                        this._tf2.color = this._shadowColor;
                        this._tf2.text = this._tf.text;
                    }
                    return;
                }
                if (Config.EDIT_MODE) {
                    this.refreshEditorDataDisplay();
                }
                else if (typeof CustomGameString != "undefined") {
                    var customDataDisplayID = v[0];
                    this._customDataDisplayFunc = CustomGameString["f" + customDataDisplayID];
                    this.refreshDataDisplay();
                }
            },
            enumerable: false,
            configurable: true
        });
        UICustomGameString.prototype.refreshDataDisplay = function () {
            if (this._customData == null || !this._customDataDisplayFunc) {
                this._tf.text = "";
                if (this._shadowEnabled) {
                    this._tf2.color = this._shadowColor;
                    this._tf2.text = this._tf.text;
                }
                return;
            }
            var value = this._customDataDisplayFunc(null, this.customData[1]);
            if (value == null) {
                this._tf.text = "";
                if (this._shadowEnabled) {
                    this._tf2.color = this._shadowColor;
                    this._tf2.text = this._tf.text;
                }
                return;
            }
            this._tf.text = value;
            if (this._shadowEnabled) {
                this._tf2.color = this._shadowColor;
                this._tf2.text = this._tf.text;
            }
        };
        Object.defineProperty(UICustomGameString.prototype, "inEditorText", {
            get: function () {
                return this._inEditorText;
            },
            set: function (v) {
                this._inEditorText = v;
                this.refreshEditorDataDisplay();
            },
            enumerable: false,
            configurable: true
        });
        UICustomGameString.prototype.inEditorInfo = function () {
            if (this._customData && this._customData[2]) {
                var idValue = this._customData[2][0];
                var customDataDisplayID = this._customData[0];
                var dataName = CommandExecute.customMessage(idValue, Game.data.customGameStringList, customDataDisplayID);
                if (dataName) {
                    var str = StringUtils.clearHtmlTag1(dataName.title);
                    str += StringUtils.clearHtmlTag1(dataName.content);
                    if (str[str.length - 1] == " ")
                        str = str.substr(0, str.length - 1);
                    return str;
                }
            }
            return "";
        };
        UICustomGameString.prototype.refreshEditorDataDisplay = function () {
            if (!Config.EDIT_MODE)
                return;
            this._tf.text = this._inEditorText;
            if (this._shadowEnabled) {
                this._tf2.color = this._shadowColor;
                this._tf2.text = this._tf.text;
            }
        };
        UICustomGameString.prototype.dispose = function () {
            if (!this.isDisposed)
                os.remove_ENTERFRAME(this.refreshDataDisplay, this);
            _super.prototype.dispose.call(this);
        };
        UICustomGameString.customCompFunctionNames = ["customData", "inEditorText", "fontSize", "color", "bold", "italic", "smooth", "align", "valign", "leading",
            "letterSpacing", "font", "wordWrap", "overflow", "shadowEnabled", "shadowColor", "shadowDx", "shadowDy", "stroke", "strokeColor", "textWidth", "textHeight", "textLength"];
        return UICustomGameString;
    }(UIComponent.UIString));
    UIComponent.UICustomGameString = UICustomGameString;
})(UIComponent || (UIComponent = {}));















(function (UIComponent) {
    var UIInput = (function (_super) {
        __extends(UIInput, _super);
        function UIInput() {
            var _this_1 = _super.call(this, !Config.EDIT_MODE) || this;
            _this_1._text = "";
            _this_1._color = "#000000";
            _this_1._promptColor = "#606060";
            _this_1.className = "UIInput";
            _this_1.valign = 1;
            _this_1.width = 200;
            _this_1.height = 30;
            _this_1.fontSize = 16;
            _this_1.align = 0;
            _this_1.inputMode = 0;
            _this_1.maxChars = 99999;
            _this_1.mouseEventEnabled = true;
            return _this_1;
        }
        UIInput.prototype.select = function () {
            this.setSelection(0, 999999999);
        };
        UIInput.prototype.setSelection = function (startIndex, endIndex) {
            if (this._inputMode == 3)
                return;
            if (this._tf instanceof TextInput) {
                this._tf.setSelection(startIndex, endIndex);
            }
        };
        ;
        UIInput.prototype.inEditorInit = function () {
            this.mouseEventEnabledData = true;
            this.text = "[#GAME_THE_DEFAULT_TEXT]";
            this.installDefaultValue();
        };
        UIInput.prototype.setTextForce = function (v) {
            this.__forceChange = true;
            this.text = v;
            this.__forceChange = false;
            this.color = this.color;
        };
        Object.defineProperty(UIInput.prototype, "focus", {
            get: function () {
                return this._tf.focus;
            },
            set: function (v) {
                this._tf.focus = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIInput.prototype, "restrict", {
            get: function () {
                return this._restrict ? this._restrict : "";
            },
            set: function (v) {
                this._restrict = this._tf.restrict = v ? v : "";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIInput.prototype, "maxChars", {
            get: function () {
                return this._tf.maxChars;
            },
            set: function (v) {
                this._tf.maxChars = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIInput.prototype, "inputMode", {
            get: function () {
                return this._inputMode;
            },
            set: function (v) {
                v = Math.floor(v);
                var lastInputMode = this._inputMode;
                this._inputMode = v;
                switch (v) {
                    case 0:
                        this._tf.type = "text";
                        break;
                    case 1:
                        this._tf.type = "password";
                        break;
                    case 2:
                        this._tf.type = "number";
                        break;
                    case 3:
                        break;
                }
                if ((lastInputMode <= 2 && v == 3) || (lastInputMode == 3 && v < 3)) {
                    this.changeTextInputType();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIInput.prototype, "text", {
            get: function () {
                if (!Config.EDIT_MODE) {
                    return this._tf.text;
                }
                else {
                    return this._text;
                }
            },
            set: function (v) {
                this._text = v;
                if (this.__forceChange) {
                    this._tf.changeText(v);
                }
                else {
                    this._tf.text = v;
                }
                this._tf.color = this._color;
                if (this._shadowEnabled) {
                    if (this._text && !this._tf2.stage)
                        this.addChildAt(this._tf2, 0);
                    this._tf2.color = this._shadowColor;
                    if (this.__forceChange) {
                        this._tf2.changeText(this._tf.text);
                    }
                    else {
                        this._tf2.text = this._tf.text;
                    }
                }
                if (Config.EDIT_MODE && !this._text && this._prompt) {
                    this._tf.changeText(this._prompt);
                    this._tf.color = this._promptColor;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIInput.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (v) {
                this._color = v;
                if (!Config.EDIT_MODE) {
                    this._tf.color = v ? v : "#000000";
                }
                else {
                    if (this._text) {
                        this._tf.color = v;
                        this.width += 1;
                        this.width -= 1;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIInput.prototype, "prompt", {
            get: function () {
                return this._prompt;
            },
            set: function (v) {
                this._prompt = v;
                if (!Config.EDIT_MODE) {
                    this._tf.prompt = v ? v : "";
                }
                else {
                    if (!this._text && this._prompt) {
                        this._tf.changeText(this._prompt);
                        this._tf.color = this._promptColor;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIInput.prototype, "promptColor", {
            get: function () {
                return this._promptColor;
            },
            set: function (v) {
                this._promptColor = v;
                if (!Config.EDIT_MODE) {
                    this._tf.promptColor = v ? v : "#606060";
                }
                else {
                    if (!this._text && this._prompt) {
                        this._tf.color = this._promptColor;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        UIInput.prototype.changeTextInputType = function () {
            var oldTf = this._tf;
            if (this._tf.parent)
                this._tf.parent.removeChild(this._tf);
            if (this._inputMode == 3) {
                this._tf = new TextArea();
                this._tf.valign = "top";
            }
            else {
                this._tf = new TextInput();
                this._tf.valign = "middle";
            }
            this.addChild(this._tf);
            var recoveryAttrs = ["text", "color", "fontSize", "leading", "align",
                "bold", "width", "height", "font", "overflow", "wordWrap", "restrict"];
            for (var i in recoveryAttrs) {
                var attr = recoveryAttrs[i];
                this._tf[attr] = oldTf[attr];
            }
            if (Config.EDIT_MODE) {
                this._tf.mouseEnabled = false;
            }
            this.refreshStroke();
        };
        Object.defineProperty(UIInput.prototype, "onInputFragEvent", {
            get: function () {
                return this._onInputFragEvent;
            },
            set: function (v) {
                this._onInputFragEvent = v;
                if (v) {
                    this.off(EventObject.INPUT, this, this.onInput_private);
                    this.on(EventObject.INPUT, this, this.onInput_private);
                }
                else {
                    this.off(EventObject.INPUT, this, this.onInput_private);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIInput.prototype, "onEnterFragEvent", {
            get: function () {
                return this._onEnterFragEvent;
            },
            set: function (v) {
                this._onEnterFragEvent = v;
                if (v) {
                    this.off(EventObject.ENTER, this, this.onEnter_private);
                    this.on(EventObject.ENTER, this, this.onEnter_private);
                }
                else {
                    this.off(EventObject.ENTER, this, this.onEnter_private);
                }
            },
            enumerable: false,
            configurable: true
        });
        UIInput.prototype.onInput_private = function () {
            if (Config.SINGLE_PLAYER_CORE) {
                if (this._onInputFragEvent && this.guiRoot && !this.guiRoot.onlyForPreload) {
                    CommandPage.startTriggerFragmentEvent(this._onInputFragEvent, Game.player.sceneObject, Game.player.sceneObject);
                }
            }
        };
        UIInput.prototype.onEnter_private = function () {
            if (Config.SINGLE_PLAYER_CORE) {
                if (this._onEnterFragEvent && this.guiRoot && !this.guiRoot.onlyForPreload) {
                    CommandPage.startTriggerFragmentEvent(this._onEnterFragEvent, Game.player.sceneObject, Game.player.sceneObject);
                }
            }
        };
        UIInput.customCompFunctionNames = ["text", "fontSize", "color", "prompt", "promptColor", "bold", "italic", "smooth", "align", "leading",
            "font", "wordWrap", "restrict", "inputMode", "maxChars", "shadowEnabled", "shadowColor", "shadowDx", "shadowDy", "onInputFragEvent", "onEnterFragEvent", "textWidth", "textHeight", "textLength"];
        return UIInput;
    }(UIComponent.UIString));
    UIComponent.UIInput = UIInput;
})(UIComponent || (UIComponent = {}));















(function (UIComponent) {
    var UIList = (function (_super) {
        __extends(UIList, _super);
        function UIList() {
            var _this_1 = _super.call(this) || this;
            _this_1.overSelectMode = true;
            _this_1._selectEnable = true;
            _this_1._repeatX = 1;
            _this_1._spaceX = 2;
            _this_1._spaceY = 20;
            _this_1._itemWidth = 200;
            _this_1._itemHeight = 50;
            _this_1._selectedIndex = -1;
            _this_1._overIndex = -1;
            _this_1._items = [];
            _this_1._itemModelGUI = -1;
            _this_1._overImageGrid9 = "0,0,0,0,0";
            _this_1._selectImageGrid9 = "0,0,0,0,0";
            _this_1._selectedImageOnTop = true;
            _this_1._overImageOnTop = true;
            _this_1._itemSize = 0;
            _this_1.subitemIndentation = 20;
            _this_1._previewSize = 5;
            _this_1.cancelSelectedIndex = -1;
            _this_1.optimizationItemUI = [];
            _this_1.optimizationItemUIMap = {};
            _this_1.optimizationItemUIPool = [];
            _this_1.maxEx = 0;
            _this_1.maxEy = 0;
            _this_1.className = "UIList";
            _this_1._contentArea = new GameSprite();
            _this_1._overImageBox = new GameSprite();
            _this_1._overImage = new UIComponent.UIBitmap();
            _this_1._overImageBox.addChild(_this_1._overImage);
            _this_1._selectedImageBox = new GameSprite();
            _this_1._selectedImage = new UIComponent.UIBitmap();
            _this_1._selectedImageBox.addChild(_this_1._selectedImage);
            _this_1._overImageBox.mouseEnabled = false;
            _this_1._selectedImageBox.mouseEnabled = false;
            _this_1._overImageBox.visible = false;
            _this_1.refreshLayer();
            _this_1.enabledLimitView = true;
            _this_1.scrollShowType = 2;
            _this_1.selectedImageAlpha = 0.5;
            _this_1.overImageAlpha = 0.5;
            _this_1.width = 200;
            _this_1.height = 200;
            return _this_1;
        }
        Object.defineProperty(UIList, "KEY_BOARD_ENABLED", {
            get: function () {
                return UIList._KEY_BOARD_ENABLED;
            },
            set: function (v) {
                UIList._KEY_BOARD_ENABLED = v;
                if (v) {
                    if (typeof stage != "undefined")
                        UIList.listKeyboardHandle();
                    else
                        EventUtils.addEventListener(ClientWorld, ClientWorld.EVENT_INITED, Callback.New(UIList.listKeyboardHandle, UIList), true);
                }
                else {
                    UIList.keyDownEnter = false;
                    UIList.keyDownEsc = false;
                    stage.off(EventObject.KEY_UP, this, UIList.onListKeyUp);
                    stage.off(EventObject.KEY_DOWN, this, UIList.onListKeyDown);
                }
            },
            enumerable: false,
            configurable: true
        });
        UIList.listKeyboardHandle = function () {
            stage.on(EventObject.KEY_DOWN, this, UIList.onListKeyDown);
            stage.on(EventObject.KEY_UP, this, UIList.onListKeyUp);
        };
        UIList.onListKeyDown = function (e) {
            this.setKeyDown(e.keyCode);
        };
        UIList.onListKeyUp = function (e) {
            if (UIList.KEY_ENTER.indexOf(e.keyCode) != -1) {
                UIList.keyDownEnter = false;
            }
            else if (UIList.KEY_ESC.indexOf(e.keyCode) != -1) {
                UIList.keyDownEsc = false;
            }
        };
        UIList.setKeyDown = function (keyCode) {
            if (!this._focus || !this._focus.stage)
                return;
            var dx = this._focus.selectedIndex % this._focus.repeatX;
            var dy = Math.floor(this._focus.selectedIndex / this._focus.repeatX);
            if (UIList.KEY_LEFT.indexOf(keyCode) != -1) {
                dx -= 1;
                if (dx < 0)
                    dx = 0;
            }
            else if (UIList.KEY_RIGHT.indexOf(keyCode) != -1) {
                dx += 1;
                if (dx >= this._focus.repeatX)
                    dx = this._focus.repeatX - 1;
            }
            else if (UIList.KEY_UP.indexOf(keyCode) != -1) {
                dy -= 1;
                if (dy < 0)
                    dy = 0;
            }
            else if (UIList.KEY_DOWN.indexOf(keyCode) != -1) {
                dy += 1;
                var rowCount = Math.ceil(this._focus.length / this._focus.repeatX);
                if (dy >= rowCount)
                    dy = rowCount - 1;
            }
            else if (UIList.KEY_ENTER.indexOf(keyCode) != -1) {
                if (UIList.keyDownEnter)
                    return;
                UIList.keyDownEnter = true;
                var data = this._focus.selectedItem;
                if (!data)
                    return;
                if (data.numChildren == 0) {
                    data.isOpen = !data.isOpen;
                    this._focus.refreshOrder();
                    this._focus.event(UIList.OPEN_STATE_CHANGE, [this._focus.getItemUI(this._focus.selectedIndex), data, this._focus.selectedIndex]);
                }
                Callback.CallLaterBeforeRender(this._focus.event, this._focus, [UIList.ITEM_CLICK]);
                return;
            }
            else if (UIList.KEY_ESC.indexOf(keyCode) != -1) {
                if (UIList.keyDownEsc)
                    return;
                UIList.keyDownEsc = true;
                if (this._focus.cancelSelectedIndex >= 0 && this._focus.cancelSelectedIndex < this._focus.items.length) {
                    this._focus.selectedIndex = this._focus.cancelSelectedIndex;
                    Callback.CallLaterBeforeRender(this._focus.event, this._focus, [UIList.ITEM_CLICK]);
                    return;
                }
            }
            var selectedIndex = dy * this._focus.repeatX + dx;
            if (selectedIndex < 0)
                selectedIndex = 0;
            if (selectedIndex >= this._focus.length)
                selectedIndex = this._focus.length - 1;
            this._focus.selectedIndex = selectedIndex;
        };
        Object.defineProperty(UIList, "focus", {
            get: function () {
                return this._focus;
            },
            set: function (list) {
                if (list && list.isDisposed)
                    list = null;
                if (this._focus == list)
                    return;
                var lastFocus = this._focus;
                if (UIList.SINGLE_FOCUS_MODE) {
                    if (this._focus)
                        this._focus.mouseEnabled = false;
                }
                this._focus = list;
                if (list) {
                    if (list.selectedIndex == -1)
                        list.selectedIndex = 0;
                    if (UIList.SINGLE_FOCUS_MODE) {
                        list.mouseEnabled = true;
                    }
                }
                EventUtils.happen(UIList, UIList.EVENT_FOCUS_CHANGE, [lastFocus, this._focus]);
            },
            enumerable: false,
            configurable: true
        });
        UIList.prototype.dispose = function () {
            if (!this.isDisposed) {
                if (Config.EDIT_MODE) {
                    EUIRoot.dataBaseWindow.win7.off(EUIWindowUI.EVENT_GUI_DATA_SYNC_COMPLETE, this, this.onItemUIChange);
                }
                this.clearItems(true);
                this._overImage.dispose();
                this._overImage = null;
                this._overImageBox.dispose();
                this._overImageBox = null;
                this._selectedImage.dispose();
                this._selectedImage = null;
                this._selectedImageBox.dispose();
                this._selectedImageBox = null;
                this._contentArea.dispose();
                this._contentArea = null;
            }
            _super.prototype.dispose.call(this);
        };
        UIList.prototype.inEditorInit = function () {
            this.overImageURL = "asset/image/picture/control/uilistover.png";
            this.selectImageURL = "asset/image/picture/control/uilistselect.png";
            _super.prototype.inEditorInit.call(this);
            this.installDefaultValue();
        };
        UIList.prototype.loadAssetTest = function () {
            if (this.itemModelClass) {
                this.event(GameUI.EVENT_TEST_LOAD_CHILD_UI);
                return;
            }
            var id = MathUtils.int(this.itemModelGUI);
            var mySkins = [this._vScroollBarImage1, this._vScroollBarImage2, this._hScroollBarImage1, this._hScroollBarImage2];
            AssetManager.loadImages(mySkins, Callback.New(function () {
                AssetManager.preLoadUIAsset(id, Callback.New(function () {
                    this.event(GameUI.EVENT_TEST_LOAD_CHILD_UI);
                }, this), this._syncLoadedEventWhenAssetExist, true);
            }, this), this._syncLoadedEventWhenAssetExist, false);
        };
        UIList.prototype.constructorInit = function (uiID, syncLoadedEventWhenAssetExist) {
            if (syncLoadedEventWhenAssetExist === void 0) { syncLoadedEventWhenAssetExist = false; }
            _super.prototype.constructorInit.apply(this, arguments);
            if (!Config.EDIT_MODE && UIList.SINGLE_FOCUS_MODE) {
                this.mouseEnabled = false;
            }
        };
        UIList.prototype.itemsPreview = function () {
            if (!Config.EDIT_MODE || !this.stage)
                return;
            if (this.checkDeepLoopAndReset(this._itemModelGUI))
                return;
            var arr = [];
            for (var i = 0; i < this._previewSize; i++) {
                var d = new UIListItemData();
                arr.push(d);
            }
            this.items = arr;
            this.selectedIndex = 0;
        };
        Object.defineProperty(UIList.prototype, "itemSprites", {
            get: function () {
                return this._contentArea["_childs"];
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "previewSize", {
            get: function () {
                return this._previewSize;
            },
            set: function (v) {
                if (!Config.EDIT_MODE)
                    return;
                if (this._previewSize != v) {
                    this._previewSize = Math.min(v, 100);
                    Callback.CallLater(this.itemsPreview, this);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "selectEnable", {
            get: function () {
                return this._selectEnable;
            },
            set: function (v) {
                if (this._selectEnable != v) {
                    this._selectEnable = v;
                    this._overImageBox.visible = v;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "repeatX", {
            get: function () {
                return this._repeatX;
            },
            set: function (v) {
                if (this._repeatX != v) {
                    this._repeatX = v;
                    if (this._repeatX < 1)
                        this._repeatX = 1;
                    this.refreshOrder();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "spaceX", {
            get: function () {
                return this._spaceX;
            },
            set: function (v) {
                if (this._spaceX != v) {
                    this._spaceX = v;
                    this.refreshOrder();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "spaceY", {
            get: function () {
                return this._spaceY;
            },
            set: function (v) {
                if (this._spaceY != v) {
                    this._spaceY = v;
                    this.refreshOrder();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "itemWidth", {
            get: function () {
                return this._itemWidth;
            },
            set: function (v) {
                if (this._itemWidth != v) {
                    this._itemWidth = v;
                    if (this._itemWidth < 1)
                        this._itemWidth = 1;
                    this.refreshOrder();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "itemHeight", {
            get: function () {
                return this._itemHeight;
            },
            set: function (v) {
                if (this._itemHeight != v) {
                    this._itemHeight = v;
                    if (this._itemHeight < 1)
                        this._itemHeight = 1;
                    this.refreshOrder();
                }
            },
            enumerable: false,
            configurable: true
        });
        UIList.prototype.scrollTo = function (index, ignoreAlreadyInVisible, tween, duration, ease, complete) {
            if (ignoreAlreadyInVisible === void 0) { ignoreAlreadyInVisible = true; }
            if (tween === void 0) { tween = false; }
            if (duration === void 0) { duration = 0; }
            if (ease === void 0) { ease = null; }
            if (complete === void 0) { complete = null; }
            var column = index % this.repeatX;
            var row = Math.floor(index / this.repeatX);
            var px = column * (this.itemWidth + this.spaceX);
            var py = row * (this.itemHeight + this.spaceY);
            var rect = new Rectangle(px, py, this.itemWidth, this.itemHeight);
            var points = [[rect.x, rect.y], [rect.right, rect.y], [rect.right, rect.bottom], [rect.x, rect.bottom]];
            var needScrollTo = false;
            var myScrollRect = this._myScrollRect.clone();
            if (this._vScrollBar.visible)
                myScrollRect.width -= this.scrollWidth;
            if (this._hScrollBar.visible)
                myScrollRect.height -= this.scrollWidth;
            var totalWidth = this._contentWidth - this._myScrollRect.width;
            var totalHeight = this._contentHeight - this._myScrollRect.height;
            var perX, perY;
            if (myScrollRect.y >= py || !ignoreAlreadyInVisible) {
                perY = py * 100 / totalHeight;
            }
            else if (rect.bottom > myScrollRect.bottom) {
                perY = (py - myScrollRect.height + rect.height) * 100 / totalHeight;
            }
            if (myScrollRect.x > px || !ignoreAlreadyInVisible) {
                perX = px * 100 / totalWidth;
            }
            else if (rect.right > myScrollRect.right) {
                perX = (px - myScrollRect.width + rect.width) * 100 / totalWidth;
            }
            if (tween) {
                if (perX != null) {
                    Tween.clearAll(this._hScrollBar);
                    Tween.to(this._hScrollBar, { value: perX }, duration, ease, complete);
                }
                if (perY != null) {
                    Tween.clearAll(this._vScrollBar);
                    Tween.to(this._vScrollBar, { value: perY }, duration, ease, complete);
                }
            }
            else {
                if (perX != null)
                    this._hScrollBar.value = perX;
                if (perY != null)
                    this._vScrollBar.value = perY;
            }
        };
        UIList.prototype.calcTotalContentSize = function () {
            var itemLen = this._itemSize;
            var itemColumnNum = Math.min(itemLen, this.repeatX);
            var itemRowNum = Math.ceil(itemLen / this.repeatX);
            var maxW = (itemColumnNum * this.itemWidth) + Math.max(itemColumnNum - 1, 0) * this.spaceX + this.maxEx;
            var maxH = (itemRowNum * this.itemHeight) + Math.max(itemRowNum - 1, 0) * this.spaceY + this.maxEy;
            return { maxW: maxW, maxH: maxH };
        };
        Object.defineProperty(UIList.prototype, "selectedImage", {
            get: function () {
                return this._selectedImage;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "overImageURL", {
            get: function () {
                return this._overImageURL;
            },
            set: function (v) {
                if (this.isDisposed)
                    return;
                if (this._overImageURL != v) {
                    this._overImageURL = v;
                    this._overImage.image = v;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "overImage", {
            get: function () {
                return this._overImage;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "selectImageURL", {
            get: function () {
                return this._selectImageURL;
            },
            set: function (v) {
                if (this.isDisposed)
                    return;
                if (this._selectImageURL != v) {
                    this._selectImageURL = v;
                    this._selectedImage.image = v;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "selectImage", {
            get: function () {
                return this._selectedImage;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "selectedImageAlpha", {
            get: function () {
                return this._selectedImageAlpha;
            },
            set: function (v) {
                if (this._selectedImageAlpha != v) {
                    this._selectedImageAlpha = v;
                    this._selectedImageBox.alpha = v;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "overImageAlpha", {
            get: function () {
                return this._overImageAlpha;
            },
            set: function (v) {
                if (this._overImageAlpha != v) {
                    this._overImageAlpha = v;
                    this._overImageBox.alpha = v;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "selectedImageOnTop", {
            get: function () {
                return this._selectedImageOnTop;
            },
            set: function (v) {
                if (this._selectedImageOnTop != v) {
                    this._selectedImageOnTop = v;
                    this.refreshLayer();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "overImageOnTop", {
            get: function () {
                return this._overImageOnTop;
            },
            set: function (v) {
                if (this._overImageOnTop != v) {
                    this._overImageOnTop = v;
                    this.refreshLayer();
                }
            },
            enumerable: false,
            configurable: true
        });
        UIList.prototype.refreshLayer = function () {
            if (!this._selectedImageOnTop) {
                this.addChild(this._selectedImageBox);
            }
            if (!this._overImageOnTop) {
                this.addChild(this._overImageBox);
            }
            this.addChild(this._contentArea);
            if (this._selectedImageOnTop) {
                this.addChild(this._selectedImageBox);
            }
            if (this._overImageOnTop) {
                this.addChild(this._overImageBox);
            }
        };
        Object.defineProperty(UIList.prototype, "overImageGrid9Width", {
            get: function () {
                return this._overImage.width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "overImageGrid9Height", {
            get: function () {
                return this._overImage.height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "overImageGrid9Skin", {
            get: function () {
                return this._overImage.image;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "overImageGrid9", {
            get: function () {
                return this._overImageGrid9;
            },
            set: function (v) {
                if (!v || v == "")
                    v = "0,0,0,0,0";
                if (this._overImageGrid9 != v) {
                    this._overImageGrid9 = v;
                    this._overImage.grid9 = v;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "selectImageGrid9Width", {
            get: function () {
                return this._selectedImage.width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "selectImageGrid9Height", {
            get: function () {
                return this._selectedImage.height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "selectImageGrid9Skin", {
            get: function () {
                return this._selectedImage.image;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "selectImageGrid9", {
            get: function () {
                return this._selectImageGrid9;
            },
            set: function (v) {
                if (!v || v == "")
                    v = "0,0,0,0,0";
                if (this._selectImageGrid9 != v) {
                    this._selectImageGrid9 = v;
                    this._selectedImage.grid9 = v;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "itemModelClass", {
            get: function () {
                return this._itemModelClass;
            },
            set: function (v) {
                if (this.isDisposed)
                    return;
                if (this._itemModelClass != v) {
                    this._itemModelClass = v;
                    this._itemModelGUI = 0;
                    this.event(EventObject.LOADED);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "itemModelGUI", {
            get: function () {
                return this._itemModelGUI;
            },
            set: function (v) {
                var _this_1 = this;
                if (this.isDisposed)
                    return;
                this._itemModelGUI = v;
                if (v == 0) {
                    this._itemModelClass = null;
                    this.itemsPreview();
                    this.event(EventObject.LOADED);
                    return;
                }
                if (Config.EDIT_MODE) {
                    Callback.CallLater(function () {
                        if (_this_1.isDisposed)
                            return;
                        if (_this_1.checkDeepLoopAndReset(_this_1._itemModelGUI))
                            return;
                        var uiData = Common.uiList.data[v];
                        if (!uiData) {
                            _this_1._itemModelClass = null;
                            _this_1.itemsPreview();
                            _this_1.event(EventObject.LOADED);
                            return;
                        }
                        var instanceClassName = uiData.uiDisplayData.instanceClassName;
                        var classObj = window[instanceClassName];
                        if (!classObj)
                            classObj = window["GUI_" + v];
                        _this_1._itemModelClass = classObj;
                        _this_1.itemsPreview();
                    }, this);
                }
                else {
                    var uiData = Common.uiList.data[v];
                    if (!uiData) {
                        this._itemModelClass = null;
                        this.itemsPreview();
                        this.event(EventObject.LOADED);
                        return;
                    }
                    var instanceClassName = uiData.uiDisplayData.instanceClassName;
                    var classObj = window[instanceClassName];
                    if (!classObj)
                        classObj = window["GUI_" + v];
                    this._itemModelClass = classObj;
                    AssetManager.preLoadUIAsset(v, Callback.New(function () {
                        _this_1.event(EventObject.LOADED);
                    }, this), true, true);
                }
            },
            enumerable: false,
            configurable: true
        });
        UIList.prototype.checkDeepLoopAndReset = function (guiID) {
            if (!guiID)
                return false;
            if (Config.EDIT_MODE && this.isDeepLoop(guiID)) {
                gcide_canvasbuilder.AlertUtils.alert("[#GAME_LOOP_NESTING_IS_NOT_ALLOWED!]");
                var p = this.parent;
                while (p) {
                    if (p instanceof UIComponent.UIGUI) {
                        p.guiID = 0;
                    }
                    if (p instanceof UIList) {
                        p.itemModelGUI = 0;
                    }
                    p = p.parent;
                }
                this.itemModelGUI = 0;
                return true;
            }
            return false;
        };
        UIList.prototype.isDeepLoop = function (guiID) {
            if (!guiID)
                return false;
            var p = this.parent;
            while (p) {
                if (p instanceof UIComponent.UIGUI) {
                    if (p.guiID == guiID)
                        return true;
                }
                if (p instanceof UIList) {
                    if (p.itemModelGUI == guiID)
                        return true;
                }
                if (p instanceof UIComponent.UIRoot) {
                    if (p.guiID == guiID)
                        return true;
                }
                p = p.parent;
            }
            return false;
        };
        UIList.prototype.clearItems = function (dispose) {
            if (dispose === void 0) { dispose = false; }
            if (this.thisItemsOptimizationMode) {
                if (dispose) {
                    var allItemUIArr = this.optimizationItemUI.concat(this.optimizationItemUIPool);
                    for (var i_22 = 0; i_22 < allItemUIArr.length; i_22++) {
                        var itemUI = allItemUIArr[i_22];
                        itemUI.dispose();
                    }
                    this.optimizationItemUIPool.length = this.optimizationItemUI.length = 0;
                }
                else {
                    for (var i_23 = 0; i_23 < this.optimizationItemUI.length; i_23++) {
                        var itemUI = this.optimizationItemUI[i_23];
                        this.freeOptimizationItemUI(itemUI);
                    }
                    this.optimizationItemUI.length = 0;
                }
            }
            else {
                for (var i_24 = 0; i_24 < this._contentArea.numChildren; i_24++) {
                    var item = this._contentArea.getChildAt(i_24);
                    item.dispose();
                    i_24--;
                }
            }
        };
        Object.defineProperty(UIList.prototype, "items", {
            get: function () {
                return this._items;
            },
            set: function (v) {
                if (this.isDisposed)
                    return;
                var lastSelectedIndex = this.selectedIndex;
                this.clearItems();
                this._items = [];
                this.thisItemsOptimizationMode = this.optimizationMode;
                if (this.thisItemsOptimizationMode) {
                    this.off(UIComponent.UIRoot.SCROLL, this, this.onListScroll);
                    this.on(UIComponent.UIRoot.SCROLL, this, this.onListScroll);
                }
                if (Config.EDIT_MODE || this._itemModelClass) {
                    this.checkDeepLoopAndReset(this._itemModelGUI);
                    var len = v.length;
                    for (var i = 0, itemIndex = 0; i < len; i++) {
                        var node = v[i];
                        if (!node)
                            continue;
                        var nodeChildren = node.getList();
                        var childrenlen = nodeChildren.length;
                        for (var s = 0; s < childrenlen; s++) {
                            var data = nodeChildren[s];
                            this._items.push(data);
                            var ui = null;
                            if (Config.EDIT_MODE) {
                                ui = this._itemModelClass ? new this._itemModelClass(false, this._itemModelGUI) : GameUI.load(this.itemModelGUI, true);
                            }
                            else {
                                if (!this.thisItemsOptimizationMode) {
                                    ui = new this._itemModelClass(false, this._itemModelGUI);
                                }
                            }
                            if (ui) {
                                this._contentArea.addChild(ui);
                                this.itemInit(ui, data, itemIndex);
                            }
                            itemIndex++;
                        }
                    }
                    this.refreshOrder();
                }
                if (lastSelectedIndex >= this.length)
                    lastSelectedIndex = this.length - 1;
                this.selectedIndex = lastSelectedIndex;
                if (Config.EDIT_MODE) {
                    EUIRoot.dataBaseWindow.win7.off(EUIWindowUI.EVENT_GUI_DATA_SYNC_COMPLETE, this, this.onItemUIChange);
                    EUIRoot.dataBaseWindow.win7.on(EUIWindowUI.EVENT_GUI_DATA_SYNC_COMPLETE, this, this.onItemUIChange);
                }
            },
            enumerable: false,
            configurable: true
        });
        UIList.prototype.onItemUIChange = function (syncGUIID) {
            if (syncGUIID == this.itemModelGUI) {
                EUIRoot.dataBaseWindow.win7.off(EUIWindowUI.EVENT_GUI_DATA_SYNC_COMPLETE, this, this.onItemUIChange);
                this.items = this.items;
            }
        };
        UIList.prototype.replaceItem = function (itemData, index) {
            if (this.isDisposed)
                return;
            if (index < 0)
                return;
            var lastItemData = this._items[index];
            if (!lastItemData)
                return;
            var ui = this.getItemUI(index);
            if (this.thisItemsOptimizationMode) {
                itemData.x = lastItemData.x;
                itemData.y = lastItemData.y;
                var needReOrder = void 0;
                if (!itemData.customSize || itemData.width == null || itemData.height == null) {
                    itemData.width = lastItemData.width;
                    itemData.height = lastItemData.height;
                    needReOrder = false;
                }
                else {
                    needReOrder = true;
                }
                this._items[index] = itemData;
                if (ui) {
                    this.itemInit(ui, itemData, index, false);
                }
                if (needReOrder)
                    this.refreshOrder();
            }
            else {
                if (!ui)
                    return;
                this._items[index] = itemData;
                ui.offAll();
                this.itemInit(ui, itemData, index);
            }
        };
        UIList.prototype.addItem = function (itemData, index) {
            if (index === void 0) { index = -1; }
            var data = itemData;
            var itemIndex = index == -1 ? this._items.length : Math.max(0, Math.min(index, this._items.length));
            this._items.splice(itemIndex, 0, data);
            if (this.thisItemsOptimizationMode) {
                this.clearItems();
                this.refreshOrder();
                return this.getItemUI(index);
            }
            else {
                var ui = new this._itemModelClass(false, this._itemModelGUI);
                this._contentArea.addChildAt(ui, itemIndex);
                this.itemInit(ui, data, itemIndex);
                this.refreshOrder();
            }
            return ui;
        };
        UIList.prototype.removeItem = function (itemData) {
            var itemIndex = this.items.indexOf(itemData);
            this.removeItemByIndex(itemIndex);
            return itemIndex;
        };
        UIList.prototype.removeItemByIndex = function (index) {
            if (index < 0 || index >= this.items.length)
                return;
            var d = this._items[index];
            var itemUI = this.getItemUI(index);
            this._items.splice(index, 1);
            if (this.thisItemsOptimizationMode) {
                this.clearItems();
            }
            else {
                itemUI.dispose();
            }
            this.refreshOrder();
            return d;
        };
        UIList.prototype.setItemIndex = function (itemData, toIndex) {
            var itemIndex = this.items.indexOf(itemData);
            return this.setItemIndexByIndex(itemIndex, toIndex);
        };
        UIList.prototype.setItemIndexByIndex = function (itemIndex, toIndex) {
            if (itemIndex < 0 || itemIndex >= this.items.length)
                return;
            var ui = this.getItemUI(itemIndex);
            var data = this.items[itemIndex];
            ArrayUtils.setIndex(this.items, data, toIndex);
            if (this.thisItemsOptimizationMode) {
                this.clearItems();
            }
            else {
                this._contentArea.setChildIndex(ui, toIndex);
            }
            this.refreshOrder();
            return true;
        };
        UIList.prototype.getItemUI = function (index) {
            if (this.thisItemsOptimizationMode) {
                return this.optimizationItemUIMap[index];
            }
            else {
                if (index < 0 || index >= this._contentArea.numChildren)
                    return null;
                return this._contentArea.getChildAt(index);
            }
        };
        UIList.prototype.itemInit = function (ui, data, index, isNewItemUI) {
            if (isNewItemUI === void 0) { isNewItemUI = true; }
            if (!ui)
                return;
            ui.data = data;
            if (this.thisItemsOptimizationMode) {
                ui.hitArea = new Rectangle(0, 0, data.width, data.height);
            }
            else {
                ui.hitArea = new Rectangle(0, 0, this.itemWidth, this.itemHeight);
            }
            var enent = EventObject.MOUSE_DOWN;
            if (os.platform == 4 || os.platform == 3) {
                enent = EventObject.MOUSE_UP;
            }
            ui.off(EventObject.MOUSE_OVER, this, this.onItemUIMouseOver);
            ui.on(EventObject.MOUSE_OVER, this, this.onItemUIMouseOver, [index, ui, data]);
            ui.off(EventObject.MOUSE_OUT, this, this.onItemUIMouseOver);
            ui.on(EventObject.MOUSE_OUT, this, this.onItemUIMouseOut, [ui]);
            ui.off(enent, this, this.onItemUIMouseDown);
            ui.on(enent, this, this.onItemUIMouseDown, [ui, data, index]);
            ui.off(EventObject.DOUBLE_CLICK, this, this.onItemUIDoubleClick);
            ui.on(EventObject.DOUBLE_CLICK, this, this.onItemUIDoubleClick, [ui, data, index]);
            this.refreshItem(ui, data, isNewItemUI);
            this.event(UIList.ITEM_CREATE, [ui, data, index]);
            this.onCreateItem && this.onCreateItem.runWith([ui, data, index, isNewItemUI]);
        };
        UIList.prototype.onItemUIMouseOver = function (index, ui, data) {
            index = this.items.indexOf(data);
            if (this.overSelectMode) {
                this.selectedIndex = index;
            }
            if (!this.overSelectMode || this.overIndex != index) {
                this._overItem = ui;
                this.overIndex = index;
            }
        };
        UIList.prototype.onItemUIMouseOut = function (ui) {
            this._overItem = null;
            this.overIndex = -1;
        };
        UIList.prototype.onItemUIMouseDown = function (ui, data, index) {
            if (this.selectedItem == data) {
                this.event(UIList.ITEM_CLICK);
                return;
            }
            this.selectedItem = data;
            if (!UIList.SINGLE_FOCUS_MODE)
                UIList.focus = this;
        };
        UIList.prototype.onItemUIDoubleClick = function (ui, data, index) {
            if (!data || data.numChildren == 0)
                return;
            index = this.items.indexOf(data);
            data.isOpen = !data.isOpen;
            this.refreshOrder();
            this.event(UIList.OPEN_STATE_CHANGE, [ui, data, index]);
        };
        UIList.prototype.refreshItem = function (ui, item, isNewItemUI) {
            if (isNewItemUI === void 0) { isNewItemUI = true; }
            var uiNames = item.uiNames;
            for (var i = 0; i < uiNames.length; i++) {
                var attrName = uiNames[i];
                var comp = ui[attrName];
                var value = item[attrName];
                if (comp && comp instanceof UIComponent.UIBase && value != null) {
                    switch (comp.className) {
                        case "UIBitmap":
                            comp.image = value;
                            break;
                        case "UIString":
                            comp.text = value;
                            break;
                        case "UIVariable":
                            comp.varID = value;
                            break;
                        case "UIAvatar":
                            comp.avatarID = value;
                            break;
                        case "UIStandAvatar":
                            comp.avatarID = value;
                            break;
                        case "UIAnimation":
                            comp.animationID = value;
                            break;
                        case "UIInput":
                            comp.text = value;
                            break;
                        case "UICheckBox":
                            comp.selected = value;
                            break;
                        case "UISwitch":
                            comp.switchID = value;
                            break;
                        case "UITabBox":
                            comp.items = value;
                            break;
                        case "UISlider":
                            comp.value = value;
                            break;
                        case "UIGUI":
                            comp.guiID = value;
                            break;
                        case "UIList":
                            comp.items = value;
                            break;
                    }
                }
            }
        };
        Object.defineProperty(UIList.prototype, "length", {
            get: function () { return this._items.length; },
            enumerable: false,
            configurable: true
        });
        ;
        Object.defineProperty(UIList.prototype, "selectedItem", {
            get: function () {
                return this._selectedItem;
            },
            set: function (v) {
                var idx = this._items.indexOf(v);
                this._selectedItem = idx != -1 ? v : null;
                this.selectedIndex = idx;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "selectedIndex", {
            get: function () {
                return this._selectedIndex;
            },
            set: function (v) {
                var newSelectedItem = v < 0 ? null : this._items[v];
                if (this._selectedIndex != v || this._selectedItem != newSelectedItem) {
                    this._selectedIndex = v;
                    this._selectedItem = newSelectedItem;
                    if (this.overSelectMode) {
                        this._overItem = this.getItemUI(v);
                        this.overIndex = v;
                    }
                    this.refreshSelectedImagePos();
                    if (!this.__forceChange)
                        this.event(EventObject.CHANGE, [0]);
                }
            },
            enumerable: false,
            configurable: true
        });
        UIList.prototype.setSelectedIndexForce = function (v) {
            this.__forceChange = true;
            this.selectedIndex = v;
            this.__forceChange = false;
        };
        Object.defineProperty(UIList.prototype, "overIndex", {
            get: function () {
                return this._overIndex;
            },
            set: function (v) {
                if (this._overIndex != v) {
                    this._overIndex = v;
                    if (this._overIndex < 0 || this._overIndex >= this.items.length) {
                        this._overItem = null;
                    }
                    else {
                        this._overItem = this.getItemUI(this._overIndex);
                    }
                    this.refreshOverImagePos();
                    if (!this.__forceChange)
                        this.event(EventObject.CHANGE, [1]);
                }
            },
            enumerable: false,
            configurable: true
        });
        UIList.prototype.setOverIndexForce = function (v) {
            this.__forceChange = true;
            this.overIndex = v;
            this.__forceChange = false;
        };
        UIList.prototype.refreshSelectedImagePos = function () {
            var ui = this.getItemUI(this.selectedIndex);
            if (!ui) {
                this._selectedImageBox.visible = false;
                return;
            }
            this._selectedImageBox.visible = ui.visible;
            this._selectedImageBox.x = ui.x;
            this._selectedImageBox.y = ui.y;
        };
        UIList.prototype.refreshOverImagePos = function () {
            var ui = this.getItemUI(this.overIndex);
            if (!ui) {
                this._overImageBox.visible = false;
                return;
            }
            this._overImageBox.visible = ui.visible;
            this._overImageBox.x = ui.x;
            this._overImageBox.y = ui.y;
        };
        UIList.prototype.refreshOrder = function () {
            if (this.thisItemsOptimizationMode) {
                this.refreshOrderOptimizationMode();
            }
            else {
                this.refreshOrderAll();
            }
        };
        UIList.prototype.refreshOrderAll = function () {
            var len = this._contentArea.numChildren;
            this._itemSize = 0;
            var eX = 0, eY = 0;
            var currentYIndex = 0;
            var maxEx = 0;
            var maxEy = 0;
            for (var i = 0, s = 0; i < len; i++) {
                var ui = this._contentArea.getChildAt(i);
                var data = ui.data;
                if (data.isHideNode) {
                    ui.visible = false;
                    continue;
                }
                this._itemSize++;
                ui.visible = true;
                var xIndex = (s % this.repeatX);
                var yIndex = Math.floor(s / this.repeatX);
                if (currentYIndex != yIndex) {
                    maxEy += eY;
                    eX = eY = 0;
                    currentYIndex = yIndex;
                }
                ui.x = xIndex * (this._itemWidth + this._spaceX) + data.depth * this.subitemIndentation + eX;
                ui.y = yIndex * (this._itemHeight + this._spaceY) + maxEy;
                if (data.customSize) {
                    eX += (data.width - this._itemWidth);
                    if (maxEx < eX)
                        maxEx = eX;
                    var _eY = data.height - this._itemHeight;
                    if (_eY > eY)
                        eY = _eY;
                }
                s++;
            }
            this.maxEx = maxEx;
            this.maxEy = maxEy;
            this._overImageBox.visible = s > 0 && this.selectEnable;
            this._contentArea.width = (this._itemWidth * this.repeatX) + (this._spaceX * this.repeatX - 1) + maxEx;
            this._contentArea.height = Math.ceil(len / this.repeatX) * this._itemHeight + Math.max(0, Math.ceil(len / this.repeatX) - 1) * this._spaceY + maxEy;
            this._overImage.width = this._itemWidth;
            this._overImage.height = this._itemHeight;
            if (this._overItem) {
                this._overImageBox.x = this._overItem.x;
                this._overImageBox.y = this._overItem.y;
            }
            this._selectedImage.width = this._itemWidth;
            this._selectedImage.height = this._itemHeight;
            this.refreshSelectedImagePos();
            this.refresh();
        };
        UIList.prototype.refreshOrderOptimizationMode = function () {
            var len = this._items.length;
            this._itemSize = 0;
            var eX = 0, eY = 0;
            var currentYIndex = 0;
            var maxEx = 0;
            var maxEy = 0;
            for (var i = 0, s = 0; i < len; i++) {
                var data = this._items[i];
                if (data.isHideNode) {
                    continue;
                }
                this._itemSize++;
                var xIndex = (s % this.repeatX);
                var yIndex = Math.floor(s / this.repeatX);
                if (currentYIndex != yIndex) {
                    maxEy += eY;
                    eX = eY = 0;
                    currentYIndex = yIndex;
                }
                data.x = xIndex * (this._itemWidth + this._spaceX) + data.depth * this.subitemIndentation + eX;
                data.y = yIndex * (this._itemHeight + this._spaceY) + maxEy;
                if (!data.customSize) {
                    data.width = this.itemWidth;
                    data.height = this.itemHeight;
                }
                else {
                    eX += (data.width - this._itemWidth);
                    if (maxEx < eX)
                        maxEx = eX;
                    var _eY = data.height - this._itemHeight;
                    if (_eY > eY)
                        eY = _eY;
                }
                s++;
            }
            this.maxEx = maxEx;
            this.maxEy = maxEy;
            this._overImageBox.visible = s > 0 && this.selectEnable;
            this._contentArea.width = (this._itemWidth * this.repeatX) + (this._spaceX * this.repeatX - 1) + maxEx;
            this._contentArea.height = Math.ceil(len / this.repeatX) * this._itemHeight + Math.max(0, Math.ceil(len / this.repeatX) - 1) * this._spaceY + maxEy;
            this._overImage.width = this._itemWidth;
            this._overImage.height = this._itemHeight;
            if (this._overItem) {
                this._overImageBox.x = this._overItem.x;
                this._overImageBox.y = this._overItem.y;
            }
            this._selectedImage.width = this._itemWidth;
            this._selectedImage.height = this._itemHeight;
            this.refreshSelectedImagePos();
            this.refresh();
            this.refreshOptimizationModeItemUI();
        };
        UIList.prototype.refreshOptimizationModeItemUI = function () {
            var listRect = this.scrollRect;
            var len = this._items.length;
            this._itemSize = 0;
            var showOptimizationItemUIArr = [];
            var showOptimizationItemUIMap = {};
            var lastOptimizationItemUIMap = {};
            for (var i = 0, s = 0; i < len; i++) {
                var data = this._items[i];
                if (data.isHideNode) {
                    continue;
                }
                this._itemSize++;
                var itemRect = new Rectangle(data.x, data.y, data.width, data.height);
                var dataVisible = listRect.intersects(itemRect);
                data.visible = dataVisible;
                if (dataVisible) {
                    var globalIndex = this._itemSize - 1;
                    showOptimizationItemUIArr.push({ globalIndex: globalIndex, localIndex: s, data: data });
                    showOptimizationItemUIMap[globalIndex] = true;
                    s++;
                }
            }
            for (var i_25 = 0; i_25 < this.optimizationItemUI.length; i_25++) {
                var itemUI = this.optimizationItemUI[i_25];
                if (!showOptimizationItemUIMap[itemUI.__listGlobalIndex]) {
                    this.freeOptimizationItemUI(itemUI);
                    this.optimizationItemUI.splice(i_25, 1);
                    i_25--;
                }
                else {
                    lastOptimizationItemUIMap[itemUI.__listGlobalIndex] = true;
                }
            }
            for (var i_26 = 0; i_26 < showOptimizationItemUIArr.length; i_26++) {
                var o = showOptimizationItemUIArr[i_26];
                if (lastOptimizationItemUIMap[o.globalIndex]) {
                    continue;
                }
                var newItemUI = this.createOptimizationItemUI(o.globalIndex, o.localIndex, o.data);
                this._contentArea.addChild(newItemUI);
                this.optimizationItemUI.push(newItemUI);
                this.optimizationItemUIMap[o.globalIndex] = newItemUI;
            }
        };
        UIList.prototype.freeOptimizationItemUI = function (itemUI) {
            delete this.optimizationItemUIMap[itemUI.__listGlobalIndex];
            itemUI.removeSelf();
            this.optimizationItemUIPool.push(itemUI);
        };
        UIList.prototype.createOptimizationItemUI = function (globalIndex, localIndex, data) {
            var ui;
            var isNewItemUI;
            if (this.optimizationItemUIPool.length > 0) {
                ui = this.optimizationItemUIPool.shift();
                isNewItemUI = false;
            }
            else {
                ui = new this._itemModelClass(false, this._itemModelGUI);
                isNewItemUI = true;
            }
            ui.__listGlobalIndex = globalIndex;
            ui.x = data.x;
            ui.y = data.y;
            this.itemInit(ui, data, globalIndex, isNewItemUI);
            return ui;
        };
        UIList.prototype.onListScroll = function () {
            this.refreshOptimizationModeItemUI();
        };
        Object.defineProperty(UIList.prototype, "onChangeFragEvent1", {
            get: function () {
                return this._onChangeFragEvent1;
            },
            set: function (v) {
                this._onChangeFragEvent1 = v;
                if (v) {
                    this.off(EventObject.CHANGE, this, this.onChange_private1);
                    this.on(EventObject.CHANGE, this, this.onChange_private1);
                }
                else {
                    this.off(EventObject.CHANGE, this, this.onChange_private1);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "onChangeFragEvent2", {
            get: function () {
                return this._onChangeFragEvent2;
            },
            set: function (v) {
                this._onChangeFragEvent2 = v;
                if (v) {
                    this.off(EventObject.CHANGE, this, this.onChange_private2);
                    this.on(EventObject.CHANGE, this, this.onChange_private2);
                }
                else {
                    this.off(EventObject.CHANGE, this, this.onChange_private2);
                }
            },
            enumerable: false,
            configurable: true
        });
        UIList.prototype.onChange_private1 = function (state) {
            if (Config.SINGLE_PLAYER_CORE) {
                if (this.guiRoot && !this.guiRoot.onlyForPreload) {
                    if (this._onChangeFragEvent1 && state == 0) {
                        CommandPage.startTriggerFragmentEvent(this._onChangeFragEvent1, Game.player.sceneObject, Game.player.sceneObject);
                    }
                }
            }
        };
        UIList.prototype.onChange_private2 = function (state) {
            if (Config.SINGLE_PLAYER_CORE) {
                if (this.guiRoot && !this.guiRoot.onlyForPreload) {
                    if (this._onChangeFragEvent1 && state == 1) {
                        CommandPage.startTriggerFragmentEvent(this._onChangeFragEvent2, Game.player.sceneObject, Game.player.sceneObject);
                    }
                }
            }
        };
        UIList.customCompFunctionNames = ["itemModelGUI", "previewSize", "selectEnable", "repeatX", "itemWidth", "itemHeight", "spaceX", "spaceY", "scrollShowType",
            "hScrollBar", "hScrollBg", "vScrollBar", "vScrollBg", "scrollWidth", "selectImageURL", "selectImageGrid9", "selectedImageAlpha", "selectedImageOnTop",
            "overImageURL", "overImageGrid9", "overImageAlpha", "overImageOnTop", "overSelectMode", "slowmotionType", "length", "selectedIndex", "overIndex", "subitemIndentation", "onChangeFragEvent1", "onChangeFragEvent2"];
        UIList.EVENT_FOCUS_CHANGE = "UIListEVENT_FOCUS_CHANGE";
        UIList.OPEN_STATE_CHANGE = "UIList_EVENT_OPEN_STATE_CHANGE";
        UIList.ITEM_CLICK = "UIListITEM_CLICK";
        UIList.ITEM_CREATE = "UIListITEM_CREATE";
        UIList.KEY_UP = [Keyboard.UP];
        UIList.KEY_DOWN = [Keyboard.DOWN];
        UIList.KEY_LEFT = [Keyboard.LEFT];
        UIList.KEY_RIGHT = [Keyboard.RIGHT];
        UIList.KEY_ENTER = [Keyboard.ENTER, Keyboard.SPACE];
        UIList.KEY_ESC = [Keyboard.ESCAPE];
        UIList.keyDownEnter = false;
        UIList.keyDownEsc = false;
        return UIList;
    }(UIComponent.UIRoot));
    UIComponent.UIList = UIList;
})(UIComponent || (UIComponent = {}));















(function (UIComponent) {
    var UIStandAvatar = (function (_super) {
        __extends(UIStandAvatar, _super);
        function UIStandAvatar() {
            var _this_1 = _super.call(this) || this;
            _this_1.className = "UIStandAvatar";
            return _this_1;
        }
        UIStandAvatar.prototype.loadAssetTest = function () {
            AssetManager.preLoadStandAvatarAsset(this.avatarID, Callback.New(function () {
                this.event(GameUI.EVENT_TEST_LOAD_CHILD_UI);
            }, this), this._syncLoadedEventWhenAssetExist, true);
        };
        UIStandAvatar.prototype.inEditorInit = function (avatarID) {
            var _this_1 = this;
            if (avatarID === void 0) { avatarID = 1; }
            this.width = 192;
            this.height = 192;
            if (!this.stage) {
                this.once(EventObject.DISPLAY, this, function () {
                    _this_1.avatarID = avatarID;
                });
            }
            else {
                this.avatarID = avatarID;
            }
            this.installDefaultValue();
        };
        UIStandAvatar.prototype.__init = function () {
            var _this_1 = this;
            this._avatar = new StandAvatar();
            if (Config.EDIT_MODE) {
                this._avatar.openAutoHitArea();
                this.mouseEnabled = true;
            }
            this.addChildAt(this._avatar, 0);
            this.avatar.on(Avatar.RENDER, this, this.refreshSize);
            this.avatar.on(EventObject.LOADED, this, function () {
                _this_1._oriMode = _this_1.avatar.oriMode;
                _this_1.refreshSize();
            });
        };
        Object.defineProperty(UIStandAvatar.prototype, "flip", {
            get: function () {
                return this.avatar.flip;
            },
            set: function (v) {
                if (v == this.flip)
                    return;
                this.avatar.flip = v;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UIStandAvatar.prototype, "avatarID", {
            get: function () {
                return this.avatar.id;
            },
            set: function (v) {
                if (this.isDisposed)
                    return;
                if (v == this.avatarID)
                    return;
                v = Math.floor(v);
                this.avatar.syncLoadWhenAssetExist = this.syncLoadedEventWhenAssetExist == null ? true : this.syncLoadedEventWhenAssetExist;
                if (Config.EDIT_MODE)
                    this.avatar.forceRender = this.avatar.syncLoadWhenAssetExist;
                this.avatar.id = v;
            },
            enumerable: false,
            configurable: true
        });
        UIStandAvatar.customCompFunctionNames = ["avatarID", "actionID", "scaleNumberX", "scaleNumberY", "flip", "playOnce", "isPlay", "avatarFrame", "avatarFPS", "avatarHue"];
        return UIStandAvatar;
    }(UIComponent.UIAvatar));
    UIComponent.UIStandAvatar = UIStandAvatar;
})(UIComponent || (UIComponent = {}));















var AnimationAnimationLayer = (function (_super) {
    __extends(AnimationAnimationLayer, _super);
    function AnimationAnimationLayer() {
        var _this_1 = _super !== null && _super.apply(this, arguments) || this;
        _this_1.type = AnimationItemType.GCAnimation;
        _this_1.loop = false;
        return _this_1;
    }
    Object.defineProperty(AnimationAnimationLayer.prototype, "animationId", {
        get: function () { return this._animationId; },
        set: function (v) {
            if (this._animationId == v)
                return;
            this._animationId = v;
            if (this._animationInstance)
                this._animationInstance.dispose();
            this._animationInstance = null;
            this._animationInstance = new GCAnimation();
            this._animationInstance.topAnimation = this.topAnimation;
            if (this.topAnimation)
                this._animationInstance.syncLoadWhenAssetExist = this.topAnimation.syncLoadWhenAssetExist;
            this._animationInstance.prerender = this.topAnimation.prerender;
            this._animationInstance.layerAnimationSign = true;
            this._animationInstance.once(EventObject.LOADED, this, this.onAnimationLoaded);
            this._animationInstance.id = v;
            this.addChildAt(this._animationInstance, 0);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimationAnimationLayer.prototype, "animationInstance", {
        get: function () { return this._animationInstance; },
        enumerable: false,
        configurable: true
    });
    AnimationAnimationLayer.prototype.onAnimationLoaded = function () {
        if (this._animationInstance.isParticle) {
            this.setBounds(new Rectangle(-96, -133, 192, 192));
            this.hitArea = new Rectangle(-96, -133, 192, 192);
        }
        else {
            if (this._isOpenAutoHitArea) {
                this.openAutoHitArea();
            }
        }
        this.event(EventObject.LOADED);
        this.updateFrame();
    };
    AnimationAnimationLayer.prototype.setData = function (data) {
        _super.prototype.setData.call(this, data);
        this.animationId = data.animationId;
        this.loop = data.loop;
    };
    AnimationAnimationLayer.prototype.openAutoHitArea = function (force) {
        if (force === void 0) { force = false; }
        _super.prototype.openAutoHitArea.call(this, force);
        if (!this._animationInstance || this._animationInstance.isParticle)
            return false;
        this.mouseEnabled = true;
        if (this._animationInstance.isLoading) {
            this._animationInstance.mouseEnabled = true;
            this._animationInstance.once(EventObject.LOADED, this._animationInstance, this._animationInstance.openAutoHitArea);
        }
        else {
            this._animationInstance.mouseEnabled = true;
            this._animationInstance.openAutoHitArea(this._openAutoHitAreaForce);
        }
        return true;
    };
    AnimationAnimationLayer.prototype.closeAutoHitArea = function (force) {
        if (force === void 0) { force = false; }
        var isClosed = _super.prototype.closeAutoHitArea.call(this, force);
        if (!isClosed)
            return false;
        this.mouseEnabled = false;
        if (this._animationInstance.isLoading) {
            this._animationInstance.mouseEnabled = false;
            this._animationInstance.once(EventObject.LOADED, this._animationInstance, this._animationInstance.closeAutoHitArea);
        }
        else {
            this._animationInstance.mouseEnabled = false;
            this._animationInstance.closeAutoHitArea();
        }
        return true;
    };
    AnimationAnimationLayer.prototype.toAnimationLayerData = function () {
        var data = _super.prototype.toAnimationLayerData.call(this);
        data.loop = this.loop;
        data.animationId = this.animationId;
        return data;
    };
    AnimationAnimationLayer.prototype.fromAnimationFrameData = function (framedata) {
        _super.prototype.fromAnimationFrameData.call(this, framedata);
        if (!framedata)
            return;
        if (framedata.scaleX == undefined)
            framedata.scaleX = 1;
        if (framedata.scaleY == undefined)
            framedata.scaleY = 1;
        this.scaleX = framedata.scaleX;
        this.scaleY = framedata.scaleY;
        if (!this.animation)
            return;
        if (!this._animationInstance)
            return;
        this._animationInstance.visible = false;
        if (!this._animationInstance.isParticle && this._isOpenAutoHitArea) {
            this.hitArea = this.getBounds();
        }
        var len = this.frames ? this.frames.length : 0;
        var totalFrame = this.animation.totalFrame ? this.animation.totalFrame : 0;
        if (len == 0 || totalFrame == 0) {
            this._animationInstance.stop();
            return;
        }
        var firstFrame = this.frames[0].index;
        var lastFrame = 0;
        if (this.loop || len == 1) {
            lastFrame = totalFrame - 1;
        }
        else if (len >= 2) {
            lastFrame = this.frames[len - 1].index;
        }
        if (this._frameIndex >= firstFrame && this._frameIndex <= lastFrame) {
            this._animationInstance.visible = this._animationInstance.showOnEditor;
            if (!this._animationInstance.isParticle) {
                this._animationInstance["_isPlaying"] = this.animation["_isPlaying"];
                var subFrame = this._frameIndex - firstFrame;
                if (this.loop)
                    subFrame = subFrame % this._animationInstance.totalFrame;
                GCAnimation.getChildrenLayers(this._animationInstance).forEach(function (layer) {
                    layer.showFrame(subFrame);
                });
            }
            else {
                this._animationInstance.play();
            }
        }
        else {
            this._animationInstance.stop();
        }
    };
    AnimationAnimationLayer.prototype.showFrame = function (frameIndex) {
        _super.prototype.showFrame.call(this, frameIndex);
        this.setOffset();
    };
    AnimationAnimationLayer.prototype.toAnimationFrameData = function (framedata) {
        framedata = _super.prototype.toAnimationFrameData.call(this, framedata);
        framedata.scaleX = this.scaleX;
        framedata.scaleY = this.scaleY;
        return framedata;
    };
    AnimationAnimationLayer.prototype.interpolationFrame = function (pf, nf, frameIndex) {
        var frame = _super.prototype.interpolationFrame.call(this, pf, nf, frameIndex);
        if (pf.scaleX == undefined)
            pf.scaleX = 1;
        if (pf.scaleY == undefined)
            pf.scaleY = 1;
        var t = (frameIndex - pf.index) / (nf.index - pf.index);
        if (nf.trans != null) {
            var value = GameUtils.getValueByTransData(nf.trans, t);
            frame.scaleX = (nf.scaleX - pf.scaleX) * value + pf.scaleX;
            frame.scaleY = (nf.scaleY - pf.scaleY) * value + pf.scaleY;
        }
        else {
            var tween = GameUtils.getTween(nf.tweenID)[0];
            frame.scaleX = tween(t, pf.scaleX, nf.scaleX - pf.scaleX, 1);
            frame.scaleY = tween(t, pf.scaleY, nf.scaleY - pf.scaleY, 1);
        }
        return frame;
    };
    AnimationAnimationLayer.prototype.dispose = function () {
        if (this._animationInstance)
            this._animationInstance.dispose();
        this._animationInstance = null;
        _super.prototype.dispose.call(this);
    };
    return AnimationAnimationLayer;
}(AnimationDisplayLayer));
AnimationLayer.typeClsMap[AnimationItemType.GCAnimation] = AnimationAnimationLayer;
var SinglePlayerGame = (function () {
    function SinglePlayerGame() {
    }
    SinglePlayerGame.init = function (onFin) {
        var _this_1 = this;
        document.ondrop = function (e) {
            e = e || window.event;
            if (e.preventDefault)
                e.preventDefault();
            e.returnValue = false;
            return false;
        };
        document.ondragover = function (e) {
            e = e || window.event;
            if (e.preventDefault)
                e.preventDefault();
            e.returnValue = false;
            return false;
        };
        SinglePlayerGame.GC_LIFE_DATA_PATH = SinglePlayerGame.toWebSaveFileURL("savedata/life.gcdata");
        SinglePlayerGame.GC_LIFE_DATA_PATH_BAK = SinglePlayerGame.toWebSaveFileURL("savedata/life.gcdatabak");
        Command.prototype.callExecuteFunction = function (triggerLineID, player, params, gameFunc) {
            if (gameFunc === void 0) { gameFunc = null; }
            var p = gameFunc ? [gameFunc].concat(params) : params;
            var args = ObjectUtils.depthClone([triggerLineID, [this.type].concat(p)]);
            GameCommand.rpcCall.apply(GameCommand, args);
        };
        Player.prototype.toScene = function (sceneID, x, y, ori) {
            var _this_1 = this;
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (ori === void 0) { ori = 0; }
            GameCommand.banSceneObjectEvent = true;
            var crossTriggerLines = ArrayUtils.matchAttributes(Game.player.sceneObject.triggerLines, { trigger: Game.player.sceneObject, executor: Game.player.sceneObject }, false);
            crossTriggerLines = ArrayUtils.matchAttributes(crossTriggerLines, { mainType: CommandTrigger.COMMAND_MAIN_TYPE_SCENE }, false, "!=");
            crossTriggerLines = ArrayUtils.matchAttributes(crossTriggerLines, { mainType: CommandTrigger.COMMAND_MAIN_TYPE_SCENE_OBJECT }, false, "!=");
            for (var i in crossTriggerLines) {
                var crossTriggerLine = crossTriggerLines[i];
                crossTriggerLine.lock = true;
            }
            var lastScene = Game.currentScene;
            var lastPlayerSceneObject = Game.player.sceneObject;
            for (var i in Game.player.sceneObject.triggerSingleLines) {
                var myTrigger = Game.player.sceneObject.triggerSingleLines[i];
                if (myTrigger.mainType == CommandTrigger.COMMAND_MAIN_TYPE_SCENE || myTrigger.trigger != Game.player.sceneObject || myTrigger.executor != Game.player.sceneObject) {
                    EventUtils.happen(myTrigger, CommandTrigger.EVENT_OVER);
                    myTrigger.dispose();
                    delete Game.player.sceneObject.triggerSingleLines[i];
                }
            }
            for (var i in Game.player.sceneObject.triggerLines) {
                var myTrigger = Game.player.sceneObject.triggerLines[i];
                if (myTrigger.mainType == CommandTrigger.COMMAND_MAIN_TYPE_SCENE || myTrigger.trigger != Game.player.sceneObject || myTrigger.executor != Game.player.sceneObject) {
                    if (!myTrigger.isDisposed)
                        EventUtils.happen(myTrigger, CommandTrigger.EVENT_OVER);
                    myTrigger.dispose();
                }
            }
            Game.player.sceneObject.triggerLines = {};
            var checkChangeScene = function (lastScene, lastPlayerSceneObject) {
                if (Game.currentScene && lastScene != Game.currentScene) {
                    GameFunction.scene = Game.currentScene;
                    if (lastPlayerSceneObject != Game.player.sceneObject) {
                        for (var i in crossTriggerLines) {
                            var crossTriggerLine = crossTriggerLines[i];
                            crossTriggerLine.lock = false;
                            crossTriggerLine.trigger = Game.player.sceneObject;
                            crossTriggerLine.executor = Game.player.sceneObject;
                            crossTriggerLine.scene = Game.currentScene;
                            Game.player.sceneObject.triggerLines[crossTriggerLine.id] = crossTriggerLine;
                        }
                    }
                    else {
                        Game.player.sceneObject.x = x;
                        Game.player.sceneObject.y = y;
                        if (ori) {
                            var __ori = [2, 4, 8, 6, 1, 3, 7, 9], _ori = 0;
                            if (ori < 9)
                                _ori = __ori[ori - 1];
                            else
                                _ori = __ori[Math.floor(Math.random() * 8)];
                            Game.player.sceneObject.avatarOri = _ori;
                        }
                        for (var i in crossTriggerLines) {
                            var crossTriggerLine = crossTriggerLines[i];
                            crossTriggerLine.lock = false;
                            crossTriggerLine.scene = Game.currentScene;
                            Game.player.sceneObject.triggerLines[crossTriggerLine.id] = crossTriggerLine;
                        }
                    }
                    GameCommand.banSceneObjectEvent = false;
                }
                else {
                    Callback.CallLaterBeforeRender(checkChangeScene, _this_1, [lastScene, lastPlayerSceneObject]);
                }
            };
            Callback.CallLaterBeforeRender(checkChangeScene, this, [lastScene, lastPlayerSceneObject]);
            SinglePlayerGame.recordSceneObjectSwitch();
            EventUtils.happen(this.sceneObject, Command.EVENT_SYSTEM_COMMAND_START, [2]);
            Game.player.sceneObject.syncAvatarStateToSceneObject();
            ObjectUtils.cloneExcludeNonExistentAttribute(Game.player.sceneObject, Game.player.data.sceneObject);
            Game.player.data.sceneObject.x = x;
            Game.player.data.sceneObject.y = y;
            EventUtils.happen(ClientScene, ClientScene.EVENT_IN_NEW_SCENE, [sceneID, 0]);
        };
        var ClientSceneObjectInit = ClientSceneObject.prototype["____beforeInstallAttributeInit"];
        ClientSceneObject.prototype["____beforeInstallAttributeInit"] = function () {
            this.switchs = [0, 0, 0, 0, 0, 0, 0];
            this.triggerLines = {};
            this.triggerSingleLines = {};
            this.customCommandPages = [];
            ClientSceneObjectInit.apply(this);
        };
        Game.currentScene = ClientScene.EMPTY = new ClientScene;
        Game.player.sceneObject = new ClientSceneObject(new SceneObject, Game.currentScene);
        Game.player.sceneObject.player = Game.player;
        var uiParse = GameUI.parse;
        var uiCmdLoaded = [];
        var uiCommandParse = function (id) {
            if (!uiCmdLoaded[id]) {
                uiCmdLoaded[id] = true;
                var uiData = Game.data.uiList.data[id];
                if (uiData) {
                    for (var uicompID in uiData.uiCommandData) {
                        if (uicompID == "id" || uicompID == "data")
                            continue;
                        var uiCommandData = uiData.uiCommandData[uicompID];
                        var commandDatas = uiCommandData.commands;
                        var commands = ClientWorld.uiCustomCommandPages[id + "_" + uicompID] = [];
                        for (var s in commandDatas) {
                            var cmdData = commandDatas[s];
                            if (!cmdData || cmdData.length == 0)
                                continue;
                            commands[s] = new CommandPage(cmdData);
                        }
                    }
                }
            }
        };
        GameUI.parse = function (data, newID, childList, uiID, root, syncLoadedEventWhenAssetExist) {
            if (newID === void 0) { newID = false; }
            if (childList === void 0) { childList = null; }
            if (uiID === void 0) { uiID = null; }
            if (root === void 0) { root = null; }
            if (syncLoadedEventWhenAssetExist === void 0) { syncLoadedEventWhenAssetExist = false; }
            uiCommandParse(data.id);
            return uiParse.apply(GameUI, arguments);
        };
        ClientScene.prototype.createSceneLoadExt = function (onFin) {
            var scene = this;
            Game.data.loadScene(scene.id, Callback.New(function () {
                var sceneData = Game.data.sceneList.data[scene.id];
                if (sceneData) {
                    var sceneObjDatas = sceneData.sceneObjectData;
                    var customCommands = SinglePlayerGame.customCommandsCache[scene.id];
                    if (customCommands) {
                        scene.customCommandPages = customCommands;
                    }
                    else {
                        for (var s in sceneObjDatas.customCommands) {
                            var commands = sceneObjDatas.customCommands[s];
                            if (commands == null)
                                continue;
                            scene.customCommandPages[s] = new CommandPage(commands);
                        }
                    }
                }
                onFin.apply(scene);
            }, this));
        };
        AssetManager.preLoadSceneAssetExt = Callback.New(function (sceneID, onFin) {
            var loadSoTask = new AsynTask(Callback.New(function () {
                onFin();
            }, _this_1));
            Game.data.loadScene(sceneID, Callback.New(function () {
                var sceneData = Game.data.sceneList.data[sceneID];
                if (sceneData) {
                    var sceneObjDatas = sceneData.sceneObjectData;
                    if (sceneData.mapData.preloadSceneObjectAsset) {
                        var sceneObjects = sceneObjDatas.sceneObjects;
                        var len = sceneObjects.length;
                        for (var i = 0; i < len; i++) {
                            var soObj = sceneObjects[i];
                            if (!soObj || soObj.isBorn)
                                continue;
                            loadSoTask.execute(1);
                            AssetManager.preLoadSceneObjectAsset(soObj, Callback.New(loadSoTask.complete, loadSoTask));
                            var statusPages = sceneObjDatas.statusPages[i];
                            for (var s in statusPages) {
                                var stp = statusPages[s];
                                loadSoTask.execute(1);
                                AssetManager.preLoadSceneObjectAsset(stp.so, Callback.New(loadSoTask.complete, loadSoTask));
                            }
                        }
                    }
                    var customCommands = SinglePlayerGame.customCommandsCache[sceneID] = [];
                    for (var i = 0; i < sceneData.sceneObjectData.customCommands.length; i++) {
                        var commands = sceneObjDatas.customCommands[i];
                        if (commands == null)
                            continue;
                        var cmdPage = customCommands[i] = new CommandPage(commands);
                        if (sceneData.mapData.preloadSceneCommandAsset) {
                            loadSoTask.execute(1);
                            AssetManager.preLoadCommandPage(cmdPage, Callback.New(loadSoTask.complete, loadSoTask));
                        }
                    }
                }
                loadSoTask.execute(1);
                loadSoTask.complete();
            }, _this_1));
        }, this);
        AssetManager.disposeSceneAssetExt = Callback.New(function (sceneID) {
            Game.data.loadScene(sceneID, Callback.New(function () {
                var sceneData = Game.data.sceneList.data[sceneID];
                if (sceneData) {
                    var sceneObjDatas = sceneData.sceneObjectData;
                    var customCommands = SinglePlayerGame.customCommandsCache[sceneID];
                    if (sceneData.mapData.preloadSceneObjectAsset) {
                        var sceneObjects = sceneObjDatas.sceneObjects;
                        var len = sceneObjects.length;
                        for (var i = 0; i < len; i++) {
                            var soObj = sceneObjects[i];
                            if (!soObj || soObj.isBorn)
                                continue;
                            AssetManager.disposeSceneObject(soObj);
                            var statusPages = sceneObjDatas.statusPages[i];
                            for (var s in statusPages) {
                                var stp = statusPages[s];
                                AssetManager.disposeSceneObject(stp.so);
                            }
                        }
                    }
                    for (var i = 0; i < sceneData.sceneObjectData.customCommands.length; i++) {
                        var commands = sceneObjDatas.customCommands[i];
                        if (commands == null)
                            continue;
                        var cmdPage = customCommands[i];
                        if (sceneData.mapData.preloadSceneCommandAsset && cmdPage) {
                            AssetManager.disposeCommandPage(cmdPage);
                        }
                    }
                }
            }, _this_1));
        }, this);
        var oriAddSceneObject = ClientScene.prototype.addSceneObject;
        ClientScene.prototype.addSceneObject = function (soData, isSoc, useModelClass) {
            if (isSoc === void 0) { isSoc = false; }
            if (useModelClass === void 0) { useModelClass = false; }
            var scene = this;
            var inSceneSo = scene.sceneObjects[soData.index];
            if (inSceneSo && inSceneSo != soData) {
                soData.index = ArrayUtils.getNullPosition(scene.sceneObjects);
            }
            return oriAddSceneObject.apply(this, arguments);
        };
        var preloadScene = AssetManager.preLoadSceneAsset;
        AssetManager.preLoadSceneAsset = function (id, complete, syncCallbackWhenAssetExist, autoDispose) {
            if (complete === void 0) { complete = null; }
            if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
            if (autoDispose === void 0) { autoDispose = false; }
            Game.data.loadScene(id, Callback.New(preloadScene, AssetManager, [id, complete, syncCallbackWhenAssetExist, autoDispose]));
        };
        Game.player.variable["listener"] = Game.player;
        ClientPlayer.prototype["onVarChange"] = function (type, varID, value) {
            var typeEvent = ClientPlayer.getEventType(type, varID);
            Game.player["event"].event(typeEvent, [type, varID, value]);
        };
        var addListenerPlayerVariable = ClientPlayer.prototype.addListenerPlayerVariable;
        ClientPlayer.prototype.addListenerPlayerVariable = function (type, varID, onChange, isOnce, immediatelyCallback) {
            if (isOnce === void 0) { isOnce = false; }
            if (immediatelyCallback === void 0) { immediatelyCallback = true; }
            this.requestSyncPlayerVars[type][varID] = true;
            addListenerPlayerVariable.apply(this, arguments);
        };
        ClientWorld.variable["listener"] = ClientWorld;
        ClientWorld["onVarChange"] = function (type, varID, value) {
            EventUtils.happen(ClientWorld, "worldVar" + type + "_" + varID, [type, varID, value]);
        };
        var refreshDisappearStatus = SceneObjectEntity.prototype["refreshDisappearStatus"];
        SceneObjectEntity.prototype["refreshDisappearStatus"] = function () {
            if (!Game.currentScene || !this.statusPages)
                return;
            var so = this;
            var stateInfo = refreshDisappearStatus.apply(this, arguments);
            if (stateInfo.state == 1) {
                if (Game.currentScene.sceneObjects[so.index] == so) {
                    Game.currentScene.addSceneObject(so, true);
                }
            }
            else if (stateInfo.state == 2) {
                Game.currentScene.removeSceneObject(so, false);
            }
            if (stateInfo.changeStatusPage) {
                if (so.inScene)
                    so.refreshCommonDisplayList();
                if (so.scene) {
                    EventUtils.happen(SceneObjectEntity, SceneObjectEntity.EVENT_CHANGE_STATUS_PAGE, [this]);
                    EventUtils.happen(this, SceneObjectEntity.EVENT_CHANGE_STATUS_PAGE_FOR_INSTANCE, [this]);
                }
            }
            return stateInfo;
        };
        ClientSceneObject.prototype.setSwitchs = function (varID, value) {
            this.switchs[varID] = value;
            this.refreshDisappearStatus();
        };
        GameCommand.mustInScene = false;
        Command.init(ClientWorld);
        SinglePlayerGame.initMain(onloadDataOver);
        ClientMsgSender.requestTriggerEventSend = Callback.New(SinglePlayerGame.triggerEvent, SinglePlayerGame);
        GameDialog.delayCloseTime = 0;
        var task = new AsynTask(onFin);
        var onloadDataOver = Callback.New(task.complete, task, []);
        task.execute(SinglePlayerGame.initCommands(onloadDataOver));
        task.execute(SinglePlayerGame.loadLifeData(onloadDataOver));
    };
    SinglePlayerGame.saveLifeData = function (onFin, globalData, completeProcess, taskLock, ifNullGlobalDataSaveLastGlobalData, lifeDataStr) {
        var _this_1 = this;
        if (globalData === void 0) { globalData = null; }
        if (completeProcess === void 0) { completeProcess = true; }
        if (taskLock === void 0) { taskLock = true; }
        if (ifNullGlobalDataSaveLastGlobalData === void 0) { ifNullGlobalDataSaveLastGlobalData = false; }
        if (lifeDataStr === void 0) { lifeDataStr = null; }
        var saveLifeDataF = function () {
            var saveGameFin = Callback.New(function (success) {
                onFin && onFin.runWith([success]);
                if (taskLock)
                    SyncTask.taskOver(SinglePlayerGame.TASK_MODIFY_FILE);
            }, _this_1);
            if (!SinglePlayerGame.saveIDs) {
                Callback.CallLater(SinglePlayerGame.saveLifeData, SinglePlayerGame, [saveGameFin, globalData, completeProcess]);
                return;
            }
            var needBak = !os.inGC() && os.platform == 2 ? true : false;
            var GC_LIFE_DATA_PATH1 = needBak ? SinglePlayerGame.GC_LIFE_DATA_PATH_BAK : SinglePlayerGame.GC_LIFE_DATA_PATH;
            if (!lifeDataStr) {
                SinglePlayerGame.getSaveLifeData(function (_saveLiftDataStr) {
                    doSave(_saveLiftDataStr);
                }, GC_LIFE_DATA_PATH1, globalData, true);
            }
            else {
                doSave(lifeDataStr);
            }
            function doSave(lifeDataStr) {
                var _this_1 = this;
                FileUtils.save(lifeDataStr, GC_LIFE_DATA_PATH1, Callback.New(function (success) {
                    if (!success) {
                        saveGameFin.runWith([success]);
                        return;
                    }
                    if (!completeProcess || !needBak) {
                        saveGameFin.runWith([success]);
                    }
                    else {
                        FileUtils.cloneFile(SinglePlayerGame.GC_LIFE_DATA_PATH_BAK, SinglePlayerGame.GC_LIFE_DATA_PATH, Callback.New(function (success) {
                            if (!success) {
                                saveGameFin.runWith([success]);
                                return;
                            }
                            FileUtils.deleteFile(SinglePlayerGame.GC_LIFE_DATA_PATH_BAK, Callback.New(function (success) {
                                saveGameFin.runWith([success]);
                            }, _this_1));
                        }, _this_1));
                    }
                }, this), false, false, false, Config.RELEASE_GAME);
            }
        };
        if (taskLock) {
            new SyncTask(SinglePlayerGame.TASK_MODIFY_FILE, saveLifeDataF);
        }
        else {
            saveLifeDataF.apply(this);
        }
    };
    SinglePlayerGame.saveLifeData2_Cover = function (onFin) {
    };
    SinglePlayerGame.saveGlobalData = function (onFin, globalData) {
        if (globalData === void 0) { globalData = null; }
        SinglePlayerGame.saveLifeData(onFin, globalData);
    };
    SinglePlayerGame.loadLifeData = function (onFin) {
        var _this_1 = this;
        var url = SinglePlayerGame.GC_LIFE_DATA_PATH;
        SinglePlayerGame.loadSaveFile(SinglePlayerGame.GC_LIFE_DATA_PATH_BAK, Callback.New(function (data) {
            SinglePlayerGame.disposeSaveFile(SinglePlayerGame.GC_LIFE_DATA_PATH_BAK, true);
            if (data) {
                SinglePlayerGame.doLoadLifeData(data, onFin);
            }
            else {
                SinglePlayerGame.loadSaveFile(url, Callback.New(function (data) {
                    SinglePlayerGame.disposeSaveFile(url, true);
                    SinglePlayerGame.doLoadLifeData(data, onFin);
                }, _this_1), false, true, false);
            }
        }, this), false, true, false);
    };
    SinglePlayerGame.doLoadLifeData = function (data, onFin) {
        var _this_1 = this;
        if (data) {
            if (data.variable)
                ObjectUtils.clone(data.variable, ClientWorld.variable);
            if (data.saveIDs)
                SinglePlayerGame.saveIDs = data.saveIDs;
            var packageGlobalData = data.globalData;
            if (packageGlobalData && packageGlobalData.___useNewGlobalData) {
                SinglePlayerGame.globalData = packageGlobalData.___globalData;
                SinglePlayerGame.currentCustomGlobalData = packageGlobalData;
            }
            else {
                SinglePlayerGame.globalData = data.globalData;
            }
            if (FileUtils.hasFileOperationJurisdiction) {
                var newSaveIDsObj = {};
                if (!SinglePlayerGame.saveIDs)
                    SinglePlayerGame.saveIDs = [];
                FileUtils.getDirectoryListing("savedata", Callback.New(function (fos) {
                    if (!fos) {
                        SinglePlayerGame.saveIDs = [];
                        onFin.delayRun(0);
                        return;
                    }
                    var fosClone = fos.concat();
                    fosClone.sort(function (a, b) { return a.lastModifyDate.getTime() < a.lastModifyDate.getTime() ? -1 : 1; });
                    var syncTaskName = "doLoadLifeData";
                    var fileIDs = [];
                    for (var i = 0; i < fosClone.length; i++) {
                        var fo = fosClone[i];
                        if (fo.isDirectory)
                            continue;
                        var fileNameArr = fo.fileName.split(".");
                        var ext = fileNameArr.pop();
                        if (ext == "gcdatabak" || ext == "gcdata") {
                            var fileName = fileNameArr.join(".");
                            if (newSaveIDsObj[fileName])
                                continue;
                            newSaveIDsObj[fileName] = true;
                            var fileNmaeIDStr = fileName.replace("gamedata", "");
                            if (fileNmaeIDStr == "" || fileNmaeIDStr == "life")
                                continue;
                            var fileNameID = MathUtils.int(fileNmaeIDStr);
                            var m = ArrayUtils.matchAttributes(SinglePlayerGame.saveIDs, { id: fileNameID }, true)[0];
                            if (!m) {
                                new SyncTask(syncTaskName, function (fileNameID, localPath, lastModifyDate) {
                                    AssetManager.loadFileArrayBuffer(localPath, Callback.New(function (buffer) {
                                        ZipManager.zipDeCompress(buffer, function (text) {
                                            try {
                                                var jsonObj = JSON.parse(text);
                                                if (jsonObj) {
                                                    var indexInfo = jsonObj[15];
                                                    if (!indexInfo)
                                                        indexInfo = {};
                                                    var newSaveID = {
                                                        id: fileNameID,
                                                        indexInfo: indexInfo,
                                                        now: lastModifyDate.getTime()
                                                    };
                                                    SinglePlayerGame.saveIDs.push(newSaveID);
                                                }
                                                Callback.New(SyncTask.taskOver, SyncTask, [syncTaskName]).delayRun(0, setFrameout);
                                            }
                                            catch (e) {
                                                AssetManager.disposeFileArrayBuffer(localPath, true);
                                                FileUtils.loadJsonFile(localPath, Callback.New(function (fileNameID, lastModifyDate, jsonObj) {
                                                    if (jsonObj) {
                                                        var indexInfo = jsonObj[15];
                                                        if (!indexInfo)
                                                            indexInfo = {};
                                                        var newSaveID = {
                                                            id: fileNameID,
                                                            indexInfo: indexInfo,
                                                            now: lastModifyDate.getTime()
                                                        };
                                                        SinglePlayerGame.saveIDs.push(newSaveID);
                                                    }
                                                    Callback.New(SyncTask.taskOver, SyncTask, [syncTaskName]).delayRun(0, setFrameout);
                                                }, this, [fileNameID, lastModifyDate]));
                                            }
                                        }, Config.z1);
                                    }, _this_1), true, true);
                                }, [fileNameID, fo.localPath, fo.lastModifyDate]);
                            }
                            fileIDs.push(fileNameID);
                        }
                    }
                    new SyncTask(syncTaskName, function () {
                        for (var i = 0; i < SinglePlayerGame.saveIDs.length; i++) {
                            var saveIDInfo = SinglePlayerGame.saveIDs[i];
                            if (!saveIDInfo || fileIDs.indexOf(saveIDInfo.id) == -1) {
                                SinglePlayerGame.saveIDs.splice(i, 1);
                                i--;
                            }
                        }
                        onFin.delayRun(0);
                        SyncTask.taskOver(syncTaskName);
                    });
                }, this));
                return;
            }
            else if (!SinglePlayerGame.saveIDs) {
                SinglePlayerGame.saveIDs = [];
            }
        }
        else {
            SinglePlayerGame.saveIDs = [];
        }
        onFin.delayRun(0);
    };
    SinglePlayerGame.newGameInit = function (soData, x, y) {
        if (soData === void 0) { soData = null; }
        if (x === void 0) { x = null; }
        if (y === void 0) { y = null; }
        if (Game.player.uid == null)
            Game.player.uid = 0;
        if (soData)
            ObjectUtils.clone(soData, this);
        Player.installCustomData(Game.player);
        var so = Game.player.data.sceneObject = new SceneObject();
        ObjectUtils.clone(Config.BORN.so, so);
        if (x != null && y != null) {
            so.x = x;
            so.y = y;
        }
        SceneObject.installCustomData(so, Config.BORN.customAttribute, false);
        so.playerUID = Game.player.uid;
    };
    SinglePlayerGame.newGame = function () {
        var sceneTest = window.location.href.split("?scene=").pop();
        if (sceneTest) {
            var sceneInfo = sceneTest.split(",");
            if (sceneInfo.length == 4) {
                var rd = MathUtils.int(sceneInfo[3].substr(0, 4));
                var fpw = MathUtils.int(sceneInfo[3].substr(4));
                var tpw = MathUtils.int(new Date().getTime() * 2.5 + rd * 100000);
                var dt = MathUtils.int((tpw - fpw) / 1000);
                if (dt <= 60 * 60 * 24) {
                    var sceneID = MathUtils.int(sceneInfo[0]);
                    var x = MathUtils.int(sceneInfo[1]);
                    var y = MathUtils.int(sceneInfo[2]);
                    this.newGameInit(null, x, y);
                    EventUtils.happen(ClientScene, ClientScene.EVENT_IN_NEW_SCENE, [sceneID, 1]);
                    return;
                }
            }
        }
        this.newGameInit();
        EventUtils.happen(ClientScene, ClientScene.EVENT_IN_NEW_SCENE, [Config.BORN.sceneID, 1]);
    };
    SinglePlayerGame.saveGame = function (index, onFin, indexInfo, customData, globalData) {
        if (indexInfo === void 0) { indexInfo = null; }
        if (customData === void 0) { customData = null; }
        if (globalData === void 0) { globalData = null; }
        new SyncTask(SinglePlayerGame.TASK_MODIFY_FILE, function () {
            var _this_1 = this;
            var saveGameFin = Callback.New(function (success) {
                onFin && onFin.runWith([success]);
                SyncTask.taskOver(SinglePlayerGame.TASK_MODIFY_FILE);
            }, this);
            if (!Game.currentScene) {
                saveGameFin.runWith([false]);
                return;
            }
            var now = new Date().getTime();
            var needBak = !os.inGC() && os.platform == 2 ? true : false;
            var gameFile = SinglePlayerGame.toWebSaveFileURL("savedata/gamedata" + index + ".gcdata");
            var saveGameFilePath = needBak ? SinglePlayerGame.toWebSaveFileURL("savedata/gamedata" + index + ".gcdatabak") : gameFile;
            var GC_LIFE_DATA_PATH1 = needBak ? SinglePlayerGame.GC_LIFE_DATA_PATH_BAK : SinglePlayerGame.GC_LIFE_DATA_PATH;
            var getDataCount = 2;
            var saveDataStr;
            var saveLiftDataStr;
            var doSaveGame = function () {
                getDataCount--;
                if (getDataCount == 0) {
                    setFrameout(function () {
                        SinglePlayerGame.saveLifeData(Callback.New(function (success) {
                            if (!success) {
                                saveGameFin.runWith([false]);
                                return;
                            }
                            if (needBak) {
                                FileUtils.save(saveDataStr, saveGameFilePath, Callback.New(function () {
                                    FileUtils.cloneFile(SinglePlayerGame.GC_LIFE_DATA_PATH_BAK, SinglePlayerGame.GC_LIFE_DATA_PATH, Callback.New(function (success) {
                                        if (!success) {
                                            saveGameFin.runWith([success]);
                                            return;
                                        }
                                        FileUtils.cloneFile(saveGameFilePath, gameFile, Callback.New(function (success) {
                                            if (!success) {
                                                saveGameFin.runWith([success]);
                                                return;
                                            }
                                            FileUtils.deleteFile(SinglePlayerGame.GC_LIFE_DATA_PATH_BAK, Callback.New(function (success) {
                                                FileUtils.deleteFile(saveGameFilePath, Callback.New(function (success) {
                                                    saveGameFin.runWith([true]);
                                                }, _this_1));
                                            }, _this_1));
                                        }, _this_1));
                                    }, _this_1));
                                }, _this_1), true, false, false, Config.RELEASE_GAME);
                            }
                            else {
                                FileUtils.save(saveDataStr, gameFile, Callback.New(function (success, localURL) {
                                    saveGameFin.runWith([success]);
                                }, _this_1), true, false, false, Config.RELEASE_GAME);
                            }
                        }, _this_1), globalData, false, false, true, saveLiftDataStr);
                    }, 0);
                }
            };
            var idx = ArrayUtils.matchAttributes(SinglePlayerGame.saveIDs, { id: index }, true, "==", true)[0];
            if (idx == null) {
                SinglePlayerGame.saveIDs.push({ id: index, indexInfo: indexInfo, now: now });
            }
            else {
                SinglePlayerGame.saveIDs[idx] = { id: index, indexInfo: indexInfo, now: now };
            }
            SinglePlayerGame.getSaveData(function (_saveDataStr) {
                saveDataStr = _saveDataStr;
                doSaveGame();
            }, saveGameFilePath, index, now, indexInfo, customData);
            SinglePlayerGame.getSaveLifeData(function (_saveLiftDataStr) {
                saveLiftDataStr = _saveLiftDataStr;
                doSaveGame();
            }, GC_LIFE_DATA_PATH1, globalData, true);
        });
    };
    SinglePlayerGame.getSaveData = function (onFin, localURL, index, now, indexInfo, customData) {
        if (indexInfo === void 0) { indexInfo = null; }
        if (customData === void 0) { customData = null; }
        index = MathUtils.int(index);
        var needLoadUIs = [];
        var worldSaveData = SinglePlayerGame.getCustomAttributeData(Common.customWorldData, ClientWorld.data);
        var playerVarialbeData = Game.player.variable.getTransportableData();
        Game.player.sceneObject.syncAvatarStateToSceneObject();
        ObjectUtils.cloneExcludeNonExistentAttribute(Game.player.sceneObject, Game.player.data.sceneObject);
        var playerData = SinglePlayerGame.getCustomAttributeData(Common.customPlayerData, Game.player.data);
        playerData.sceneObject = Game.player.data.sceneObject;
        var playerSoModuleDatas = null;
        if (Config.useNewSceneObjectModel) {
            playerSoModuleDatas = SceneObjectEntity.getModulesSaveData(Game.player.sceneObject, false);
        }
        SinglePlayerGame.recordSceneObjectSwitch();
        var audioInfo = [GameAudio.lastBgmURL, GameAudio.lastBGMPitch, GameAudio.lastBGMVolume, GameAudio.lastBgsURL, GameAudio.lastBGSPitch, GameAudio.lastBGSVolume, GameAudio.bgmVolume, GameAudio.bgsVolume, GameAudio.seVolume, GameAudio.tsVolume];
        var sceneObjectData = SinglePlayerGame.getCurrentSceneObject();
        var triggerEventDatas = SinglePlayerGame.getTriggerEventSaveData();
        var triggerEventData = triggerEventDatas[0];
        needLoadUIs = needLoadUIs.concat(triggerEventDatas[1]);
        var gameCommandData = SinglePlayerGame.getGameCommandData();
        var sceneStatus = SinglePlayerGame.getSceneStatusData();
        var packageCustomData = {
            ___customData: customData,
            ___useNewCustomData: true
        };
        for (var i = 0; i < SinglePlayerGame.regSaveCustomDataCallbacks.length; i++) {
            var cbInfo = SinglePlayerGame.regSaveCustomDataCallbacks[i];
            packageCustomData[cbInfo.dataName] = cbInfo.dataFunction.run();
        }
        var saveData = [Game.getSaveData(), now, Game.currentScene.id, worldSaveData, playerVarialbeData, playerData, SinglePlayerGame.sceneDatas, audioInfo, triggerEventData, sceneObjectData, gameCommandData, sceneStatus, packageCustomData, needLoadUIs, playerSoModuleDatas, indexInfo, Game.now];
        if (SinglePlayerGame.syncSaveMode) {
            saveData = ObjectUtils.depthClone(saveData);
        }
        var indiaAppGameInfo = Config.INDIA_APPLICATION_GAME_INFO;
        if (indiaAppGameInfo) {
            ObjectUtils.jsonSerialize({ isJson: true, format: true, localURL: localURL, dataObject: saveData }, onFin, 3, !Config.EDIT_MODE);
        }
        else {
            ObjectUtils.jsonSerialize({ isJson: true, format: true, dataObject: saveData }, onFin, 3, !Config.EDIT_MODE);
        }
    };
    SinglePlayerGame.getSaveLifeData = function (onFin, localURL, globalData, ifNullGlobalDataSaveLastGlobalData) {
        if (globalData === void 0) { globalData = null; }
        var packageGlobalData = {
            ___globalData: globalData,
            ___useNewGlobalData: true
        };
        var currentCustomGlobalData = SinglePlayerGame.currentCustomGlobalData;
        if (!currentCustomGlobalData)
            currentCustomGlobalData = SinglePlayerGame.currentCustomGlobalData = {};
        for (var i = 0; i < SinglePlayerGame.regSaveCustomGlobalDataCallbacks.length; i++) {
            var cbInfo = SinglePlayerGame.regSaveCustomGlobalDataCallbacks[i];
            var value = cbInfo.globalDataFunction.run();
            packageGlobalData[cbInfo.globalDataName] = value;
            currentCustomGlobalData[cbInfo.globalDataName] = value;
        }
        globalData = packageGlobalData;
        var worldVarialbeData = ClientWorld.variable.getTransportableData();
        if (ifNullGlobalDataSaveLastGlobalData && packageGlobalData.___globalData == null) {
            packageGlobalData.___globalData = SinglePlayerGame.globalData;
        }
        var lifeData = { variable: worldVarialbeData, saveIDs: SinglePlayerGame.saveIDs, globalData: globalData };
        var indiaAppGameInfo = Config.INDIA_APPLICATION_GAME_INFO;
        if (indiaAppGameInfo) {
            ObjectUtils.jsonSerialize({ isJson: true, format: true, localURL: localURL, dataObject: lifeData }, onFin, 3, !Config.EDIT_MODE);
        }
        else {
            ObjectUtils.jsonSerialize({ isJson: true, format: true, dataObject: lifeData }, onFin, 3, !Config.EDIT_MODE);
        }
    };
    SinglePlayerGame.getCustomAttributeData = function (attributeSetting, target) {
        var data = {};
        var attrSettings = CustomCompositeSetting.getAllAttributes(attributeSetting, false);
        for (var s in attrSettings) {
            var attrSetting = attrSettings[s];
            if (attrSetting.onlyConfig || CustomAttributeSetting.ONLY_DISPLAY.indexOf(attrSetting.compData.compType) != -1)
                continue;
            var varName = attrSetting.varName;
            if (target[varName] != undefined)
                data[varName] = target[varName];
        }
        return data;
    };
    SinglePlayerGame.regSaveCustomData = function (dataName, dataFunction) {
        SinglePlayerGame.regSaveCustomDataCallbacks.push({ dataName: dataName, dataFunction: dataFunction });
    };
    SinglePlayerGame.regSaveCustomGlobalData = function (globalDataName, globalDataFunction) {
        SinglePlayerGame.regSaveCustomGlobalDataCallbacks.push({ globalDataName: globalDataName, globalDataFunction: globalDataFunction });
    };
    SinglePlayerGame.loadGame = function (index, onFin, onProgress) {
        var _this_1 = this;
        if (onProgress === void 0) { onProgress = null; }
        index = MathUtils.int(index);
        var m = ArrayUtils.matchAttributes(SinglePlayerGame.saveIDs, { id: index }, true);
        if (m.length != 1) {
            onFin.runWith([false]);
            return;
        }
        var url = SinglePlayerGame.toWebSaveFileURL("savedata/gamedata" + index + ".gcdata");
        var urlBAK = SinglePlayerGame.toWebSaveFileURL("savedata/gamedata" + index + ".gcdatabak");
        SinglePlayerGame.loadSaveFile(urlBAK, Callback.New(function (saveData) {
            SinglePlayerGame.disposeSaveFile(urlBAK, true);
            if (saveData) {
                SinglePlayerGame.doLoadGame(index, onFin, onProgress, saveData);
            }
            else {
                SinglePlayerGame.loadSaveFile(url, Callback.New(function (saveData) {
                    SinglePlayerGame.disposeSaveFile(url, true);
                    SinglePlayerGame.doLoadGame(index, onFin, onProgress, saveData);
                }, _this_1));
            }
        }, this), false, true, false);
    };
    SinglePlayerGame.getSaveCustomData = function (dataName) {
        return this.currentSaveFileCustomData ? this.currentSaveFileCustomData[dataName] : null;
    };
    SinglePlayerGame.getSaveCustomGlobalData = function (globalDataName) {
        var g = SinglePlayerGame.currentCustomGlobalData;
        return g ? g[globalDataName] : "";
    };
    SinglePlayerGame.toWebSaveFileURL = function (url) {
        if (os.platform == 2)
            return url;
        var locahostURL = window.location.href;
        var newHead;
        if (Config.INDIA_APPLICATION_GAME_INFO) {
            newHead = "";
        }
        else {
            var gcCloudHeadReg = /https{0,1}:\/\/(material|global)\.gamecreator\.com\.cn\//g;
            if (locahostURL.search(gcCloudHeadReg) == 0) {
                var projectSID = locahostURL.replace(gcCloudHeadReg, "").split("/")[1];
                if (projectSID && projectSID.search(/\d+_/g) != -1) {
                    newHead = projectSID + "/";
                }
                else {
                    newHead = locahostURL.split("?").shift() + "/" + (Config.gameSID ? Config.gameSID + "/" : "");
                }
            }
            else {
                newHead = locahostURL.split("?").shift() + "/" + (Config.gameSID ? Config.gameSID + "/" : "");
            }
        }
        if (url.indexOf(newHead) == 0) {
            return url;
        }
        return newHead + url;
    };
    SinglePlayerGame.loadSaveFile = function (url, complete, syncCallbackWhenAssetExist, useRef, onErrorTips) {
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (useRef === void 0) { useRef = true; }
        if (onErrorTips === void 0) { onErrorTips = true; }
        if (os.platform == 2) {
            AssetManager.loadFileArrayBuffer(url, Callback.New(function (buffer) {
                ZipManager.zipDeCompress(buffer, function (text) {
                    try {
                        var jsonObj = JSON.parse(text);
                        complete.runWith([jsonObj]);
                    }
                    catch (e) {
                        AssetManager.disposeFileArrayBuffer(url, true);
                        AssetManager.loadJson(url, complete, syncCallbackWhenAssetExist, useRef, onErrorTips);
                    }
                }, Config.z1);
            }, this), useRef, syncCallbackWhenAssetExist);
        }
        else {
            url = SinglePlayerGame.toWebSaveFileURL(url);
            var indiaAppGameInfo = Config.INDIA_APPLICATION_GAME_INFO;
            if (indiaAppGameInfo) {
                AssetManager.loadFileArrayBuffer(url, Callback.New(function (buffer) {
                    ZipManager.zipDeCompress(buffer, function (text) {
                        try {
                            var jsonObj = JSON.parse(text);
                            ObjectUtils.depthClone(jsonObj, !Config.EDIT_MODE, function (data) {
                                complete.runWith([data]);
                            });
                        }
                        catch (e) {
                            AssetManager.disposeFileArrayBuffer(url, true);
                            AssetManager.loadJson(url, Callback.New(function (jsonObj) {
                                ObjectUtils.depthClone(jsonObj, !Config.EDIT_MODE, function (data) {
                                    complete.runWith([data]);
                                });
                            }, this), syncCallbackWhenAssetExist, useRef, onErrorTips);
                        }
                    }, Config.z1);
                }, this), useRef, syncCallbackWhenAssetExist);
                return;
            }
            if (IndexedDBManager.support && IndexedDBManager.used) {
                IndexedDBManager.getIndexDB(url, function (value) {
                    ZipManager.zipDeCompressText(value, function (text) {
                        try {
                            var jsonObj = JSON.parse(text);
                            complete.delayRun(0, null, [jsonObj]);
                        }
                        catch (e) {
                            try {
                                complete.delayRun(0, null, [JSON.parse(value)]);
                            }
                            catch (e) {
                                complete.delayRun(0, null, [null]);
                            }
                        }
                    }, Config.z1);
                });
            }
            else {
                var dataString = LocalStorage.getItem(url);
                ZipManager.zipDeCompressText(dataString, function (text) {
                    try {
                        var jsonObj = JSON.parse(text);
                        complete.delayRun(0, null, [jsonObj]);
                    }
                    catch (e) {
                        try {
                            complete.delayRun(0, null, [JSON.parse(dataString)]);
                        }
                        catch (e) {
                            complete.delayRun(0, null, [null]);
                        }
                    }
                }, Config.z1);
            }
        }
    };
    SinglePlayerGame.disposeSaveFile = function (url, force) {
        if (force === void 0) { force = false; }
        if (os.platform == 2)
            AssetManager.disposeJson(url, force);
    };
    SinglePlayerGame.doLoadGame = function (index, onFin, onProgress, saveData) {
        var _this_1 = this;
        if (onProgress === void 0) { onProgress = null; }
        if (!saveData) {
            onFin.runWith([false]);
            return;
        }
        for (var i in Game.player.sceneObject.triggerLines) {
            var t = Game.player.sceneObject.triggerLines[i];
            t.dispose();
        }
        Game.player.sceneObject.triggerLines = {};
        Game.player.sceneObject.triggerSingleLines = {};
        GameCommand.inputTriggerLine = -1;
        GameCommand.cmdTriggerLines = {};
        if (Game.currentScene) {
            for (var s in Game.currentScene.sceneObjects) {
                var so = Game.currentScene.sceneObjects[s];
                if (!so)
                    continue;
                if (so instanceof SceneObjectEntity) {
                    for (var i in so.triggerLines) {
                        var t = Game.player.sceneObject.triggerLines[i];
                        if (t)
                            t.dispose();
                    }
                }
                so.triggerLines = {};
                so.triggerSingleLines = {};
            }
        }
        SinglePlayerGame.saveDateTime = saveData[1];
        var sceneID = saveData[2];
        var worldSaveData = saveData[3];
        delete worldSaveData.saveFileMax;
        var playerVarialbeData = saveData[4];
        var playerData = saveData[5];
        this.newGameInit(playerData.sceneObject);
        var attrs = CustomCompositeSetting.getAllAttributes(Game.data.customGameAttribute.worldAttributeSetting, false);
        CustomAttributeSetting.installAttributeFromRecordData(ClientWorld.data, worldSaveData, attrs, Game.data.customGameAttribute.worldAttributeConfig.attrs);
        ObjectUtils.clone(playerVarialbeData, Game.player.variable);
        ObjectUtils.clone(playerData.sceneObject, Game.player.data.sceneObject);
        SceneObject.installCustomData(Game.player.data.sceneObject, Config.BORN.customAttribute);
        Player.installFilePlayerData(Game.player, playerData);
        if (Config.useNewSceneObjectModel) {
            var playerSoModuleDatas = saveData[14];
            Game.player.data.sceneObject.___gcRestoreModules = playerSoModuleDatas;
        }
        SinglePlayerGame.sceneDatas = saveData[6];
        SinglePlayerGame.audioInfo = saveData[7];
        SinglePlayerGame.triggerLinesRecord = saveData[8];
        SinglePlayerGame.soDatas = saveData[9];
        SinglePlayerGame.GameCommandData = saveData[10];
        SinglePlayerGame.sceneStatus = saveData[11];
        var gameNow = saveData[16];
        if (gameNow != null)
            Game["_now"] = gameNow;
        var packageCustomData = saveData[12];
        if (packageCustomData == null || !packageCustomData["___useNewCustomData"]) {
            var customData = packageCustomData;
        }
        else {
            this.currentSaveFileCustomData = packageCustomData;
            customData = packageCustomData.___customData;
        }
        var needLoadUIs = saveData[13];
        if (!needLoadUIs)
            needLoadUIs = [];
        var preLoadTask = new AsynTask(Callback.New(function () {
            var gameSaveData = saveData[0];
            Game.recoverySaveData(gameSaveData);
            EventUtils.happen(ClientScene, ClientScene.EVENT_IN_NEW_SCENE, [sceneID, 2]);
            onFin.runWith([true, customData]);
        }, this));
        AssetManager.batchPreLoadAsset(Callback.New(function () {
            preLoadTask.execute(1);
            for (var i = 0; i < SinglePlayerGame.soDatas.length; i++) {
                var recordSo = SinglePlayerGame.soDatas[i].so;
                var copyFrom = recordSo["_copyFrom"];
                if (copyFrom) {
                    preLoadTask.execute(1);
                    Game.data.loadScene(copyFrom.sceneID, Callback.New(function () {
                        preLoadTask.complete();
                    }, _this_1));
                }
            }
            preLoadTask.complete();
        }, this), onProgress, [], [], [], [], [], needLoadUIs, [], [], [], false, true);
    };
    SinglePlayerGame.getSaveInfo = function () {
        return SinglePlayerGame.saveIDs.concat();
    };
    SinglePlayerGame.getSaveInfoByID = function (id) {
        return ArrayUtils.matchAttributes(SinglePlayerGame.saveIDs, { id: id }, true)[0];
    };
    SinglePlayerGame.getGlobalData = function () {
        return this.globalData;
    };
    SinglePlayerGame.deleteGlobalData = function (onFin) {
        if (onFin === void 0) { onFin = null; }
        new SyncTask(SinglePlayerGame.TASK_MODIFY_FILE, function () {
            var saveGameFin = Callback.New(function (success) {
                onFin && onFin.runWith([success]);
                SyncTask.taskOver(SinglePlayerGame.TASK_MODIFY_FILE);
            }, this);
            FileUtils.deleteFile(SinglePlayerGame.GC_LIFE_DATA_PATH, saveGameFin);
        });
    };
    SinglePlayerGame.delSaveFile = function (index, onFin) {
        new SyncTask(SinglePlayerGame.TASK_MODIFY_FILE, function () {
            var _this_1 = this;
            var saveGameFin = Callback.New(function (success) {
                onFin && onFin.runWith([success]);
                SyncTask.taskOver(SinglePlayerGame.TASK_MODIFY_FILE);
            }, this);
            var idx = ArrayUtils.matchAttributes(SinglePlayerGame.saveIDs, { id: index }, true, "==", true)[0];
            if (idx == null) {
                saveGameFin && saveGameFin.runWith([false]);
                return;
            }
            SinglePlayerGame.saveIDs.splice(idx, 1);
            var urlBak = SinglePlayerGame.toWebSaveFileURL("savedata/gamedata" + index + ".gcdatabak");
            var url = SinglePlayerGame.toWebSaveFileURL("savedata/gamedata" + index + ".gcdata");
            FileUtils.deleteFile(urlBak, Callback.New(function (success) {
                FileUtils.deleteFile(url, Callback.New(function (success) {
                    SinglePlayerGame.saveLifeData(saveGameFin, SinglePlayerGame.globalData, true, false);
                }, _this_1));
            }, this));
        });
    };
    SinglePlayerGame.recordSceneObjectSwitch = function (saveExtraObjects) {
        if (saveExtraObjects === void 0) { saveExtraObjects = false; }
        if (!Game.currentScene || Game.currentScene == ClientScene.EMPTY)
            return;
        var sceneData = Game.data.sceneList.data[Game.currentScene.id];
        var switchs = [];
        for (var i = 0; i < sceneData.sceneObjectData.sceneObjects.length; i++) {
            var soData = sceneData.sceneObjectData.sceneObjects[i];
            if (!soData || soData.isBorn)
                continue;
            var so = Game.currentScene.sceneObjects[i];
            if (so)
                switchs[i] = so["switchs"];
        }
        this.sceneDatas[Game.currentScene.id] = { sceneObjectSwitchs: switchs };
    };
    SinglePlayerGame.getSceneObjectSwitch = function (sceneID, soIndex) {
        var sceneData = this.sceneDatas[sceneID];
        if (!sceneData)
            return null;
        return sceneData.sceneObjectSwitchs[soIndex];
    };
    SinglePlayerGame.triggerEvent = function (type, mainType, indexType, params, triggerSceneObjectIndex, executorSceneObjectIndex) {
        if (triggerSceneObjectIndex === void 0) { triggerSceneObjectIndex = null; }
        if (executorSceneObjectIndex === void 0) { executorSceneObjectIndex = null; }
        if (!Game.currentScene)
            return;
        if (params.length < 1)
            return;
        var onReturnID = params[2];
        if (type == 0) {
            SinglePlayerGame.startTriggerCommandV2(mainType, indexType, params, onReturnID != 0 ? Callback.New(function (onReturnID, trigger) {
                EventUtils.addEventListener(trigger, CommandTrigger.EVENT_OVER, Callback.New(ClientMsgSender.cmdReturn, ClientMsgSender, [onReturnID]), true);
            }, this, [onReturnID]) : null, triggerSceneObjectIndex, executorSceneObjectIndex);
            return;
        }
        var commandID = params[0];
        var playerInput = params[1];
        if (playerInput == null)
            playerInput = [];
        switch (type) {
            case 1:
                var trigger = Game.player.sceneObject.triggerLines[commandID];
                if (trigger) {
                    CommandPage.executeEvent(trigger, playerInput);
                }
                else {
                    var len = Game.currentScene.sceneObjects.length;
                    for (var i = 0; i < len; i++) {
                        var targetSo = Game.currentScene.sceneObjects[i];
                        if (!targetSo)
                            continue;
                        trigger = targetSo.triggerLines[commandID];
                        if (trigger) {
                            CommandPage.executeEvent(trigger, playerInput);
                            break;
                        }
                    }
                }
                break;
            case 2:
                var commonEvCmd = ClientWorld.commonEventPages[commandID];
                if (commonEvCmd) {
                    var triggerSceneObject = null;
                    if (triggerSceneObjectIndex != null) {
                        triggerSceneObject = Game.currentScene.sceneObjects[triggerSceneObjectIndex];
                    }
                    if (triggerSceneObject == null)
                        triggerSceneObject = Game.player.sceneObject;
                    var executorSceneObject = null;
                    if (executorSceneObjectIndex != null) {
                        executorSceneObject = Game.currentScene.sceneObjects[executorSceneObjectIndex];
                    }
                    if (executorSceneObject == null)
                        executorSceneObject = Game.player.sceneObject;
                    var trigger_1 = new CommandTrigger(CommandTrigger.COMMAND_MAIN_TYPE_CALL_COMMON_EVENT, commandID, Game.currentScene, triggerSceneObject, true, executorSceneObject);
                    if (onReturnID != 0 && trigger_1)
                        EventUtils.addEventListener(trigger_1, CommandTrigger.EVENT_OVER, Callback.New(ClientMsgSender.cmdReturn, ClientMsgSender, [onReturnID]), true);
                    commonEvCmd.startTriggerEvent(trigger_1, playerInput);
                }
                break;
        }
    };
    SinglePlayerGame.startTriggerCommandV2 = function (mainType, indexType, params, onTriggerCreated, triggerSceneObjectIndex, executorSceneObjectIndex) {
        if (triggerSceneObjectIndex === void 0) { triggerSceneObjectIndex = null; }
        if (executorSceneObjectIndex === void 0) { executorSceneObjectIndex = null; }
        var scene = Game.currentScene;
        if (!scene || indexType < 0)
            return;
        if (params.length < 1)
            return;
        var commandID = params[0];
        var playerInput = params[1];
        if (playerInput == null)
            playerInput = [];
        switch (mainType) {
            case CommandTrigger.COMMAND_MAIN_TYPE_SCENE:
                var cmdPage = scene.customCommandPages[indexType];
                if (cmdPage) {
                    var trigger = Game.player.sceneObject.getCommandTrigger(mainType, indexType, scene, Game.player.sceneObject);
                    if (trigger) {
                        onTriggerCreated && onTriggerCreated.runWith([trigger]);
                        cmdPage.startTriggerEvent(trigger, playerInput);
                    }
                    return trigger;
                }
                break;
            case CommandTrigger.COMMAND_MAIN_TYPE_SCENE_OBJECT:
                if (commandID < 0)
                    return;
                var so = scene.sceneObjects[commandID];
                if (so) {
                    var triggerSceneObject = Game.player.sceneObject;
                    if (triggerSceneObjectIndex != null) {
                        triggerSceneObject = scene.sceneObjects[triggerSceneObjectIndex];
                    }
                    var trigger_2 = triggerSceneObject.getCommandTrigger(mainType, indexType, scene, so);
                    if (trigger_2) {
                        onTriggerCreated && onTriggerCreated.runWith([trigger_2]);
                        var cmdPage_1 = so.customCommandPages[indexType];
                        if (cmdPage_1) {
                            cmdPage_1.startTriggerEvent(trigger_2, playerInput);
                            return trigger_2;
                        }
                    }
                }
                break;
            case CommandTrigger.COMMAND_MAIN_TYPE_UI:
                var commands = ClientWorld.uiCustomCommandPages[commandID];
                if (commands) {
                    var cmdPage_2 = commands[indexType];
                    if (cmdPage_2) {
                        var trigger = Game.player.sceneObject.getCommandTrigger(mainType, indexType, scene, Game.player.sceneObject, commandID);
                        if (trigger) {
                            onTriggerCreated && onTriggerCreated.runWith([trigger]);
                            cmdPage_2.startTriggerEvent(trigger, playerInput);
                        }
                        return trigger;
                    }
                }
                break;
        }
    };
    SinglePlayerGame.initMain = function (onFin) {
        ClientMain.prototype.startLogin = function (onLoginSuccess) {
            onLoginSuccess && onLoginSuccess.run();
        };
    };
    SinglePlayerGame.initCommands = function (onFin) {
        var task = new AsynTask(onFin);
        task.execute("commonEvent");
        ClientWorld.commonEventPages = [];
        Game.data.loadCommonEventList(Callback.New(function () {
            var wsList = Game.data.commonEventList.data;
            for (var i in wsList) {
                var scriptData = wsList[i];
                var ws = new CommandPage(scriptData.commands);
                ClientWorld.commonEventPages[i] = ws;
            }
            task.complete();
            Game.data.commonEventList = null;
        }, this));
    };
    SinglePlayerGame.recoveryData = function () {
        EventUtils.happen(SinglePlayerGame, SinglePlayerGame.EVENT_ON_BEFORE_RECOVERY_DATA);
        SinglePlayerGame.recoveryGameImage();
        SinglePlayerGame.recoveryCurrentSceneObject();
        SinglePlayerGame.recoverySceneStatusData();
        SinglePlayerGame.recoveryTriggerEventSaveDataAndBehaviors();
        EventUtils.happen(SinglePlayerGame, SinglePlayerGame.EVENT_ON_AFTER_RECOVERY_DATA);
    };
    SinglePlayerGame.getCurrentSceneObject = function () {
        var sceneObjects = Game.currentScene.sceneObjects;
        var soDatas = [];
        SinglePlayerGame.toGetSceneObjectData(sceneObjects, soDatas);
        return soDatas;
    };
    SinglePlayerGame.toGetSceneObjectData = function (sceneObjects, soDatas) {
        for (var i = 0; i < sceneObjects.length; i++) {
            var so = sceneObjects[i];
            if (!so)
                continue;
            so.syncAvatarStateToSceneObject();
            var soData = new SceneObject();
            ObjectUtils.cloneExcludeNonExistentAttribute(so, soData);
            var modelData = Common.sceneObjectModelList.data[soData.modelID];
            if (modelData) {
                if (Config.useNewSceneObjectModel) {
                    var fixModelData = Common.sceneObjectModelList.data[0];
                }
                else {
                    fixModelData = modelData;
                }
                for (var s = 0; s < fixModelData.varAttributes.length; s++) {
                    var attr = fixModelData.varAttributes[s];
                    soData[attr.varName] = so[attr.varName];
                }
            }
            var behaviors = so.getBehaviors();
            var behaviorDatas = [];
            if (behaviors) {
                for (var s = 0; s < behaviors.length; s++) {
                    behaviorDatas.push(behaviors[s].getSaveData());
                }
            }
            soData["_isCopy"] = so.isCopy;
            soData["_copyFrom"] = so._copyFrom;
            soData["allowAutoSave"] = so.allowAutoSave;
            var soModuleDatas = null;
            if (Config.useNewSceneObjectModel) {
                soModuleDatas = SceneObjectEntity.getModulesSaveData(so, false);
                soData.moduleIDs = so.moduleIDs ? so.moduleIDs.concat() : [];
            }
            soDatas.push({ so: soData, behaviorDatas: behaviorDatas, moduleDatas: soModuleDatas });
        }
    };
    SinglePlayerGame.recoveryCurrentSceneObject = function () {
        var presetSceneObjects = Game.currentScene.getPresetSceneObjectDatas();
        var soDatas = SinglePlayerGame.soDatas;
        SinglePlayerGame.toRecoverySceneObject(soDatas, presetSceneObjects);
    };
    SinglePlayerGame.toRecoverySceneObject = function (soDatas, presetSceneObjects) {
        for (var i = 0; i < soDatas.length; i++) {
            var soData = soDatas[i];
            var copyFrom = soData.so["_copyFrom"];
            var soc;
            var presetSceneObjectData;
            var fromSceneID = Game.currentScene.id;
            var fromSceneObjectindex = soData.so.index;
            var soSwitchs = SinglePlayerGame.getSceneObjectSwitch(Game.currentScene.id, soData.so.index);
            if (copyFrom) {
                var sceneData = Game.data.sceneList.data[copyFrom.sceneID];
                if (sceneData) {
                    presetSceneObjectData = sceneData.sceneObjectData.sceneObjects[copyFrom.sceneObjectIndex];
                    if (presetSceneObjectData) {
                        fromSceneID = copyFrom.sceneID;
                        fromSceneObjectindex = copyFrom.sceneObjectIndex;
                    }
                }
            }
            else if (soData.so["allowAutoSave"]) {
                if (Config.useNewSceneObjectModel) {
                    SceneObjectEntity.recoveryModulesData[soData.so.index] = { needCheckModulesCustomAttributes: false, presetData: soData.moduleDatas };
                }
                soc = Game.currentScene.addNewSceneObject(soData.so.modelID, null, soSwitchs, soData.so);
                continue;
            }
            else {
                presetSceneObjectData = presetSceneObjects[soData.so.index];
            }
            if (soData.so.index == Game.player.sceneObject.index)
                continue;
            var soSwitchs = SinglePlayerGame.getSceneObjectSwitch(Game.currentScene.id, soData.so.index);
            if (!presetSceneObjectData) {
                continue;
            }
            else {
                if (Config.useNewSceneObjectModel) {
                    var sceneData = Game.data.sceneList.data[Game.currentScene.id];
                    SceneObjectEntity.recoveryModulesData[soData.so.index] = { needCheckModulesCustomAttributes: true, presetData: soData.moduleDatas };
                }
                soc = Game.currentScene.addSceneObjectFromClone(fromSceneID, fromSceneObjectindex, soData.so['_isCopy'], null, soSwitchs, soData.so);
            }
        }
    };
    SinglePlayerGame.getGameCommandData = function () {
        var o = [];
        o[0] = GameCommand.getSaveData();
        o[1] = GameImage.getSaveData();
        return o;
    };
    SinglePlayerGame.recoveryGameImage = function () {
        var o = SinglePlayerGame.GameCommandData[1];
        GameImage.recoverySaveData(o);
    };
    SinglePlayerGame.getSceneStatusData = function () {
        var o = {};
        o.camera = Game.currentScene.camera.getSaveData();
        o.fog = ClientSceneLayer.getSaveData(Game.currentScene.fogLayer);
        o.tonal = Game.currentScene.displayObject.getTonal();
        var layerLen = Game.currentScene.getLayerLength();
        var layerInfo = [];
        for (var i_11 = 0; i_11 < layerLen; i_11++) {
            var layer = Game.currentScene.getLayer(i_11);
            if (layer == Game.currentScene.displayObject) {
                continue;
            }
            layerInfo[i_11] = ClientSceneLayer.getSaveData(layer);
        }
        o.layerInfo = layerInfo;
        return o;
    };
    SinglePlayerGame.recoverySceneStatusData = function () {
        var o = SinglePlayerGame.sceneStatus;
        Game.currentScene.camera.recoverySaveData(o.camera);
        ClientSceneLayer.recoverySaveData(Game.currentScene.fogLayer, o.fog);
        var t = o.tonal;
        Game.currentScene.displayObject.setTonal(t[0], t[1], t[2], t[3], t[4], t[5], t[6]);
        var a = SinglePlayerGame.audioInfo;
        if (SinglePlayerGame.saveConfig.audioVolume) {
            GameAudio.bgmVolume = a[6];
            GameAudio.bgsVolume = a[7];
            GameAudio.seVolume = a[8];
            if (a[9] != null) {
                GameAudio.tsVolume = a[9];
            }
        }
        if (SinglePlayerGame.saveConfig.bgm) {
            GameAudio.playBGM(a[0], a[2], 99999, true, 500, a[1]);
        }
        if (SinglePlayerGame.saveConfig.bgs) {
            GameAudio.playBGS(a[3], a[5], 99999, true, 500, a[4]);
        }
        var layerInfo = o.layerInfo;
        if (layerInfo) {
            var isAllSameLayer = true;
            var layerLen = Game.currentScene.getLayerLength();
            if (layerLen != layerInfo.length) {
                isAllSameLayer = false;
            }
            else {
                for (var i_12 = 0; i_12 < layerLen; i_12++) {
                    var layer = Game.currentScene.getLayer(i_12);
                    if (layer == Game.currentScene.displayObject) {
                        continue;
                    }
                    var rLayer = layerInfo[i_12];
                    if (!rLayer || layer.drawMode != rLayer.drawMode) {
                        isAllSameLayer = false;
                        break;
                    }
                }
            }
            if (isAllSameLayer) {
                for (var i_13 = 0; i_13 < layerLen; i_13++) {
                    var layer = Game.currentScene.getLayer(i_13);
                    if (layer == Game.currentScene.displayObject) {
                        continue;
                    }
                    ClientSceneLayer.recoverySaveData(layer, layerInfo[i_13]);
                }
            }
        }
    };
    SinglePlayerGame.getTriggerEventSaveData = function () {
        var triggerLines = [];
        var needLoadUIs = [];
        if (SinglePlayerGame.saveConfig.event) {
            for (var s = 0; s < Game.currentScene.sceneObjects.length; s++) {
                var so = Game.currentScene.sceneObjects[s];
                if (!so)
                    continue;
                for (var i in so.triggerLines) {
                    var trigger = so.triggerLines[i];
                    if (!trigger.isExecuteing)
                        continue;
                    if (trigger.mainType == CommandTrigger.COMMAND_MAIN_TYPE_UI && typeof trigger.from == "string") {
                        var uiID = MathUtils.int(trigger.from.split("_")[0]);
                        needLoadUIs.push(uiID);
                    }
                    triggerLines.push(trigger.getSaveData());
                }
            }
        }
        return [triggerLines, needLoadUIs];
    };
    SinglePlayerGame.recoveryTriggerEventSaveDataAndBehaviors = function () {
        var now = new Date().getTime();
        var intervalTime = now - SinglePlayerGame.saveDateTime;
        var triggerLines = SinglePlayerGame.triggerLinesRecord;
        var allTriggers = [];
        for (var i = 0; i < triggerLines.length; i++) {
            var o = triggerLines[i];
            var executor = Game.currentScene.sceneObjects[o.executor];
            if (!executor)
                continue;
            var trigger = Game.currentScene.sceneObjects[o.trigger];
            if (!trigger)
                continue;
            if (executor) {
                var cmdTrigger = trigger.getCommandTrigger(o.mainType, o.indexType, Game.currentScene, executor, o.from);
                if (cmdTrigger) {
                    var recoverySuccess = cmdTrigger.recoverySaveData(o, Game.currentScene, ClientWorld.commonEventPages, intervalTime);
                    if (recoverySuccess) {
                        allTriggers.push({ trigger: cmdTrigger, data: o });
                    }
                }
            }
        }
        var GameCommandData = SinglePlayerGame.GameCommandData[0];
        var inputTriggerLine = GameCommandData[2];
        var m = ArrayUtils.matchAttributesD2(allTriggers, "data", { id: inputTriggerLine }, true);
        if (m.length == 1) {
            GameCommand.inputTriggerLine = m[0].trigger.id;
            GameCommand.isNeedPlayerInput = GameCommandData[1];
        }
        var cmdTriggerLines = GameCommandData[0];
        for (var triggerLineID in cmdTriggerLines) {
            var m = ArrayUtils.matchAttributesD2(allTriggers, "data", { id: triggerLineID }, true);
            if (m.length == 1) {
                var newTriggerLineID = m[0].trigger.id;
                var funcsData = cmdTriggerLines[triggerLineID].funcs;
                var newFuncs = [];
                for (var i = 0; i < funcsData.length; i++) {
                    var newFunc = funcsData[i];
                    newFunc[1][0] = newTriggerLineID;
                    var spoceType = newFunc[2];
                    var gameFuncName = newFunc[3];
                    var executeFunction;
                    if (spoceType == 0) {
                        executeFunction = GameFunction[gameFuncName];
                    }
                    else {
                        executeFunction = CommandExecuteGame[gameFuncName];
                    }
                    newFunc.unshift(executeFunction);
                    newFuncs.push(newFunc);
                }
                GameCommand.cmdTriggerLines[newTriggerLineID] = { stop: cmdTriggerLines[triggerLineID].stop, funcs: newFuncs };
            }
        }
        var GameImageData = SinglePlayerGame.GameCommandData[1];
        if (GameImageData.executeGroups) {
            for (var i = 0; i < GameImageData.executeGroups.length; i++) {
                var groupData = GameImageData.executeGroups[i];
                if (!groupData)
                    continue;
                var oldGroupTriggerLineID = groupData.triggerLineID;
                var m = ArrayUtils.matchAttributesD2(allTriggers, "data", { id: oldGroupTriggerLineID }, true);
                if (m.length == 1) {
                    groupData.triggerLineID = m[0].trigger.id;
                    if (groupData.gameImageGroup) {
                        groupData.gameImageGroup.triggerLineID = groupData.triggerLineID;
                        delete groupData.gameImageGroup;
                    }
                }
            }
        }
        if (GameImageData.listeningWaitImagePlayOvers) {
            for (var i = 0; i < GameImageData.listeningWaitImagePlayOvers.length; i++) {
                var oldListenerWaitOverTriggerLineID = GameImageData.listeningWaitImagePlayOvers[i];
                var m = ArrayUtils.matchAttributesD2(allTriggers, "data", { id: oldListenerWaitOverTriggerLineID }, true);
                if (m.length == 1) {
                    GameImageData.listeningWaitImagePlayOvers[i] = m[0].trigger.id;
                }
            }
        }
        var soDatas = SinglePlayerGame.soDatas;
        for (var i = 0; i < soDatas.length; i++) {
            var soData = soDatas[i];
            var soc = Game.currentScene.sceneObjects[soData.so.index];
            if (!soc)
                continue;
            var soBehaviorDataArr = soData.behaviorDatas;
            if (!soBehaviorDataArr)
                continue;
            for (var beLayer = 0; beLayer < soBehaviorDataArr.length; beLayer++) {
                var behaviorDataX = soBehaviorDataArr[beLayer];
                var soBehaviorData = behaviorDataX[0];
                var behaviorIndex = behaviorDataX[1];
                var loop = behaviorDataX[2];
                var delayFrame = behaviorDataX[3];
                if (delayFrame == null)
                    delayFrame = 0;
                var targetSceneObjectIndex = behaviorDataX[4];
                var executorIndex = behaviorDataX[5];
                var fromTrigger = targetSceneObjectIndex == -1 || targetSceneObjectIndex == null ? Game.player.sceneObject : Game.currentScene.sceneObjects[targetSceneObjectIndex];
                var fromExecutor = executorIndex == -1 || executorIndex == null ? Game.player.sceneObject : Game.currentScene.sceneObjects[executorIndex];
                var behaviorfromTrigger = false;
                for (var s = 0; s < allTriggers.length; s++) {
                    var triggerData = allTriggers[s];
                    var n = ArrayUtils.matchAttributes(triggerData.data.behaviors, { soIndex: soc.index, behaviorIndex: beLayer }, true);
                    if (n.length > 0) {
                        behaviorfromTrigger = true;
                        triggerData.trigger.addBehavior(soc, soBehaviorData, loop, fromTrigger, false, behaviorIndex, false, false, delayFrame, fromExecutor);
                        break;
                    }
                }
                if (!behaviorfromTrigger) {
                    soc.addBehavior(soBehaviorData, loop, fromTrigger, null, false, behaviorIndex, false, false, delayFrame, fromExecutor);
                }
            }
        }
        for (var s = 0; s < allTriggers.length; s++) {
            var cmdTrigger = allTriggers[s].trigger;
            EventUtils.happen(SinglePlayerGame, SinglePlayerGame.EVENT_RECOVER_TRIGGER, [cmdTrigger]);
            cmdTrigger.recovery();
        }
        SinglePlayerGame.triggerLinesRecord = null;
    };
    SinglePlayerGame.EVENT_RECOVER_TRIGGER = "SinglePlayerGameEVENT_RECOVER_TRIGGER";
    SinglePlayerGame.EVENT_ON_BEFORE_RECOVERY_DATA = "SinglePlayerGameEVENT_BEFORE_RECOVER_DATA";
    SinglePlayerGame.EVENT_ON_AFTER_RECOVERY_DATA = "SinglePlayerGameEVENT_ON_AFTER_RECOVER_DATA";
    SinglePlayerGame.syncSaveMode = true;
    SinglePlayerGame.fileSaveConfig = {
        ui: true,
        uiComp: true,
    };
    SinglePlayerGame.saveConfig = {
        event: true,
        audioVolume: true,
        bgm: true,
        bgs: true
    };
    SinglePlayerGame.sceneDatas = [];
    SinglePlayerGame.customCommandsCache = [];
    SinglePlayerGame.TASK_MODIFY_FILE = "__SinglePlayerGame__TASK_MODIFY_FILE";
    SinglePlayerGame.regSaveCustomDataCallbacks = [];
    SinglePlayerGame.regSaveCustomGlobalDataCallbacks = [];
    return SinglePlayerGame;
}());
var GCPolyfill = (function () {
    function GCPolyfill() {
    }
    GCPolyfill.init = function () {
        var minFilters = ["LINEAR", "NEAREST", "NEAREST_MIPMAP_NEAREST", "LINEAR_MIPMAP_NEAREST", "NEAREST_MIPMAP_LINEAR", "LINEAR_MIPMAP_LINEAR"];
        var magFilters = ["LINEAR", "NEAREST"];
        var oldTexParameteri = WebGLRenderingContext.prototype.texParameteri;
        WebGLRenderingContext.prototype.texParameteri = function (target, pname, param) {
            switch (pname) {
                case WebGLRenderingContext.TEXTURE_MIN_FILTER:
                    var v = minFilters.filter(function (v) { return WebGLRenderingContext[v] == param; });
                    param = WebGLRenderingContext.LINEAR;
                    break;
                case WebGLRenderingContext.TEXTURE_MAG_FILTER:
                    var v1 = magFilters.filter(function (v) { return WebGLRenderingContext[v] == param; });
                    param = Config.GAME_MAG_FILTER ? Config.GAME_MAG_FILTER : 0x2600;
                    break;
            }
            oldTexParameteri.call(this, target, pname, param);
        };
        ClientMain.prototype["initOver"] = function () {
            if (IndexedDBManager && IndexedDBManager.support) {
                try {
                    var href = window.location.href;
                    var index = href.indexOf('releaseProject/');
                    var str = href.substring(index, href.length);
                    var gameID = parseInt(str.split("_")[1]);
                    if (gameID != null && os.platform == 0) {
                        IndexedDBManager.databaseName = gameID.toString();
                        IndexedDBManager.used = true;
                    }
                    else if (Config.gameSID) {
                        IndexedDBManager.databaseName = Config.gameSID.toString();
                        IndexedDBManager.used = true;
                    }
                    else {
                        IndexedDBManager.used = false;
                    }
                }
                catch (e) {
                    IndexedDBManager.used = false;
                }
            }
            Config.TILE_SPLIT_SIZE_LOCK = true;
            SinglePlayerGame.init(Callback.New(function () {
                EventUtils.happen(ClientWorld, ClientWorld.EVENT_BEFORE_INITED);
                EventUtils.happen(ClientWorld, ClientWorld.EVENT_INITED);
            }, this));
        };
        gcParent.window["onunload"] = window["onunload"] = function (isRealClose) {
            gcParent.window["onunload"] = window["onunload"] = null;
            GameAudio.stopBGM();
            GameAudio.stopSE();
            GameAudio.stopBGS();
            GameAudio.stopTS();
            if (typeof mainDomain_kdsrpg != "undefined") {
                mainDomain_frameRef(-1);
            }
            return false;
        };
        window.addEventListener("mousedown", function (e) {
            if (typeof mainDomain_kdsrpg == "undefined")
                return;
            var ev = new Event("mousedown");
            ev.domain = "midCanvas";
            ev.clientX = e.clientX;
            ev.clientY = e.clientY + 32;
            if (gcParent != window)
                gcParent.window.dispatchEvent(ev);
        });
        window.addEventListener("mousemove", function (e) {
            if (typeof mainDomain_kdsrpg == "undefined")
                return;
            var ev = new Event("mousemove");
            ev.domain = "midCanvas";
            ev.clientX = e.clientX;
            ev.clientY = e.clientY + 32;
            if (gcParent != window)
                gcParent.window.dispatchEvent(ev);
        });
        window.addEventListener("onmouseup", function (e) {
            if (typeof mainDomain_kdsrpg == "undefined")
                return;
            var ev = new Event("mouseup");
            ev.domain = "midCanvas";
            ev.clientX = e.clientX;
            ev.clientY = e.clientY + 32;
            if (gcParent != window)
                gcParent.window.dispatchEvent(ev);
        });
        if (typeof window["CumtomGameNumber"] != "undefined") {
            if (typeof window["CustomGameNumber"] == "undefined") {
                window["CustomGameNumber"] = window["CumtomGameNumber"];
            }
            else {
                for (var i in window["CumtomGameNumber"]) {
                    if (!window["CustomGameNumber"][i]) {
                        window["CustomGameNumber"][i] = window["CumtomGameNumber"][i];
                    }
                }
            }
        }
    };
    return GCPolyfill;
}());
var playerMap = {};
var layer3Test;
function main() {
    Config.SINGLE_PLAYER_CORE = true;
    GCPolyfill.init();
    ClientWorld.init();
}
GameUI.init();
